; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strtold.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_powten	DQ	04024000000000000r		; 10
	DQ	04059000000000000r		; 100
	DQ	040c3880000000000r		; 10000
	DQ	04197d78400000000r		; 1e+008
	DQ	04341c37937e08000r		; 1e+016
	DQ	04693b8b5b5056e17r		; 1e+032
	DQ	04d384f03e93ff9f5r		; 1e+064
	DQ	05a827748f9301d32r		; 1e+128
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
_DATA	ENDS
PUBLIC	_strtold
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
EXTRN	___osctype:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtold.c
;	COMDAT _strtold
_TEXT	SEGMENT
tv356 = -12						; size = 8
tv350 = -12						; size = 8
tv335 = -12						; size = 8
_sign$ = -4						; size = 4
tv357 = 8						; size = 4
tv351 = 8						; size = 4
_s$ = 8							; size = 4
_sret$ = 12						; size = 4
_strtold PROC						; COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 16   : 	double r;		/* result */
; 17   : 	int e, ne;			/* exponent */
; 18   : 	int sign;			/* +- 1.0 */
; 19   : 	int esign;
; 20   : 	int flags=0;
; 21   : 	int l2powm1;
; 22   : 
; 23   : 	r = 0.0L;
; 24   : 	sign = 1;
; 25   : 	e = ne = 0;
; 26   : 	esign = 1;
; 27   : 
; 28   : 	while(*s && isspace(*s))

  00006	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00009	33 c9		 xor	 ecx, ecx
  0000b	d9 ee		 fldz
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8a 02		 mov	 al, BYTE PTR [edx]
  00011	33 db		 xor	 ebx, ebx
  00013	57		 push	 edi
  00014	33 ff		 xor	 edi, edi
  00016	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1
  0001d	d9 c0		 fld	 ST(0)
  0001f	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  00022	84 c0		 test	 al, al
  00024	74 14		 je	 SHORT $LN54@strtold
$LN30@strtold:
  00026	0f b6 c0	 movzx	 eax, al
  00029	f6 80 00 00 00
	00 20		 test	 BYTE PTR ___osctype[eax], 32 ; 00000020H
  00030	74 08		 je	 SHORT $LN54@strtold
  00032	8a 42 01	 mov	 al, BYTE PTR [edx+1]

; 29   : 		s++;

  00035	42		 inc	 edx
  00036	84 c0		 test	 al, al
  00038	75 ec		 jne	 SHORT $LN30@strtold
$LN54@strtold:

; 30   : 
; 31   : 	if (*s == '+')

  0003a	8a 02		 mov	 al, BYTE PTR [edx]
  0003c	3c 2b		 cmp	 al, 43			; 0000002bH
  0003e	74 0b		 je	 SHORT $LN126@strtold

; 32   : 		s++;
; 33   : 	else if (*s == '-')

  00040	3c 2d		 cmp	 al, 45			; 0000002dH
  00042	75 08		 jne	 SHORT $LN34@strtold

; 34   : 	{
; 35   : 		sign = -1;

  00044	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
$LN126@strtold:

; 36   : 		s++;

  0004b	42		 inc	 edx
$LN34@strtold:

; 37   : 	}
; 38   : 
; 39   : 	while ((*s >= '0') && (*s <= '9'))

  0004c	8a 02		 mov	 al, BYTE PTR [edx]
  0004e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00054	3c 30		 cmp	 al, 48			; 00000030H
  00056	7c 25		 jl	 SHORT $LN55@strtold
$LN25@strtold:
  00058	3c 39		 cmp	 al, 57			; 00000039H
  0005a	7f 21		 jg	 SHORT $LN55@strtold

; 40   : 	{
; 41   : 		flags |= 1;
; 42   : 		r *= 10.0L;
; 43   : 		r += *s - '0';

  0005c	0f be c0	 movsx	 eax, al

; 44   : 		s++;

  0005f	42		 inc	 edx
  00060	83 e8 30	 sub	 eax, 48			; 00000030H
  00063	0b fe		 or	 edi, esi
  00065	89 45 08	 mov	 DWORD PTR tv357[ebp], eax
  00068	db 45 08	 fild	 DWORD PTR tv357[ebp]
  0006b	dd 5d f4	 fstp	 QWORD PTR tv356[ebp]
  0006e	dd 45 f4	 fld	 QWORD PTR tv356[ebp]
  00071	d9 ca		 fxch	 ST(2)
  00073	8a 02		 mov	 al, BYTE PTR [edx]
  00075	d8 c9		 fmul	 ST(0), ST(1)
  00077	de c2		 faddp	 ST(2), ST(0)
  00079	3c 30		 cmp	 al, 48			; 00000030H
  0007b	7d db		 jge	 SHORT $LN25@strtold
$LN55@strtold:

; 45   : 	}
; 46   : 
; 47   : 	if (*s == '.')

  0007d	80 3a 2e	 cmp	 BYTE PTR [edx], 46	; 0000002eH
  00080	75 2f		 jne	 SHORT $LN78@strtold

; 48   : 	{
; 49   : 		s++;
; 50   : 		while ((*s >= '0') && (*s <= '9'))

  00082	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00085	42		 inc	 edx
  00086	3c 30		 cmp	 al, 48			; 00000030H
  00088	7c 27		 jl	 SHORT $LN78@strtold
$LN22@strtold:
  0008a	3c 39		 cmp	 al, 57			; 00000039H
  0008c	7f 23		 jg	 SHORT $LN78@strtold

; 51   : 		{
; 52   : 			flags |= 2;
; 53   : 			r *= 10.0L;
; 54   : 			r += *s - '0';

  0008e	0f be c0	 movsx	 eax, al

; 55   : 			s++;

  00091	42		 inc	 edx
  00092	83 e8 30	 sub	 eax, 48			; 00000030H
  00095	83 cf 02	 or	 edi, 2
  00098	89 45 08	 mov	 DWORD PTR tv351[ebp], eax

; 56   : 			ne++;

  0009b	43		 inc	 ebx
  0009c	db 45 08	 fild	 DWORD PTR tv351[ebp]
  0009f	dd 5d f4	 fstp	 QWORD PTR tv350[ebp]
  000a2	dd 45 f4	 fld	 QWORD PTR tv350[ebp]
  000a5	d9 ca		 fxch	 ST(2)
  000a7	8a 02		 mov	 al, BYTE PTR [edx]
  000a9	d8 c9		 fmul	 ST(0), ST(1)
  000ab	de c2		 faddp	 ST(2), ST(0)
  000ad	3c 30		 cmp	 al, 48			; 00000030H
  000af	7d d9		 jge	 SHORT $LN22@strtold
$LN78@strtold:
  000b1	dd d8		 fstp	 ST(0)

; 57   : 		}
; 58   : 	}
; 59   : 	if (flags == 0)

  000b3	85 ff		 test	 edi, edi
  000b5	75 16		 jne	 SHORT $LN20@strtold

; 60   : 	{
; 61   : 		if (sret)

  000b7	8b 45 0c	 mov	 eax, DWORD PTR _sret$[ebp]
  000ba	dd d8		 fstp	 ST(0)
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 ad 00 00
	00		 je	 $LN31@strtold

; 62   : 			*sret = (char *)s;

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	89 10		 mov	 DWORD PTR [eax], edx
  000c8	5b		 pop	 ebx

; 122  : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN20@strtold:

; 63   : 		return 0.0L;
; 64   : 	}
; 65   : 
; 66   : 	if ((*s == 'e') || (*s == 'E'))

  000cd	8a 02		 mov	 al, BYTE PTR [edx]
  000cf	3c 65		 cmp	 al, 101			; 00000065H
  000d1	74 04		 je	 SHORT $LN17@strtold
  000d3	3c 45		 cmp	 al, 69			; 00000045H
  000d5	75 38		 jne	 SHORT $LN11@strtold
$LN17@strtold:

; 67   : 	{
; 68   : 		s++;
; 69   : 		if (*s == '+')

  000d7	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  000da	42		 inc	 edx
  000db	3c 2b		 cmp	 al, 43			; 0000002bH
  000dd	75 03		 jne	 SHORT $LN16@strtold

; 70   : 			s++;

  000df	42		 inc	 edx
  000e0	eb 08		 jmp	 SHORT $LN36@strtold
$LN16@strtold:

; 71   : 		else if (*s == '-')

  000e2	3c 2d		 cmp	 al, 45			; 0000002dH
  000e4	75 04		 jne	 SHORT $LN36@strtold

; 72   : 		{
; 73   : 			s++;

  000e6	42		 inc	 edx

; 74   : 			esign = -1;

  000e7	83 ce ff	 or	 esi, -1
$LN36@strtold:

; 75   : 		}
; 76   : 		while ((*s >= '0') && (*s <= '9'))

  000ea	8a 02		 mov	 al, BYTE PTR [edx]
  000ec	3c 30		 cmp	 al, 48			; 00000030H
  000ee	7c 17		 jl	 SHORT $LN57@strtold
$LN13@strtold:
  000f0	3c 39		 cmp	 al, 57			; 00000039H
  000f2	7f 13		 jg	 SHORT $LN57@strtold

; 77   : 		{
; 78   : 			e *= 10;
; 79   : 			e += *s - '0';

  000f4	0f be c0	 movsx	 eax, al
  000f7	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]

; 80   : 			s++;

  000fa	42		 inc	 edx
  000fb	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  000fe	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00101	8a 02		 mov	 al, BYTE PTR [edx]
  00103	3c 30		 cmp	 al, 48			; 00000030H
  00105	7d e9		 jge	 SHORT $LN13@strtold
$LN57@strtold:

; 81   : 		}
; 82   : 	}
; 83   : 	if (esign < 0)

  00107	85 f6		 test	 esi, esi
  00109	79 04		 jns	 SHORT $LN11@strtold

; 84   : 	{
; 85   : 		esign = -esign;

  0010b	f7 de		 neg	 esi

; 86   : 		e = -e;

  0010d	f7 d9		 neg	 ecx
$LN11@strtold:

; 87   : 	}
; 88   : 	e = e - ne;

  0010f	2b cb		 sub	 ecx, ebx

; 89   : 	if (e < -4096)

  00111	81 f9 00 f0 ff
	ff		 cmp	 ecx, -4096		; fffff000H
  00117	7d 0a		 jge	 SHORT $LN90@strtold

; 90   : 	{
; 91   : 		/* possibly subnormal number, 10^e would overflow */
; 92   : 		r *= 1.0e-2048L;

  00119	de c9		 fmulp	 ST(1), ST(0)

; 93   : 		e += 2048;

  0011b	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H
  00121	eb 02		 jmp	 SHORT $LN10@strtold
$LN90@strtold:
  00123	dd d9		 fstp	 ST(1)
$LN10@strtold:

; 94   : 	}
; 95   : 	if (e < 0)

  00125	85 c9		 test	 ecx, ecx
  00127	79 04		 jns	 SHORT $LN9@strtold

; 96   : 	{
; 97   : 		e = -e;

  00129	f7 d9		 neg	 ecx

; 98   : 		esign = -esign;

  0012b	f7 de		 neg	 esi
$LN9@strtold:

; 99   : 	}
; 100  : 	if (e >= 8192)

  0012d	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00133	7c 07		 jl	 SHORT $LN8@strtold

; 101  : 		e = 8191;

  00135	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH

; 102  : 	if (e)

  0013a	eb 04		 jmp	 SHORT $LN53@strtold
$LN8@strtold:
  0013c	85 c9		 test	 ecx, ecx
  0013e	74 1f		 je	 SHORT $LN2@strtold
$LN53@strtold:

; 103  : 	{
; 104  : 		double d = 1.0L;

  00140	d9 e8		 fld1
  00142	b8 00 00 00 00	 mov	 eax, OFFSET _powten
$LN6@strtold:

; 105  : 		l2powm1 = 0;
; 106  : 		while (e)
; 107  : 		{
; 108  : 			if (e & 1)

  00147	f6 c1 01	 test	 cl, 1
  0014a	74 02		 je	 SHORT $LN4@strtold

; 109  : 				d *= powten[l2powm1];

  0014c	dc 08		 fmul	 QWORD PTR [eax]
$LN4@strtold:

; 110  : 			e >>= 1;
; 111  : 			l2powm1++;

  0014e	83 c0 08	 add	 eax, 8
  00151	d1 f9		 sar	 ecx, 1
  00153	75 f2		 jne	 SHORT $LN6@strtold

; 112  : 		}
; 113  : 		if (esign > 0)

  00155	85 f6		 test	 esi, esi
  00157	7e 04		 jle	 SHORT $LN3@strtold

; 114  : 			r *= d;

  00159	de c9		 fmulp	 ST(1), ST(0)

; 115  : 		else

  0015b	eb 02		 jmp	 SHORT $LN2@strtold
$LN3@strtold:

; 116  : 			r /= d;

  0015d	de f9		 fdivp	 ST(1), ST(0)
$LN2@strtold:

; 117  : 	}
; 118  : 	if (sret)

  0015f	8b 45 0c	 mov	 eax, DWORD PTR _sret$[ebp]
  00162	85 c0		 test	 eax, eax
  00164	74 02		 je	 SHORT $LN1@strtold

; 119  : 		*sret = (char *)s;

  00166	89 10		 mov	 DWORD PTR [eax], edx
$LN1@strtold:

; 120  : 	
; 121  : 	return r * sign;

  00168	db 45 fc	 fild	 DWORD PTR _sign$[ebp]
  0016b	dd 5d f4	 fstp	 QWORD PTR tv335[ebp]
  0016e	dc 4d f4	 fmul	 QWORD PTR tv335[ebp]
$LN31@strtold:
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx

; 122  : }

  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
_strtold ENDP
_TEXT	ENDS
END
