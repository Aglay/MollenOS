; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strtold.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_powten	DQ	04024000000000000r		; 10
	DQ	04059000000000000r		; 100
	DQ	040c3880000000000r		; 10000
	DQ	04197d78400000000r		; 1e+008
	DQ	04341c37937e08000r		; 1e+016
	DQ	04693b8b5b5056e17r		; 1e+032
	DQ	04d384f03e93ff9f5r		; 1e+064
	DQ	05a827748f9301d32r		; 1e+128
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
_DATA	ENDS
PUBLIC	__strtold
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
EXTRN	__ctype:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtold.c
;	COMDAT __strtold
_TEXT	SEGMENT
tv344 = -8						; size = 8
_sign$1$ = -4						; size = 4
_s$ = 8							; size = 4
_sret$ = 12						; size = 4
__strtold PROC						; COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16   : 	double r;		/* result */
; 17   : 	int e, ne;			/* exponent */
; 18   : 	int sign;			/* +- 1.0 */
; 19   : 	int esign;
; 20   : 	int flags=0;
; 21   : 	int l2powm1;
; 22   : 
; 23   : 	r = 0.0L;
; 24   : 	sign = 1;
; 25   : 	e = ne = 0;
; 26   : 	esign = 1;
; 27   : 
; 28   : 	while(*s && isspace(*s))

  00006	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00009	0f 57 db	 xorps	 xmm3, xmm3
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	33 f6		 xor	 esi, esi
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _sign$1$[ebp], 1
  00017	8a 02		 mov	 al, BYTE PTR [edx]
  00019	33 db		 xor	 ebx, ebx
  0001b	33 c9		 xor	 ecx, ecx
  0001d	66 0f 28 cb	 movapd	 xmm1, xmm3
  00021	57		 push	 edi
  00022	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  00025	84 c0		 test	 al, al
  00027	74 1b		 je	 SHORT $LN54@strtold
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL30@strtold:
  00030	0f b6 c0	 movzx	 eax, al
  00033	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  0003a	74 08		 je	 SHORT $LN54@strtold
  0003c	8a 42 01	 mov	 al, BYTE PTR [edx+1]

; 29   : 		s++;

  0003f	42		 inc	 edx
  00040	84 c0		 test	 al, al
  00042	75 ec		 jne	 SHORT $LL30@strtold
$LN54@strtold:

; 30   : 
; 31   : 	if (*s == '+')

  00044	8a 02		 mov	 al, BYTE PTR [edx]
  00046	3c 2b		 cmp	 al, 43			; 0000002bH
  00048	74 0b		 je	 SHORT $LN58@strtold

; 32   : 		s++;
; 33   : 	else if (*s == '-')

  0004a	3c 2d		 cmp	 al, 45			; 0000002dH
  0004c	75 08		 jne	 SHORT $LN34@strtold

; 34   : 	{
; 35   : 		sign = -1;

  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _sign$1$[ebp], -1
$LN58@strtold:

; 36   : 		s++;

  00055	42		 inc	 edx
$LN34@strtold:

; 37   : 	}
; 38   : 
; 39   : 	while ((*s >= '0') && (*s <= '9'))

  00056	8a 02		 mov	 al, BYTE PTR [edx]
  00058	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@4024000000000000
  00060	3c 30		 cmp	 al, 48			; 00000030H
  00062	7c 23		 jl	 SHORT $LN55@strtold
$LL25@strtold:
  00064	3c 39		 cmp	 al, 57			; 00000039H
  00066	7f 1f		 jg	 SHORT $LN55@strtold

; 40   : 	{
; 41   : 		flags |= 1;
; 42   : 		r *= 10.0L;
; 43   : 		r += *s - '0';

  00068	0f be c0	 movsx	 eax, al

; 44   : 		s++;

  0006b	42		 inc	 edx
  0006c	83 e8 30	 sub	 eax, 48			; 00000030H
  0006f	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00073	0b f7		 or	 esi, edi
  00075	66 0f 6e c0	 movd	 xmm0, eax
  00079	8a 02		 mov	 al, BYTE PTR [edx]
  0007b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0007f	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00083	3c 30		 cmp	 al, 48			; 00000030H
  00085	7d dd		 jge	 SHORT $LL25@strtold
$LN55@strtold:

; 45   : 	}
; 46   : 
; 47   : 	if (*s == '.')

  00087	80 3a 2e	 cmp	 BYTE PTR [edx], 46	; 0000002eH
  0008a	75 2d		 jne	 SHORT $LN56@strtold

; 48   : 	{
; 49   : 		s++;
; 50   : 		while ((*s >= '0') && (*s <= '9'))

  0008c	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  0008f	42		 inc	 edx
  00090	3c 30		 cmp	 al, 48			; 00000030H
  00092	7c 25		 jl	 SHORT $LN56@strtold
$LL22@strtold:
  00094	3c 39		 cmp	 al, 57			; 00000039H
  00096	7f 21		 jg	 SHORT $LN56@strtold

; 51   : 		{
; 52   : 			flags |= 2;
; 53   : 			r *= 10.0L;
; 54   : 			r += *s - '0';

  00098	0f be c0	 movsx	 eax, al

; 55   : 			s++;

  0009b	42		 inc	 edx
  0009c	83 e8 30	 sub	 eax, 48			; 00000030H
  0009f	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  000a3	83 ce 02	 or	 esi, 2

; 56   : 			ne++;

  000a6	43		 inc	 ebx
  000a7	66 0f 6e c0	 movd	 xmm0, eax
  000ab	8a 02		 mov	 al, BYTE PTR [edx]
  000ad	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000b1	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000b5	3c 30		 cmp	 al, 48			; 00000030H
  000b7	7d db		 jge	 SHORT $LL22@strtold
$LN56@strtold:

; 57   : 		}
; 58   : 	}
; 59   : 	if (flags == 0)

  000b9	85 f6		 test	 esi, esi
  000bb	75 12		 jne	 SHORT $LN20@strtold

; 60   : 	{
; 61   : 		if (sret)

  000bd	8b 45 0c	 mov	 eax, DWORD PTR _sret$[ebp]
  000c0	85 c0		 test	 eax, eax
  000c2	74 02		 je	 SHORT $LN19@strtold

; 62   : 			*sret = (char *)s;

  000c4	89 10		 mov	 DWORD PTR [eax], edx
$LN19@strtold:

; 63   : 		return 0.0L;

  000c6	d9 ee		 fldz
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx

; 122  : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
$LN20@strtold:

; 64   : 	}
; 65   : 
; 66   : 	if ((*s == 'e') || (*s == 'E'))

  000cf	8a 02		 mov	 al, BYTE PTR [edx]
  000d1	3c 65		 cmp	 al, 101			; 00000065H
  000d3	74 04		 je	 SHORT $LN17@strtold
  000d5	3c 45		 cmp	 al, 69			; 00000045H
  000d7	75 38		 jne	 SHORT $LN11@strtold
$LN17@strtold:

; 67   : 	{
; 68   : 		s++;
; 69   : 		if (*s == '+')

  000d9	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  000dc	42		 inc	 edx
  000dd	3c 2b		 cmp	 al, 43			; 0000002bH
  000df	75 03		 jne	 SHORT $LN16@strtold

; 70   : 			s++;

  000e1	42		 inc	 edx
  000e2	eb 08		 jmp	 SHORT $LN36@strtold
$LN16@strtold:

; 71   : 		else if (*s == '-')

  000e4	3c 2d		 cmp	 al, 45			; 0000002dH
  000e6	75 04		 jne	 SHORT $LN36@strtold

; 72   : 		{
; 73   : 			s++;

  000e8	42		 inc	 edx

; 74   : 			esign = -1;

  000e9	83 cf ff	 or	 edi, -1
$LN36@strtold:

; 75   : 		}
; 76   : 		while ((*s >= '0') && (*s <= '9'))

  000ec	8a 02		 mov	 al, BYTE PTR [edx]
  000ee	3c 30		 cmp	 al, 48			; 00000030H
  000f0	7c 17		 jl	 SHORT $LN57@strtold
$LL13@strtold:
  000f2	3c 39		 cmp	 al, 57			; 00000039H
  000f4	7f 13		 jg	 SHORT $LN57@strtold

; 77   : 		{
; 78   : 			e *= 10;
; 79   : 			e += *s - '0';

  000f6	0f be c0	 movsx	 eax, al
  000f9	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]

; 80   : 			s++;

  000fc	42		 inc	 edx
  000fd	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  00100	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00103	8a 02		 mov	 al, BYTE PTR [edx]
  00105	3c 30		 cmp	 al, 48			; 00000030H
  00107	7d e9		 jge	 SHORT $LL13@strtold
$LN57@strtold:

; 81   : 		}
; 82   : 	}
; 83   : 	if (esign < 0)

  00109	85 ff		 test	 edi, edi
  0010b	79 04		 jns	 SHORT $LN11@strtold

; 84   : 	{
; 85   : 		esign = -esign;

  0010d	f7 df		 neg	 edi

; 86   : 		e = -e;

  0010f	f7 d9		 neg	 ecx
$LN11@strtold:

; 87   : 	}
; 88   : 	e = e - ne;

  00111	2b cb		 sub	 ecx, ebx

; 89   : 	if (e < -4096)

  00113	81 f9 00 f0 ff
	ff		 cmp	 ecx, -4096		; fffff000H
  00119	7d 0a		 jge	 SHORT $LN10@strtold

; 90   : 	{
; 91   : 		/* possibly subnormal number, 10^e would overflow */
; 92   : 		r *= 1.0e-2048L;

  0011b	f2 0f 59 cb	 mulsd	 xmm1, xmm3

; 93   : 		e += 2048;

  0011f	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H
$LN10@strtold:

; 94   : 	}
; 95   : 	if (e < 0)

  00125	85 c9		 test	 ecx, ecx
  00127	79 04		 jns	 SHORT $LN9@strtold

; 96   : 	{
; 97   : 		e = -e;

  00129	f7 d9		 neg	 ecx

; 98   : 		esign = -esign;

  0012b	f7 df		 neg	 edi
$LN9@strtold:

; 99   : 	}
; 100  : 	if (e >= 8192)

  0012d	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00133	7c 07		 jl	 SHORT $LN8@strtold

; 101  : 		e = 8191;

  00135	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH

; 102  : 	if (e)

  0013a	eb 04		 jmp	 SHORT $LN53@strtold
$LN8@strtold:
  0013c	85 c9		 test	 ecx, ecx
  0013e	74 2e		 je	 SHORT $LN2@strtold
$LN53@strtold:

; 103  : 	{
; 104  : 		double d = 1.0L;

  00140	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00148	b8 00 00 00 00	 mov	 eax, OFFSET _powten
  0014d	8d 49 00	 npad	 3
$LL6@strtold:

; 105  : 		l2powm1 = 0;
; 106  : 		while (e)
; 107  : 		{
; 108  : 			if (e & 1)

  00150	f6 c1 01	 test	 cl, 1
  00153	74 04		 je	 SHORT $LN4@strtold

; 109  : 				d *= powten[l2powm1];

  00155	f2 0f 59 10	 mulsd	 xmm2, QWORD PTR [eax]
$LN4@strtold:

; 110  : 			e >>= 1;
; 111  : 			l2powm1++;

  00159	83 c0 08	 add	 eax, 8
  0015c	d1 f9		 sar	 ecx, 1
  0015e	75 f0		 jne	 SHORT $LL6@strtold

; 112  : 		}
; 113  : 		if (esign > 0)

  00160	85 ff		 test	 edi, edi
  00162	7e 06		 jle	 SHORT $LN3@strtold

; 114  : 			r *= d;

  00164	f2 0f 59 ca	 mulsd	 xmm1, xmm2

; 115  : 		else

  00168	eb 04		 jmp	 SHORT $LN2@strtold
$LN3@strtold:

; 116  : 			r /= d;

  0016a	f2 0f 5e ca	 divsd	 xmm1, xmm2
$LN2@strtold:

; 117  : 	}
; 118  : 	if (sret)

  0016e	8b 45 0c	 mov	 eax, DWORD PTR _sret$[ebp]
  00171	85 c0		 test	 eax, eax
  00173	74 02		 je	 SHORT $LN1@strtold

; 119  : 		*sret = (char *)s;

  00175	89 10		 mov	 DWORD PTR [eax], edx
$LN1@strtold:
  00177	66 0f 6e 45 fc	 movd	 xmm0, DWORD PTR _sign$1$[ebp]

; 120  : 	
; 121  : 	return r * sign;

  0017c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	5b		 pop	 ebx
  00183	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00187	f2 0f 11 45 f8	 movsd	 QWORD PTR tv344[ebp], xmm0
  0018c	dd 45 f8	 fld	 QWORD PTR tv344[ebp]

; 122  : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c3		 ret	 0
__strtold ENDP
_TEXT	ENDS
END
