; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strchr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strchr
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strchr.c
;	COMDAT _strchr
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_i$ = 12						; size = 4
_strchr	PROC						; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	const unsigned char *s = (const unsigned char *)s1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00006	53		 push	 ebx

; 64   : 	unsigned char c = (unsigned char)i;
; 65   : 	unsigned long mask,j;
; 66   : 	unsigned long *aligned_addr;
; 67   : 
; 68   : 	/* Special case for finding 0.  */
; 69   : 	if (!c)

  00007	8a 5d 0c	 mov	 bl, BYTE PTR _i$[ebp]
  0000a	84 db		 test	 bl, bl
  0000c	75 5e		 jne	 SHORT $LN26@strchr

; 70   : 	{
; 71   : 		while (_strchrUNALIGNED (s))

  0000e	a8 03		 test	 al, 3
  00010	74 0e		 je	 SHORT $LN18@strchr
$LL19@strchr:

; 72   : 		{
; 73   : 			if (!*s)

  00012	80 38 00	 cmp	 BYTE PTR [eax], 0
  00015	0f 84 e7 00 00
	00		 je	 $LN21@strchr

; 74   : 				return (char *) s;
; 75   : 			s++;

  0001b	40		 inc	 eax
  0001c	a8 03		 test	 al, 3
  0001e	75 f2		 jne	 SHORT $LL19@strchr
$LN18@strchr:

; 76   : 		}
; 77   : 		/* Operate a word at a time.  */
; 78   : 		aligned_addr = (unsigned long *) s;

  00020	8b c8		 mov	 ecx, eax

; 79   : 		while (!DETECTNULL (*aligned_addr))

  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	8d 90 ff fe fe
	fe		 lea	 edx, DWORD PTR [eax-16843009]
  0002a	f7 d0		 not	 eax
  0002c	23 d0		 and	 edx, eax
  0002e	f7 c2 80 80 80
	80		 test	 edx, -2139062144	; 80808080H
  00034	75 22		 jne	 SHORT $LN15@strchr
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL16@strchr:
  00040	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 80   : 			aligned_addr++;

  00043	83 c1 04	 add	 ecx, 4
  00046	8d 90 ff fe fe
	fe		 lea	 edx, DWORD PTR [eax-16843009]
  0004c	f7 d0		 not	 eax
  0004e	23 d0		 and	 edx, eax
  00050	f7 c2 80 80 80
	80		 test	 edx, -2139062144	; 80808080H
  00056	74 e8		 je	 SHORT $LL16@strchr
$LN15@strchr:

; 81   : 		/* Found the end of string.  */
; 82   : 		s = (const unsigned char *) aligned_addr;
; 83   : 		while (*s) s++;

  00058	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0005b	8b c1		 mov	 eax, ecx
  0005d	0f 84 9f 00 00
	00		 je	 $LN21@strchr
$LL14@strchr:
  00063	40		 inc	 eax
  00064	80 38 00	 cmp	 BYTE PTR [eax], 0
  00067	75 fa		 jne	 SHORT $LL14@strchr
  00069	5b		 pop	 ebx

; 116  : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN26@strchr:

; 84   : 		return (char *) s;
; 85   : 	}
; 86   : 
; 87   : 	/* All other bytes.  Align the pointer, then search a long at a time.  */
; 88   : 	while (_strchrUNALIGNED (s))

  0006c	a8 03		 test	 al, 3
  0006e	74 17		 je	 SHORT $LN11@strchr
$LL12@strchr:

; 89   : 	{
; 90   : 		if (!*s)

  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	84 c9		 test	 cl, cl
  00074	0f 84 86 00 00
	00		 je	 $LN1@strchr

; 91   : 			return NULL;
; 92   : 		if (*s == c)

  0007a	3a cb		 cmp	 cl, bl
  0007c	0f 84 80 00 00
	00		 je	 $LN21@strchr

; 93   : 			return (char *) s;
; 94   : 		s++;

  00082	40		 inc	 eax
  00083	a8 03		 test	 al, 3
  00085	75 e9		 jne	 SHORT $LL12@strchr
$LN11@strchr:
  00087	56		 push	 esi

; 95   : 	}
; 96   : 
; 97   : 	mask = c;

  00088	0f b6 d3	 movzx	 edx, bl

; 98   : 	for (j = 8; j < LBLOCKSIZE * 8; j <<= 1)

  0008b	b9 08 00 00 00	 mov	 ecx, 8
  00090	57		 push	 edi
$LL8@strchr:

; 99   : 		mask = (mask << j) | mask;

  00091	8b f2		 mov	 esi, edx
  00093	d3 e6		 shl	 esi, cl
  00095	03 c9		 add	 ecx, ecx
  00097	0b d6		 or	 edx, esi
  00099	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009c	72 f3		 jb	 SHORT $LL8@strchr

; 100  : 
; 101  : 	aligned_addr = (unsigned long *) s;

  0009e	8b c8		 mov	 ecx, eax

; 102  : 	while (!DETECTNULL (*aligned_addr) && !DETECTCHAR (*aligned_addr, mask))

  000a0	8b 00		 mov	 eax, DWORD PTR [eax]
  000a2	8b f8		 mov	 edi, eax
  000a4	8d b0 ff fe fe
	fe		 lea	 esi, DWORD PTR [eax-16843009]
  000aa	f7 d7		 not	 edi
  000ac	23 f7		 and	 esi, edi
  000ae	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  000b4	75 2e		 jne	 SHORT $LN4@strchr
$LL5@strchr:
  000b6	33 c2		 xor	 eax, edx
  000b8	8d b0 ff fe fe
	fe		 lea	 esi, DWORD PTR [eax-16843009]
  000be	f7 d0		 not	 eax
  000c0	23 f0		 and	 esi, eax
  000c2	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  000c8	75 1a		 jne	 SHORT $LN4@strchr
  000ca	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 103  : 		aligned_addr++;

  000cd	83 c1 04	 add	 ecx, 4
  000d0	8b f8		 mov	 edi, eax
  000d2	8d b0 ff fe fe
	fe		 lea	 esi, DWORD PTR [eax-16843009]
  000d8	f7 d7		 not	 edi
  000da	23 f7		 and	 esi, edi
  000dc	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  000e2	74 d2		 je	 SHORT $LL5@strchr
$LN4@strchr:

; 104  : 
; 105  : 	/* The block of bytes currently pointed to by aligned_addr
; 106  : 		contains either a null or the target char, or both.  We
; 107  : 		catch it using the bytewise search.  */
; 108  : 
; 109  : 	s = (unsigned char *) aligned_addr;

  000e4	8b c1		 mov	 eax, ecx

; 110  : 
; 111  : 	while (*s && *s != c)

  000e6	8a 09		 mov	 cl, BYTE PTR [ecx]
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	84 c9		 test	 cl, cl
  000ec	74 0e		 je	 SHORT $LN2@strchr
  000ee	8b ff		 npad	 2
$LL3@strchr:
  000f0	3a cb		 cmp	 cl, bl
  000f2	74 0e		 je	 SHORT $LN21@strchr
  000f4	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 112  : 		s++;

  000f7	40		 inc	 eax
  000f8	84 c9		 test	 cl, cl
  000fa	75 f4		 jne	 SHORT $LL3@strchr
$LN2@strchr:

; 113  : 	if (*s == c)

  000fc	38 18		 cmp	 BYTE PTR [eax], bl

; 114  : 		return (char *)s;

  000fe	74 02		 je	 SHORT $LN21@strchr
$LN1@strchr:

; 115  : 	return NULL;

  00100	33 c0		 xor	 eax, eax
$LN21@strchr:
  00102	5b		 pop	 ebx

; 116  : }

  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_strchr	ENDP
_TEXT	ENDS
END
