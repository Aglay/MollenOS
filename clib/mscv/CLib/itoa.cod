; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\itoa.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_i64toa
PUBLIC	_i64toa_s
PUBLIC	_ui64toa
PUBLIC	_ui64toa_s
PUBLIC	_itoa_s
PUBLIC	_itoa
PUBLIC	_ltoa
PUBLIC	_ltoa_s
PUBLIC	_ultoa
EXTRN	___errno:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__aulldvrm:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ultoa
_TEXT	SEGMENT
_buffer$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ultoa	PROC						; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 327  :     char buffer[33];
; 328  :     char *pos;
; 329  :     int digit;
; 330  : 
; 331  :     pos = &buffer[32];
; 332  :     *pos = '\0';

  00010	8b 4d 10	 mov	 ecx, DWORD PTR _radix$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _string$[ebp]
  0001b	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+32]
  0001e	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL5@ultoa:

; 333  : 
; 334  :     do {
; 335  : 	digit = value % radix;

  00022	33 d2		 xor	 edx, edx

; 336  : 	value = value / radix;
; 337  : 	if (digit < 10) {
; 338  : 	    *--pos = (char)('0' + digit);

  00024	4e		 dec	 esi
  00025	f7 f1		 div	 ecx
  00027	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0002a	7d 05		 jge	 SHORT $LN2@ultoa
  0002c	80 c2 30	 add	 dl, 48			; 00000030H

; 339  : 	} else {

  0002f	eb 03		 jmp	 SHORT $LN11@ultoa
$LN2@ultoa:

; 340  : 	    *--pos = (char)('a' + digit - 10);

  00031	80 c2 57	 add	 dl, 87			; 00000057H
$LN11@ultoa:
  00034	88 16		 mov	 BYTE PTR [esi], dl

; 341  : 	} /* if */
; 342  :     } while (value != 0L);

  00036	85 c0		 test	 eax, eax
  00038	75 e8		 jne	 SHORT $LL5@ultoa

; 343  : 
; 344  :     memcpy(string, pos, &buffer[32] - pos + 1);

  0003a	8d 4d f9	 lea	 ecx, DWORD PTR _buffer$[ebp+33]
  0003d	2b ce		 sub	 ecx, esi
  0003f	51		 push	 ecx
  00040	56		 push	 esi
  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 _memcpy

; 345  : 
; 346  :     return string;
; 347  : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	8b c7		 mov	 eax, edi
  0004f	33 cd		 xor	 ecx, ebp
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_ultoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ltoa_s
_TEXT	SEGMENT
_buffer$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_ltoa_s	PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 0c	 mov	 edi, DWORD PTR _str$[ebp]

; 249  :     unsigned long val;
; 250  :     unsigned int digit;
; 251  :     int is_negative;
; 252  :     char buffer[33], *pos;
; 253  :     size_t len;
; 254  : 
; 255  :     if (!(str != NULL) || !(size > 0) ||
; 256  :         (radix >= 2) || !(radix <= 36))

  00016	85 ff		 test	 edi, edi
  00018	0f 84 a9 00 00
	00		 je	 $LN14@ltoa_s
  0001e	8b 75 10	 mov	 esi, DWORD PTR _size$[ebp]
  00021	85 f6		 test	 esi, esi
  00023	0f 84 9e 00 00
	00		 je	 $LN14@ltoa_s
  00029	8b 5d 14	 mov	 ebx, DWORD PTR _radix$[ebp]
  0002c	83 fb 02	 cmp	 ebx, 2
  0002f	0f 8d 8b 00 00
	00		 jge	 $LN15@ltoa_s

; 262  :         return EINVAL;
; 263  :     }
; 264  : 
; 265  :     if (value < 0 && radix == 10)
; 266  :     {
; 267  :         is_negative = 1;
; 268  :         val = -value;
; 269  :     }
; 270  :     else
; 271  :     {
; 272  :         is_negative = 0;
; 273  :         val = value;

  00035	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 274  :     }
; 275  : 
; 276  :     pos = buffer + 32;

  00038	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 277  :     *pos = '\0';

  0003b	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
  0003f	90		 npad	 1
$LL11@ltoa_s:

; 278  : 
; 279  :     do
; 280  :     {
; 281  :         digit = val % radix;

  00040	33 d2		 xor	 edx, edx

; 282  :         val /= radix;
; 283  : 
; 284  :         if (digit < 10)
; 285  :             *--pos = (char)('0' + digit);

  00042	49		 dec	 ecx
  00043	f7 f3		 div	 ebx
  00045	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00048	73 05		 jae	 SHORT $LN8@ltoa_s
  0004a	80 c2 30	 add	 dl, 48			; 00000030H

; 286  :         else

  0004d	eb 03		 jmp	 SHORT $LN27@ltoa_s
$LN8@ltoa_s:

; 287  :             *--pos = (char)('a' + digit - 10);

  0004f	80 c2 57	 add	 dl, 87			; 00000057H
$LN27@ltoa_s:
  00052	88 11		 mov	 BYTE PTR [ecx], dl

; 288  :     }
; 289  :     while (val != 0);

  00054	85 c0		 test	 eax, eax
  00056	75 e8		 jne	 SHORT $LL11@ltoa_s

; 290  : 
; 291  :     if (is_negative)
; 292  :         *--pos = '-';
; 293  : 
; 294  :     len = buffer + 33 - pos;

  00058	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  0005b	2b c1		 sub	 eax, ecx

; 295  :     if (len > size)

  0005d	3b c6		 cmp	 eax, esi
  0005f	76 41		 jbe	 SHORT $LN5@ltoa_s

; 296  :     {
; 297  :         size_t i;
; 298  :         char *p = str;
; 299  : 
; 300  :         /* Copy the temporary buffer backwards up to the available number of
; 301  :          * characters. Don't copy the negative sign if present. */
; 302  : 
; 303  :         if (is_negative)
; 304  :         {
; 305  :             p++;
; 306  :             size--;
; 307  :         }
; 308  : 
; 309  :         for (pos = buffer + 31, i = 0; i < size; i++)

  00061	8d 55 f7	 lea	 edx, DWORD PTR _buffer$[ebp+31]
  00064	8b cf		 mov	 ecx, edi
  00066	85 f6		 test	 esi, esi
  00068	74 14		 je	 SHORT $LN1@ltoa_s
  0006a	8d 9b 00 00 00
	00		 npad	 6
$LL3@ltoa_s:

; 310  :             *p++ = *pos--;

  00070	8a 02		 mov	 al, BYTE PTR [edx]
  00072	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00075	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00078	8d 52 ff	 lea	 edx, DWORD PTR [edx-1]
  0007b	4e		 dec	 esi
  0007c	75 f2		 jne	 SHORT $LL3@ltoa_s
$LN1@ltoa_s:

; 311  : 
; 312  :         str[0] = '\0';

  0007e	c6 07 00	 mov	 BYTE PTR [edi], 0

; 313  :         //("str[size] is too small");
; 314  :         *__errno() = EINVAL;

  00081	e8 00 00 00 00	 call	 ___errno
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 315  :         return ERANGE;

  0008f	b8 22 00 00 00	 mov	 eax, 34			; 00000022H

; 320  : }

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	33 cd		 xor	 ecx, ebp
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
$LN5@ltoa_s:

; 316  :     }
; 317  : 
; 318  :     memcpy(str, pos, len);

  000a2	50		 push	 eax
  000a3	51		 push	 ecx
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 _memcpy
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 319  :     return 0;

  000ad	33 c0		 xor	 eax, eax
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx

; 320  : }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
$LN15@ltoa_s:

; 257  :     {
; 258  :         if (str && size)

  000c0	85 f6		 test	 esi, esi
  000c2	74 03		 je	 SHORT $LN14@ltoa_s

; 259  :             str[0] = '\0';

  000c4	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN14@ltoa_s:

; 260  : 
; 261  :         *__errno() = EINVAL;

  000c7	e8 00 00 00 00	 call	 ___errno

; 320  : }

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  000d7	33 cd		 xor	 ecx, ebp
  000d9	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000de	5b		 pop	 ebx
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
_ltoa_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ltoa
_TEXT	SEGMENT
_buffer$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ltoa	PROC						; COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 209  :     unsigned long val;
; 210  :     int negative;
; 211  :     char buffer[33];
; 212  :     char *pos;
; 213  :     int digit;
; 214  : 
; 215  :     if (value < 0 && radix == 10) {

  00010	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _string$[ebp]
  0001c	85 c0		 test	 eax, eax
  0001e	79 0c		 jns	 SHORT $LN8@ltoa
  00020	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00023	75 07		 jne	 SHORT $LN8@ltoa

; 216  : 	negative = 1;

  00025	8d 5e f7	 lea	 ebx, DWORD PTR [esi-9]

; 217  :         val = -value;

  00028	f7 d8		 neg	 eax

; 218  :     } else {

  0002a	eb 02		 jmp	 SHORT $LN7@ltoa
$LN8@ltoa:

; 219  : 	negative = 0;

  0002c	33 db		 xor	 ebx, ebx
$LN7@ltoa:

; 220  :         val = value;
; 221  :     } /* if */
; 222  : 
; 223  :     pos = &buffer[32];

  0002e	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 224  :     *pos = '\0';

  00031	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL6@ltoa:

; 225  : 
; 226  :     do {
; 227  : 	digit = val % radix;

  00035	33 d2		 xor	 edx, edx

; 228  : 	val = val / radix;
; 229  : 	if (digit < 10) {
; 230  : 	    *--pos = (char)('0' + digit);

  00037	49		 dec	 ecx
  00038	f7 f6		 div	 esi
  0003a	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0003d	7d 05		 jge	 SHORT $LN3@ltoa
  0003f	80 c2 30	 add	 dl, 48			; 00000030H

; 231  : 	} else {

  00042	eb 03		 jmp	 SHORT $LN14@ltoa
$LN3@ltoa:

; 232  : 	    *--pos = (char)('a' + digit - 10);

  00044	80 c2 57	 add	 dl, 87			; 00000057H
$LN14@ltoa:
  00047	88 11		 mov	 BYTE PTR [ecx], dl

; 233  : 	} /* if */
; 234  :     } while (val != 0L);

  00049	85 c0		 test	 eax, eax
  0004b	75 e8		 jne	 SHORT $LL6@ltoa

; 235  : 
; 236  :     if (negative) {

  0004d	85 db		 test	 ebx, ebx
  0004f	74 04		 je	 SHORT $LN1@ltoa

; 237  : 	*--pos = '-';

  00051	49		 dec	 ecx
  00052	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN1@ltoa:

; 238  :     } /* if */
; 239  : 
; 240  :     memcpy(string, pos, &buffer[32] - pos + 1);

  00055	8d 55 f9	 lea	 edx, DWORD PTR _buffer$[ebp+33]
  00058	2b d1		 sub	 edx, ecx
  0005a	52		 push	 edx
  0005b	51		 push	 ecx
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 _memcpy

; 241  :     return string;
; 242  : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	8b c7		 mov	 eax, edi
  0006a	33 cd		 xor	 ecx, ebp
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_ltoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _itoa
_TEXT	SEGMENT
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_itoa	PROC						; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : }

  00003	5d		 pop	 ebp

; 201  :   return ltoa(value, string, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa
_itoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _itoa_s
_TEXT	SEGMENT
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_itoa_s	PROC						; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : }

  00003	5d		 pop	 ebp

; 193  :     return ltoa_s(value, str, size, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa_s
_itoa_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ui64toa_s
_TEXT	SEGMENT
tv138 = -92						; size = 8
tv94 = -84						; size = 4
tv95 = -80						; size = 4
_str$GSCopy$1$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_ui64toa_s PROC						; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]
  00013	89 45 b4	 mov	 DWORD PTR _str$GSCopy$1$[ebp], eax

; 155  :     char buffer[65], *pos;
; 156  :     int digit;
; 157  : 
; 158  :     if (!(str != NULL) || !(size > 0) ||
; 159  :         !(radix>=2) || !(radix<=36)) {

  00016	85 c0		 test	 eax, eax
  00018	0f 84 a8 00 00
	00		 je	 $LN7@ui64toa_s
  0001e	83 7d 14 00	 cmp	 DWORD PTR _size$[ebp], 0
  00022	0f 86 9e 00 00
	00		 jbe	 $LN7@ui64toa_s
  00028	8b 45 18	 mov	 eax, DWORD PTR _radix$[ebp]
  0002b	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  0002e	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00031	0f 87 8f 00 00
	00		 ja	 $LN7@ui64toa_s

; 161  :         return EINVAL;
; 162  :     }
; 163  : 
; 164  :     pos = buffer+64;
; 165  :     *pos = '\0';

  00037	99		 cdq
  00038	56		 push	 esi
  00039	8b c8		 mov	 ecx, eax
  0003b	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0003f	57		 push	 edi
  00040	8b 7d 08	 mov	 edi, DWORD PTR _value$[ebp]
  00043	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  00046	8b c2		 mov	 eax, edx
  00048	89 4d b0	 mov	 DWORD PTR tv95[ebp], ecx
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  0004e	89 45 ac	 mov	 DWORD PTR tv94[ebp], eax
  00051	53		 push	 ebx
$LL6@ui64toa_s:

; 166  : 
; 167  :     do {
; 168  :         digit = value%radix;

  00052	50		 push	 eax
  00053	51		 push	 ecx
  00054	52		 push	 edx
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 __aulldvrm

; 169  :         value /= radix;
; 170  : 
; 171  :         if(digit < 10)
; 172  :             *--pos = (char)('0' + digit);

  0005b	4e		 dec	 esi
  0005c	89 5d a8	 mov	 DWORD PTR tv138[ebp+4], ebx
  0005f	8b f8		 mov	 edi, eax
  00061	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00064	7d 05		 jge	 SHORT $LN3@ui64toa_s
  00066	80 c1 30	 add	 cl, 48			; 00000030H

; 173  :         else

  00069	eb 03		 jmp	 SHORT $LN15@ui64toa_s
$LN3@ui64toa_s:

; 174  :             *--pos = (char)('a' + digit - 10);

  0006b	80 c1 57	 add	 cl, 87			; 00000057H
$LN15@ui64toa_s:

; 175  :     }while(value != 0);

  0006e	8b c7		 mov	 eax, edi
  00070	88 0e		 mov	 BYTE PTR [esi], cl
  00072	8b 4d b0	 mov	 ecx, DWORD PTR tv95[ebp]
  00075	0b c2		 or	 eax, edx
  00077	8b 45 ac	 mov	 eax, DWORD PTR tv94[ebp]
  0007a	75 d6		 jne	 SHORT $LL6@ui64toa_s

; 176  : 
; 177  :     if((unsigned)(buffer-pos+65) > size) {

  0007c	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  0007f	2b c6		 sub	 eax, esi
  00081	5b		 pop	 ebx
  00082	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  00085	76 20		 jbe	 SHORT $LN1@ui64toa_s

; 178  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 179  : 
; 180  :         *__errno() = EINVAL;

  00087	e8 00 00 00 00	 call	 ___errno
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 181  :         return EINVAL;

  00094	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 186  : }

  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	33 cd		 xor	 ecx, ebp
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN1@ui64toa_s:

; 182  :     }
; 183  : 
; 184  :     memcpy(str, pos, buffer-pos+65);

  000a7	50		 push	 eax
  000a8	56		 push	 esi
  000a9	ff 75 b4	 push	 DWORD PTR _str$GSCopy$1$[ebp]
  000ac	e8 00 00 00 00	 call	 _memcpy
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  :     return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi

; 186  : }

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bb	33 cd		 xor	 ecx, ebp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN7@ui64toa_s:

; 160  :         *__errno() = EINVAL;

  000c6	e8 00 00 00 00	 call	 ___errno

; 186  : }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  000d6	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_ui64toa_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ui64toa
_TEXT	SEGMENT
tv131 = -92						; size = 8
tv147 = -84						; size = 4
tv146 = -80						; size = 4
_string$GSCopy$1$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_string$ = 16						; size = 4
_radix$ = 20						; size = 4
_ui64toa PROC						; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _string$[ebp]
  00013	89 45 b4	 mov	 DWORD PTR _string$GSCopy$1$[ebp], eax
  00016	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00019	99		 cdq
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	8b c8		 mov	 ecx, eax

; 129  :     char buffer[65];
; 130  :     char *pos;
; 131  :     int digit;
; 132  : 
; 133  :     pos = &buffer[64];
; 134  :     *pos = '\0';

  0001e	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  00022	8b c2		 mov	 eax, edx
  00024	89 4d b0	 mov	 DWORD PTR tv146[ebp], ecx
  00027	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  0002a	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  0002d	57		 push	 edi
  0002e	8b 7d 08	 mov	 edi, DWORD PTR _value$[ebp]
  00031	89 45 ac	 mov	 DWORD PTR tv147[ebp], eax
$LL5@ui64toa:

; 135  : 
; 136  :     do {
; 137  : 	digit = value % radix;

  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	52		 push	 edx
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 __aulldvrm

; 138  : 	value = value / radix;
; 139  : 	if (digit < 10) {
; 140  : 	    *--pos = (char)('0' + digit);

  0003d	4e		 dec	 esi
  0003e	89 5d a8	 mov	 DWORD PTR tv131[ebp+4], ebx
  00041	8b f8		 mov	 edi, eax
  00043	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00046	7d 05		 jge	 SHORT $LN2@ui64toa
  00048	80 c1 30	 add	 cl, 48			; 00000030H

; 141  : 	} else {

  0004b	eb 03		 jmp	 SHORT $LN11@ui64toa
$LN2@ui64toa:

; 142  : 	    *--pos = (char)('a' + digit - 10);

  0004d	80 c1 57	 add	 cl, 87			; 00000057H
$LN11@ui64toa:

; 143  : 	} /* if */
; 144  :     } while (value != 0L);

  00050	8b c7		 mov	 eax, edi
  00052	88 0e		 mov	 BYTE PTR [esi], cl
  00054	8b 4d b0	 mov	 ecx, DWORD PTR tv146[ebp]
  00057	0b c2		 or	 eax, edx
  00059	8b 45 ac	 mov	 eax, DWORD PTR tv147[ebp]
  0005c	75 d6		 jne	 SHORT $LL5@ui64toa

; 145  : 
; 146  :     memcpy(string, pos, &buffer[64] - pos + 1);

  0005e	8d 4d f9	 lea	 ecx, DWORD PTR _buffer$[ebp+65]
  00061	2b ce		 sub	 ecx, esi
  00063	51		 push	 ecx
  00064	56		 push	 esi
  00065	8b 75 b4	 mov	 esi, DWORD PTR _string$GSCopy$1$[ebp]
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 _memcpy

; 147  :     return string;
; 148  : }

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	8b c6		 mov	 eax, esi
  00076	33 cd		 xor	 ecx, ebp
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_ui64toa ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _i64toa_s
_TEXT	SEGMENT
tv297 = -92						; size = 8
_val$2$ = -88						; size = 4
tv186 = -84						; size = 4
_is_negative$1$ = -80					; size = 4
_str$GSCopy$1$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_i64toa_s PROC						; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]
  00013	89 45 b4	 mov	 DWORD PTR _str$GSCopy$1$[ebp], eax
  00016	57		 push	 edi

; 51   :     unsigned __int64 val;
; 52   :     unsigned int digit;
; 53   :     int is_negative;
; 54   :     char buffer[65], *pos;
; 55   :     size_t len;
; 56   : 
; 57   :     if (!(str != NULL) || !(size > 0) ||
; 58   :         !(radix >= 2) || !(radix <= 36))

  00017	85 c0		 test	 eax, eax
  00019	0f 84 0e 01 00
	00		 je	 $LN14@i64toa_s
  0001f	8b 7d 14	 mov	 edi, DWORD PTR _size$[ebp]
  00022	85 ff		 test	 edi, edi
  00024	0f 84 03 01 00
	00		 je	 $LN14@i64toa_s
  0002a	8b 55 18	 mov	 edx, DWORD PTR _radix$[ebp]
  0002d	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00030	83 f8 22	 cmp	 eax, 34			; 00000022H
  00033	0f 87 ea 00 00
	00		 ja	 $LN27@i64toa_s

; 63   :         return EINVAL;
; 64   :     }
; 65   : 
; 66   :     if (value < 0 && radix == 10)

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0003c	53		 push	 ebx
  0003d	8b 5d 0c	 mov	 ebx, DWORD PTR _value$[ebp+4]
  00040	56		 push	 esi
  00041	85 db		 test	 ebx, ebx
  00043	7f 1b		 jg	 SHORT $LN13@i64toa_s
  00045	7c 04		 jl	 SHORT $LN26@i64toa_s
  00047	85 c9		 test	 ecx, ecx
  00049	73 15		 jae	 SHORT $LN13@i64toa_s
$LN26@i64toa_s:
  0004b	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0004e	75 10		 jne	 SHORT $LN13@i64toa_s

; 67   :     {
; 68   :         is_negative = 1;
; 69   :         val = -value;

  00050	f7 d9		 neg	 ecx
  00052	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _is_negative$1$[ebp], 1
  00059	83 d3 00	 adc	 ebx, 0
  0005c	f7 db		 neg	 ebx

; 70   :     }
; 71   :     else

  0005e	eb 07		 jmp	 SHORT $LN12@i64toa_s
$LN13@i64toa_s:

; 72   :     {
; 73   :         is_negative = 0;

  00060	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _is_negative$1$[ebp], 0
$LN12@i64toa_s:
  00067	8b c2		 mov	 eax, edx

; 74   :         val = value;
; 75   :     }
; 76   : 
; 77   :     pos = buffer + 64;
; 78   :     *pos = '\0';

  00069	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0006d	99		 cdq
  0006e	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  00071	89 45 ac	 mov	 DWORD PTR tv186[ebp], eax
  00074	8b fa		 mov	 edi, edx
$LL11@i64toa_s:

; 79   : 
; 80   :     do
; 81   :     {
; 82   :         digit = val % radix;

  00076	57		 push	 edi
  00077	50		 push	 eax
  00078	53		 push	 ebx
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 __aulldvrm
  0007f	89 5d a8	 mov	 DWORD PTR tv297[ebp+4], ebx

; 83   :         val /= radix;
; 84   : 
; 85   :         if (digit < 10)
; 86   :             *--pos = (char)('0' + digit);

  00082	4e		 dec	 esi
  00083	89 45 a8	 mov	 DWORD PTR _val$2$[ebp], eax
  00086	8b da		 mov	 ebx, edx
  00088	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0008b	73 05		 jae	 SHORT $LN8@i64toa_s
  0008d	80 c1 30	 add	 cl, 48			; 00000030H

; 87   :         else

  00090	eb 03		 jmp	 SHORT $LN30@i64toa_s
$LN8@i64toa_s:

; 88   :             *--pos = (char)('a' + digit - 10);

  00092	80 c1 57	 add	 cl, 87			; 00000057H
$LN30@i64toa_s:
  00095	88 0e		 mov	 BYTE PTR [esi], cl

; 89   :     }
; 90   :     while (val != 0);

  00097	8b 4d a8	 mov	 ecx, DWORD PTR _val$2$[ebp]
  0009a	8b c1		 mov	 eax, ecx
  0009c	0b c3		 or	 eax, ebx
  0009e	8b 45 ac	 mov	 eax, DWORD PTR tv186[ebp]
  000a1	75 d3		 jne	 SHORT $LL11@i64toa_s

; 91   : 
; 92   :     if (is_negative)

  000a3	8b 55 b0	 mov	 edx, DWORD PTR _is_negative$1$[ebp]
  000a6	8b 7d 14	 mov	 edi, DWORD PTR _size$[ebp]
  000a9	85 d2		 test	 edx, edx
  000ab	74 04		 je	 SHORT $LN6@i64toa_s

; 93   :         *--pos = '-';

  000ad	4e		 dec	 esi
  000ae	c6 06 2d	 mov	 BYTE PTR [esi], 45	; 0000002dH
$LN6@i64toa_s:

; 94   : 
; 95   :     len = buffer + 65 - pos;

  000b1	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  000b4	2b c6		 sub	 eax, esi

; 96   :     if (len > size)

  000b6	3b c7		 cmp	 eax, edi
  000b8	76 48		 jbe	 SHORT $LN5@i64toa_s

; 97   :     {
; 98   :         size_t i;
; 99   :         char *p = str;

  000ba	8b 75 b4	 mov	 esi, DWORD PTR _str$GSCopy$1$[ebp]
  000bd	8b ce		 mov	 ecx, esi

; 100  : 
; 101  :         /* Copy the temporary buffer backwards up to the available number of
; 102  :          * characters. Don't copy the negative sign if present. */
; 103  : 
; 104  :         if (is_negative)

  000bf	85 d2		 test	 edx, edx
  000c1	74 04		 je	 SHORT $LN4@i64toa_s

; 105  :         {
; 106  :             p++;

  000c3	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 107  :             size--;

  000c6	4f		 dec	 edi
$LN4@i64toa_s:

; 108  :         }
; 109  : 
; 110  :         for (pos = buffer + 63, i = 0; i < size; i++)

  000c7	8d 55 f7	 lea	 edx, DWORD PTR _buffer$[ebp+63]
  000ca	85 ff		 test	 edi, edi
  000cc	74 10		 je	 SHORT $LN1@i64toa_s
  000ce	8b ff		 npad	 2
$LL3@i64toa_s:

; 111  :             *p++ = *pos--;

  000d0	8a 02		 mov	 al, BYTE PTR [edx]
  000d2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000d5	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  000d8	8d 52 ff	 lea	 edx, DWORD PTR [edx-1]
  000db	4f		 dec	 edi
  000dc	75 f2		 jne	 SHORT $LL3@i64toa_s
$LN1@i64toa_s:

; 112  : 
; 113  :         str[0] = '\0';

  000de	c6 06 00	 mov	 BYTE PTR [esi], 0

; 114  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 115  : 
; 116  :         *__errno() = ERANGE;

  000e1	e8 00 00 00 00	 call	 ___errno
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	5f		 pop	 edi
  000e9	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H

; 117  :         return ERANGE;

  000ef	b8 22 00 00 00	 mov	 eax, 34			; 00000022H

; 122  : }

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	33 cd		 xor	 ecx, ebp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
$LN5@i64toa_s:

; 118  :     }
; 119  : 
; 120  :     memcpy(str, pos, len);

  00102	50		 push	 eax
  00103	56		 push	 esi
  00104	8b 75 b4	 mov	 esi, DWORD PTR _str$GSCopy$1$[ebp]
  00107	56		 push	 esi
  00108	e8 00 00 00 00	 call	 _memcpy
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  :     return 0;

  00110	33 c0		 xor	 eax, eax
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	5f		 pop	 edi

; 122  : }

  00115	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00118	33 cd		 xor	 ecx, ebp
  0011a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN27@i64toa_s:
  00123	8b 45 b4	 mov	 eax, DWORD PTR _str$GSCopy$1$[ebp]

; 59   :     {
; 60   :         if (str && size)

  00126	85 ff		 test	 edi, edi
  00128	74 03		 je	 SHORT $LN14@i64toa_s

; 61   :             str[0] = '\0';

  0012a	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN14@i64toa_s:

; 62   :         *__errno() = EINVAL;

  0012d	e8 00 00 00 00	 call	 ___errno

; 122  : }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	5f		 pop	 edi
  00138	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0013e	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
_i64toa_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _i64toa
_TEXT	SEGMENT
tv130 = -96						; size = 8
_string$GSCopy$1$ = -88					; size = 4
tv149 = -84						; size = 4
tv148 = -80						; size = 4
_negative$1$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_string$ = 16						; size = 4
_radix$ = 20						; size = 4
_i64toa	PROC						; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _string$[ebp]
  00013	53		 push	 ebx

; 11   :     unsigned long long val;
; 12   :     int negative;
; 13   :     char buffer[65];
; 14   :     char *pos;
; 15   :     int digit;
; 16   : 
; 17   :     if (value < 0 && radix == 10) {

  00014	8b 5d 08	 mov	 ebx, DWORD PTR _value$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _value$[ebp+4]
  0001c	89 45 a8	 mov	 DWORD PTR _string$GSCopy$1$[ebp], eax
  0001f	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00022	85 ff		 test	 edi, edi
  00024	7f 1b		 jg	 SHORT $LN8@i64toa
  00026	7c 04		 jl	 SHORT $LN14@i64toa
  00028	85 db		 test	 ebx, ebx
  0002a	73 15		 jae	 SHORT $LN8@i64toa
$LN14@i64toa:
  0002c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0002f	75 10		 jne	 SHORT $LN8@i64toa

; 18   : 	negative = 1;
; 19   :         val = -value;

  00031	f7 db		 neg	 ebx
  00033	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _negative$1$[ebp], 1
  0003a	83 d7 00	 adc	 edi, 0
  0003d	f7 df		 neg	 edi

; 20   :     } else {

  0003f	eb 07		 jmp	 SHORT $LN7@i64toa
$LN8@i64toa:

; 21   : 	negative = 0;

  00041	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _negative$1$[ebp], 0
$LN7@i64toa:
  00048	99		 cdq

; 22   :         val = value;
; 23   :     } /* if */
; 24   : 
; 25   :     pos = &buffer[64];

  00049	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  0004c	8b c8		 mov	 ecx, eax

; 26   :     *pos = '\0';

  0004e	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  00052	8b c2		 mov	 eax, edx
  00054	89 4d b0	 mov	 DWORD PTR tv148[ebp], ecx
  00057	89 45 ac	 mov	 DWORD PTR tv149[ebp], eax
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL6@i64toa:

; 27   : 
; 28   :     do {
; 29   : 	digit = val % radix;

  00060	50		 push	 eax
  00061	51		 push	 ecx
  00062	57		 push	 edi
  00063	53		 push	 ebx
  00064	e8 00 00 00 00	 call	 __aulldvrm

; 30   : 	val = val / radix;
; 31   : 	if (digit < 10) {
; 32   : 	    *--pos = (char)('0' + digit);

  00069	4e		 dec	 esi
  0006a	89 5d a4	 mov	 DWORD PTR tv130[ebp+4], ebx
  0006d	8b d8		 mov	 ebx, eax
  0006f	8b fa		 mov	 edi, edx
  00071	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00074	7d 05		 jge	 SHORT $LN3@i64toa
  00076	80 c1 30	 add	 cl, 48			; 00000030H

; 33   : 	} else {

  00079	eb 03		 jmp	 SHORT $LN15@i64toa
$LN3@i64toa:

; 34   : 	    *--pos = (char)('a' + digit - 10);

  0007b	80 c1 57	 add	 cl, 87			; 00000057H
$LN15@i64toa:

; 35   : 	} /* if */
; 36   :     } while (val != 0L);

  0007e	8b c3		 mov	 eax, ebx
  00080	88 0e		 mov	 BYTE PTR [esi], cl
  00082	8b 4d b0	 mov	 ecx, DWORD PTR tv148[ebp]
  00085	0b c7		 or	 eax, edi
  00087	8b 45 ac	 mov	 eax, DWORD PTR tv149[ebp]
  0008a	75 d4		 jne	 SHORT $LL6@i64toa

; 37   : 
; 38   :     if (negative) {

  0008c	83 7d b4 00	 cmp	 DWORD PTR _negative$1$[ebp], 0
  00090	74 04		 je	 SHORT $LN1@i64toa

; 39   : 	*--pos = '-';

  00092	4e		 dec	 esi
  00093	c6 06 2d	 mov	 BYTE PTR [esi], 45	; 0000002dH
$LN1@i64toa:

; 40   :     } /* if */
; 41   : 
; 42   :     memcpy(string, pos, &buffer[64] - pos + 1);

  00096	8d 4d f9	 lea	 ecx, DWORD PTR _buffer$[ebp+65]
  00099	2b ce		 sub	 ecx, esi
  0009b	51		 push	 ecx
  0009c	56		 push	 esi
  0009d	8b 75 a8	 mov	 esi, DWORD PTR _string$GSCopy$1$[ebp]
  000a0	56		 push	 esi
  000a1	e8 00 00 00 00	 call	 _memcpy

; 43   :     return string;
; 44   : }

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	8b c6		 mov	 eax, esi
  000ae	33 cd		 xor	 ecx, ebp
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
_i64toa	ENDP
_TEXT	ENDS
END
