; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\itoa.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	__errno:DWORD
_DATA	ENDS
PUBLIC	_i64toa
PUBLIC	_i64toa_s
PUBLIC	_ui64toa
PUBLIC	_ui64toa_s
PUBLIC	_itoa_s
PUBLIC	_itoa
PUBLIC	_ltoa
PUBLIC	_ltoa_s
PUBLIC	_ultoa
EXTRN	___errno:PROC
EXTRN	__aulldvrm:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ultoa
_TEXT	SEGMENT
_buffer$ = -36						; size = 33
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ultoa	PROC						; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 327  :     char buffer[33];
; 328  :     char *pos;
; 329  :     int digit;
; 330  : 
; 331  :     pos = &buffer[32];
; 332  :     *pos = '\0';

  00006	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00009	8d 4d fc	 lea	 ecx, DWORD PTR _buffer$[ebp+32]
  0000c	56		 push	 esi
  0000d	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  00010	c6 45 fc 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL5@ultoa:

; 333  : 
; 334  :     do {
; 335  : 	digit = value % radix;

  00014	33 d2		 xor	 edx, edx

; 336  : 	value = value / radix;
; 337  : 	if (digit < 10) {
; 338  : 	    *--pos = (char)('0' + digit);

  00016	49		 dec	 ecx
  00017	f7 f6		 div	 esi
  00019	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0001c	7d 05		 jge	 SHORT $LN2@ultoa
  0001e	80 c2 30	 add	 dl, 48			; 00000030H

; 339  : 	} else {

  00021	eb 03		 jmp	 SHORT $LN11@ultoa
$LN2@ultoa:

; 340  : 	    *--pos = (char)('a' + digit - 10);

  00023	80 c2 57	 add	 dl, 87			; 00000057H
$LN11@ultoa:
  00026	88 11		 mov	 BYTE PTR [ecx], dl

; 341  : 	} /* if */
; 342  :     } while (value != 0L);

  00028	85 c0		 test	 eax, eax
  0002a	75 e8		 jne	 SHORT $LL5@ultoa

; 343  : 
; 344  :     memcpy(string, pos, &buffer[32] - pos + 1);

  0002c	8b 75 0c	 mov	 esi, DWORD PTR _string$[ebp]
  0002f	8d 45 fd	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  00032	2b c1		 sub	 eax, ecx
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 345  : 
; 346  :     return string;

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 347  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_ultoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ltoa_s
_TEXT	SEGMENT
_buffer$ = -36						; size = 33
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_ltoa_s	PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 249  :     unsigned long val;
; 250  :     unsigned int digit;
; 251  :     int is_negative;
; 252  :     char buffer[33], *pos;
; 253  :     size_t len;
; 254  : 
; 255  :     if (!(str != NULL) || !(size > 0) ||
; 256  :         (radix >= 2) || !(radix <= 36))

  00009	8b 7d 0c	 mov	 edi, DWORD PTR _str$[ebp]
  0000c	85 ff		 test	 edi, edi
  0000e	0f 84 8f 00 00
	00		 je	 $LN14@ltoa_s
  00014	8b 75 10	 mov	 esi, DWORD PTR _size$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	0f 84 84 00 00
	00		 je	 $LN14@ltoa_s
  0001f	8b 5d 14	 mov	 ebx, DWORD PTR _radix$[ebp]
  00022	83 fb 02	 cmp	 ebx, 2
  00025	7d 75		 jge	 SHORT $LN15@ltoa_s

; 263  :     }
; 264  : 
; 265  :     if (value < 0 && radix == 10)
; 266  :     {
; 267  :         is_negative = 1;
; 268  :         val = -value;
; 269  :     }
; 270  :     else
; 271  :     {
; 272  :         is_negative = 0;
; 273  :         val = value;

  00027	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]

; 274  :     }
; 275  : 
; 276  :     pos = buffer + 32;

  0002a	8d 4d fc	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 277  :     *pos = '\0';

  0002d	c6 45 fc 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL11@ltoa_s:

; 278  : 
; 279  :     do
; 280  :     {
; 281  :         digit = val % radix;

  00031	33 d2		 xor	 edx, edx

; 282  :         val /= radix;
; 283  : 
; 284  :         if (digit < 10)
; 285  :             *--pos = (char)('0' + digit);

  00033	49		 dec	 ecx
  00034	f7 f3		 div	 ebx
  00036	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00039	73 05		 jae	 SHORT $LN8@ltoa_s
  0003b	80 c2 30	 add	 dl, 48			; 00000030H

; 286  :         else

  0003e	eb 03		 jmp	 SHORT $LN27@ltoa_s
$LN8@ltoa_s:

; 287  :             *--pos = (char)('a' + digit - 10);

  00040	80 c2 57	 add	 dl, 87			; 00000057H
$LN27@ltoa_s:
  00043	88 11		 mov	 BYTE PTR [ecx], dl

; 288  :     }
; 289  :     while (val != 0);

  00045	85 c0		 test	 eax, eax
  00047	75 e8		 jne	 SHORT $LL11@ltoa_s

; 290  : 
; 291  :     if (is_negative)
; 292  :         *--pos = '-';
; 293  : 
; 294  :     len = buffer + 33 - pos;

  00049	8d 45 fd	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  0004c	2b c1		 sub	 eax, ecx

; 295  :     if (len > size)

  0004e	3b c6		 cmp	 eax, esi
  00050	76 36		 jbe	 SHORT $LN5@ltoa_s

; 296  :     {
; 297  :         size_t i;
; 298  :         char *p = str;
; 299  : 
; 300  :         /* Copy the temporary buffer backwards up to the available number of
; 301  :          * characters. Don't copy the negative sign if present. */
; 302  : 
; 303  :         if (is_negative)
; 304  :         {
; 305  :             p++;
; 306  :             size--;
; 307  :         }
; 308  : 
; 309  :         for (pos = buffer + 31, i = 0; i < size; i++)

  00052	8d 55 fb	 lea	 edx, DWORD PTR _buffer$[ebp+31]
  00055	8b cf		 mov	 ecx, edi
  00057	85 f6		 test	 esi, esi
  00059	74 13		 je	 SHORT $LN1@ltoa_s
  0005b	eb 03 8d 49 00	 npad	 5
$LL3@ltoa_s:

; 310  :             *p++ = *pos--;

  00060	8a 02		 mov	 al, BYTE PTR [edx]
  00062	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00065	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  00068	8d 52 ff	 lea	 edx, DWORD PTR [edx-1]
  0006b	4e		 dec	 esi
  0006c	75 f2		 jne	 SHORT $LL3@ltoa_s
$LN1@ltoa_s:

; 311  : 
; 312  :         str[0] = '\0';

  0006e	c6 07 00	 mov	 BYTE PTR [edi], 0

; 313  :         //("str[size] is too small");
; 314  :         *__errno() = EINVAL;

  00071	e8 00 00 00 00	 call	 ___errno
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 315  :         return ERANGE;

  0007f	b8 22 00 00 00	 mov	 eax, 34			; 00000022H

; 320  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN5@ltoa_s:

; 316  :     }
; 317  : 
; 318  :     memcpy(str, pos, len);

  00088	50		 push	 eax
  00089	51		 push	 ecx
  0008a	57		 push	 edi
  0008b	e8 00 00 00 00	 call	 _memcpy
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 319  :     return 0;

  00093	33 c0		 xor	 eax, eax
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 320  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$LN15@ltoa_s:

; 257  :     {
; 258  :         if (str && size)

  0009c	85 f6		 test	 esi, esi
  0009e	74 03		 je	 SHORT $LN14@ltoa_s

; 259  :             str[0] = '\0';

  000a0	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN14@ltoa_s:

; 260  : 
; 261  :         *__errno() = EINVAL;

  000a3	e8 00 00 00 00	 call	 ___errno
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 262  :         return EINVAL;

  000b1	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 320  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_ltoa_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ltoa
_TEXT	SEGMENT
_buffer$ = -36						; size = 33
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ltoa	PROC						; COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 209  :     unsigned long val;
; 210  :     int negative;
; 211  :     char buffer[33];
; 212  :     char *pos;
; 213  :     int digit;
; 214  : 
; 215  :     if (value < 0 && radix == 10) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  0000d	57		 push	 edi
  0000e	85 c0		 test	 eax, eax
  00010	79 0c		 jns	 SHORT $LN8@ltoa
  00012	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00015	75 07		 jne	 SHORT $LN8@ltoa

; 216  : 	negative = 1;

  00017	8d 7e f7	 lea	 edi, DWORD PTR [esi-9]

; 217  :         val = -value;

  0001a	f7 d8		 neg	 eax

; 218  :     } else {

  0001c	eb 02		 jmp	 SHORT $LN7@ltoa
$LN8@ltoa:

; 219  : 	negative = 0;

  0001e	33 ff		 xor	 edi, edi
$LN7@ltoa:

; 220  :         val = value;
; 221  :     } /* if */
; 222  : 
; 223  :     pos = &buffer[32];

  00020	8d 4d fc	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 224  :     *pos = '\0';

  00023	c6 45 fc 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL6@ltoa:

; 225  : 
; 226  :     do {
; 227  : 	digit = val % radix;

  00027	33 d2		 xor	 edx, edx

; 228  : 	val = val / radix;
; 229  : 	if (digit < 10) {
; 230  : 	    *--pos = (char)('0' + digit);

  00029	49		 dec	 ecx
  0002a	f7 f6		 div	 esi
  0002c	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0002f	7d 05		 jge	 SHORT $LN3@ltoa
  00031	80 c2 30	 add	 dl, 48			; 00000030H

; 231  : 	} else {

  00034	eb 03		 jmp	 SHORT $LN14@ltoa
$LN3@ltoa:

; 232  : 	    *--pos = (char)('a' + digit - 10);

  00036	80 c2 57	 add	 dl, 87			; 00000057H
$LN14@ltoa:
  00039	88 11		 mov	 BYTE PTR [ecx], dl

; 233  : 	} /* if */
; 234  :     } while (val != 0L);

  0003b	85 c0		 test	 eax, eax
  0003d	75 e8		 jne	 SHORT $LL6@ltoa

; 235  : 
; 236  :     if (negative) {

  0003f	85 ff		 test	 edi, edi
  00041	74 04		 je	 SHORT $LN1@ltoa

; 237  : 	*--pos = '-';

  00043	49		 dec	 ecx
  00044	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN1@ltoa:

; 238  :     } /* if */
; 239  : 
; 240  :     memcpy(string, pos, &buffer[32] - pos + 1);

  00047	8b 75 0c	 mov	 esi, DWORD PTR _string$[ebp]
  0004a	8d 45 fd	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  0004d	2b c1		 sub	 eax, ecx
  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 _memcpy
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 241  :     return string;

  0005a	8b c6		 mov	 eax, esi
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 242  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_ltoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _itoa
_TEXT	SEGMENT
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_itoa	PROC						; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : }

  00003	5d		 pop	 ebp

; 201  :   return ltoa(value, string, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa
_itoa	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _itoa_s
_TEXT	SEGMENT
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_itoa_s	PROC						; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : }

  00003	5d		 pop	 ebp

; 193  :     return ltoa_s(value, str, size, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa_s
_itoa_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ui64toa_s
_TEXT	SEGMENT
_buffer$ = -84						; size = 65
tv136 = -16						; size = 8
tv94 = -8						; size = 4
tv89 = -4						; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_ui64toa_s PROC						; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H

; 155  :     char buffer[65], *pos;
; 156  :     int digit;
; 157  : 
; 158  :     if (!(str != NULL) || !(size > 0) ||
; 159  :         !(radix>=2) || !(radix<=36)) {

  00006	83 7d 10 00	 cmp	 DWORD PTR _str$[ebp], 0
  0000a	0f 84 90 00 00
	00		 je	 $LN7@ui64toa_s
  00010	83 7d 14 00	 cmp	 DWORD PTR _size$[ebp], 0
  00014	0f 86 86 00 00
	00		 jbe	 $LN7@ui64toa_s
  0001a	8b 45 18	 mov	 eax, DWORD PTR _radix$[ebp]
  0001d	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  00020	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00023	77 7b		 ja	 SHORT $LN7@ui64toa_s

; 162  :     }
; 163  : 
; 164  :     pos = buffer+64;
; 165  :     *pos = '\0';

  00025	99		 cdq
  00026	56		 push	 esi
  00027	8b c8		 mov	 ecx, eax
  00029	c6 45 ec 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0002d	57		 push	 edi
  0002e	8b 7d 08	 mov	 edi, DWORD PTR _value$[ebp]
  00031	8d 75 ec	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  00034	8b c2		 mov	 eax, edx
  00036	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  00039	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  0003c	89 45 fc	 mov	 DWORD PTR tv89[ebp], eax
  0003f	53		 push	 ebx
$LL6@ui64toa_s:

; 166  : 
; 167  :     do {
; 168  :         digit = value%radix;

  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	52		 push	 edx
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 __aulldvrm

; 169  :         value /= radix;
; 170  : 
; 171  :         if(digit < 10)
; 172  :             *--pos = (char)('0' + digit);

  00049	4e		 dec	 esi
  0004a	89 5d f4	 mov	 DWORD PTR tv136[ebp+4], ebx
  0004d	8b f8		 mov	 edi, eax
  0004f	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00052	7d 05		 jge	 SHORT $LN3@ui64toa_s
  00054	80 c1 30	 add	 cl, 48			; 00000030H

; 173  :         else

  00057	eb 03		 jmp	 SHORT $LN15@ui64toa_s
$LN3@ui64toa_s:

; 174  :             *--pos = (char)('a' + digit - 10);

  00059	80 c1 57	 add	 cl, 87			; 00000057H
$LN15@ui64toa_s:

; 175  :     }while(value != 0);

  0005c	8b c7		 mov	 eax, edi
  0005e	88 0e		 mov	 BYTE PTR [esi], cl
  00060	8b 4d f8	 mov	 ecx, DWORD PTR tv94[ebp]
  00063	0b c2		 or	 eax, edx
  00065	8b 45 fc	 mov	 eax, DWORD PTR tv89[ebp]
  00068	75 d6		 jne	 SHORT $LL6@ui64toa_s

; 176  : 
; 177  :     if((unsigned)(buffer-pos+65) > size) {

  0006a	8d 45 ed	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  0006d	2b c6		 sub	 eax, esi
  0006f	5b		 pop	 ebx
  00070	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  00073	76 16		 jbe	 SHORT $LN1@ui64toa_s

; 178  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 179  : 
; 180  :         *__errno() = EINVAL;

  00075	e8 00 00 00 00	 call	 ___errno
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 181  :         return EINVAL;

  00082	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 186  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN1@ui64toa_s:

; 182  :     }
; 183  : 
; 184  :     memcpy(str, pos, buffer-pos+65);

  0008b	50		 push	 eax
  0008c	56		 push	 esi
  0008d	ff 75 10	 push	 DWORD PTR _str$[ebp]
  00090	e8 00 00 00 00	 call	 _memcpy
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  :     return 0;

  00098	33 c0		 xor	 eax, eax
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi

; 186  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN7@ui64toa_s:

; 160  :         *__errno() = EINVAL;

  000a0	e8 00 00 00 00	 call	 ___errno
  000a5	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 161  :         return EINVAL;

  000ab	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 186  : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
_ui64toa_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _ui64toa
_TEXT	SEGMENT
_buffer$ = -72						; size = 65
tv147 = -4						; size = 4
tv131 = 8						; size = 8
_value$ = 8						; size = 8
_string$ = 16						; size = 4
tv148 = 20						; size = 4
_radix$ = 20						; size = 4
_ui64toa PROC						; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00009	99		 cdq
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b c8		 mov	 ecx, eax

; 129  :     char buffer[65];
; 130  :     char *pos;
; 131  :     int digit;
; 132  : 
; 133  :     pos = &buffer[64];
; 134  :     *pos = '\0';

  0000e	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  00012	8b c2		 mov	 eax, edx
  00014	89 4d fc	 mov	 DWORD PTR tv147[ebp], ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  0001a	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  0001d	57		 push	 edi
  0001e	8b 7d 08	 mov	 edi, DWORD PTR _value$[ebp]
  00021	89 45 14	 mov	 DWORD PTR tv148[ebp], eax
$LL5@ui64toa:

; 135  : 
; 136  :     do {
; 137  : 	digit = value % radix;

  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	52		 push	 edx
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 __aulldvrm

; 138  : 	value = value / radix;
; 139  : 	if (digit < 10) {
; 140  : 	    *--pos = (char)('0' + digit);

  0002d	4e		 dec	 esi
  0002e	89 5d 0c	 mov	 DWORD PTR tv131[ebp+4], ebx
  00031	8b f8		 mov	 edi, eax
  00033	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00036	7d 05		 jge	 SHORT $LN2@ui64toa
  00038	80 c1 30	 add	 cl, 48			; 00000030H

; 141  : 	} else {

  0003b	eb 03		 jmp	 SHORT $LN11@ui64toa
$LN2@ui64toa:

; 142  : 	    *--pos = (char)('a' + digit - 10);

  0003d	80 c1 57	 add	 cl, 87			; 00000057H
$LN11@ui64toa:

; 143  : 	} /* if */
; 144  :     } while (value != 0L);

  00040	8b c7		 mov	 eax, edi
  00042	88 0e		 mov	 BYTE PTR [esi], cl
  00044	8b 4d fc	 mov	 ecx, DWORD PTR tv147[ebp]
  00047	0b c2		 or	 eax, edx
  00049	8b 45 14	 mov	 eax, DWORD PTR tv148[ebp]
  0004c	75 d6		 jne	 SHORT $LL5@ui64toa

; 145  : 
; 146  :     memcpy(string, pos, &buffer[64] - pos + 1);

  0004e	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  00051	2b c6		 sub	 eax, esi
  00053	50		 push	 eax
  00054	56		 push	 esi
  00055	8b 75 10	 mov	 esi, DWORD PTR _string$[ebp]
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 _memcpy
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  :     return string;

  00061	8b c6		 mov	 eax, esi
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx

; 148  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_ui64toa ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _i64toa_s
_TEXT	SEGMENT
_buffer$ = -84						; size = 65
tv187 = -16						; size = 4
tv299 = -12						; size = 8
_val$2$ = -8						; size = 4
_is_negative$1$ = -4					; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_i64toa_s PROC						; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   :     unsigned __int64 val;
; 52   :     unsigned int digit;
; 53   :     int is_negative;
; 54   :     char buffer[65], *pos;
; 55   :     size_t len;
; 56   : 
; 57   :     if (!(str != NULL) || !(size > 0) ||
; 58   :         !(radix >= 2) || !(radix <= 36))

  00003	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]
  00006	83 ec 54	 sub	 esp, 84			; 00000054H
  00009	57		 push	 edi
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 fe 00 00
	00		 je	 $LN14@i64toa_s
  00012	8b 7d 14	 mov	 edi, DWORD PTR _size$[ebp]
  00015	85 ff		 test	 edi, edi
  00017	0f 84 f3 00 00
	00		 je	 $LN14@i64toa_s
  0001d	8b 55 18	 mov	 edx, DWORD PTR _radix$[ebp]
  00020	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00023	83 f8 22	 cmp	 eax, 34			; 00000022H
  00026	0f 87 da 00 00
	00		 ja	 $LN27@i64toa_s

; 64   :     }
; 65   : 
; 66   :     if (value < 0 && radix == 10)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0002f	53		 push	 ebx
  00030	8b 5d 0c	 mov	 ebx, DWORD PTR _value$[ebp+4]
  00033	85 db		 test	 ebx, ebx
  00035	7f 1b		 jg	 SHORT $LN13@i64toa_s
  00037	7c 04		 jl	 SHORT $LN26@i64toa_s
  00039	85 c9		 test	 ecx, ecx
  0003b	73 15		 jae	 SHORT $LN13@i64toa_s
$LN26@i64toa_s:
  0003d	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00040	75 10		 jne	 SHORT $LN13@i64toa_s

; 67   :     {
; 68   :         is_negative = 1;
; 69   :         val = -value;

  00042	f7 d9		 neg	 ecx
  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _is_negative$1$[ebp], 1
  0004b	83 d3 00	 adc	 ebx, 0
  0004e	f7 db		 neg	 ebx

; 70   :     }
; 71   :     else

  00050	eb 07		 jmp	 SHORT $LN12@i64toa_s
$LN13@i64toa_s:

; 72   :     {
; 73   :         is_negative = 0;

  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _is_negative$1$[ebp], 0
$LN12@i64toa_s:
  00059	8b c2		 mov	 eax, edx

; 74   :         val = value;
; 75   :     }
; 76   : 
; 77   :     pos = buffer + 64;
; 78   :     *pos = '\0';

  0005b	c6 45 ec 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0005f	99		 cdq
  00060	56		 push	 esi
  00061	8d 75 ec	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  00064	89 45 f0	 mov	 DWORD PTR tv187[ebp], eax
  00067	8b fa		 mov	 edi, edx
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL11@i64toa_s:

; 79   : 
; 80   :     do
; 81   :     {
; 82   :         digit = val % radix;

  00070	57		 push	 edi
  00071	50		 push	 eax
  00072	53		 push	 ebx
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 __aulldvrm
  00079	89 5d f8	 mov	 DWORD PTR tv299[ebp+4], ebx

; 83   :         val /= radix;
; 84   : 
; 85   :         if (digit < 10)
; 86   :             *--pos = (char)('0' + digit);

  0007c	4e		 dec	 esi
  0007d	89 45 f8	 mov	 DWORD PTR _val$2$[ebp], eax
  00080	8b da		 mov	 ebx, edx
  00082	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00085	73 05		 jae	 SHORT $LN8@i64toa_s
  00087	80 c1 30	 add	 cl, 48			; 00000030H

; 87   :         else

  0008a	eb 03		 jmp	 SHORT $LN31@i64toa_s
$LN8@i64toa_s:

; 88   :             *--pos = (char)('a' + digit - 10);

  0008c	80 c1 57	 add	 cl, 87			; 00000057H
$LN31@i64toa_s:
  0008f	88 0e		 mov	 BYTE PTR [esi], cl

; 89   :     }
; 90   :     while (val != 0);

  00091	8b 4d f8	 mov	 ecx, DWORD PTR _val$2$[ebp]
  00094	8b c1		 mov	 eax, ecx
  00096	0b c3		 or	 eax, ebx
  00098	8b 45 f0	 mov	 eax, DWORD PTR tv187[ebp]
  0009b	75 d3		 jne	 SHORT $LL11@i64toa_s

; 91   : 
; 92   :     if (is_negative)

  0009d	8b 55 fc	 mov	 edx, DWORD PTR _is_negative$1$[ebp]
  000a0	8b 7d 14	 mov	 edi, DWORD PTR _size$[ebp]
  000a3	85 d2		 test	 edx, edx
  000a5	74 04		 je	 SHORT $LN6@i64toa_s

; 93   :         *--pos = '-';

  000a7	4e		 dec	 esi
  000a8	c6 06 2d	 mov	 BYTE PTR [esi], 45	; 0000002dH
$LN6@i64toa_s:

; 94   : 
; 95   :     len = buffer + 65 - pos;

  000ab	8d 45 ed	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  000ae	2b c6		 sub	 eax, esi

; 96   :     if (len > size)

  000b0	3b c7		 cmp	 eax, edi
  000b2	76 3c		 jbe	 SHORT $LN5@i64toa_s

; 97   :     {
; 98   :         size_t i;
; 99   :         char *p = str;

  000b4	8b 5d 10	 mov	 ebx, DWORD PTR _str$[ebp]
  000b7	8b cb		 mov	 ecx, ebx

; 100  : 
; 101  :         /* Copy the temporary buffer backwards up to the available number of
; 102  :          * characters. Don't copy the negative sign if present. */
; 103  : 
; 104  :         if (is_negative)

  000b9	85 d2		 test	 edx, edx
  000bb	74 04		 je	 SHORT $LN4@i64toa_s

; 105  :         {
; 106  :             p++;

  000bd	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]

; 107  :             size--;

  000c0	4f		 dec	 edi
$LN4@i64toa_s:

; 108  :         }
; 109  : 
; 110  :         for (pos = buffer + 63, i = 0; i < size; i++)

  000c1	8d 55 eb	 lea	 edx, DWORD PTR _buffer$[ebp+63]
  000c4	85 ff		 test	 edi, edi
  000c6	74 0e		 je	 SHORT $LN1@i64toa_s
$LL3@i64toa_s:

; 111  :             *p++ = *pos--;

  000c8	8a 02		 mov	 al, BYTE PTR [edx]
  000ca	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000cd	88 41 ff	 mov	 BYTE PTR [ecx-1], al
  000d0	8d 52 ff	 lea	 edx, DWORD PTR [edx-1]
  000d3	4f		 dec	 edi
  000d4	75 f2		 jne	 SHORT $LL3@i64toa_s
$LN1@i64toa_s:

; 112  : 
; 113  :         str[0] = '\0';

  000d6	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 114  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 115  : 
; 116  :         *__errno() = ERANGE;

  000d9	e8 00 00 00 00	 call	 ___errno
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	5f		 pop	 edi
  000e1	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H

; 117  :         return ERANGE;

  000e7	b8 22 00 00 00	 mov	 eax, 34			; 00000022H

; 122  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
$LN5@i64toa_s:

; 118  :     }
; 119  : 
; 120  :     memcpy(str, pos, len);

  000f0	50		 push	 eax
  000f1	56		 push	 esi
  000f2	ff 75 10	 push	 DWORD PTR _str$[ebp]
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  :     return 0;

  000fd	33 c0		 xor	 eax, eax
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	5f		 pop	 edi

; 122  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN27@i64toa_s:
  00106	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]

; 59   :     {
; 60   :         if (str && size)

  00109	85 ff		 test	 edi, edi
  0010b	74 03		 je	 SHORT $LN14@i64toa_s

; 61   :             str[0] = '\0';

  0010d	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN14@i64toa_s:

; 62   :         *__errno() = EINVAL;

  00110	e8 00 00 00 00	 call	 ___errno
  00115	5f		 pop	 edi
  00116	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 63   :         return EINVAL;

  0011c	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 122  : }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
_i64toa_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _i64toa
_TEXT	SEGMENT
_buffer$ = -80						; size = 65
tv128 = -12						; size = 8
tv149 = -4						; size = 4
_value$ = 8						; size = 8
tv150 = 12						; size = 4
_string$ = 16						; size = 4
_negative$1$ = 20					; size = 4
_radix$ = 20						; size = 4
_i64toa	PROC						; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11   :     unsigned long long val;
; 12   :     int negative;
; 13   :     char buffer[65];
; 14   :     char *pos;
; 15   :     int digit;
; 16   : 
; 17   :     if (value < 0 && radix == 10) {

  00003	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00006	83 ec 50	 sub	 esp, 80			; 00000050H
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _value$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR _value$[ebp+4]
  00012	85 ff		 test	 edi, edi
  00014	7f 1b		 jg	 SHORT $LN8@i64toa
  00016	7c 04		 jl	 SHORT $LN14@i64toa
  00018	85 db		 test	 ebx, ebx
  0001a	73 15		 jae	 SHORT $LN8@i64toa
$LN14@i64toa:
  0001c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0001f	75 10		 jne	 SHORT $LN8@i64toa

; 18   : 	negative = 1;
; 19   :         val = -value;

  00021	f7 db		 neg	 ebx
  00023	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _negative$1$[ebp], 1
  0002a	83 d7 00	 adc	 edi, 0
  0002d	f7 df		 neg	 edi

; 20   :     } else {

  0002f	eb 07		 jmp	 SHORT $LN7@i64toa
$LN8@i64toa:

; 21   : 	negative = 0;

  00031	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _negative$1$[ebp], 0
$LN7@i64toa:
  00038	99		 cdq

; 22   :         val = value;
; 23   :     } /* if */
; 24   : 
; 25   :     pos = &buffer[64];

  00039	8d 75 f0	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  0003c	8b c8		 mov	 ecx, eax

; 26   :     *pos = '\0';

  0003e	c6 45 f0 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  00042	8b c2		 mov	 eax, edx
  00044	89 4d fc	 mov	 DWORD PTR tv149[ebp], ecx
  00047	89 45 0c	 mov	 DWORD PTR tv150[ebp], eax
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL6@i64toa:

; 27   : 
; 28   :     do {
; 29   : 	digit = val % radix;

  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	57		 push	 edi
  00053	53		 push	 ebx
  00054	e8 00 00 00 00	 call	 __aulldvrm

; 30   : 	val = val / radix;
; 31   : 	if (digit < 10) {
; 32   : 	    *--pos = (char)('0' + digit);

  00059	4e		 dec	 esi
  0005a	89 5d f8	 mov	 DWORD PTR tv128[ebp+4], ebx
  0005d	8b d8		 mov	 ebx, eax
  0005f	8b fa		 mov	 edi, edx
  00061	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00064	7d 05		 jge	 SHORT $LN3@i64toa
  00066	80 c1 30	 add	 cl, 48			; 00000030H

; 33   : 	} else {

  00069	eb 03		 jmp	 SHORT $LN15@i64toa
$LN3@i64toa:

; 34   : 	    *--pos = (char)('a' + digit - 10);

  0006b	80 c1 57	 add	 cl, 87			; 00000057H
$LN15@i64toa:

; 35   : 	} /* if */
; 36   :     } while (val != 0L);

  0006e	8b c3		 mov	 eax, ebx
  00070	88 0e		 mov	 BYTE PTR [esi], cl
  00072	8b 4d fc	 mov	 ecx, DWORD PTR tv149[ebp]
  00075	0b c7		 or	 eax, edi
  00077	8b 45 0c	 mov	 eax, DWORD PTR tv150[ebp]
  0007a	75 d4		 jne	 SHORT $LL6@i64toa

; 37   : 
; 38   :     if (negative) {

  0007c	83 7d 14 00	 cmp	 DWORD PTR _negative$1$[ebp], 0
  00080	74 04		 je	 SHORT $LN1@i64toa

; 39   : 	*--pos = '-';

  00082	4e		 dec	 esi
  00083	c6 06 2d	 mov	 BYTE PTR [esi], 45	; 0000002dH
$LN1@i64toa:

; 40   :     } /* if */
; 41   : 
; 42   :     memcpy(string, pos, &buffer[64] - pos + 1);

  00086	8d 45 f1	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  00089	2b c6		 sub	 eax, esi
  0008b	50		 push	 eax
  0008c	56		 push	 esi
  0008d	8b 75 10	 mov	 esi, DWORD PTR _string$[ebp]
  00090	56		 push	 esi
  00091	e8 00 00 00 00	 call	 _memcpy
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 43   :     return string;

  00099	8b c6		 mov	 eax, esi
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx

; 44   : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_i64toa	ENDP
_TEXT	ENDS
END
