; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\itoa.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_string$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_i64toa
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	__aulldvrm:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _i64toa
_TEXT	SEGMENT
tv133 = -96						; size = 8
_string$GSCopy$ = -88					; size = 4
tv164 = -84						; size = 8
_negative$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_string$ = 16						; size = 4
_radix$ = 20						; size = 4
_i64toa	PROC						; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _string$[ebp]

; 11   :     unsigned long long val;
; 12   :     int negative;
; 13   :     char buffer[65];
; 14   :     char *pos;
; 15   :     int digit;
; 16   : 
; 17   :     if (value < 0 && radix == 10) {

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp+4]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _value$[ebp]
  0001b	33 d2		 xor	 edx, edx

; 40   :     } /* if */
; 41   : 
; 42   :     memcpy(string, pos, &buffer[64] - pos + 1);

  0001d	89 45 a8	 mov	 DWORD PTR _string$GSCopy$[ebp], eax
  00020	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00023	57		 push	 edi
  00024	3b ca		 cmp	 ecx, edx
  00026	7f 1a		 jg	 SHORT $LN8@i64toa

; 11   :     unsigned long long val;
; 12   :     int negative;
; 13   :     char buffer[65];
; 14   :     char *pos;
; 15   :     int digit;
; 16   : 
; 17   :     if (value < 0 && radix == 10) {

  00028	7c 04		 jl	 SHORT $LN12@i64toa
  0002a	3b f2		 cmp	 esi, edx
  0002c	73 14		 jae	 SHORT $LN8@i64toa
$LN12@i64toa:
  0002e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00031	75 0f		 jne	 SHORT $LN8@i64toa

; 18   : 	negative = 1;
; 19   :         val = -value;

  00033	f7 de		 neg	 esi
  00035	13 ca		 adc	 ecx, edx
  00037	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1
  0003e	f7 d9		 neg	 ecx

; 20   :     } else {

  00040	eb 03		 jmp	 SHORT $LN14@i64toa
$LN8@i64toa:

; 21   : 	negative = 0;

  00042	89 55 b4	 mov	 DWORD PTR _negative$[ebp], edx
$LN14@i64toa:

; 22   :         val = value;
; 23   :     } /* if */
; 24   : 
; 25   :     pos = &buffer[64];
; 26   :     *pos = '\0';

  00045	88 55 f8	 mov	 BYTE PTR _buffer$[ebp+64], dl

; 35   : 	} /* if */
; 36   :     } while (val != 0L);

  00048	99		 cdq
  00049	8b d9		 mov	 ebx, ecx
  0004b	8d 7d f8	 lea	 edi, DWORD PTR _buffer$[ebp+64]
  0004e	89 45 ac	 mov	 DWORD PTR tv164[ebp], eax
  00051	89 55 b0	 mov	 DWORD PTR tv164[ebp+4], edx
$LL6@i64toa:

; 27   : 
; 28   :     do {
; 29   : 	digit = val % radix;

  00054	8b 4d b0	 mov	 ecx, DWORD PTR tv164[ebp+4]
  00057	8b 55 ac	 mov	 edx, DWORD PTR tv164[ebp]
  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 __aulldvrm

; 30   : 	val = val / radix;
; 31   : 	if (digit < 10) {
; 32   : 	    *--pos = (char)('0' + digit);

  00063	4f		 dec	 edi
  00064	89 5d a4	 mov	 DWORD PTR tv133[ebp+4], ebx
  00067	8b f0		 mov	 esi, eax
  00069	8b da		 mov	 ebx, edx
  0006b	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0006e	7d 05		 jge	 SHORT $LN3@i64toa
  00070	80 c1 30	 add	 cl, 48			; 00000030H

; 33   : 	} else {

  00073	eb 03		 jmp	 SHORT $LN15@i64toa
$LN3@i64toa:

; 34   : 	    *--pos = (char)('a' + digit - 10);

  00075	80 c1 57	 add	 cl, 87			; 00000057H
$LN15@i64toa:

; 35   : 	} /* if */
; 36   :     } while (val != 0L);

  00078	8b c6		 mov	 eax, esi
  0007a	0b c3		 or	 eax, ebx
  0007c	88 0f		 mov	 BYTE PTR [edi], cl
  0007e	75 d4		 jne	 SHORT $LL6@i64toa

; 37   : 
; 38   :     if (negative) {

  00080	39 45 b4	 cmp	 DWORD PTR _negative$[ebp], eax
  00083	74 04		 je	 SHORT $LN1@i64toa

; 39   : 	*--pos = '-';

  00085	4f		 dec	 edi
  00086	c6 07 2d	 mov	 BYTE PTR [edi], 45	; 0000002dH
$LN1@i64toa:

; 40   :     } /* if */
; 41   : 
; 42   :     memcpy(string, pos, &buffer[64] - pos + 1);

  00089	8b 75 a8	 mov	 esi, DWORD PTR _string$GSCopy$[ebp]
  0008c	8d 4d f9	 lea	 ecx, DWORD PTR _buffer$[ebp+65]
  0008f	2b cf		 sub	 ecx, edi
  00091	51		 push	 ecx
  00092	57		 push	 edi
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 _memcpy

; 43   :     return string;
; 44   : }

  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	5f		 pop	 edi
  000a0	8b c6		 mov	 eax, esi
  000a2	5e		 pop	 esi
  000a3	33 cd		 xor	 ecx, ebp
  000a5	5b		 pop	 ebx
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_i64toa	ENDP
_TEXT	ENDS
PUBLIC	_str$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_i64toa_s
EXTRN	___errno:PROC
; Function compile flags: /Ogtp
;	COMDAT _i64toa_s
_TEXT	SEGMENT
tv191 = -96						; size = 8
tv200 = -88						; size = 8
_is_negative$ = -80					; size = 4
_str$GSCopy$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_i64toa_s PROC						; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _str$[ebp]

; 51   :     unsigned __int64 val;
; 52   :     unsigned int digit;
; 53   :     int is_negative;
; 54   :     char buffer[65], *pos;
; 55   :     size_t len;
; 56   : 
; 57   :     if (!(str != NULL) || !(size > 0) ||
; 58   :         !(radix >= 2) || !(radix <= 36))

  00013	33 c0		 xor	 eax, eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 118  :     }
; 119  : 
; 120  :     memcpy(str, pos, len);

  00017	89 55 b4	 mov	 DWORD PTR _str$GSCopy$[ebp], edx
  0001a	3b d0		 cmp	 edx, eax
  0001c	0f 84 00 01 00
	00		 je	 $LN14@i64toa_s

; 51   :     unsigned __int64 val;
; 52   :     unsigned int digit;
; 53   :     int is_negative;
; 54   :     char buffer[65], *pos;
; 55   :     size_t len;
; 56   : 
; 57   :     if (!(str != NULL) || !(size > 0) ||
; 58   :         !(radix >= 2) || !(radix <= 36))

  00022	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00025	3b c8		 cmp	 ecx, eax
  00027	0f 86 f1 00 00
	00		 jbe	 $LN26@i64toa_s
  0002d	8b 7d 18	 mov	 edi, DWORD PTR _radix$[ebp]
  00030	8d 77 fe	 lea	 esi, DWORD PTR [edi-2]
  00033	83 fe 22	 cmp	 esi, 34			; 00000022H
  00036	0f 87 e0 00 00
	00		 ja	 $LN15@i64toa_s

; 63   :         return EINVAL;
; 64   :     }
; 65   : 
; 66   :     if (value < 0 && radix == 10)

  0003c	8b 75 08	 mov	 esi, DWORD PTR _value$[ebp]
  0003f	53		 push	 ebx
  00040	8b 5d 0c	 mov	 ebx, DWORD PTR _value$[ebp+4]
  00043	3b d8		 cmp	 ebx, eax
  00045	7f 1a		 jg	 SHORT $LN13@i64toa_s
  00047	7c 04		 jl	 SHORT $LN22@i64toa_s
  00049	3b f0		 cmp	 esi, eax
  0004b	73 14		 jae	 SHORT $LN13@i64toa_s
$LN22@i64toa_s:
  0004d	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00050	75 0f		 jne	 SHORT $LN13@i64toa_s

; 67   :     {
; 68   :         is_negative = 1;
; 69   :         val = -value;

  00052	f7 de		 neg	 esi
  00054	13 d8		 adc	 ebx, eax
  00056	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _is_negative$[ebp], 1
  0005d	f7 db		 neg	 ebx

; 70   :     }
; 71   :     else

  0005f	eb 03		 jmp	 SHORT $LN12@i64toa_s
$LN13@i64toa_s:

; 72   :     {
; 73   :         is_negative = 0;

  00061	89 45 b0	 mov	 DWORD PTR _is_negative$[ebp], eax
$LN12@i64toa_s:

; 74   :         val = value;
; 75   :     }
; 76   : 
; 77   :     pos = buffer + 64;
; 78   :     *pos = '\0';

  00064	88 45 f8	 mov	 BYTE PTR _buffer$[ebp+64], al

; 89   :     }
; 90   :     while (val != 0);

  00067	8b 45 18	 mov	 eax, DWORD PTR _radix$[ebp]
  0006a	99		 cdq
  0006b	8d 7d f8	 lea	 edi, DWORD PTR _buffer$[ebp+64]
  0006e	89 45 a8	 mov	 DWORD PTR tv200[ebp], eax
  00071	89 55 ac	 mov	 DWORD PTR tv200[ebp+4], edx
$LL11@i64toa_s:

; 79   : 
; 80   :     do
; 81   :     {
; 82   :         digit = val % radix;

  00074	8b 45 ac	 mov	 eax, DWORD PTR tv200[ebp+4]
  00077	8b 4d a8	 mov	 ecx, DWORD PTR tv200[ebp]
  0007a	50		 push	 eax
  0007b	51		 push	 ecx
  0007c	53		 push	 ebx
  0007d	56		 push	 esi
  0007e	e8 00 00 00 00	 call	 __aulldvrm

; 83   :         val /= radix;
; 84   : 
; 85   :         if (digit < 10)
; 86   :             *--pos = (char)('0' + digit);

  00083	4f		 dec	 edi
  00084	89 5d a4	 mov	 DWORD PTR tv191[ebp+4], ebx
  00087	8b f0		 mov	 esi, eax
  00089	8b da		 mov	 ebx, edx
  0008b	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0008e	73 05		 jae	 SHORT $LN8@i64toa_s
  00090	80 c1 30	 add	 cl, 48			; 00000030H

; 87   :         else

  00093	eb 03		 jmp	 SHORT $LN27@i64toa_s
$LN8@i64toa_s:

; 88   :             *--pos = (char)('a' + digit - 10);

  00095	80 c1 57	 add	 cl, 87			; 00000057H
$LN27@i64toa_s:

; 89   :     }
; 90   :     while (val != 0);

  00098	8b d6		 mov	 edx, esi
  0009a	0b d3		 or	 edx, ebx
  0009c	88 0f		 mov	 BYTE PTR [edi], cl
  0009e	75 d4		 jne	 SHORT $LL11@i64toa_s

; 91   : 
; 92   :     if (is_negative)

  000a0	8b 4d b0	 mov	 ecx, DWORD PTR _is_negative$[ebp]
  000a3	5b		 pop	 ebx
  000a4	85 c9		 test	 ecx, ecx
  000a6	74 04		 je	 SHORT $LN24@i64toa_s

; 93   :         *--pos = '-';

  000a8	4f		 dec	 edi
  000a9	c6 07 2d	 mov	 BYTE PTR [edi], 45	; 0000002dH
$LN24@i64toa_s:

; 94   : 
; 95   :     len = buffer + 65 - pos;
; 96   :     if (len > size)

  000ac	8b 75 14	 mov	 esi, DWORD PTR _size$[ebp]
  000af	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  000b2	2b c7		 sub	 eax, edi
  000b4	3b c6		 cmp	 eax, esi
  000b6	76 44		 jbe	 SHORT $LN5@i64toa_s

; 97   :     {
; 98   :         size_t i;
; 99   :         char *p = str;

  000b8	8b 7d b4	 mov	 edi, DWORD PTR _str$GSCopy$[ebp]
  000bb	8b c7		 mov	 eax, edi

; 100  : 
; 101  :         /* Copy the temporary buffer backwards up to the available number of
; 102  :          * characters. Don't copy the negative sign if present. */
; 103  : 
; 104  :         if (is_negative)

  000bd	85 c9		 test	 ecx, ecx
  000bf	74 04		 je	 SHORT $LN25@i64toa_s

; 105  :         {
; 106  :             p++;

  000c1	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 107  :             size--;

  000c4	4e		 dec	 esi
$LN25@i64toa_s:

; 108  :         }
; 109  : 
; 110  :         for (pos = buffer + 63, i = 0; i < size; i++)

  000c5	8d 4d f7	 lea	 ecx, DWORD PTR _buffer$[ebp+63]
  000c8	85 f6		 test	 esi, esi
  000ca	74 0d		 je	 SHORT $LN1@i64toa_s
  000cc	8d 64 24 00	 npad	 4
$LL3@i64toa_s:

; 111  :             *p++ = *pos--;

  000d0	8a 11		 mov	 dl, BYTE PTR [ecx]
  000d2	88 10		 mov	 BYTE PTR [eax], dl
  000d4	40		 inc	 eax
  000d5	49		 dec	 ecx
  000d6	4e		 dec	 esi
  000d7	75 f7		 jne	 SHORT $LL3@i64toa_s
$LN1@i64toa_s:

; 112  : 
; 113  :         str[0] = '\0';

  000d9	c6 07 00	 mov	 BYTE PTR [edi], 0

; 114  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 115  : 
; 116  :         *__errno() = ERANGE;

  000dc	e8 00 00 00 00	 call	 ___errno
  000e1	5f		 pop	 edi
  000e2	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H

; 117  :         return ERANGE;

  000e8	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000ed	5e		 pop	 esi

; 122  : }

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f1	33 cd		 xor	 ecx, ebp
  000f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
$LN5@i64toa_s:

; 118  :     }
; 119  : 
; 120  :     memcpy(str, pos, len);

  000fc	50		 push	 eax
  000fd	8b 45 b4	 mov	 eax, DWORD PTR _str$GSCopy$[ebp]
  00100	57		 push	 edi
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _memcpy
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	5f		 pop	 edi

; 121  :     return 0;

  0010b	33 c0		 xor	 eax, eax
  0010d	5e		 pop	 esi

; 122  : }

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN15@i64toa_s:

; 59   :     {
; 60   :         if (str && size)

  0011c	3b c8		 cmp	 ecx, eax
$LN26@i64toa_s:
  0011e	74 02		 je	 SHORT $LN14@i64toa_s

; 61   :             str[0] = '\0';

  00120	88 02		 mov	 BYTE PTR [edx], al
$LN14@i64toa_s:

; 62   :         *__errno() = EINVAL;

  00122	e8 00 00 00 00	 call	 ___errno

; 122  : }

  00127	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012a	5f		 pop	 edi
  0012b	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00131	33 cd		 xor	 ecx, ebp
  00133	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00138	5e		 pop	 esi
  00139	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
_i64toa_s ENDP
_TEXT	ENDS
PUBLIC	_string$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ui64toa
; Function compile flags: /Ogtp
;	COMDAT _ui64toa
_TEXT	SEGMENT
tv133 = -92						; size = 8
tv161 = -84						; size = 8
_string$GSCopy$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_string$ = 16						; size = 4
_radix$ = 20						; size = 4
_ui64toa PROC						; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _string$[ebp]

; 143  : 	} /* if */
; 144  :     } while (value != 0L);

  00013	89 45 b4	 mov	 DWORD PTR _string$GSCopy$[ebp], eax
  00016	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00019	53		 push	 ebx
  0001a	99		 cdq
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b f8		 mov	 edi, eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00022	89 55 b0	 mov	 DWORD PTR tv161[ebp+4], edx
  00025	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00028	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  0002b	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0002f	90		 npad	 1
$LL5@ui64toa:

; 129  :     char buffer[65];
; 130  :     char *pos;
; 131  :     int digit;
; 132  : 
; 133  :     pos = &buffer[64];
; 134  :     *pos = '\0';
; 135  : 
; 136  :     do {
; 137  : 	digit = value % radix;

  00030	8b 4d b0	 mov	 ecx, DWORD PTR tv161[ebp+4]
  00033	51		 push	 ecx
  00034	57		 push	 edi
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 __aulldvrm

; 138  : 	value = value / radix;
; 139  : 	if (digit < 10) {
; 140  : 	    *--pos = (char)('0' + digit);

  0003c	4e		 dec	 esi
  0003d	89 5d a8	 mov	 DWORD PTR tv133[ebp+4], ebx
  00040	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00043	7d 05		 jge	 SHORT $LN2@ui64toa
  00045	80 c1 30	 add	 cl, 48			; 00000030H

; 141  : 	} else {

  00048	eb 03		 jmp	 SHORT $LN10@ui64toa
$LN2@ui64toa:

; 142  : 	    *--pos = (char)('a' + digit - 10);

  0004a	80 c1 57	 add	 cl, 87			; 00000057H
$LN10@ui64toa:
  0004d	88 0e		 mov	 BYTE PTR [esi], cl

; 143  : 	} /* if */
; 144  :     } while (value != 0L);

  0004f	8b c8		 mov	 ecx, eax
  00051	0b ca		 or	 ecx, edx
  00053	75 db		 jne	 SHORT $LL5@ui64toa

; 145  : 
; 146  :     memcpy(string, pos, &buffer[64] - pos + 1);

  00055	8d 55 f9	 lea	 edx, DWORD PTR _buffer$[ebp+65]
  00058	2b d6		 sub	 edx, esi
  0005a	52		 push	 edx
  0005b	56		 push	 esi
  0005c	8b 75 b4	 mov	 esi, DWORD PTR _string$GSCopy$[ebp]
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 _memcpy

; 147  :     return string;
; 148  : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	5f		 pop	 edi
  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi
  0006f	33 cd		 xor	 ecx, ebp
  00071	5b		 pop	 ebx
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_ui64toa ENDP
_TEXT	ENDS
PUBLIC	_str$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ui64toa_s
; Function compile flags: /Ogtp
;	COMDAT _ui64toa_s
_TEXT	SEGMENT
tv140 = -92						; size = 8
tv165 = -84						; size = 8
_str$GSCopy$ = -76					; size = 4
_buffer$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_ui64toa_s PROC						; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]

; 175  :     }while(value != 0);

  00013	89 45 b4	 mov	 DWORD PTR _str$GSCopy$[ebp], eax
  00016	85 c0		 test	 eax, eax
  00018	0f 84 a2 00 00
	00		 je	 $LN7@ui64toa_s

; 155  :     char buffer[65], *pos;
; 156  :     int digit;
; 157  : 
; 158  :     if (!(str != NULL) || !(size > 0) ||
; 159  :         !(radix>=2) || !(radix<=36)) {

  0001e	83 7d 14 00	 cmp	 DWORD PTR _size$[ebp], 0
  00022	0f 86 98 00 00
	00		 jbe	 $LN7@ui64toa_s
  00028	8b 45 18	 mov	 eax, DWORD PTR _radix$[ebp]
  0002b	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  0002e	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00031	0f 87 89 00 00
	00		 ja	 $LN7@ui64toa_s

; 175  :     }while(value != 0);

  00037	99		 cdq
  00038	56		 push	 esi
  00039	57		 push	 edi
  0003a	8b f8		 mov	 edi, eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0003f	89 55 b0	 mov	 DWORD PTR tv165[ebp+4], edx
  00042	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00045	8d 75 f8	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  00048	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0004c	53		 push	 ebx
  0004d	8d 49 00	 npad	 3
$LL6@ui64toa_s:

; 161  :         return EINVAL;
; 162  :     }
; 163  : 
; 164  :     pos = buffer+64;
; 165  :     *pos = '\0';
; 166  : 
; 167  :     do {
; 168  :         digit = value%radix;

  00050	8b 4d b0	 mov	 ecx, DWORD PTR tv165[ebp+4]
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	52		 push	 edx
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 __aulldvrm

; 169  :         value /= radix;
; 170  : 
; 171  :         if(digit < 10)
; 172  :             *--pos = (char)('0' + digit);

  0005c	4e		 dec	 esi
  0005d	89 5d a8	 mov	 DWORD PTR tv140[ebp+4], ebx
  00060	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00063	7d 05		 jge	 SHORT $LN3@ui64toa_s
  00065	80 c1 30	 add	 cl, 48			; 00000030H

; 173  :         else

  00068	eb 03		 jmp	 SHORT $LN14@ui64toa_s
$LN3@ui64toa_s:

; 174  :             *--pos = (char)('a' + digit - 10);

  0006a	80 c1 57	 add	 cl, 87			; 00000057H
$LN14@ui64toa_s:
  0006d	88 0e		 mov	 BYTE PTR [esi], cl

; 175  :     }while(value != 0);

  0006f	8b c8		 mov	 ecx, eax
  00071	0b ca		 or	 ecx, edx
  00073	75 db		 jne	 SHORT $LL6@ui64toa_s

; 176  : 
; 177  :     if((unsigned)(buffer-pos+65) > size) {

  00075	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  00078	2b c6		 sub	 eax, esi
  0007a	5b		 pop	 ebx
  0007b	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  0007e	76 20		 jbe	 SHORT $LN1@ui64toa_s

; 178  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 179  : 
; 180  :         *__errno() = EINVAL;

  00080	e8 00 00 00 00	 call	 ___errno
  00085	5f		 pop	 edi
  00086	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 181  :         return EINVAL;

  0008c	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00091	5e		 pop	 esi

; 186  : }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	33 cd		 xor	 ecx, ebp
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN1@ui64toa_s:

; 182  :     }
; 183  : 
; 184  :     memcpy(str, pos, buffer-pos+65);

  000a0	8b 55 b4	 mov	 edx, DWORD PTR _str$GSCopy$[ebp]
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _memcpy
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	5f		 pop	 edi

; 185  :     return 0;

  000af	33 c0		 xor	 eax, eax
  000b1	5e		 pop	 esi

; 186  : }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
$LN7@ui64toa_s:

; 160  :         *__errno() = EINVAL;

  000c0	e8 00 00 00 00	 call	 ___errno

; 186  : }

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  000ce	33 cd		 xor	 ecx, ebp
  000d0	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_ui64toa_s ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_ltoa
; Function compile flags: /Ogtp
;	COMDAT _ltoa
_TEXT	SEGMENT
_buffer$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ltoa	PROC						; COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 209  :     unsigned long val;
; 210  :     int negative;
; 211  :     char buffer[33];
; 212  :     char *pos;
; 213  :     int digit;
; 214  : 
; 215  :     if (value < 0 && radix == 10) {

  00010	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _string$[ebp]
  00017	56		 push	 esi
  00018	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  0001b	57		 push	 edi
  0001c	85 c0		 test	 eax, eax
  0001e	79 0c		 jns	 SHORT $LN8@ltoa
  00020	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00023	75 07		 jne	 SHORT $LN8@ltoa

; 216  : 	negative = 1;

  00025	8d 7e f7	 lea	 edi, DWORD PTR [esi-9]

; 217  :         val = -value;

  00028	f7 d8		 neg	 eax

; 218  :     } else {

  0002a	eb 02		 jmp	 SHORT $LN7@ltoa
$LN8@ltoa:

; 219  : 	negative = 0;

  0002c	33 ff		 xor	 edi, edi
$LN7@ltoa:

; 220  :         val = value;
; 221  :     } /* if */
; 222  : 
; 223  :     pos = &buffer[32];

  0002e	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 224  :     *pos = '\0';

  00031	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL6@ltoa:

; 225  : 
; 226  :     do {
; 227  : 	digit = val % radix;

  00035	33 d2		 xor	 edx, edx
  00037	f7 f6		 div	 esi

; 228  : 	val = val / radix;
; 229  : 	if (digit < 10) {
; 230  : 	    *--pos = (char)('0' + digit);

  00039	49		 dec	 ecx
  0003a	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0003d	7d 05		 jge	 SHORT $LN3@ltoa
  0003f	80 c2 30	 add	 dl, 48			; 00000030H

; 231  : 	} else {

  00042	eb 03		 jmp	 SHORT $LN12@ltoa
$LN3@ltoa:

; 232  : 	    *--pos = (char)('a' + digit - 10);

  00044	80 c2 57	 add	 dl, 87			; 00000057H
$LN12@ltoa:
  00047	88 11		 mov	 BYTE PTR [ecx], dl

; 233  : 	} /* if */
; 234  :     } while (val != 0L);

  00049	85 c0		 test	 eax, eax
  0004b	75 e8		 jne	 SHORT $LL6@ltoa

; 235  : 
; 236  :     if (negative) {

  0004d	85 ff		 test	 edi, edi
  0004f	74 04		 je	 SHORT $LN1@ltoa

; 237  : 	*--pos = '-';

  00051	49		 dec	 ecx
  00052	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN1@ltoa:

; 238  :     } /* if */
; 239  : 
; 240  :     memcpy(string, pos, &buffer[32] - pos + 1);

  00055	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  00058	2b c1		 sub	 eax, ecx
  0005a	50		 push	 eax
  0005b	51		 push	 ecx
  0005c	53		 push	 ebx
  0005d	e8 00 00 00 00	 call	 _memcpy

; 241  :     return string;
; 242  : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b c3		 mov	 eax, ebx
  0006c	33 cd		 xor	 ecx, ebp
  0006e	5b		 pop	 ebx
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_ltoa	ENDP
_TEXT	ENDS
PUBLIC	_str$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_ltoa_s
; Function compile flags: /Ogtp
;	COMDAT _ltoa_s
_TEXT	SEGMENT
_str$GSCopy$ = -44					; size = 4
_buffer$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_ltoa_s	PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00013	53		 push	 ebx
  00014	57		 push	 edi

; 257  :     {
; 258  :         if (str && size)

  00015	89 45 d4	 mov	 DWORD PTR _str$GSCopy$[ebp], eax
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 d5 00 00
	00		 je	 $LN14@ltoa_s

; 249  :     unsigned long val;
; 250  :     unsigned int digit;
; 251  :     int is_negative;
; 252  :     char buffer[33], *pos;
; 253  :     size_t len;
; 254  : 
; 255  :     if (!(str != NULL) || !(size > 0) ||
; 256  :         (radix >= 2) || !(radix <= 36))

  00020	8b 5d 10	 mov	 ebx, DWORD PTR _size$[ebp]
  00023	85 db		 test	 ebx, ebx
  00025	0f 84 ca 00 00
	00		 je	 $LN14@ltoa_s
  0002b	8b 7d 14	 mov	 edi, DWORD PTR _radix$[ebp]
  0002e	83 ff 02	 cmp	 edi, 2
  00031	0f 8d b7 00 00
	00		 jge	 $LN15@ltoa_s
  00037	83 ff 24	 cmp	 edi, 36			; 00000024H
  0003a	0f 8f ae 00 00
	00		 jg	 $LN15@ltoa_s

; 262  :         return EINVAL;
; 263  :     }
; 264  : 
; 265  :     if (value < 0 && radix == 10)

  00040	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00043	56		 push	 esi
  00044	85 c0		 test	 eax, eax
  00046	79 0c		 jns	 SHORT $LN13@ltoa_s
  00048	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  0004b	75 07		 jne	 SHORT $LN13@ltoa_s

; 266  :     {
; 267  :         is_negative = 1;

  0004d	8d 77 f7	 lea	 esi, DWORD PTR [edi-9]

; 268  :         val = -value;

  00050	f7 d8		 neg	 eax

; 269  :     }
; 270  :     else

  00052	eb 02		 jmp	 SHORT $LN12@ltoa_s
$LN13@ltoa_s:

; 271  :     {
; 272  :         is_negative = 0;

  00054	33 f6		 xor	 esi, esi
$LN12@ltoa_s:

; 273  :         val = value;
; 274  :     }
; 275  : 
; 276  :     pos = buffer + 32;

  00056	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 277  :     *pos = '\0';

  00059	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
  0005d	8d 49 00	 npad	 3
$LL11@ltoa_s:

; 278  : 
; 279  :     do
; 280  :     {
; 281  :         digit = val % radix;

  00060	33 d2		 xor	 edx, edx
  00062	f7 f7		 div	 edi

; 282  :         val /= radix;
; 283  : 
; 284  :         if (digit < 10)
; 285  :             *--pos = (char)('0' + digit);

  00064	49		 dec	 ecx
  00065	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00068	73 05		 jae	 SHORT $LN8@ltoa_s
  0006a	80 c2 30	 add	 dl, 48			; 00000030H

; 286  :         else

  0006d	eb 03		 jmp	 SHORT $LN26@ltoa_s
$LN8@ltoa_s:

; 287  :             *--pos = (char)('a' + digit - 10);

  0006f	80 c2 57	 add	 dl, 87			; 00000057H
$LN26@ltoa_s:
  00072	88 11		 mov	 BYTE PTR [ecx], dl

; 288  :     }
; 289  :     while (val != 0);

  00074	85 c0		 test	 eax, eax
  00076	75 e8		 jne	 SHORT $LL11@ltoa_s

; 290  : 
; 291  :     if (is_negative)

  00078	85 f6		 test	 esi, esi
  0007a	74 04		 je	 SHORT $LN22@ltoa_s

; 292  :         *--pos = '-';

  0007c	49		 dec	 ecx
  0007d	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN22@ltoa_s:

; 293  : 
; 294  :     len = buffer + 33 - pos;

  00080	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  00083	2b c1		 sub	 eax, ecx

; 295  :     if (len > size)

  00085	3b c3		 cmp	 eax, ebx
  00087	76 44		 jbe	 SHORT $LN5@ltoa_s

; 296  :     {
; 297  :         size_t i;
; 298  :         char *p = str;

  00089	8b 7d d4	 mov	 edi, DWORD PTR _str$GSCopy$[ebp]
  0008c	8b c7		 mov	 eax, edi

; 299  : 
; 300  :         /* Copy the temporary buffer backwards up to the available number of
; 301  :          * characters. Don't copy the negative sign if present. */
; 302  : 
; 303  :         if (is_negative)

  0008e	85 f6		 test	 esi, esi
  00090	74 04		 je	 SHORT $LN23@ltoa_s

; 304  :         {
; 305  :             p++;

  00092	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 306  :             size--;

  00095	4b		 dec	 ebx
$LN23@ltoa_s:

; 307  :         }
; 308  : 
; 309  :         for (pos = buffer + 31, i = 0; i < size; i++)

  00096	8d 4d f7	 lea	 ecx, DWORD PTR _buffer$[ebp+31]
  00099	85 db		 test	 ebx, ebx
  0009b	74 0c		 je	 SHORT $LN1@ltoa_s
  0009d	8b f3		 mov	 esi, ebx
  0009f	90		 npad	 1
$LL3@ltoa_s:

; 310  :             *p++ = *pos--;

  000a0	8a 11		 mov	 dl, BYTE PTR [ecx]
  000a2	88 10		 mov	 BYTE PTR [eax], dl
  000a4	40		 inc	 eax
  000a5	49		 dec	 ecx
  000a6	4e		 dec	 esi
  000a7	75 f7		 jne	 SHORT $LL3@ltoa_s
$LN1@ltoa_s:

; 311  : 
; 312  :         str[0] = '\0';

  000a9	c6 07 00	 mov	 BYTE PTR [edi], 0

; 313  :         //("str[size] is too small");
; 314  :         *__errno() = EINVAL;

  000ac	e8 00 00 00 00	 call	 ___errno
  000b1	5e		 pop	 esi
  000b2	5f		 pop	 edi
  000b3	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 315  :         return ERANGE;

  000b9	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000be	5b		 pop	 ebx

; 320  : }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	33 cd		 xor	 ecx, ebp
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN5@ltoa_s:

; 316  :     }
; 317  : 
; 318  :     memcpy(str, pos, len);

  000cd	50		 push	 eax
  000ce	8b 45 d4	 mov	 eax, DWORD PTR _str$GSCopy$[ebp]
  000d1	51		 push	 ecx
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	5e		 pop	 esi
  000dc	5f		 pop	 edi

; 319  :     return 0;

  000dd	33 c0		 xor	 eax, eax
  000df	5b		 pop	 ebx

; 320  : }

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
$LN15@ltoa_s:

; 257  :     {
; 258  :         if (str && size)

  000ee	85 db		 test	 ebx, ebx
  000f0	74 03		 je	 SHORT $LN14@ltoa_s

; 259  :             str[0] = '\0';

  000f2	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN14@ltoa_s:

; 260  : 
; 261  :         *__errno() = EINVAL;

  000f5	e8 00 00 00 00	 call	 ___errno

; 320  : }

  000fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fd	5f		 pop	 edi
  000fe	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00104	33 cd		 xor	 ecx, ebp
  00106	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0010b	5b		 pop	 ebx
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
_ltoa_s	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_ultoa
; Function compile flags: /Ogtp
;	COMDAT _ultoa
_TEXT	SEGMENT
_buffer$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ultoa	PROC						; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 327  :     char buffer[33];
; 328  :     char *pos;
; 329  :     int digit;
; 330  : 
; 331  :     pos = &buffer[32];
; 332  :     *pos = '\0';

  00010	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00013	56		 push	 esi
  00014	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _string$[ebp]
  0001b	8d 4d f8	 lea	 ecx, DWORD PTR _buffer$[ebp+32]
  0001e	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL5@ultoa:

; 333  : 
; 334  :     do {
; 335  : 	digit = value % radix;

  00022	33 d2		 xor	 edx, edx
  00024	f7 f6		 div	 esi

; 336  : 	value = value / radix;
; 337  : 	if (digit < 10) {
; 338  : 	    *--pos = (char)('0' + digit);

  00026	49		 dec	 ecx
  00027	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0002a	7d 05		 jge	 SHORT $LN2@ultoa
  0002c	80 c2 30	 add	 dl, 48			; 00000030H

; 339  : 	} else {

  0002f	eb 03		 jmp	 SHORT $LN9@ultoa
$LN2@ultoa:

; 340  : 	    *--pos = (char)('a' + digit - 10);

  00031	80 c2 57	 add	 dl, 87			; 00000057H
$LN9@ultoa:
  00034	88 11		 mov	 BYTE PTR [ecx], dl

; 341  : 	} /* if */
; 342  :     } while (value != 0L);

  00036	85 c0		 test	 eax, eax
  00038	75 e8		 jne	 SHORT $LL5@ultoa

; 343  : 
; 344  :     memcpy(string, pos, &buffer[32] - pos + 1);

  0003a	8d 45 f9	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  0003d	2b c1		 sub	 eax, ecx
  0003f	50		 push	 eax
  00040	51		 push	 ecx
  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 _memcpy

; 345  : 
; 346  :     return string;
; 347  : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	8b c7		 mov	 eax, edi
  0004f	5f		 pop	 edi
  00050	33 cd		 xor	 ecx, ebp
  00052	5e		 pop	 esi
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_ultoa	ENDP
_TEXT	ENDS
PUBLIC	_itoa_s
; Function compile flags: /Ogtp
;	COMDAT _itoa_s
_TEXT	SEGMENT
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_itoa_s	PROC						; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : }

  00003	5d		 pop	 ebp

; 193  :     return ltoa_s(value, str, size, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa_s
_itoa_s	ENDP
_TEXT	ENDS
PUBLIC	_itoa
; Function compile flags: /Ogtp
;	COMDAT _itoa
_TEXT	SEGMENT
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_itoa	PROC						; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : }

  00003	5d		 pop	 ebp

; 201  :   return ltoa(value, string, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa
_itoa	ENDP
_TEXT	ENDS
END
