; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strtoul.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoul
EXTRN	___errno:PROC
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strtoul.c
;	COMDAT _strtoul
_TEXT	SEGMENT
tv304 = -12						; size = 4
_neg$ = -8						; size = 4
_any$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoul PROC						; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 17   :   const char *s = nptr;

  00008	8b 7d 08	 mov	 edi, DWORD PTR _nptr$[ebp]

; 18   :   unsigned long acc;
; 19   :   int c;
; 20   :   unsigned long cutoff;
; 21   :   int neg = 0, any, cutlim;

  0000b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _neg$[ebp], 0
  00012	b0 20		 mov	 al, 32			; 00000020H
$LL25@strtoul:

; 22   : 
; 23   :   /*
; 24   :    * See strtol for comments as to the logic used.
; 25   :    */
; 26   :   do {
; 27   :     c = *s++;

  00014	0f be 0f	 movsx	 ecx, BYTE PTR [edi]

; 28   :   } while (isspace(c));

  00017	0f b6 d1	 movzx	 edx, cl
  0001a	47		 inc	 edi
  0001b	84 82 00 00 00
	00		 test	 BYTE PTR __ctype[edx], al
  00021	75 f1		 jne	 SHORT $LL25@strtoul

; 29   :   if (c == '-')

  00023	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00026	75 09		 jne	 SHORT $LN22@strtoul

; 30   :   {
; 31   :     neg = 1;

  00028	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _neg$[ebp], 1

; 32   :     c = *s++;

  0002f	eb 05		 jmp	 SHORT $LN36@strtoul
$LN22@strtoul:

; 33   :   }
; 34   :   else if (c == '+')

  00031	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00034	75 04		 jne	 SHORT $LN34@strtoul
$LN36@strtoul:

; 35   :     c = *s++;

  00036	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  00039	47		 inc	 edi
$LN34@strtoul:

; 36   :   if ((base == 0 || base == 16) &&
; 37   :       c == '0' && (*s == 'x' || *s == 'X'))

  0003a	8b 75 10	 mov	 esi, DWORD PTR _base$[ebp]
  0003d	85 f6		 test	 esi, esi
  0003f	74 05		 je	 SHORT $LN18@strtoul
  00041	83 fe 10	 cmp	 esi, 16			; 00000010H
  00044	75 1f		 jne	 SHORT $LN35@strtoul
$LN18@strtoul:
  00046	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00049	75 1a		 jne	 SHORT $LN35@strtoul
  0004b	8a 07		 mov	 al, BYTE PTR [edi]
  0004d	3c 78		 cmp	 al, 120			; 00000078H
  0004f	74 04		 je	 SHORT $LN17@strtoul
  00051	3c 58		 cmp	 al, 88			; 00000058H
  00053	75 10		 jne	 SHORT $LN35@strtoul
$LN17@strtoul:

; 38   :   {
; 39   :     c = s[1];

  00055	0f be 4f 01	 movsx	 ecx, BYTE PTR [edi+1]

; 40   :     s += 2;

  00059	83 c7 02	 add	 edi, 2

; 41   :     base = 16;

  0005c	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H

; 42   :   }
; 43   :   if (base == 0)

  00063	eb 13		 jmp	 SHORT $LN37@strtoul
$LN35@strtoul:
  00065	85 f6		 test	 esi, esi
  00067	75 12		 jne	 SHORT $LN16@strtoul

; 44   :     base = c == '0' ? 8 : 10;

  00069	33 c0		 xor	 eax, eax
  0006b	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006e	0f 95 c0	 setne	 al
  00071	8d 44 00 08	 lea	 eax, DWORD PTR [eax+eax+8]
  00075	89 45 10	 mov	 DWORD PTR _base$[ebp], eax
$LN37@strtoul:
  00078	8b 75 10	 mov	 esi, DWORD PTR _base$[ebp]
$LN16@strtoul:

; 45   :   cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;

  0007b	33 d2		 xor	 edx, edx
  0007d	83 c8 ff	 or	 eax, -1
  00080	f7 f6		 div	 esi

; 46   :   cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  00082	33 f6		 xor	 esi, esi
  00084	53		 push	 ebx
  00085	89 55 f4	 mov	 DWORD PTR tv304[ebp], edx
  00088	8b d0		 mov	 edx, eax
  0008a	33 c0		 xor	 eax, eax
  0008c	89 45 fc	 mov	 DWORD PTR _any$[ebp], eax
  0008f	90		 npad	 1
$LL15@strtoul:

; 48   :   {
; 49   :     if (isdigit(c))

  00090	0f b6 d9	 movzx	 ebx, cl
  00093	8a 9b 00 00 00
	00		 mov	 bl, BYTE PTR __ctype[ebx]
  00099	f6 c3 04	 test	 bl, 4
  0009c	74 05		 je	 SHORT $LN12@strtoul

; 50   :       c -= '0';

  0009e	83 e9 30	 sub	 ecx, 48			; 00000030H
  000a1	eb 17		 jmp	 SHORT $LN9@strtoul
$LN12@strtoul:

; 51   :     else if (isalpha(c))

  000a3	f6 c3 03	 test	 bl, 3
  000a6	74 4d		 je	 SHORT $LN32@strtoul

; 52   :       c -= isupper(c) ? 'A' - 10 : 'a' - 10;

  000a8	80 e3 01	 and	 bl, 1
  000ab	0f b6 db	 movzx	 ebx, bl
  000ae	f7 db		 neg	 ebx
  000b0	1b db		 sbb	 ebx, ebx
  000b2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000b5	83 c3 57	 add	 ebx, 87			; 00000057H
  000b8	2b cb		 sub	 ecx, ebx
$LN9@strtoul:

; 53   :     else
; 54   :       break;
; 55   :     if (c >= base)

  000ba	8b 5d 10	 mov	 ebx, DWORD PTR _base$[ebp]
  000bd	3b cb		 cmp	 ecx, ebx
  000bf	7d 34		 jge	 SHORT $LN32@strtoul

; 56   :       break;
; 57   :     if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000c1	85 c0		 test	 eax, eax
  000c3	78 20		 js	 SHORT $LN6@strtoul
  000c5	3b f2		 cmp	 esi, edx
  000c7	77 1c		 ja	 SHORT $LN6@strtoul
  000c9	75 05		 jne	 SHORT $LN7@strtoul
  000cb	3b 4d f4	 cmp	 ecx, DWORD PTR tv304[ebp]
  000ce	7f 15		 jg	 SHORT $LN6@strtoul
$LN7@strtoul:

; 59   :     else {
; 60   :       any = 1;
; 61   :       acc *= base;

  000d0	0f af f3	 imul	 esi, ebx

; 62   :       acc += c;

  000d3	03 f1		 add	 esi, ecx
  000d5	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  000d8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _any$[ebp], 1
  000df	8b 45 fc	 mov	 eax, DWORD PTR _any$[ebp]
  000e2	47		 inc	 edi
  000e3	eb ab		 jmp	 SHORT $LL15@strtoul
$LN6@strtoul:

; 46   :   cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  000e5	0f be 0f	 movsx	 ecx, BYTE PTR [edi]

; 58   :       any = -1;

  000e8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _any$[ebp], -1
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _any$[ebp]
  000f2	47		 inc	 edi
  000f3	eb 9b		 jmp	 SHORT $LL15@strtoul
$LN32@strtoul:
  000f5	5b		 pop	 ebx

; 63   :     }
; 64   :   }
; 65   :   if (any < 0)

  000f6	85 c0		 test	 eax, eax
  000f8	79 13		 jns	 SHORT $LN4@strtoul

; 66   :   {
; 67   :     acc = ULONG_MAX;

  000fa	83 ce ff	 or	 esi, -1

; 68   :     errno = ERANGE;

  000fd	e8 00 00 00 00	 call	 ___errno
  00102	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00108	8b 45 fc	 mov	 eax, DWORD PTR _any$[ebp]
  0010b	eb 08		 jmp	 SHORT $LN2@strtoul
$LN4@strtoul:

; 69   :   }
; 70   :   else if (neg)

  0010d	83 7d f8 00	 cmp	 DWORD PTR _neg$[ebp], 0
  00111	74 02		 je	 SHORT $LN2@strtoul

; 71   :     acc = 0-acc;

  00113	f7 de		 neg	 esi
$LN2@strtoul:

; 72   :   if (endptr != 0)

  00115	8b 4d 0c	 mov	 ecx, DWORD PTR _endptr$[ebp]
  00118	85 c9		 test	 ecx, ecx
  0011a	74 0c		 je	 SHORT $LN33@strtoul

; 73   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  0011c	85 c0		 test	 eax, eax
  0011e	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00121	75 03		 jne	 SHORT $LN29@strtoul
  00123	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
$LN29@strtoul:
  00126	89 01		 mov	 DWORD PTR [ecx], eax
$LN33@strtoul:
  00128	5f		 pop	 edi

; 74   :   return acc;

  00129	8b c6		 mov	 eax, esi
  0012b	5e		 pop	 esi

; 75   : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
_strtoul ENDP
_TEXT	ENDS
END
