; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strncmp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strncmp
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strncmp.c
;	COMDAT _strncmp
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
_strncmp PROC						; COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	unsigned long *a1;
; 24   : 	unsigned long *a2;
; 25   : 
; 26   : 	if (n == 0)

  00003	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN10@strncmp

; 65   : }

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN10@strncmp:

; 27   : 		return 0;
; 28   : 
; 29   : 	/* If s1 or s2 are unaligned, then compare bytes. */
; 30   : 	if (!UNALIGNED (s1, s2))

  0000c	8b 55 08	 mov	 edx, DWORD PTR _s1$[ebp]
  0000f	8b ca		 mov	 ecx, edx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _s2$[ebp]
  00015	0b ce		 or	 ecx, esi
  00017	57		 push	 edi
  00018	f6 c1 03	 test	 cl, 3
  0001b	75 2d		 jne	 SHORT $LN7@strncmp

; 31   : 	{
; 32   : 		/* If s1 and s2 are word-aligned, compare them a word at a time. */
; 33   : 		a1 = (unsigned long*)s1;
; 34   : 		a2 = (unsigned long*)s2;
; 35   : 		while (n >= sizeof (long) && *a1 == *a2)

  0001d	83 f8 04	 cmp	 eax, 4
  00020	72 28		 jb	 SHORT $LN7@strncmp
$LL8@strncmp:
  00022	8b 3a		 mov	 edi, DWORD PTR [edx]
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 22		 jne	 SHORT $LN7@strncmp

; 36   : 		{
; 37   : 			n -= sizeof (long);

  00028	83 e8 04	 sub	 eax, 4

; 38   : 
; 39   : 			/* If we've run out of bytes or hit a null, return zero
; 40   : 			since we already know *a1 == *a2.  */
; 41   : 			if (n == 0 || DETECTNULL (*a1))

  0002b	74 44		 je	 SHORT $LN16@strncmp
  0002d	8d 8f ff fe fe
	fe		 lea	 ecx, DWORD PTR [edi-16843009]
  00033	f7 d7		 not	 edi
  00035	23 cf		 and	 ecx, edi
  00037	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  0003d	75 32		 jne	 SHORT $LN16@strncmp

; 42   : 				return 0;
; 43   : 
; 44   : 			a1++;

  0003f	83 c2 04	 add	 edx, 4

; 45   : 			a2++;

  00042	83 c6 04	 add	 esi, 4
  00045	83 f8 04	 cmp	 eax, 4
  00048	73 d8		 jae	 SHORT $LL8@strncmp
$LN7@strncmp:

; 46   : 		}
; 47   : 
; 48   : 		/* A difference was detected in last few bytes of s1, so search bytewise */
; 49   : 		s1 = (char*)a1;
; 50   : 		s2 = (char*)a2;
; 51   : 	}
; 52   : 
; 53   : 	while (n-- > 0 && *s1 == *s2)

  0004a	85 c0		 test	 eax, eax
  0004c	74 17		 je	 SHORT $LN18@strncmp
  0004e	8b ff		 npad	 2
$LL4@strncmp:
  00050	8a 0a		 mov	 cl, BYTE PTR [edx]
  00052	48		 dec	 eax
  00053	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00055	75 0e		 jne	 SHORT $LN18@strncmp

; 54   : 	{
; 55   : 		/* If we've run out of bytes or hit a null, return zero
; 56   : 		since we already know *s1 == *s2.  */
; 57   : 		if (n == 0 || *s1 == '\0')

  00057	85 c0		 test	 eax, eax
  00059	74 16		 je	 SHORT $LN16@strncmp
  0005b	84 c9		 test	 cl, cl
  0005d	74 12		 je	 SHORT $LN16@strncmp

; 59   : 
; 60   : 		s1++;

  0005f	42		 inc	 edx

; 61   : 		s2++;

  00060	46		 inc	 esi
  00061	85 c0		 test	 eax, eax
  00063	75 eb		 jne	 SHORT $LL4@strncmp
$LN18@strncmp:

; 62   : 	}
; 63   : 
; 64   : 	return (*(unsigned char *) s1) - (*(unsigned char *) s2);

  00065	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00068	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0006b	5f		 pop	 edi
  0006c	2b c1		 sub	 eax, ecx
  0006e	5e		 pop	 esi

; 65   : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN16@strncmp:
  00071	5f		 pop	 edi

; 58   : 			return 0;

  00072	33 c0		 xor	 eax, eax
  00074	5e		 pop	 esi

; 65   : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_strncmp ENDP
_TEXT	ENDS
END
