; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdio\stream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2781	DB	'-', 00H
	ORG $+2
$SG2784	DB	'+', 00H
	ORG $+2
$SG2787	DB	' ', 00H
	ORG $+2
?_nullstring@?1??streamout@@9@9 DD FLAT:$SG2826		; `streamout'::`2'::_nullstring
$SG2826	DB	'(null)', 00H
	ORG $+1
$SG3043	DB	'-', 00H
	ORG $+2
$SG3046	DB	'+', 00H
	ORG $+2
$SG3049	DB	' ', 00H
	ORG $+2
$SG3053	DB	'0', 00H
_DATA	ENDS
CONST	SEGMENT
?digits_l@?1??format_float@@9@9 DB '0123456789abcdef0x', 00H ; `format_float'::`2'::digits_l
	ORG $+1
?digits_u@?1??format_float@@9@9 DB '0123456789ABCDEF0X', 00H ; `format_float'::`2'::digits_u
	ORG $+1
?_nan@?1??format_float@@9@9 DB '#QNAN', 00H		; `format_float'::`2'::_nan
	ORG $+2
?_infinity@?1??format_float@@9@9 DB '#INF', 00H		; `format_float'::`2'::_infinity
	ORG $+3
?digits_l@?1??streamout@@9@9 DB '0123456789abcdef0x', 00H ; `streamout'::`2'::digits_l
	ORG $+1
?digits_u@?1??streamout@@9@9 DB '0123456789ABCDEF0X', 00H ; `streamout'::`2'::digits_u
CONST	ENDS
PUBLIC	_StreamCharacterToUtf8
PUBLIC	_format_float
PUBLIC	_streamout
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@43e0000000000000
EXTRN	_putchar:PROC
EXTRN	__finite:PROC
EXTRN	__isnan:PROC
EXTRN	_wcsnlen:PROC
EXTRN	__CIlog10:PROC
EXTRN	__CIpow:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__aullrem:PROC
EXTRN	__ftol2:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+018
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout
_TEXT	SEGMENT
_buffer$ = -104						; size = 50
_flags$1$ = -52						; size = 4
tv731 = -52						; size = 4
_prefixlen$1$ = -48					; size = 4
tv666 = -48						; size = 4
_prefix$ = -48						; size = 4
_digits$1$ = -44					; size = 4
_uLen$1 = -44						; size = 4
tv599 = -40						; size = 8
_base$1$ = -36						; size = 4
_padding$2$ = -32					; size = 4
_padding$1$ = -32					; size = 4
_val64$2$ = -28						; size = 4
_string$ = -28						; size = 4
_cnt$ = -24						; size = 4
_prefix$1$ = -20					; size = 4
_chr$ = -16						; size = 1
_written_all$1$ = -12					; size = 4
_val64$1$ = -8						; size = 4
_written$4$ = -8					; size = 4
_string$1$ = -4						; size = 4
_out$ = 8						; size = 4
_precision$2$ = 12					; size = 4
_precision$1$ = 12					; size = 4
tv729 = 12						; size = 4
tv665 = 12						; size = 4
_size$ = 12						; size = 4
_format$ = 16						; size = 4
_argptr$ = 20						; size = 4
_streamout PROC						; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H

; 443  : 	static const char digits_l[] = "0123456789abcdef0x";
; 444  : 	static const char digits_u[] = "0123456789ABCDEF0X";
; 445  : 	static const char *_nullstring = "(null)";
; 446  : 	char buffer[BUFFER_SIZE + 1];
; 447  : 	uint32_t cnt = size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]

; 448  : 	char chr, *string;
; 449  : 	STRING *nt_string;
; 450  : 	const char *digits, *prefix;
; 451  : 	int base, fieldwidth, precision, padding;
; 452  : 	size_t prefixlen, len;
; 453  : 	int written = 1, written_all = 0;

  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	53		 push	 ebx
  0000f	56		 push	 esi

; 454  : 	unsigned int flags;
; 455  : 	unsigned __int64 val64;
; 456  : 
; 457  : 	buffer[BUFFER_SIZE] = '\0';

  00010	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  00013	57		 push	 edi
  00014	33 ff		 xor	 edi, edi
  00016	89 45 e8	 mov	 DWORD PTR _cnt$[ebp], eax
  00019	89 55 f8	 mov	 DWORD PTR _written$4$[ebp], edx
  0001c	89 7d f4	 mov	 DWORD PTR _written_all$1$[ebp], edi
  0001f	c6 45 c9 00	 mov	 BYTE PTR _buffer$[ebp+49], 0
$LN269@streamout:

; 461  : 	{
; 462  : 		/* Get character and advance */
; 463  : 		chr = *format++;

  00023	8a 06		 mov	 al, BYTE PTR [esi]
  00025	46		 inc	 esi
  00026	8b 5d 08	 mov	 ebx, DWORD PTR _out$[ebp]

; 464  : 
; 465  : 		/* Check for end of format string */
; 466  : 		if (chr == '\0') 

  00029	84 c0		 test	 al, al
  0002b	0f 84 15 07 00
	00		 je	 $LN119@streamout

; 467  : 			break;
; 468  : 
; 469  : 		/* Check for 'normal' character or double % */
; 470  : 		if ((chr != ('%')) ||
; 471  : 			(chr = *format++) == ('%'))

  00031	3c 25		 cmp	 al, 37			; 00000025H
  00033	0f 85 6c 06 00
	00		 jne	 $LN116@streamout
  00039	8a 06		 mov	 al, BYTE PTR [esi]
  0003b	46		 inc	 esi
  0003c	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0003f	3c 25		 cmp	 al, 37			; 00000025H
  00041	0f 84 5e 06 00
	00		 je	 $LN116@streamout

; 521  : 			continue;
; 522  : 		}
; 523  : 
; 524  : 		/* Handle flags-characters */
; 525  : 		flags = 0;

  00047	33 db		 xor	 ebx, ebx
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL104@streamout:

; 526  : 		while (1)
; 527  : 		{
; 528  : 			if (chr == ('-')) flags |= FLAG_ALIGN_LEFT;

  00050	3c 2d		 cmp	 al, 45			; 0000002dH
  00052	75 0b		 jne	 SHORT $LN102@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00054	8a 06		 mov	 al, BYTE PTR [esi]
  00056	83 cb 01	 or	 ebx, 1
  00059	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0005c	46		 inc	 esi

; 535  : 		}

  0005d	eb f1		 jmp	 SHORT $LL104@streamout
$LN102@streamout:

; 529  : 			else if (chr == ('+')) flags |= FLAG_FORCE_SIGN;

  0005f	3c 2b		 cmp	 al, 43			; 0000002bH
  00061	75 0b		 jne	 SHORT $LN100@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00063	8a 06		 mov	 al, BYTE PTR [esi]
  00065	83 cb 02	 or	 ebx, 2
  00068	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0006b	46		 inc	 esi

; 535  : 		}

  0006c	eb e2		 jmp	 SHORT $LL104@streamout
$LN100@streamout:

; 530  : 			else if (chr == (' ')) flags |= FLAG_FORCE_SIGNSP;

  0006e	3c 20		 cmp	 al, 32			; 00000020H
  00070	75 0b		 jne	 SHORT $LN98@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00072	8a 06		 mov	 al, BYTE PTR [esi]
  00074	83 cb 04	 or	 ebx, 4
  00077	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0007a	46		 inc	 esi

; 535  : 		}

  0007b	eb d3		 jmp	 SHORT $LL104@streamout
$LN98@streamout:

; 531  : 			else if (chr == ('0')) flags |= FLAG_PAD_ZERO;

  0007d	3c 30		 cmp	 al, 48			; 00000030H
  0007f	75 0b		 jne	 SHORT $LN96@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00081	8a 06		 mov	 al, BYTE PTR [esi]
  00083	83 cb 08	 or	 ebx, 8
  00086	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00089	46		 inc	 esi

; 535  : 		}

  0008a	eb c4		 jmp	 SHORT $LL104@streamout
$LN96@streamout:

; 532  : 			else if (chr == ('#')) flags |= FLAG_SPECIAL;

  0008c	3c 23		 cmp	 al, 35			; 00000023H
  0008e	75 0b		 jne	 SHORT $LN94@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00090	8a 06		 mov	 al, BYTE PTR [esi]
  00092	83 cb 10	 or	 ebx, 16			; 00000010H
  00095	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00098	46		 inc	 esi

; 535  : 		}

  00099	eb b5		 jmp	 SHORT $LL104@streamout
$LN94@streamout:

; 536  : 
; 537  : 		/* Handle field width modifier */
; 538  : 		if (chr == ('*'))

  0009b	3c 2a		 cmp	 al, 42			; 0000002aH
  0009d	75 23		 jne	 SHORT $LN92@streamout

; 539  : 		{
; 540  : 			fieldwidth = va_arg(argptr, int);

  0009f	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  000a2	83 c0 04	 add	 eax, 4
  000a5	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  000a8	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  000ab	89 4d e0	 mov	 DWORD PTR _padding$1$[ebp], ecx

; 541  : 			if (fieldwidth < 0)

  000ae	85 c9		 test	 ecx, ecx
  000b0	79 08		 jns	 SHORT $LN91@streamout

; 542  : 			{
; 543  : 				flags |= FLAG_ALIGN_LEFT;

  000b2	83 cb 01	 or	 ebx, 1

; 544  : 				fieldwidth = -fieldwidth;

  000b5	f7 d9		 neg	 ecx
  000b7	89 4d e0	 mov	 DWORD PTR _padding$1$[ebp], ecx
$LN91@streamout:

; 545  : 			}
; 546  : 			chr = *format++;

  000ba	8a 06		 mov	 al, BYTE PTR [esi]
  000bc	46		 inc	 esi
  000bd	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 547  : 		}
; 548  : 		else

  000c0	eb 2b		 jmp	 SHORT $LN88@streamout
$LN92@streamout:

; 549  : 		{
; 550  : 			fieldwidth = 0;

  000c2	33 c9		 xor	 ecx, ecx
  000c4	89 4d e0	 mov	 DWORD PTR _padding$1$[ebp], ecx

; 551  : 			while (chr >= ('0') && chr <= ('9'))

  000c7	3c 30		 cmp	 al, 48			; 00000030H
  000c9	7c 22		 jl	 SHORT $LN88@streamout
  000cb	eb 03 8d 49 00	 npad	 5
$LL89@streamout:
  000d0	3c 39		 cmp	 al, 57			; 00000039H
  000d2	7f 16		 jg	 SHORT $LN248@streamout

; 552  : 			{
; 553  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000d4	0f be c0	 movsx	 eax, al
  000d7	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000da	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  000dd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 554  : 				chr = *format++;

  000e0	8a 06		 mov	 al, BYTE PTR [esi]
  000e2	46		 inc	 esi
  000e3	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  000e6	3c 30		 cmp	 al, 48			; 00000030H
  000e8	7d e6		 jge	 SHORT $LL89@streamout
$LN248@streamout:
  000ea	89 4d e0	 mov	 DWORD PTR _padding$1$[ebp], ecx
$LN88@streamout:

; 555  : 			}
; 556  : 		}
; 557  : 
; 558  : 		/* Handle precision modifier */
; 559  : 		if (chr == '.')

  000ed	3c 2e		 cmp	 al, 46			; 0000002eH
  000ef	75 4e		 jne	 SHORT $LN87@streamout

; 560  : 		{
; 561  : 			chr = *format++;

  000f1	8a 06		 mov	 al, BYTE PTR [esi]
  000f3	46		 inc	 esi
  000f4	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 562  : 
; 563  : 			if (chr == ('*'))

  000f7	3c 2a		 cmp	 al, 42			; 0000002aH
  000f9	75 17		 jne	 SHORT $LN86@streamout

; 564  : 			{
; 565  : 				precision = va_arg(argptr, int);

  000fb	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  000fe	83 c0 04	 add	 eax, 4
  00101	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  00104	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 566  : 				chr = *format++;

  00107	8a 06		 mov	 al, BYTE PTR [esi]
  00109	46		 inc	 esi
  0010a	89 4d 0c	 mov	 DWORD PTR _precision$1$[ebp], ecx
  0010d	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 567  : 			}
; 568  : 			else

  00110	eb 34		 jmp	 SHORT $LL81@streamout
$LN86@streamout:

; 569  : 			{
; 570  : 				precision = 0;

  00112	33 c9		 xor	 ecx, ecx
  00114	89 4d 0c	 mov	 DWORD PTR _precision$1$[ebp], ecx

; 571  : 				while (chr >= ('0') && chr <= ('9'))

  00117	3c 30		 cmp	 al, 48			; 00000030H
  00119	7c 2b		 jl	 SHORT $LL81@streamout
  0011b	eb 03 8d 49 00	 npad	 5
$LL84@streamout:
  00120	3c 39		 cmp	 al, 57			; 00000039H
  00122	7f 22		 jg	 SHORT $LL81@streamout

; 572  : 				{
; 573  : 					precision = precision * 10 + (chr - ('0'));

  00124	0f be c0	 movsx	 eax, al
  00127	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0012a	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  0012d	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 574  : 					chr = *format++;

  00130	8a 06		 mov	 al, BYTE PTR [esi]
  00132	46		 inc	 esi
  00133	89 4d 0c	 mov	 DWORD PTR _precision$1$[ebp], ecx
  00136	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00139	3c 30		 cmp	 al, 48			; 00000030H
  0013b	7d e3		 jge	 SHORT $LL84@streamout

; 575  : 				}
; 576  : 			}

  0013d	eb 07		 jmp	 SHORT $LL81@streamout
$LN87@streamout:

; 577  : 		}
; 578  : 		else precision = -1;

  0013f	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR _precision$1$[ebp], -1
$LL81@streamout:

; 579  : 
; 580  : 		/* Handle argument size prefix */
; 581  : 		do
; 582  : 		{
; 583  : 			if (chr == ('h')) flags |= FLAG_SHORT;

  00146	3c 68		 cmp	 al, 104			; 00000068H
  00148	75 0e		 jne	 SHORT $LN78@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  0014a	8a 06		 mov	 al, BYTE PTR [esi]
  0014c	81 cb 00 01 00
	00		 or	 ebx, 256		; 00000100H
  00152	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00155	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  00156	eb ee		 jmp	 SHORT $LL81@streamout
$LN78@streamout:

; 584  : 			else if (chr == ('w')) flags |= FLAG_WIDECHAR;

  00158	3c 77		 cmp	 al, 119			; 00000077H
  0015a	75 0e		 jne	 SHORT $LN76@streamout
$LN69@streamout:

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  0015c	8a 06		 mov	 al, BYTE PTR [esi]
  0015e	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  00164	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00167	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  00168	eb dc		 jmp	 SHORT $LL81@streamout
$LN76@streamout:

; 585  : 			else if (chr == ('L')) flags |= 0; // FIXME: long double

  0016a	3c 4c		 cmp	 al, 76			; 0000004cH
  0016c	74 73		 je	 SHORT $LN60@streamout

; 586  : 			else if (chr == ('F')) flags |= 0; // FIXME: what is that?

  0016e	3c 46		 cmp	 al, 70			; 00000046H
  00170	74 6f		 je	 SHORT $LN60@streamout

; 587  : 			else if (chr == ('l'))

  00172	3c 6c		 cmp	 al, 108			; 0000006cH
  00174	75 13		 jne	 SHORT $LN70@streamout

; 588  : 			{
; 589  : 				/* Check if this is the 2nd 'l' in a row */
; 590  : 				if (format[-2] == 'l') flags |= FLAG_INT64;

  00176	38 46 fe	 cmp	 BYTE PTR [esi-2], al
  00179	75 e1		 jne	 SHORT $LN69@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  0017b	8a 06		 mov	 al, BYTE PTR [esi]
  0017d	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  00183	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00186	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  00187	eb bd		 jmp	 SHORT $LL81@streamout
$LN70@streamout:

; 591  : 				else flags |= FLAG_LONG;
; 592  : 			}
; 593  : 			else if (chr == ('I'))

  00189	3c 49		 cmp	 al, 73			; 00000049H
  0018b	75 5f		 jne	 SHORT $LN79@streamout

; 594  : 			{
; 595  : 				if (format[0] == ('3') && format[1] == ('2'))

  0018d	8a 0e		 mov	 cl, BYTE PTR [esi]
  0018f	80 f9 33	 cmp	 cl, 51			; 00000033H
  00192	75 12		 jne	 SHORT $LN65@streamout
  00194	80 7e 01 32	 cmp	 BYTE PTR [esi+1], 50	; 00000032H
  00198	75 0c		 jne	 SHORT $LN65@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  0019a	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  0019d	83 c6 02	 add	 esi, 2
  001a0	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  001a3	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  001a4	eb a0		 jmp	 SHORT $LL81@streamout
$LN65@streamout:

; 596  : 				{
; 597  : 					format += 2;
; 598  : 				}
; 599  : 				else if (format[0] == ('6') && format[1] == ('4'))

  001a6	80 f9 36	 cmp	 cl, 54			; 00000036H
  001a9	75 18		 jne	 SHORT $LN63@streamout
  001ab	80 7e 01 34	 cmp	 BYTE PTR [esi+1], 52	; 00000034H
  001af	75 12		 jne	 SHORT $LN63@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  001b1	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001b4	83 c6 02	 add	 esi, 2
  001b7	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  001bd	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  001c0	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  001c1	eb 83		 jmp	 SHORT $LL81@streamout
$LN63@streamout:

; 600  : 				{
; 601  : 					format += 2;
; 602  : 					flags |= FLAG_INT64;
; 603  : 				}
; 604  : 				else if (format[0] == ('x') || format[0] == ('X') ||
; 605  : 					format[0] == ('d') || format[0] == ('i') ||
; 606  : 					format[0] == ('u') || format[0] == ('o'))

  001c3	80 f9 78	 cmp	 cl, 120			; 00000078H
  001c6	74 19		 je	 SHORT $LN60@streamout
  001c8	80 f9 58	 cmp	 cl, 88			; 00000058H
  001cb	74 14		 je	 SHORT $LN60@streamout
  001cd	80 f9 64	 cmp	 cl, 100			; 00000064H
  001d0	74 0f		 je	 SHORT $LN60@streamout
  001d2	80 f9 69	 cmp	 cl, 105			; 00000069H
  001d5	74 0a		 je	 SHORT $LN60@streamout
  001d7	80 f9 75	 cmp	 cl, 117			; 00000075H
  001da	74 05		 je	 SHORT $LN60@streamout
  001dc	80 f9 6f	 cmp	 cl, 111			; 0000006fH
  001df	75 0b		 jne	 SHORT $LN79@streamout
$LN60@streamout:

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  001e1	8a 06		 mov	 al, BYTE PTR [esi]
  001e3	46		 inc	 esi
  001e4	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  001e7	e9 5a ff ff ff	 jmp	 $LL81@streamout
$LN79@streamout:

; 616  : 
; 617  : 		/* Handle the format specifier */
; 618  : 		digits = digits_l;
; 619  : 		string = &buffer[BUFFER_SIZE];

  001ec	8d 4d c9	 lea	 ecx, DWORD PTR _buffer$[ebp+49]

; 620  : 		base = 10;
; 621  : 		prefix = 0;
; 622  : 		switch (chr)

  001ef	0f be c0	 movsx	 eax, al
  001f2	89 4d fc	 mov	 DWORD PTR _string$1$[ebp], ecx
  001f5	83 c0 bf	 add	 eax, -65		; ffffffbfH
  001f8	89 4d e4	 mov	 DWORD PTR _string$[ebp], ecx
  001fb	33 c9		 xor	 ecx, ecx
  001fd	89 75 10	 mov	 DWORD PTR _format$[ebp], esi
  00200	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??streamout@@9@9
  00207	c7 45 dc 0a 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 10 ; 0000000aH
  0020e	89 4d ec	 mov	 DWORD PTR _prefix$1$[ebp], ecx
  00211	89 4d d0	 mov	 DWORD PTR _prefix$[ebp], ecx
  00214	83 f8 37	 cmp	 eax, 55			; 00000037H
  00217	0f 87 82 04 00
	00		 ja	 $LN22@streamout
  0021d	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN222@streamout[eax]
  00224	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN271@streamout[eax*4]
$LN55@streamout:

; 623  : 		{
; 624  : 		case ('n'):
; 625  : 			if (flags & FLAG_INT64)

  0022b	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00231	74 1c		 je	 SHORT $LN54@streamout

; 626  : 				*va_arg(argptr, __int64*) = written_all;

  00233	8b 5d 14	 mov	 ebx, DWORD PTR _argptr$[ebp]
  00236	8b c7		 mov	 eax, edi
  00238	83 c3 04	 add	 ebx, 4
  0023b	99		 cdq
  0023c	89 5d 14	 mov	 DWORD PTR _argptr$[ebp], ebx
  0023f	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  00242	89 01		 mov	 DWORD PTR [ecx], eax
  00244	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00247	8b 55 f8	 mov	 edx, DWORD PTR _written$4$[ebp]
  0024a	e9 ef 04 00 00	 jmp	 $LN163@streamout
$LN54@streamout:

; 627  : 			else if (flags & FLAG_SHORT)

  0024f	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00255	74 14		 je	 SHORT $LN52@streamout

; 628  : 				*va_arg(argptr, short*) = (short)written_all;

  00257	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  0025a	83 c1 04	 add	 ecx, 4
  0025d	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00260	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00263	66 89 38	 mov	 WORD PTR [eax], di

; 629  : 			else

  00266	e9 d3 04 00 00	 jmp	 $LN163@streamout
$LN52@streamout:

; 630  : 				*va_arg(argptr, int*) = written_all;

  0026b	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  0026e	83 c0 04	 add	 eax, 4
  00271	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  00274	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00277	89 38		 mov	 DWORD PTR [eax], edi

; 631  : 			continue;

  00279	e9 c0 04 00 00	 jmp	 $LN163@streamout
$LN50@streamout:

; 632  : 
; 633  : 		case ('C'):
; 634  : 		case ('c'):
; 635  : 			string = buffer;

  0027e	8d 45 98	 lea	 eax, DWORD PTR _buffer$[ebp]

; 636  : 			len = 1;
; 637  : 
; 638  : 			/* Get character */
; 639  : 			uint32_t uChar = (uint32_t)va_arg(argptr, int);
; 640  : 			uint32_t uLen = 0;

  00281	89 4d d4	 mov	 DWORD PTR _uLen$1[ebp], ecx
  00284	89 45 fc	 mov	 DWORD PTR _string$1$[ebp], eax

; 641  : 
; 642  : 			/* Stream it out */
; 643  : 			StreamCharacterToUtf8(uChar, string, &uLen);

  00287	8d 4d d4	 lea	 ecx, DWORD PTR _uLen$1[ebp]
  0028a	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  0028d	51		 push	 ecx
  0028e	83 c0 04	 add	 eax, 4
  00291	8d 4d 98	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00294	51		 push	 ecx
  00295	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  00298	ff 70 fc	 push	 DWORD PTR [eax-4]
  0029b	e8 00 00 00 00	 call	 _StreamCharacterToUtf8

; 644  : 
; 645  : 			/* Null terminate */
; 646  : 			((char*)string)[uLen] = (char)('\0');

  002a0	8b 7d d4	 mov	 edi, DWORD PTR _uLen$1[ebp]
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a6	c6 44 3d 98 00	 mov	 BYTE PTR _buffer$[ebp+edi], 0
$LN251@streamout:
  002ab	8b 55 0c	 mov	 edx, DWORD PTR _precision$1$[ebp]
$LN131@streamout:

; 768  : 		}
; 769  : 
; 770  : 		/* Calculate padding */
; 771  : 		prefixlen = prefix ? strlen(prefix) : 0;

  002ae	33 c9		 xor	 ecx, ecx
$LN266@streamout:

; 772  : 		if (precision < 0) precision = 0;

  002b0	33 c0		 xor	 eax, eax
  002b2	89 4d d0	 mov	 DWORD PTR _prefixlen$1$[ebp], ecx
  002b5	85 d2		 test	 edx, edx
  002b7	0f 98 c0	 sets	 al
  002ba	48		 dec	 eax
  002bb	23 c2		 and	 eax, edx

; 773  : 		padding = (int)(fieldwidth - len - prefixlen - precision);

  002bd	8b 55 e0	 mov	 edx, DWORD PTR _padding$1$[ebp]
  002c0	2b d1		 sub	 edx, ecx
  002c2	89 45 0c	 mov	 DWORD PTR _precision$2$[ebp], eax
  002c5	2b d7		 sub	 edx, edi
  002c7	2b d0		 sub	 edx, eax

; 774  : 		if (padding < 0) padding = 0;

  002c9	b8 00 00 00 00	 mov	 eax, 0
  002ce	0f 98 c0	 sets	 al
  002d1	48		 dec	 eax
  002d2	23 c2		 and	 eax, edx
  002d4	89 45 e0	 mov	 DWORD PTR _padding$2$[ebp], eax

; 775  : 
; 776  : 		/* Optional left space padding */
; 777  : 		if ((flags & (FLAG_ALIGN_LEFT | FLAG_PAD_ZERO)) == 0)

  002d7	f6 c3 09	 test	 bl, 9
  002da	75 2e		 jne	 SHORT $LN16@streamout

; 778  : 		{
; 779  : 			for (; padding > 0; padding--)

  002dc	85 c0		 test	 eax, eax
  002de	7e 2a		 jle	 SHORT $LN16@streamout
$LL18@streamout:

; 780  : 			{
; 781  : 				if ((written = StreamOutCharacter(out, &cnt, (' '))) == 0) return -1;

  002e0	6a 20		 push	 32			; 00000020H
  002e2	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  002e5	50		 push	 eax
  002e6	ff 75 08	 push	 DWORD PTR _out$[ebp]
  002e9	e8 00 00 00 00	 call	 _StreamOutCharacter
  002ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f1	85 c0		 test	 eax, eax
  002f3	0f 84 5b 04 00
	00		 je	 $LN152@streamout

; 782  : 				written_all += written;

  002f9	01 45 f4	 add	 DWORD PTR _written_all$1$[ebp], eax
  002fc	8b 45 e0	 mov	 eax, DWORD PTR _padding$2$[ebp]
  002ff	48		 dec	 eax
  00300	89 45 e0	 mov	 DWORD PTR _padding$2$[ebp], eax
  00303	85 c0		 test	 eax, eax
  00305	7f d9		 jg	 SHORT $LL18@streamout
  00307	8b 4d d0	 mov	 ecx, DWORD PTR _prefixlen$1$[ebp]
$LN16@streamout:

; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 		/* Optional prefix */
; 787  : 		if (prefix)

  0030a	8b 45 ec	 mov	 eax, DWORD PTR _prefix$1$[ebp]
  0030d	85 c0		 test	 eax, eax
  0030f	74 1d		 je	 SHORT $LN14@streamout

; 788  : 		{
; 789  : 			written = streamout_string(out, &cnt, prefix, prefixlen);

  00311	51		 push	 ecx
  00312	50		 push	 eax
  00313	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00316	50		 push	 eax
  00317	ff 75 08	 push	 DWORD PTR _out$[ebp]
  0031a	e8 00 00 00 00	 call	 _StreamOutString
  0031f	83 c4 10	 add	 esp, 16			; 00000010H

; 790  : 			if (written == -1) return -1;

  00322	83 f8 ff	 cmp	 eax, -1
  00325	0f 84 29 04 00
	00		 je	 $LN152@streamout

; 791  : 			written_all += written;

  0032b	01 45 f4	 add	 DWORD PTR _written_all$1$[ebp], eax
$LN14@streamout:

; 792  : 		}
; 793  : 
; 794  : 		/* Optional left '0' padding */
; 795  : 		if ((flags & FLAG_ALIGN_LEFT) == 0) precision += padding;

  0032e	8b c3		 mov	 eax, ebx
  00330	83 e0 01	 and	 eax, 1
  00333	89 45 cc	 mov	 DWORD PTR tv731[ebp], eax
  00336	8b 45 0c	 mov	 eax, DWORD PTR _precision$2$[ebp]
  00339	75 03		 jne	 SHORT $LN143@streamout
  0033b	03 45 e0	 add	 eax, DWORD PTR _padding$2$[ebp]
$LN143@streamout:

; 796  : 		while (precision-- > 0)

  0033e	85 c0		 test	 eax, eax
  00340	7e 27		 jle	 SHORT $LN158@streamout
$LL11@streamout:
  00342	48		 dec	 eax
  00343	89 45 0c	 mov	 DWORD PTR _precision$2$[ebp], eax

; 797  : 		{
; 798  : 			if ((written = StreamOutCharacter(out, &cnt, ('0'))) == 0) return -1;

  00346	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00349	6a 30		 push	 48			; 00000030H
  0034b	50		 push	 eax
  0034c	ff 75 08	 push	 DWORD PTR _out$[ebp]
  0034f	e8 00 00 00 00	 call	 _StreamOutCharacter
  00354	83 c4 0c	 add	 esp, 12			; 0000000cH
  00357	85 c0		 test	 eax, eax
  00359	0f 84 f5 03 00
	00		 je	 $LN152@streamout

; 799  : 			written_all += written;

  0035f	01 45 f4	 add	 DWORD PTR _written_all$1$[ebp], eax
  00362	8b 45 0c	 mov	 eax, DWORD PTR _precision$2$[ebp]
  00365	85 c0		 test	 eax, eax
  00367	7f d9		 jg	 SHORT $LL11@streamout
$LN158@streamout:

; 800  : 		}
; 801  : 
; 802  : 		/* Output the string */
; 803  : 		if (flags & FLAG_WIDECHAR)
; 804  : 			written = StreamOutWString(out, &cnt, (wchar_t*)string, len);

  00369	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  0036c	57		 push	 edi
  0036d	ff 75 fc	 push	 DWORD PTR _string$1$[ebp]
  00370	50		 push	 eax
  00371	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00374	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  0037a	0f 84 bf 02 00
	00		 je	 $LN8@streamout
  00380	e8 00 00 00 00	 call	 _StreamOutWString
  00385	8b d0		 mov	 edx, eax
  00387	89 55 f8	 mov	 DWORD PTR _written$4$[ebp], edx

; 805  : 		else

  0038a	e9 ba 02 00 00	 jmp	 $LN267@streamout
$LN49@streamout:

; 647  : 			len = (size_t)uLen;
; 648  : 			
; 649  : 			/* Done */
; 650  : 			break;
; 651  : 
; 652  : 		case ('Z'):
; 653  : 			nt_string = va_arg(argptr, void*);

  0038f	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  00392	83 c0 04	 add	 eax, 4
  00395	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  00398	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 654  : 			if (nt_string && (string = nt_string->Buffer))

  0039b	85 c9		 test	 ecx, ecx
  0039d	74 52		 je	 SHORT $LN208@streamout
  0039f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  003a2	89 45 fc	 mov	 DWORD PTR _string$1$[ebp], eax
  003a5	85 c0		 test	 eax, eax
  003a7	74 48		 je	 SHORT $LN208@streamout

; 655  : 			{
; 656  : 				len = nt_string->Length;

  003a9	0f b7 39	 movzx	 edi, WORD PTR [ecx]

; 657  : 				if (flags & FLAG_WIDECHAR) len /= sizeof(wchar_t);

  003ac	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  003b2	0f 84 f3 fe ff
	ff		 je	 $LN251@streamout
  003b8	d1 ef		 shr	 edi, 1

; 658  : 				break;

  003ba	e9 ec fe ff ff	 jmp	 $LN251@streamout
$LN46@streamout:

; 659  : 			}
; 660  : 			string = 0;
; 661  : 			goto case_string;
; 662  : 
; 663  : 		case ('S'):
; 664  : 			string = va_arg(argptr, void*);

  003bf	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  003c2	83 c0 04	 add	 eax, 4
  003c5	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  003c8	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  003cb	89 45 fc	 mov	 DWORD PTR _string$1$[ebp], eax

; 665  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  003ce	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  003d4	75 17		 jne	 SHORT $case_string$272
  003d6	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H

; 666  : 			goto case_string;

  003dc	eb 0f		 jmp	 SHORT $case_string$272
$LN44@streamout:

; 667  : 
; 668  : 		case ('s'):
; 669  : 			string = va_arg(argptr, void*);

  003de	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  003e1	83 c0 04	 add	 eax, 4
  003e4	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  003e7	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  003ea	89 45 fc	 mov	 DWORD PTR _string$1$[ebp], eax
$case_string$272:

; 670  : 
; 671  : case_string:
; 672  : 			if (!string)

  003ed	85 c0		 test	 eax, eax
  003ef	75 0e		 jne	 SHORT $LN43@streamout
$LN208@streamout:

; 673  : 			{
; 674  : 				string = (char*)_nullstring;

  003f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_nullstring@?1??streamout@@9@9

; 675  : 				flags &= ~FLAG_WIDECHAR;

  003f6	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  003fc	89 45 fc	 mov	 DWORD PTR _string$1$[ebp], eax
$LN43@streamout:

; 676  : 			}
; 677  : 
; 678  :  			if (flags & FLAG_WIDECHAR)

  003ff	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00405	74 16		 je	 SHORT $LN42@streamout

; 679  :  				len = wcsnlen((wchar_t*)string, (unsigned)precision);

  00407	8b 55 0c	 mov	 edx, DWORD PTR _precision$1$[ebp]
  0040a	52		 push	 edx
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 _wcsnlen
  00411	83 c4 08	 add	 esp, 8
  00414	8b f8		 mov	 edi, eax

; 682  : 			precision = 0;

  00416	33 d2		 xor	 edx, edx

; 683  : 			break;

  00418	e9 91 fe ff ff	 jmp	 $LN131@streamout
$LN42@streamout:

; 680  :  			else
; 681  : 				len = strlen((char*)string);

  0041d	8b f8		 mov	 edi, eax
  0041f	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL223@streamout:
  00422	8a 07		 mov	 al, BYTE PTR [edi]
  00424	47		 inc	 edi
  00425	84 c0		 test	 al, al
  00427	75 f9		 jne	 SHORT $LL223@streamout
  00429	2b f9		 sub	 edi, ecx

; 682  : 			precision = 0;

  0042b	33 d2		 xor	 edx, edx

; 683  : 			break;

  0042d	e9 7c fe ff ff	 jmp	 $LN131@streamout
$LN40@streamout:

; 684  : 
; 685  : 		case ('G'):
; 686  : 		case ('E'):
; 687  : 		case ('A'):
; 688  : 		case ('g'):
; 689  : 		case ('e'):
; 690  : 		case ('a'):
; 691  : 		case ('f'):
; 692  : #ifdef _UNICODE
; 693  : 			flags |= FLAG_WIDECHAR;
; 694  : #else
; 695  : 			flags &= ~FLAG_WIDECHAR;
; 696  : #endif
; 697  : 			/* Use external function, one for kernel one for user mode */
; 698  : 			format_float(chr, flags, precision, &string, &prefix, &argptr);

  00432	8b 55 0c	 mov	 edx, DWORD PTR _precision$1$[ebp]
  00435	8d 45 14	 lea	 eax, DWORD PTR _argptr$[ebp]
  00438	50		 push	 eax
  00439	8d 45 d0	 lea	 eax, DWORD PTR _prefix$[ebp]
  0043c	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  00442	50		 push	 eax
  00443	8d 45 e4	 lea	 eax, DWORD PTR _string$[ebp]
  00446	50		 push	 eax
  00447	52		 push	 edx
  00448	53		 push	 ebx
  00449	ff 75 f0	 push	 DWORD PTR _chr$[ebp]
  0044c	e8 00 00 00 00	 call	 _format_float

; 699  : 			len = strlen(string);

  00451	8b 45 e4	 mov	 eax, DWORD PTR _string$[ebp]
  00454	83 c4 18	 add	 esp, 24			; 00000018H
  00457	8b f8		 mov	 edi, eax
  00459	89 45 fc	 mov	 DWORD PTR _string$1$[ebp], eax
  0045c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0045f	90		 npad	 1
$LL224@streamout:
  00460	8a 07		 mov	 al, BYTE PTR [edi]
  00462	47		 inc	 edi
  00463	84 c0		 test	 al, al
  00465	75 f9		 jne	 SHORT $LL224@streamout

; 700  : 			precision = 0;
; 701  : 			break;

  00467	8b 45 d0	 mov	 eax, DWORD PTR _prefix$[ebp]
  0046a	2b f9		 sub	 edi, ecx
  0046c	33 d2		 xor	 edx, edx
  0046e	89 45 ec	 mov	 DWORD PTR _prefix$1$[ebp], eax
  00471	e9 e9 00 00 00	 jmp	 $LN56@streamout
$LN39@streamout:

; 702  : 
; 703  : 		case ('d'):
; 704  : 		case ('i'):
; 705  : 			val64 = (__int64)va_arg_f(argptr, flags);

  00476	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  0047c	74 11		 je	 SHORT $LN125@streamout
  0047e	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00481	83 c1 08	 add	 ecx, 8
  00484	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00487	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0048a	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0048d	eb 24		 jmp	 SHORT $LN264@streamout
$LN125@streamout:
  0048f	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00495	74 0f		 je	 SHORT $LN123@streamout
  00497	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  0049a	83 c1 04	 add	 ecx, 4
  0049d	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  004a0	0f bf 41 fc	 movsx	 eax, WORD PTR [ecx-4]
  004a4	eb 0c		 jmp	 SHORT $LN124@streamout
$LN123@streamout:
  004a6	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  004a9	83 c0 04	 add	 eax, 4
  004ac	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  004af	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
$LN124@streamout:
  004b2	99		 cdq
$LN264@streamout:
  004b3	89 55 e4	 mov	 DWORD PTR _val64$2$[ebp], edx
  004b6	89 45 f8	 mov	 DWORD PTR _val64$1$[ebp], eax

; 706  : 
; 707  : 			if ((__int64)val64 < 0)

  004b9	85 d2		 test	 edx, edx
  004bb	0f 8f be 00 00
	00		 jg	 $LN38@streamout
  004c1	7c 08		 jl	 SHORT $LN225@streamout
  004c3	85 c0		 test	 eax, eax
  004c5	0f 83 b4 00 00
	00		 jae	 $LN38@streamout
$LN225@streamout:

; 708  : 			{
; 709  : 				val64 = -(__int64)val64;

  004cb	f7 d8		 neg	 eax

; 710  : 				prefix = ("-");

  004cd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3043
  004d4	89 45 f8	 mov	 DWORD PTR _val64$1$[ebp], eax
  004d7	83 d2 00	 adc	 edx, 0
  004da	f7 da		 neg	 edx
  004dc	89 55 e4	 mov	 DWORD PTR _val64$2$[ebp], edx
$LN252@streamout:
  004df	8b 4d f8	 mov	 ecx, DWORD PTR _val64$1$[ebp]
$case_number$273:

; 748  : 
; 749  : case_number:
; 750  : 			flags &= ~FLAG_WIDECHAR;
; 751  : 			if (precision < 0) precision = 1;

  004e2	8b 7d 0c	 mov	 edi, DWORD PTR _precision$1$[ebp]
  004e5	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  004eb	89 5d cc	 mov	 DWORD PTR _flags$1$[ebp], ebx
  004ee	85 ff		 test	 edi, edi
  004f0	79 08		 jns	 SHORT $LN141@streamout
  004f2	bf 01 00 00 00	 mov	 edi, 1
  004f7	89 7d 0c	 mov	 DWORD PTR _precision$1$[ebp], edi
$LN141@streamout:

; 752  : 
; 753  : 			/* Gather digits in reverse order */
; 754  : 			while (val64)

  004fa	8b c1		 mov	 eax, ecx
  004fc	0b c2		 or	 eax, edx
  004fe	74 47		 je	 SHORT $LN23@streamout
  00500	8b 45 dc	 mov	 eax, DWORD PTR _base$1$[ebp]
  00503	8b 75 fc	 mov	 esi, DWORD PTR _string$1$[ebp]
  00506	8b 5d f8	 mov	 ebx, DWORD PTR _val64$1$[ebp]
  00509	99		 cdq
  0050a	8b c8		 mov	 ecx, eax
  0050c	8b c2		 mov	 eax, edx
  0050e	8b 55 e4	 mov	 edx, DWORD PTR _val64$2$[ebp]
  00511	89 4d d0	 mov	 DWORD PTR tv666[ebp], ecx
  00514	89 45 0c	 mov	 DWORD PTR tv665[ebp], eax
$LL24@streamout:

; 755  : 			{
; 756  : 				*--string = digits[val64 % base];

  00517	50		 push	 eax
  00518	51		 push	 ecx
  00519	52		 push	 edx
  0051a	53		 push	 ebx
  0051b	4e		 dec	 esi
  0051c	e8 00 00 00 00	 call	 __aulldvrm
  00521	89 5d dc	 mov	 DWORD PTR tv599[ebp+4], ebx

; 757  : 				val64 /= base;
; 758  : 				precision--;

  00524	4f		 dec	 edi
  00525	8b d8		 mov	 ebx, eax
  00527	8b 45 d4	 mov	 eax, DWORD PTR _digits$1$[ebp]
  0052a	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  0052d	8b 4d d0	 mov	 ecx, DWORD PTR tv666[ebp]
  00530	88 06		 mov	 BYTE PTR [esi], al
  00532	8b c3		 mov	 eax, ebx
  00534	0b c2		 or	 eax, edx
  00536	8b 45 0c	 mov	 eax, DWORD PTR tv665[ebp]
  00539	75 dc		 jne	 SHORT $LL24@streamout
  0053b	8b 5d cc	 mov	 ebx, DWORD PTR _flags$1$[ebp]
  0053e	89 75 fc	 mov	 DWORD PTR _string$1$[ebp], esi
  00541	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  00544	89 7d 0c	 mov	 DWORD PTR _precision$1$[ebp], edi
$LN23@streamout:

; 759  : 			}
; 760  : 
; 761  : 			len = strlen(string);

  00547	8b 7d fc	 mov	 edi, DWORD PTR _string$1$[ebp]
  0054a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0054d	8d 49 00	 npad	 3
$LL226@streamout:
  00550	8a 07		 mov	 al, BYTE PTR [edi]
  00552	47		 inc	 edi
  00553	84 c0		 test	 al, al
  00555	75 f9		 jne	 SHORT $LL226@streamout
  00557	8b 55 0c	 mov	 edx, DWORD PTR _precision$1$[ebp]
  0055a	2b f9		 sub	 edi, ecx
  0055c	8b 45 ec	 mov	 eax, DWORD PTR _prefix$1$[ebp]
$LN56@streamout:

; 768  : 		}
; 769  : 
; 770  : 		/* Calculate padding */
; 771  : 		prefixlen = prefix ? strlen(prefix) : 0;

  0055f	85 c0		 test	 eax, eax
  00561	0f 84 47 fd ff
	ff		 je	 $LN131@streamout
  00567	8b c8		 mov	 ecx, eax
  00569	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0056c	89 45 0c	 mov	 DWORD PTR tv729[ebp], eax
  0056f	90		 npad	 1
$LL227@streamout:
  00570	8a 01		 mov	 al, BYTE PTR [ecx]
  00572	41		 inc	 ecx
  00573	84 c0		 test	 al, al
  00575	75 f9		 jne	 SHORT $LL227@streamout
  00577	2b 4d 0c	 sub	 ecx, DWORD PTR tv729[ebp]
  0057a	e9 31 fd ff ff	 jmp	 $LN266@streamout
$LN38@streamout:

; 711  : 			}
; 712  : 			else if (flags & FLAG_FORCE_SIGN)

  0057f	f6 c3 02	 test	 bl, 2
  00582	74 0c		 je	 SHORT $LN36@streamout

; 713  : 				prefix = ("+");

  00584	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3046
  0058b	e9 4f ff ff ff	 jmp	 $LN252@streamout
$LN36@streamout:

; 714  : 			else if (flags & FLAG_FORCE_SIGNSP)

  00590	f6 c3 04	 test	 bl, 4
  00593	0f 84 46 ff ff
	ff		 je	 $LN252@streamout

; 715  : 				prefix = (" ");

  00599	b8 00 00 00 00	 mov	 eax, OFFSET $SG3049
  0059e	89 45 ec	 mov	 DWORD PTR _prefix$1$[ebp], eax

; 716  : 
; 717  : 			goto case_number;

  005a1	e9 39 ff ff ff	 jmp	 $LN252@streamout
$LN33@streamout:

; 718  : 
; 719  : 		case ('o'):
; 720  : 			base = 8;

  005a6	c7 45 dc 08 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 8

; 721  : 			if (flags & FLAG_SPECIAL)

  005ad	f6 c3 10	 test	 bl, 16			; 00000010H
  005b0	74 3d		 je	 SHORT $case_unsigned$274

; 722  : 			{
; 723  : 				prefix = ("0");
; 724  : 				if (precision > 0) precision--;

  005b2	8b 55 0c	 mov	 edx, DWORD PTR _precision$1$[ebp]
  005b5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3053
  005bc	85 d2		 test	 edx, edx
  005be	7e 2f		 jle	 SHORT $case_unsigned$274
  005c0	4a		 dec	 edx
  005c1	89 55 0c	 mov	 DWORD PTR _precision$1$[ebp], edx

; 725  : 			}
; 726  : 			goto case_unsigned;

  005c4	eb 29		 jmp	 SHORT $case_unsigned$274
$LN30@streamout:

; 727  : 
; 728  : 		case ('p'):
; 729  : 			precision = 2 * sizeof(void*);

  005c6	c7 45 0c 08 00
	00 00		 mov	 DWORD PTR _precision$1$[ebp], 8

; 730  : 			flags &= ~FLAG_PAD_ZERO;

  005cd	83 e3 f7	 and	 ebx, -9			; fffffff7H
$LN29@streamout:

; 731  : 			flags |= FLAG_INTPTR;
; 732  : 			/* Fall through */
; 733  : 
; 734  : 		case ('X'):
; 735  : 			digits = digits_u;

  005d0	b8 00 00 00 00	 mov	 eax, OFFSET ?digits_u@?1??streamout@@9@9
  005d5	89 45 d4	 mov	 DWORD PTR _digits$1$[ebp], eax
  005d8	eb 03		 jmp	 SHORT $LN28@streamout
$LN253@streamout:
  005da	8b 45 d4	 mov	 eax, DWORD PTR _digits$1$[ebp]
$LN28@streamout:

; 736  : 			/* Fall through */
; 737  : 
; 738  : 		case ('x'):
; 739  : 			base = 16;

  005dd	c7 45 dc 10 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 16 ; 00000010H

; 740  : 			if (flags & FLAG_SPECIAL)

  005e4	f6 c3 10	 test	 bl, 16			; 00000010H
  005e7	74 06		 je	 SHORT $case_unsigned$274

; 741  : 			{
; 742  : 				prefix = &digits[16];

  005e9	83 c0 10	 add	 eax, 16			; 00000010H
  005ec	89 45 ec	 mov	 DWORD PTR _prefix$1$[ebp], eax
$case_unsigned$274:

; 743  : 			}
; 744  : 
; 745  : 		case ('u'):
; 746  : case_unsigned:
; 747  : 			val64 = va_arg_fu(argptr, flags);

  005ef	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]
  005f2	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  005f8	74 16		 je	 SHORT $LN129@streamout
  005fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fc	83 c0 08	 add	 eax, 8
  005ff	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  00602	89 4d f8	 mov	 DWORD PTR _val64$1$[ebp], ecx
  00605	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00608	89 55 e4	 mov	 DWORD PTR _val64$2$[ebp], edx
  0060b	e9 d2 fe ff ff	 jmp	 $case_number$273
$LN129@streamout:
  00610	83 c0 04	 add	 eax, 4
  00613	89 45 14	 mov	 DWORD PTR _argptr$[ebp], eax
  00616	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0061c	74 11		 je	 SHORT $LN127@streamout
  0061e	0f b7 48 fc	 movzx	 ecx, WORD PTR [eax-4]
  00622	33 d2		 xor	 edx, edx
  00624	89 4d f8	 mov	 DWORD PTR _val64$1$[ebp], ecx
  00627	89 55 e4	 mov	 DWORD PTR _val64$2$[ebp], edx
  0062a	e9 b3 fe ff ff	 jmp	 $case_number$273
$LN127@streamout:
  0062f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00632	33 d2		 xor	 edx, edx
  00634	89 4d f8	 mov	 DWORD PTR _val64$1$[ebp], ecx
  00637	89 55 e4	 mov	 DWORD PTR _val64$2$[ebp], edx
  0063a	e9 a3 fe ff ff	 jmp	 $case_number$273
$LN8@streamout:

; 806  : 			written = StreamOutString(out, &cnt, (char*)string, len);

  0063f	e8 00 00 00 00	 call	 _StreamOutString
  00644	8b d0		 mov	 edx, eax
  00646	89 45 f8	 mov	 DWORD PTR _written$4$[ebp], eax
$LN267@streamout:
  00649	83 c4 10	 add	 esp, 16			; 00000010H

; 807  : 		if (written == -1) return -1;

  0064c	83 fa ff	 cmp	 edx, -1
  0064f	0f 84 ff 00 00
	00		 je	 $LN152@streamout

; 808  : 		written_all += written;

  00655	8b 7d f4	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  00658	03 fa		 add	 edi, edx

; 809  : 
; 810  : #if 0 && SUPPORT_FLOAT
; 811  : 		/* Optional right '0' padding */
; 812  : 		while (precision-- > 0)
; 813  : 		{
; 814  : 			if ((written = StreamOutCharacter(out, &cnt, ('0'))) == 0) return -1;
; 815  : 			written_all += written;
; 816  : 			len++;
; 817  : 		}
; 818  : #endif
; 819  : 
; 820  : 		/* Optional right padding */
; 821  : 		if (flags & FLAG_ALIGN_LEFT)

  0065a	83 7d cc 00	 cmp	 DWORD PTR tv731[ebp], 0
  0065e	89 7d f4	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00661	0f 84 d7 00 00
	00		 je	 $LN163@streamout

; 822  : 		{
; 823  : 			while (padding-- > 0)

  00667	8b 5d e0	 mov	 ebx, DWORD PTR _padding$2$[ebp]
  0066a	85 db		 test	 ebx, ebx
  0066c	0f 8e cc 00 00
	00		 jle	 $LN163@streamout
$LL4@streamout:

; 824  : 			{
; 825  : 				if ((written = StreamOutCharacter(out, &cnt, (' '))) == 0) return -1;

  00672	6a 20		 push	 32			; 00000020H
  00674	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00677	4b		 dec	 ebx
  00678	50		 push	 eax
  00679	ff 75 08	 push	 DWORD PTR _out$[ebp]
  0067c	e8 00 00 00 00	 call	 _StreamOutCharacter
  00681	8b d0		 mov	 edx, eax
  00683	83 c4 0c	 add	 esp, 12			; 0000000cH
  00686	89 55 f8	 mov	 DWORD PTR _written$4$[ebp], edx
  00689	85 d2		 test	 edx, edx
  0068b	0f 84 c3 00 00
	00		 je	 $LN152@streamout

; 826  : 				written_all += written;

  00691	03 fa		 add	 edi, edx
  00693	89 7d f4	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00696	85 db		 test	 ebx, ebx
  00698	7f d8		 jg	 SHORT $LL4@streamout

; 827  : 			}
; 828  : 		}
; 829  : 
; 830  : 	}

  0069a	e9 9f 00 00 00	 jmp	 $LN163@streamout
$LN22@streamout:

; 762  : 			break;
; 763  : 
; 764  : 		default:
; 765  : 			/* Treat anything else as a new character */
; 766  : 			format--;

  0069f	4e		 dec	 esi

; 767  : 			continue;

  006a0	e9 99 00 00 00	 jmp	 $LN163@streamout
$LN116@streamout:

; 472  : 		{
; 473  : 			/* Sanity */
; 474  : 			if (IsUTF8(chr))

  006a5	8a c8		 mov	 cl, al
  006a7	80 e1 c0	 and	 cl, 192			; 000000c0H
  006aa	80 f9 80	 cmp	 cl, 128			; 00000080H
  006ad	75 70		 jne	 SHORT $LN115@streamout

; 475  : 			{
; 476  : 				/* Build UTF-8 */
; 477  : 				uint32_t uChar = (uint32_t)chr;
; 478  : 				uint32_t Size = 0;
; 479  : 
; 480  : 				/* Iterate */
; 481  : 				while (*format && IsUTF8(*format))

  006af	8a 16		 mov	 dl, BYTE PTR [esi]
  006b1	33 db		 xor	 ebx, ebx
  006b3	0f be c8	 movsx	 ecx, al
  006b6	84 d2		 test	 dl, dl
  006b8	74 1e		 je	 SHORT $LN249@streamout
  006ba	8d 9b 00 00 00
	00		 npad	 6
$LL114@streamout:
  006c0	8a c2		 mov	 al, dl
  006c2	24 c0		 and	 al, 192			; 000000c0H
  006c4	3c 80		 cmp	 al, 128			; 00000080H
  006c6	75 10		 jne	 SHORT $LN249@streamout

; 482  : 				{
; 483  : 					/* Move */
; 484  : 					uChar <<= 6;
; 485  : 
; 486  : 					/* Add */
; 487  : 					uChar += (unsigned char)*format;
; 488  : 
; 489  : 					/* Inc */
; 490  : 					Size++;
; 491  : 					format++;

  006c8	46		 inc	 esi
  006c9	c1 e1 06	 shl	 ecx, 6
  006cc	0f b6 c2	 movzx	 eax, dl
  006cf	43		 inc	 ebx
  006d0	03 c8		 add	 ecx, eax
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	84 d2		 test	 dl, dl
  006d6	75 e8		 jne	 SHORT $LL114@streamout
$LN249@streamout:

; 492  : 				}
; 493  : 
; 494  : 				/* Move */
; 495  : 				uChar <<= 6;

  006d8	c1 e1 06	 shl	 ecx, 6

; 496  : 
; 497  : 				/* Add the last byte */
; 498  : 				if (Size == 1)

  006db	83 fb 01	 cmp	 ebx, 1
  006de	75 08		 jne	 SHORT $LN112@streamout

; 499  : 					uChar |= (((unsigned char)*format) & 0x1F);

  006e0	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006e3	83 e0 1f	 and	 eax, 31			; 0000001fH
  006e6	eb 18		 jmp	 SHORT $LN268@streamout
$LN112@streamout:

; 500  : 				else if (Size == 2)

  006e8	83 fb 02	 cmp	 ebx, 2
  006eb	75 08		 jne	 SHORT $LN110@streamout

; 501  : 					uChar |= (((unsigned char)*format) & 0xF);

  006ed	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006f0	83 e0 0f	 and	 eax, 15			; 0000000fH
  006f3	eb 0b		 jmp	 SHORT $LN268@streamout
$LN110@streamout:

; 502  : 				else if (Size == 3)

  006f5	83 fb 03	 cmp	 ebx, 3
  006f8	75 08		 jne	 SHORT $LN108@streamout

; 503  : 					uChar |= (((unsigned char)*format) & 0x7);

  006fa	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006fd	83 e0 07	 and	 eax, 7
$LN268@streamout:
  00700	0b c8		 or	 ecx, eax
$LN108@streamout:

; 504  : 
; 505  : 				/* Write the character to the stream */
; 506  : 				if ((written = StreamOutCharacter(out, &cnt, uChar)) == 0)

  00702	8b 5d 08	 mov	 ebx, DWORD PTR _out$[ebp]
  00705	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00708	51		 push	 ecx
  00709	50		 push	 eax
  0070a	53		 push	 ebx
  0070b	e8 00 00 00 00	 call	 _StreamOutCharacter
  00710	8b d0		 mov	 edx, eax
  00712	83 c4 0c	 add	 esp, 12			; 0000000cH
  00715	89 55 f8	 mov	 DWORD PTR _written$4$[ebp], edx
  00718	85 d2		 test	 edx, edx
  0071a	74 38		 je	 SHORT $LN152@streamout

; 508  : 
; 509  : 				/* Skip */
; 510  : 				format++;

  0071c	46		 inc	 esi

; 511  : 			}
; 512  : 			else

  0071d	eb 1a		 jmp	 SHORT $LN105@streamout
$LN115@streamout:

; 513  : 			{
; 514  : 				/* Write the character to the stream */
; 515  : 				if ((written = StreamOutCharacter(out, &cnt, (uint32_t)chr)) == 0)

  0071f	0f be c0	 movsx	 eax, al
  00722	50		 push	 eax
  00723	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00726	50		 push	 eax
  00727	53		 push	 ebx
  00728	e8 00 00 00 00	 call	 _StreamOutCharacter
  0072d	8b d0		 mov	 edx, eax
  0072f	89 45 f8	 mov	 DWORD PTR _written$4$[ebp], eax
  00732	83 c4 0c	 add	 esp, 12			; 0000000cH
  00735	85 d2		 test	 edx, edx
  00737	74 1b		 je	 SHORT $LN152@streamout
$LN105@streamout:

; 516  : 					return -1;
; 517  : 			}
; 518  : 
; 519  : 			/* Done */
; 520  : 			written_all += written;

  00739	03 fa		 add	 edi, edx
  0073b	89 7d f4	 mov	 DWORD PTR _written_all$1$[ebp], edi
$LN163@streamout:

; 458  : 
; 459  : 	/* Iterate String */
; 460  : 	while (written >= 0)

  0073e	85 d2		 test	 edx, edx
  00740	0f 89 dd f8 ff
	ff		 jns	 $LN269@streamout
$LN119@streamout:

; 831  : 
; 832  : 	if (written == -1) return -1;

  00746	83 fa ff	 cmp	 edx, -1
  00749	74 09		 je	 SHORT $LN152@streamout

; 833  : 
; 834  : 	return written_all;

  0074b	8b c7		 mov	 eax, edi
  0074d	5f		 pop	 edi
  0074e	5e		 pop	 esi
  0074f	5b		 pop	 ebx

; 835  : }

  00750	8b e5		 mov	 esp, ebp
  00752	5d		 pop	 ebp
  00753	c3		 ret	 0
$LN152@streamout:
  00754	5f		 pop	 edi
  00755	5e		 pop	 esi

; 507  : 					return -1;

  00756	83 c8 ff	 or	 eax, -1
  00759	5b		 pop	 ebx

; 835  : }

  0075a	8b e5		 mov	 esp, ebp
  0075c	5d		 pop	 ebp
  0075d	c3		 ret	 0
  0075e	8b ff		 npad	 2
$LN271@streamout:
  00760	00 00 00 00	 DD	 $LN40@streamout
  00764	00 00 00 00	 DD	 $LN50@streamout
  00768	00 00 00 00	 DD	 $LN46@streamout
  0076c	00 00 00 00	 DD	 $LN29@streamout
  00770	00 00 00 00	 DD	 $LN49@streamout
  00774	00 00 00 00	 DD	 $LN39@streamout
  00778	00 00 00 00	 DD	 $LN55@streamout
  0077c	00 00 00 00	 DD	 $LN33@streamout
  00780	00 00 00 00	 DD	 $LN30@streamout
  00784	00 00 00 00	 DD	 $LN44@streamout
  00788	00 00 00 00	 DD	 $case_unsigned$274
  0078c	00 00 00 00	 DD	 $LN253@streamout
  00790	00 00 00 00	 DD	 $LN22@streamout
$LN222@streamout:
  00794	00		 DB	 0
  00795	0c		 DB	 12			; 0000000cH
  00796	01		 DB	 1
  00797	0c		 DB	 12			; 0000000cH
  00798	00		 DB	 0
  00799	0c		 DB	 12			; 0000000cH
  0079a	00		 DB	 0
  0079b	0c		 DB	 12			; 0000000cH
  0079c	0c		 DB	 12			; 0000000cH
  0079d	0c		 DB	 12			; 0000000cH
  0079e	0c		 DB	 12			; 0000000cH
  0079f	0c		 DB	 12			; 0000000cH
  007a0	0c		 DB	 12			; 0000000cH
  007a1	0c		 DB	 12			; 0000000cH
  007a2	0c		 DB	 12			; 0000000cH
  007a3	0c		 DB	 12			; 0000000cH
  007a4	0c		 DB	 12			; 0000000cH
  007a5	0c		 DB	 12			; 0000000cH
  007a6	02		 DB	 2
  007a7	0c		 DB	 12			; 0000000cH
  007a8	0c		 DB	 12			; 0000000cH
  007a9	0c		 DB	 12			; 0000000cH
  007aa	0c		 DB	 12			; 0000000cH
  007ab	03		 DB	 3
  007ac	0c		 DB	 12			; 0000000cH
  007ad	04		 DB	 4
  007ae	0c		 DB	 12			; 0000000cH
  007af	0c		 DB	 12			; 0000000cH
  007b0	0c		 DB	 12			; 0000000cH
  007b1	0c		 DB	 12			; 0000000cH
  007b2	0c		 DB	 12			; 0000000cH
  007b3	0c		 DB	 12			; 0000000cH
  007b4	00		 DB	 0
  007b5	0c		 DB	 12			; 0000000cH
  007b6	01		 DB	 1
  007b7	05		 DB	 5
  007b8	00		 DB	 0
  007b9	00		 DB	 0
  007ba	00		 DB	 0
  007bb	0c		 DB	 12			; 0000000cH
  007bc	05		 DB	 5
  007bd	0c		 DB	 12			; 0000000cH
  007be	0c		 DB	 12			; 0000000cH
  007bf	0c		 DB	 12			; 0000000cH
  007c0	0c		 DB	 12			; 0000000cH
  007c1	06		 DB	 6
  007c2	07		 DB	 7
  007c3	08		 DB	 8
  007c4	0c		 DB	 12			; 0000000cH
  007c5	0c		 DB	 12			; 0000000cH
  007c6	09		 DB	 9
  007c7	0c		 DB	 12			; 0000000cH
  007c8	0a		 DB	 10			; 0000000aH
  007c9	0c		 DB	 12			; 0000000cH
  007ca	0c		 DB	 12			; 0000000cH
  007cb	0b		 DB	 11			; 0000000bH
_streamout ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _format_float
_TEXT	SEGMENT
tv566 = -48						; size = 8
tv559 = -48						; size = 8
tv493 = -48						; size = 8
tv358 = -48						; size = 8
tv351 = -48						; size = 8
tv81 = -48						; size = 8
tv486 = -40						; size = 8
tv471 = -40						; size = 8
tv425 = -40						; size = 8
tv421 = -40						; size = 8
tv393 = -40						; size = 8
tv385 = -40						; size = 8
_fpval$1$ = -32						; size = 8
_padding$1$ = -24					; size = 4
_exponent$1$ = -20					; size = 4
_fpval2$1$ = -16					; size = 8
_sign$ = -12						; size = 4
_digits$1$ = -8						; size = 4
_precision$1$ = -4					; size = 4
tv398 = 8						; size = 4
tv79 = 8						; size = 4
_chr$ = 8						; size = 1
_flags$ = 12						; size = 4
tv733 = 16						; size = 4
tv487 = 16						; size = 4
tv472 = 16						; size = 4
tv386 = 16						; size = 4
tv130 = 16						; size = 4
tv76 = 16						; size = 4
_num_digits$2$ = 16					; size = 4
_num_digits$1$ = 16					; size = 4
_precision$ = 16					; size = 4
_string$ = 20						; size = 4
_prefix$ = 24						; size = 4
_argptr$ = 28						; size = 4
_format_float PROC					; COMDAT

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	53		 push	 ebx

; 302  : 	static const char digits_l[] = ("0123456789abcdef0x");
; 303  : 	static const char digits_u[] = ("0123456789ABCDEF0X");
; 304  : 	static const char _nan[] = ("#QNAN");
; 305  : 	static const char _infinity[] = ("#INF");
; 306  : 	const char *digits = digits_l;
; 307  : 	int exponent = 0, sign;
; 308  : 	long double fpval, fpval2;
; 309  : 	int padding = 0, num_digits, val32, base = 10;

  00007	33 db		 xor	 ebx, ebx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??format_float@@9@9
  00010	89 5d e8	 mov	 DWORD PTR _padding$1$[ebp], ebx

; 310  : 
; 311  : 	/* Normalize the precision */
; 312  : 	if (precision < 0) precision = 6;

  00013	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
  00016	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	85 db		 test	 ebx, ebx
  0001d	79 07		 jns	 SHORT $LN37@format_flo
  0001f	bb 06 00 00 00	 mov	 ebx, 6
  00024	eb 10		 jmp	 SHORT $LN168@format_flo
$LN37@format_flo:

; 313  : 	else if (precision > 17)

  00026	83 fb 11	 cmp	 ebx, 17			; 00000011H
  00029	7e 11		 jle	 SHORT $LN35@format_flo

; 314  : 	{
; 315  : 		padding = precision - 17;

  0002b	83 c3 ef	 add	 ebx, -17		; ffffffefH
  0002e	89 5d e8	 mov	 DWORD PTR _padding$1$[ebp], ebx

; 316  : 		precision = 17;

  00031	bb 11 00 00 00	 mov	 ebx, 17			; 00000011H
$LN168@format_flo:
  00036	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
  00039	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
$LN35@format_flo:

; 317  : 	}
; 318  : 
; 319  : 	/* Get the float value and calculate the exponent */
; 320  : 	fpval = va_arg_ffp(*argptr, flags);

  0003c	8b 45 1c	 mov	 eax, DWORD PTR _argptr$[ebp]
  0003f	83 00 08	 add	 DWORD PTR [eax], 8
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00047	dd 55 e0	 fst	 QWORD PTR _fpval$1$[ebp]

; 321  : 	exponent = get_exp((double)fpval);

  0004a	d9 ee		 fldz
  0004c	dd e1		 fucom	 ST(1)
  0004e	df e0		 fnstsw	 ax
  00050	f6 c4 44	 test	 ah, 68			; 00000044H
  00053	7a 04		 jp	 SHORT $LN44@format_flo
  00055	dd d9		 fstp	 ST(1)
  00057	eb 10		 jmp	 SHORT $LN43@format_flo
$LN44@format_flo:
  00059	d8 d9		 fcomp	 ST(1)
  0005b	df e0		 fnstsw	 ax
  0005d	f6 c4 41	 test	 ah, 65			; 00000041H
  00060	7b 02		 jnp	 SHORT $LN169@format_flo
  00062	d9 e0		 fchs
$LN169@format_flo:
  00064	e8 00 00 00 00	 call	 __CIlog10
$LN43@format_flo:
  00069	83 ec 08	 sub	 esp, 8
  0006c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0006f	e8 00 00 00 00	 call	 _floor
  00074	83 c4 08	 add	 esp, 8
  00077	e8 00 00 00 00	 call	 __ftol2_sse

; 322  : 	sign = fpval < 0 ? -1 : 1;

  0007c	dd 45 e0	 fld	 QWORD PTR _fpval$1$[ebp]
  0007f	8b f0		 mov	 esi, eax
  00081	d9 ee		 fldz
  00083	d8 d9		 fcomp	 ST(1)
  00085	89 75 ec	 mov	 DWORD PTR _exponent$1$[ebp], esi
  00088	df e0		 fnstsw	 ax
  0008a	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
  00091	f6 c4 41	 test	 ah, 65			; 00000041H
  00094	74 07		 je	 SHORT $LN47@format_flo
  00096	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1
$LN47@format_flo:

; 323  : 
; 324  : 	switch (chr)

  0009d	8b 45 08	 mov	 eax, DWORD PTR _chr$[ebp]
  000a0	8b 7d 14	 mov	 edi, DWORD PTR _string$[ebp]
  000a3	0f be c0	 movsx	 eax, al
  000a6	83 c0 bf	 add	 eax, -65		; ffffffbfH
  000a9	83 f8 26	 cmp	 eax, 38			; 00000026H
  000ac	0f 87 57 02 00
	00		 ja	 $LN102@format_flo
  000b2	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN84@format_flo[eax]
  000b9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN173@format_flo[eax*4]
$LN32@format_flo:

; 325  : 	{
; 326  : 	case ('G'):
; 327  : 		digits = digits_u;

  000c0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN31@format_flo:

; 328  : 	case ('g'):
; 329  : 		if (precision > 0) precision--;

  000c7	85 db		 test	 ebx, ebx
  000c9	7e 07		 jle	 SHORT $LN30@format_flo
  000cb	4b		 dec	 ebx
  000cc	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
  000cf	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
$LN30@format_flo:

; 330  : 		if (exponent < -4 || exponent >= precision) goto case_e;

  000d2	83 fe fc	 cmp	 esi, -4			; fffffffcH
  000d5	0f 8c bb 00 00
	00		 jl	 $case_e$174
  000db	3b f3		 cmp	 esi, ebx
  000dd	0f 8d b3 00 00
	00		 jge	 $case_e$174

; 331  : 
; 332  : 		/* Shift the decimal point and round */
; 333  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  000e3	dd d8		 fstp	 ST(0)
  000e5	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  000e8	dd 5d d0	 fstp	 QWORD PTR tv566[ebp]
  000eb	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  000f1	dd 45 d0	 fld	 QWORD PTR tv566[ebp]
  000f4	e8 00 00 00 00	 call	 __CIpow
  000f9	db 45 f4	 fild	 DWORD PTR _sign$[ebp]
  000fc	83 ec 08	 sub	 esp, 8
  000ff	dd 5d d0	 fstp	 QWORD PTR tv559[ebp]
  00102	dd 45 d0	 fld	 QWORD PTR tv559[ebp]
  00105	dc 4d e0	 fmul	 QWORD PTR _fpval$1$[ebp]
  00108	de c9		 fmulp	 ST(1), ST(0)
  0010a	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00110	dd 1c 24	 fstp	 QWORD PTR [esp]
  00113	e8 00 00 00 00	 call	 _floor
  00118	83 c4 08	 add	 esp, 8
  0011b	dd 55 f0	 fst	 QWORD PTR _fpval2$1$[ebp]

; 334  : 
; 335  : 		/* Skip trailing zeroes */
; 336  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  0011e	85 db		 test	 ebx, ebx
  00120	0f 84 22 02 00
	00		 je	 $LN170@format_flo
  00126	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  0012c	eb 02		 jmp	 SHORT $LN27@format_flo
$LN137@format_flo:
  0012e	d9 c9		 fxch	 ST(1)
$LN27@format_flo:
  00130	d9 c1		 fld	 ST(1)
  00132	33 c9		 xor	 ecx, ecx
  00134	d8 d1		 fcom	 ST(1)
  00136	89 4d 10	 mov	 DWORD PTR tv733[ebp], ecx
  00139	df e0		 fnstsw	 ax
  0013b	33 f6		 xor	 esi, esi
  0013d	f6 c4 01	 test	 ah, 1
  00140	75 16		 jne	 SHORT $LN85@format_flo
  00142	d8 e1		 fsub	 ST(0), ST(1)
  00144	d8 d1		 fcom	 ST(1)
  00146	df e0		 fnstsw	 ax
  00148	f6 c4 05	 test	 ah, 5
  0014b	7a 0b		 jp	 SHORT $LN85@format_flo
  0014d	03 f1		 add	 esi, ecx
  0014f	81 d1 00 00 00
	80		 adc	 ecx, -2147483648	; 80000000H
  00155	89 4d 10	 mov	 DWORD PTR tv733[ebp], ecx
$LN85@format_flo:
  00158	e8 00 00 00 00	 call	 __ftol2
  0015d	03 c6		 add	 eax, esi
  0015f	6a 00		 push	 0
  00161	13 55 10	 adc	 edx, DWORD PTR tv733[ebp]
  00164	6a 0a		 push	 10			; 0000000aH
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 __aullrem
  0016d	0b c2		 or	 eax, edx
  0016f	0f 85 d1 01 00
	00		 jne	 $LN133@format_flo

; 337  : 		{
; 338  : 			precision--;
; 339  : 			fpval2 /= 10;

  00175	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0017b	4b		 dec	 ebx
  0017c	de fa		 fdivp	 ST(2), ST(0)
  0017e	d9 c9		 fxch	 ST(1)
  00180	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
  00183	dd 55 f0	 fst	 QWORD PTR _fpval2$1$[ebp]
  00186	75 a6		 jne	 SHORT $LN137@format_flo
  00188	dd d8		 fstp	 ST(0)

; 340  : 		}
; 341  : 		break;

  0018a	e9 b9 01 00 00	 jmp	 $LN170@format_flo
$LN25@format_flo:

; 342  : 
; 343  : 	case ('E'):
; 344  : 		digits = digits_u;

  0018f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$case_e$174:

; 345  : 	case ('e'):
; 346  : case_e:
; 347  : 		/* Shift the decimal point and round */
; 348  : 		fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  00196	db 45 f4	 fild	 DWORD PTR _sign$[ebp]
  00199	8b c3		 mov	 eax, ebx
  0019b	2b c6		 sub	 eax, esi
  0019d	89 45 10	 mov	 DWORD PTR tv487[ebp], eax
  001a0	dd 5d d0	 fstp	 QWORD PTR tv493[ebp]
  001a3	dc 4d d0	 fmul	 QWORD PTR tv493[ebp]
  001a6	dd 5d d0	 fstp	 QWORD PTR tv81[ebp]
  001a9	db 45 10	 fild	 DWORD PTR tv487[ebp]
  001ac	dd 5d d8	 fstp	 QWORD PTR tv486[ebp]
  001af	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001b5	dd 45 d8	 fld	 QWORD PTR tv486[ebp]
  001b8	e8 00 00 00 00	 call	 __CIpow
  001bd	dc 4d d0	 fmul	 QWORD PTR tv81[ebp]
  001c0	83 ec 08	 sub	 esp, 8
  001c3	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  001c9	dd 1c 24	 fstp	 QWORD PTR [esp]
  001cc	e8 00 00 00 00	 call	 _floor
  001d1	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]

; 349  : 
; 350  : 		/* Compensate for changed exponent through rounding */
; 351  : 		if (fpval2 >= (unsigned __int64)pow(10., precision + 1))

  001d4	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  001d7	83 c4 08	 add	 esp, 8
  001da	89 45 10	 mov	 DWORD PTR tv472[ebp], eax
  001dd	db 45 10	 fild	 DWORD PTR tv472[ebp]
  001e0	dd 5d d8	 fstp	 QWORD PTR tv471[ebp]
  001e3	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001e9	dd 45 d8	 fld	 QWORD PTR tv471[ebp]
  001ec	e8 00 00 00 00	 call	 __CIpow
  001f1	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  001f7	33 c9		 xor	 ecx, ecx
  001f9	d8 d1		 fcom	 ST(1)
  001fb	89 4d 10	 mov	 DWORD PTR tv76[ebp], ecx
  001fe	df e0		 fnstsw	 ax
  00200	33 d2		 xor	 edx, edx
  00202	89 55 08	 mov	 DWORD PTR tv79[ebp], edx
  00205	f6 c4 41	 test	 ah, 65			; 00000041H
  00208	7a 1b		 jp	 SHORT $LN116@format_flo
  0020a	dc e9		 fsub	 ST(1), ST(0)
  0020c	d8 d9		 fcomp	 ST(1)
  0020e	df e0		 fnstsw	 ax
  00210	f6 c4 41	 test	 ah, 65			; 00000041H
  00213	75 12		 jne	 SHORT $LN86@format_flo
  00215	03 c9		 add	 ecx, ecx
  00217	89 4d 10	 mov	 DWORD PTR tv76[ebp], ecx
  0021a	81 d2 00 00 00
	80		 adc	 edx, -2147483648	; 80000000H
  00220	89 55 08	 mov	 DWORD PTR tv79[ebp], edx
  00223	eb 02		 jmp	 SHORT $LN86@format_flo
$LN116@format_flo:
  00225	dd d8		 fstp	 ST(0)
$LN86@format_flo:
  00227	e8 00 00 00 00	 call	 __ftol2
  0022c	03 45 10	 add	 eax, DWORD PTR tv76[ebp]
  0022f	89 45 d8	 mov	 DWORD PTR tv425[ebp], eax
  00232	13 55 08	 adc	 edx, DWORD PTR tv79[ebp]
  00235	8b c2		 mov	 eax, edx
  00237	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0023d	89 55 dc	 mov	 DWORD PTR tv425[ebp+4], edx
  00240	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00245	df 6d d8	 fild	 QWORD PTR tv425[ebp]
  00248	89 45 dc	 mov	 DWORD PTR tv421[ebp+4], eax
  0024b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv421[ebp], 0
  00252	df 6d d8	 fild	 QWORD PTR tv421[ebp]
  00255	d9 e0		 fchs
  00257	de c1		 faddp	 ST(1), ST(0)
  00259	dd 5d d8	 fstp	 QWORD PTR tv393[ebp]
  0025c	dd 45 d8	 fld	 QWORD PTR tv393[ebp]
  0025f	dc 5d f0	 fcomp	 QWORD PTR _fpval2$1$[ebp]
  00262	df e0		 fnstsw	 ax
  00264	f6 c4 41	 test	 ah, 65			; 00000041H
  00267	7a 39		 jp	 SHORT $LN23@format_flo

; 352  : 		{
; 353  : 			exponent++;

  00269	46		 inc	 esi

; 354  : 			fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  0026a	8b c3		 mov	 eax, ebx
  0026c	2b c6		 sub	 eax, esi
  0026e	89 75 ec	 mov	 DWORD PTR _exponent$1$[ebp], esi
  00271	89 45 10	 mov	 DWORD PTR tv386[ebp], eax
  00274	db 45 10	 fild	 DWORD PTR tv386[ebp]
  00277	dd 5d d8	 fstp	 QWORD PTR tv385[ebp]
  0027a	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00280	dd 45 d8	 fld	 QWORD PTR tv385[ebp]
  00283	e8 00 00 00 00	 call	 __CIpow
  00288	dc 4d d0	 fmul	 QWORD PTR tv81[ebp]
  0028b	83 ec 08	 sub	 esp, 8
  0028e	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00294	dd 1c 24	 fstp	 QWORD PTR [esp]
  00297	e8 00 00 00 00	 call	 _floor
  0029c	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]
  0029f	83 c4 08	 add	 esp, 8
$LN23@format_flo:

; 355  : 		}
; 356  : 
; 357  : 		val32 = exponent >= 0 ? exponent : -exponent;

  002a2	8b c6		 mov	 eax, esi
  002a4	99		 cdq
  002a5	8b d8		 mov	 ebx, eax

; 358  : 
; 359  : 		// FIXME: handle length of exponent field:
; 360  : 		// http://msdn.microsoft.com/de-de/library/0fatw238%28VS.80%29.aspx
; 361  : 		num_digits = 3;
; 362  : 		while (num_digits--)

  002a7	b8 03 00 00 00	 mov	 eax, 3
  002ac	33 da		 xor	 ebx, edx
  002ae	2b da		 sub	 ebx, edx
$LL22@format_flo:
  002b0	48		 dec	 eax

; 363  : 		{
; 364  : 			*--(*string) = digits[val32 % 10];

  002b1	ff 0f		 dec	 DWORD PTR [edi]
  002b3	89 45 10	 mov	 DWORD PTR _num_digits$1$[ebp], eax
  002b6	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  002bb	8b 37		 mov	 esi, DWORD PTR [edi]
  002bd	f7 eb		 imul	 ebx
  002bf	c1 fa 02	 sar	 edx, 2
  002c2	8b ca		 mov	 ecx, edx
  002c4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002c7	03 ca		 add	 ecx, edx
  002c9	8b 55 f8	 mov	 edx, DWORD PTR _digits$1$[ebp]
  002cc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  002cf	03 c0		 add	 eax, eax
  002d1	2b d8		 sub	 ebx, eax
  002d3	8a 04 13	 mov	 al, BYTE PTR [ebx+edx]

; 365  : 			val32 /= 10;

  002d6	8b d9		 mov	 ebx, ecx
  002d8	88 06		 mov	 BYTE PTR [esi], al
  002da	8b 45 10	 mov	 eax, DWORD PTR _num_digits$1$[ebp]
  002dd	85 c0		 test	 eax, eax
  002df	75 cf		 jne	 SHORT $LL22@format_flo

; 366  : 		}
; 367  : 
; 368  : 		/* Sign for the exponent */
; 369  : 		*--(*string) = (exponent >= 0 ? ('+') : ('-'));

  002e1	ff 0f		 dec	 DWORD PTR [edi]
  002e3	39 45 ec	 cmp	 DWORD PTR _exponent$1$[ebp], eax
  002e6	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 370  : 
; 371  : 		/* Add 'e' or 'E' separator */
; 372  : 		*--(*string) = digits[0xe];
; 373  : 		break;

  002e8	8b 5d fc	 mov	 ebx, DWORD PTR _precision$1$[ebp]
  002eb	0f 9c c0	 setl	 al
  002ee	8d 04 45 2b 00
	00 00		 lea	 eax, DWORD PTR [eax*2+43]
  002f5	88 01		 mov	 BYTE PTR [ecx], al
  002f7	ff 0f		 dec	 DWORD PTR [edi]
  002f9	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002fb	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  002fe	88 01		 mov	 BYTE PTR [ecx], al
  00300	eb 48		 jmp	 SHORT $LN33@format_flo
$LN103@format_flo:

; 374  : 
; 375  : 	case ('A'):
; 376  : 		digits = digits_u;

  00302	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN102@format_flo:
  00309	dd d8		 fstp	 ST(0)

; 377  : 	case ('a'):
; 378  : 		//            base = 16;
; 379  : 		// FIXME: TODO
; 380  : 
; 381  : 	case ('f'):
; 382  : 	default:
; 383  : 		/* Shift the decimal point and round */
; 384  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  0030b	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  0030e	dd 5d d0	 fstp	 QWORD PTR tv358[ebp]
  00311	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00317	dd 45 d0	 fld	 QWORD PTR tv358[ebp]
  0031a	e8 00 00 00 00	 call	 __CIpow
  0031f	db 45 f4	 fild	 DWORD PTR _sign$[ebp]
  00322	83 ec 08	 sub	 esp, 8
  00325	dd 5d d0	 fstp	 QWORD PTR tv351[ebp]
  00328	dd 45 d0	 fld	 QWORD PTR tv351[ebp]
  0032b	dc 4d e0	 fmul	 QWORD PTR _fpval$1$[ebp]
  0032e	de c9		 fmulp	 ST(1), ST(0)
  00330	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00336	dd 1c 24	 fstp	 QWORD PTR [esp]
  00339	e8 00 00 00 00	 call	 _floor
  0033e	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]
  00341	83 c4 08	 add	 esp, 8
  00344	eb 04		 jmp	 SHORT $LN33@format_flo
$LN133@format_flo:
  00346	dd d9		 fstp	 ST(1)
$LN170@format_flo:
  00348	dd d8		 fstp	 ST(0)
$LN33@format_flo:

; 385  : 		break;
; 386  : 	}
; 387  : 
; 388  : 	/* Handle sign */
; 389  : 	if (fpval < 0)

  0034a	dd 45 e0	 fld	 QWORD PTR _fpval$1$[ebp]
  0034d	d9 ee		 fldz
  0034f	d8 d9		 fcomp	 ST(1)
  00351	df e0		 fnstsw	 ax
  00353	f6 c4 41	 test	 ah, 65			; 00000041H
  00356	75 0b		 jne	 SHORT $LN18@format_flo

; 390  : 	{
; 391  : 		*prefix = ("-");

  00358	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  0035b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2781
  00361	eb 1f		 jmp	 SHORT $LN14@format_flo
$LN18@format_flo:

; 392  : 	}
; 393  : 	else if (flags & FLAG_FORCE_SIGN)

  00363	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00366	a8 02		 test	 al, 2
  00368	74 0b		 je	 SHORT $LN16@format_flo

; 394  : 		*prefix = ("+");

  0036a	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  0036d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2784
  00373	eb 0d		 jmp	 SHORT $LN14@format_flo
$LN16@format_flo:

; 395  : 	else if (flags & FLAG_FORCE_SIGNSP)

  00375	a8 04		 test	 al, 4
  00377	74 09		 je	 SHORT $LN14@format_flo

; 396  : 		*prefix = (" ");

  00379	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  0037c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2787
$LN14@format_flo:

; 397  : 
; 398  : 	/* Handle special cases first */
; 399  : 	if (_isnan((double)fpval))

  00382	83 ec 08	 sub	 esp, 8
  00385	dd 1c 24	 fstp	 QWORD PTR [esp]
  00388	e8 00 00 00 00	 call	 __isnan
  0038d	83 c4 08	 add	 esp, 8
  00390	85 c0		 test	 eax, eax
  00392	74 21		 je	 SHORT $LN13@format_flo

; 400  : 	{
; 401  : 		(*string) -= sizeof(_nan) / sizeof(char) - 1;

  00394	83 07 fb	 add	 DWORD PTR [edi], -5	; fffffffbH

; 402  : 		strcpy((*string), _nan);

  00397	b9 00 00 00 00	 mov	 ecx, OFFSET ?_nan@?1??format_float@@9@9
  0039c	8b 17		 mov	 edx, DWORD PTR [edi]
  0039e	8b ff		 npad	 2
$LL48@format_flo:
  003a0	8a 01		 mov	 al, BYTE PTR [ecx]
  003a2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  003a5	88 02		 mov	 BYTE PTR [edx], al
  003a7	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003aa	84 c0		 test	 al, al
  003ac	75 f2		 jne	 SHORT $LL48@format_flo

; 403  : 		fpval2 = 1;

  003ae	d9 e8		 fld1
  003b0	e9 b2 00 00 00	 jmp	 $LN171@format_flo
$LN13@format_flo:

; 404  : 	}
; 405  : 	else if (!_finite((double)fpval))

  003b5	dd 45 e0	 fld	 QWORD PTR _fpval$1$[ebp]
  003b8	83 ec 08	 sub	 esp, 8
  003bb	dd 1c 24	 fstp	 QWORD PTR [esp]
  003be	e8 00 00 00 00	 call	 __finite
  003c3	83 c4 08	 add	 esp, 8
  003c6	85 c0		 test	 eax, eax
  003c8	75 1f		 jne	 SHORT $LN54@format_flo

; 406  : 	{
; 407  : 		(*string) -= sizeof(_infinity) / sizeof(char) - 1;

  003ca	83 07 fc	 add	 DWORD PTR [edi], -4	; fffffffcH

; 408  : 		strcpy((*string), _infinity);

  003cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?_infinity@?1??format_float@@9@9
  003d2	8b 17		 mov	 edx, DWORD PTR [edi]
$LL49@format_flo:
  003d4	8a 01		 mov	 al, BYTE PTR [ecx]
  003d6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  003d9	88 02		 mov	 BYTE PTR [edx], al
  003db	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003de	84 c0		 test	 al, al
  003e0	75 f2		 jne	 SHORT $LL49@format_flo

; 409  : 		fpval2 = 1;

  003e2	d9 e8		 fld1

; 410  : 	}
; 411  : 	else

  003e4	e9 7e 00 00 00	 jmp	 $LN171@format_flo
$LN54@format_flo:

; 412  : 	{
; 413  : 		/* Zero padding */
; 414  : 		while (padding-- > 0) *--(*string) = ('0');

  003e9	8b 4d e8	 mov	 ecx, DWORD PTR _padding$1$[ebp]
  003ec	85 c9		 test	 ecx, ecx
  003ee	7e 0c		 jle	 SHORT $LN60@format_flo
$LL9@format_flo:
  003f0	ff 0f		 dec	 DWORD PTR [edi]
  003f2	49		 dec	 ecx
  003f3	8b 07		 mov	 eax, DWORD PTR [edi]
  003f5	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  003f8	85 c9		 test	 ecx, ecx
  003fa	7f f4		 jg	 SHORT $LL9@format_flo
$LN60@format_flo:

; 415  : 
; 416  : 		/* Digits after the decimal point */
; 417  : 		num_digits = precision;

  003fc	89 5d 10	 mov	 DWORD PTR _num_digits$2$[ebp], ebx

; 418  : 		while (num_digits-- > 0)

  003ff	85 db		 test	 ebx, ebx
  00401	7e 6b		 jle	 SHORT $LN82@format_flo
  00403	dd 45 f0	 fld	 QWORD PTR _fpval2$1$[ebp]
$LN7@format_flo:

; 419  : 		{
; 420  : 			*--(*string) = digits[(unsigned __int64)fpval2 % 10];

  00406	ff 0f		 dec	 DWORD PTR [edi]
  00408	d9 c0		 fld	 ST(0)
  0040a	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  00410	33 c9		 xor	 ecx, ecx
  00412	d8 d1		 fcom	 ST(1)
  00414	89 4d 10	 mov	 DWORD PTR tv130[ebp], ecx
  00417	df e0		 fnstsw	 ax
  00419	4b		 dec	 ebx
  0041a	33 f6		 xor	 esi, esi
  0041c	f6 c4 41	 test	 ah, 65			; 00000041H
  0041f	7a 18		 jp	 SHORT $LN149@format_flo
  00421	dc e9		 fsub	 ST(1), ST(0)
  00423	d8 d9		 fcomp	 ST(1)
  00425	df e0		 fnstsw	 ax
  00427	f6 c4 41	 test	 ah, 65			; 00000041H
  0042a	75 0f		 jne	 SHORT $LN87@format_flo
  0042c	03 f1		 add	 esi, ecx
  0042e	81 d1 00 00 00
	80		 adc	 ecx, -2147483648	; 80000000H
  00434	89 4d 10	 mov	 DWORD PTR tv130[ebp], ecx
  00437	eb 02		 jmp	 SHORT $LN87@format_flo
$LN149@format_flo:
  00439	dd d8		 fstp	 ST(0)
$LN87@format_flo:
  0043b	e8 00 00 00 00	 call	 __ftol2
  00440	03 c6		 add	 eax, esi
  00442	6a 00		 push	 0
  00444	13 55 10	 adc	 edx, DWORD PTR tv130[ebp]
  00447	6a 0a		 push	 10			; 0000000aH
  00449	52		 push	 edx
  0044a	50		 push	 eax
  0044b	e8 00 00 00 00	 call	 __aullrem
  00450	8b 4d f8	 mov	 ecx, DWORD PTR _digits$1$[ebp]

; 421  : 			fpval2 /= base;

  00453	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4024000000000000
  00459	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0045c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0045e	88 01		 mov	 BYTE PTR [ecx], al
  00460	85 db		 test	 ebx, ebx
  00462	7f a2		 jg	 SHORT $LN7@format_flo
  00464	8b 5d fc	 mov	 ebx, DWORD PTR _precision$1$[ebp]
$LN171@format_flo:
  00467	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]

; 422  : 		}
; 423  : 	}
; 424  : 
; 425  : 	if (precision > 0 || flags & FLAG_SPECIAL)

  0046a	85 db		 test	 ebx, ebx
  0046c	7f 06		 jg	 SHORT $LN4@format_flo
$LN82@format_flo:
  0046e	f6 45 0c 10	 test	 BYTE PTR _flags$[ebp], 16 ; 00000010H
  00472	74 07		 je	 SHORT $LN83@format_flo
$LN4@format_flo:

; 426  : 		*--(*string) = ('.');

  00474	ff 0f		 dec	 DWORD PTR [edi]
  00476	8b 07		 mov	 eax, DWORD PTR [edi]
  00478	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
$LN83@format_flo:
  0047b	dd 45 f0	 fld	 QWORD PTR _fpval2$1$[ebp]
  0047e	33 f6		 xor	 esi, esi
  00480	d9 c0		 fld	 ST(0)
  00482	33 db		 xor	 ebx, ebx
  00484	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  0048a	d8 d1		 fcom	 ST(1)
  0048c	df e0		 fnstsw	 ax
  0048e	f6 c4 41	 test	 ah, 65			; 00000041H
  00491	7a 13		 jp	 SHORT $LN88@format_flo
  00493	dc e9		 fsub	 ST(1), ST(0)
  00495	d8 d1		 fcom	 ST(1)
  00497	df e0		 fnstsw	 ax
  00499	f6 c4 41	 test	 ah, 65			; 00000041H
  0049c	75 08		 jne	 SHORT $LN88@format_flo
  0049e	03 f3		 add	 esi, ebx
  004a0	81 d3 00 00 00
	80		 adc	 ebx, -2147483648	; 80000000H
$LN88@format_flo:
  004a6	d9 c9		 fxch	 ST(1)
  004a8	e8 00 00 00 00	 call	 __ftol2
  004ad	8b c8		 mov	 ecx, eax
  004af	03 ce		 add	 ecx, esi
  004b1	13 d3		 adc	 edx, ebx
$LN3@format_flo:

; 427  : 
; 428  : 	/* Digits before the decimal point */
; 429  : 	do
; 430  : 	{
; 431  : 		*--(*string) = digits[(unsigned __int64)fpval2 % base];

  004b3	ff 0f		 dec	 DWORD PTR [edi]
  004b5	8b 37		 mov	 esi, DWORD PTR [edi]
  004b7	6a 00		 push	 0
  004b9	6a 0a		 push	 10			; 0000000aH
  004bb	52		 push	 edx
  004bc	51		 push	 ecx
  004bd	e8 00 00 00 00	 call	 __aullrem

; 432  : 		fpval2 /= base;

  004c2	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000

; 433  : 	}
; 434  : 	while ((unsigned __int64)fpval2);

  004c8	33 db		 xor	 ebx, ebx
  004ca	de fa		 fdivp	 ST(2), ST(0)
  004cc	8b 4d f8	 mov	 ecx, DWORD PTR _digits$1$[ebp]
  004cf	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  004d2	88 06		 mov	 BYTE PTR [esi], al
  004d4	33 f6		 xor	 esi, esi
  004d6	d9 c1		 fld	 ST(1)
  004d8	d8 d1		 fcom	 ST(1)
  004da	df e0		 fnstsw	 ax
  004dc	f6 c4 01	 test	 ah, 1
  004df	75 13		 jne	 SHORT $LN89@format_flo
  004e1	d8 e1		 fsub	 ST(0), ST(1)
  004e3	d8 d1		 fcom	 ST(1)
  004e5	df e0		 fnstsw	 ax
  004e7	f6 c4 05	 test	 ah, 5
  004ea	7a 08		 jp	 SHORT $LN89@format_flo
  004ec	03 f3		 add	 esi, ebx
  004ee	81 d3 00 00 00
	80		 adc	 ebx, -2147483648	; 80000000H
$LN89@format_flo:
  004f4	e8 00 00 00 00	 call	 __ftol2
  004f9	8b c8		 mov	 ecx, eax
  004fb	03 ce		 add	 ecx, esi
  004fd	8b c1		 mov	 eax, ecx
  004ff	13 d3		 adc	 edx, ebx
  00501	0b c2		 or	 eax, edx
  00503	75 ae		 jne	 SHORT $LN3@format_flo
  00505	5f		 pop	 edi
  00506	dd d9		 fstp	 ST(1)
  00508	5e		 pop	 esi
  00509	dd d8		 fstp	 ST(0)
  0050b	5b		 pop	 ebx

; 435  : 
; 436  : }

  0050c	8b e5		 mov	 esp, ebp
  0050e	5d		 pop	 ebp
  0050f	c3		 ret	 0
$LN173@format_flo:
  00510	00 00 00 00	 DD	 $LN103@format_flo
  00514	00 00 00 00	 DD	 $LN25@format_flo
  00518	00 00 00 00	 DD	 $LN32@format_flo
  0051c	00 00 00 00	 DD	 $case_e$174
  00520	00 00 00 00	 DD	 $LN31@format_flo
  00524	00 00 00 00	 DD	 $LN102@format_flo
$LN84@format_flo:
  00528	00		 DB	 0
  00529	05		 DB	 5
  0052a	05		 DB	 5
  0052b	05		 DB	 5
  0052c	01		 DB	 1
  0052d	05		 DB	 5
  0052e	02		 DB	 2
  0052f	05		 DB	 5
  00530	05		 DB	 5
  00531	05		 DB	 5
  00532	05		 DB	 5
  00533	05		 DB	 5
  00534	05		 DB	 5
  00535	05		 DB	 5
  00536	05		 DB	 5
  00537	05		 DB	 5
  00538	05		 DB	 5
  00539	05		 DB	 5
  0053a	05		 DB	 5
  0053b	05		 DB	 5
  0053c	05		 DB	 5
  0053d	05		 DB	 5
  0053e	05		 DB	 5
  0053f	05		 DB	 5
  00540	05		 DB	 5
  00541	05		 DB	 5
  00542	05		 DB	 5
  00543	05		 DB	 5
  00544	05		 DB	 5
  00545	05		 DB	 5
  00546	05		 DB	 5
  00547	05		 DB	 5
  00548	05		 DB	 5
  00549	05		 DB	 5
  0054a	05		 DB	 5
  0054b	05		 DB	 5
  0054c	03		 DB	 3
  0054d	05		 DB	 5
  0054e	04		 DB	 4
_format_float ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutWString
_TEXT	SEGMENT
_oStream$ = 8						; size = 4
_oLen$ = 12						; size = 4
_iStream$ = 16						; size = 4
_iLen$ = 20						; size = 4
_StreamOutWString PROC					; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 277  : 	/* Vars */
; 278  : 	wchar_t Character;
; 279  : 	int bWritten = 0;
; 280  : 
; 281  : 	/* Iterate count */
; 282  : 	while (iLen--)

  00005	8b 75 14	 mov	 esi, DWORD PTR _iLen$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	85 f6		 test	 esi, esi
  0000d	74 22		 je	 SHORT $LN8@StreamOutW
  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _iStream$[ebp]
$LL3@StreamOutW:

; 283  : 	{
; 284  : 		/* Get char */
; 285  : 		Character = *iStream++;

  00012	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00015	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]

; 286  : 
; 287  : 		/* Just write it, this function will do neccessary conversions */
; 288  : 		if (StreamOutCharacter(oStream, oLen, Character) == 0)

  00018	50		 push	 eax
  00019	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  0001c	4e		 dec	 esi
  0001d	ff 75 08	 push	 DWORD PTR _oStream$[ebp]
  00020	e8 00 00 00 00	 call	 _StreamOutCharacter
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	85 c0		 test	 eax, eax
  0002a	74 0c		 je	 SHORT $LN7@StreamOutW

; 290  : 
; 291  : 		/* Inc */
; 292  : 		bWritten++;

  0002c	47		 inc	 edi
  0002d	85 f6		 test	 esi, esi
  0002f	75 e1		 jne	 SHORT $LL3@StreamOutW
$LN8@StreamOutW:

; 293  : 	}
; 294  : 
; 295  : 	/* Num of chars copied */
; 296  : 	return bWritten;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 297  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN7@StreamOutW:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 289  : 			return -1;

  0003a	83 c8 ff	 or	 eax, -1
  0003d	5b		 pop	 ebx

; 297  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_StreamOutWString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutString
_TEXT	SEGMENT
_iLen$2$ = 8						; size = 4
_oStream$ = 8						; size = 4
_oLen$ = 12						; size = 4
_iStream$ = 16						; size = 4
_iLen$ = 20						; size = 4
_StreamOutString PROC					; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 	char Character;
; 191  : 	int bWritten = 0;
; 192  : 
; 193  : 	/* Sanity */
; 194  : 	if (oStream)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _oStream$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 40		 je	 SHORT $LN22@StreamOutS

; 195  : 	{
; 196  : 		while (iLen) {

  0000f	8b 75 14	 mov	 esi, DWORD PTR _iLen$[ebp]
  00012	85 f6		 test	 esi, esi
  00014	0f 84 e7 00 00
	00		 je	 $LN12@StreamOutS
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _iStream$[ebp]
  0001d	8d 49 00	 npad	 3
$LL17@StreamOutS:

; 197  : 			Character = *iStream++;

  00020	8a 07		 mov	 al, BYTE PTR [edi]
  00022	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]

; 198  : 			
; 199  : 			/* Write the character to the stream */
; 200  : 			if (StreamOutCharacter(oStream, oLen, (uint32_t)Character) == 0)

  00025	0f be c0	 movsx	 eax, al
  00028	50		 push	 eax
  00029	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _StreamOutCharacter
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN24@StreamOutS

; 202  : 
; 203  : 			/* Inc */
; 204  : 			bWritten++;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _oStream$[ebp]
  0003c	43		 inc	 ebx

; 205  : 			iLen--;

  0003d	4e		 dec	 esi
  0003e	75 e0		 jne	 SHORT $LL17@StreamOutS

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : 
; 270  : 	/* Num of bytes copied */
; 271  : 	return bWritten;

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	8b c3		 mov	 eax, ebx
  00044	5b		 pop	 ebx

; 272  : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN24@StreamOutS:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 201  : 				return -1;

  00049	83 c8 ff	 or	 eax, -1
  0004c	5b		 pop	 ebx

; 272  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN22@StreamOutS:

; 206  : 		}
; 207  : 	}
; 208  : 	else
; 209  : 	{
; 210  : 		/* Iterate chars */
; 211  : 		while (iLen)

  0004f	8b 45 14	 mov	 eax, DWORD PTR _iLen$[ebp]
  00052	89 45 08	 mov	 DWORD PTR _iLen$2$[ebp], eax
  00055	85 c0		 test	 eax, eax
  00057	0f 84 a4 00 00
	00		 je	 $LN12@StreamOutS
  0005d	8b 75 10	 mov	 esi, DWORD PTR _iStream$[ebp]
$LL13@StreamOutS:

; 212  : 		{
; 213  : 			Character = *iStream++;

  00060	8a 0e		 mov	 cl, BYTE PTR [esi]
  00062	46		 inc	 esi

; 214  : 			
; 215  : 			/* Sanity */
; 216  : 			if (IsUTF8(Character))

  00063	8a c1		 mov	 al, cl
  00065	24 c0		 and	 al, 192			; 000000c0H
  00067	3c 80		 cmp	 al, 128			; 00000080H

; 217  : 			{
; 218  : 				/* Build UTF-8 */
; 219  : 				uint32_t uChar = (uint32_t)Character;

  00069	0f be c1	 movsx	 eax, cl
  0006c	75 6d		 jne	 SHORT $LN11@StreamOutS

; 220  : 				uint32_t Size = 0;
; 221  : 
; 222  : 				/* Iterate */
; 223  : 				while (*iStream && IsUTF8(*iStream))

  0006e	8a 16		 mov	 dl, BYTE PTR [esi]
  00070	33 ff		 xor	 edi, edi
  00072	84 d2		 test	 dl, dl
  00074	74 1a		 je	 SHORT $LN36@StreamOutS
$LL10@StreamOutS:
  00076	8a ca		 mov	 cl, dl
  00078	80 e1 c0	 and	 cl, 192			; 000000c0H
  0007b	80 f9 80	 cmp	 cl, 128			; 00000080H
  0007e	75 10		 jne	 SHORT $LN36@StreamOutS

; 224  : 				{
; 225  : 					/* Move */
; 226  : 					uChar <<= 6;
; 227  : 
; 228  : 					/* Add */
; 229  : 					uChar += (unsigned char)*iStream;
; 230  : 
; 231  : 					/* Inc */
; 232  : 					Size++;
; 233  : 					iStream++;

  00080	46		 inc	 esi
  00081	c1 e0 06	 shl	 eax, 6
  00084	0f b6 ca	 movzx	 ecx, dl
  00087	47		 inc	 edi
  00088	03 c1		 add	 eax, ecx
  0008a	8a 16		 mov	 dl, BYTE PTR [esi]
  0008c	84 d2		 test	 dl, dl
  0008e	75 e6		 jne	 SHORT $LL10@StreamOutS
$LN36@StreamOutS:

; 234  : 				}
; 235  : 
; 236  : 				/* Move */
; 237  : 				uChar <<= 6;

  00090	c1 e0 06	 shl	 eax, 6

; 238  : 
; 239  : 				/* Add the last byte */
; 240  : 				if (Size == 1)

  00093	83 ff 01	 cmp	 edi, 1
  00096	75 08		 jne	 SHORT $LN8@StreamOutS

; 241  : 					uChar |= (((unsigned char)*iStream) & 0x1F);

  00098	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  0009b	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0009e	eb 18		 jmp	 SHORT $LN37@StreamOutS
$LN8@StreamOutS:

; 242  : 				else if (Size == 2)

  000a0	83 ff 02	 cmp	 edi, 2
  000a3	75 08		 jne	 SHORT $LN6@StreamOutS

; 243  : 					uChar |= (((unsigned char)*iStream) & 0xF);

  000a5	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  000a8	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000ab	eb 0b		 jmp	 SHORT $LN37@StreamOutS
$LN6@StreamOutS:

; 244  : 				else if (Size == 3)

  000ad	83 ff 03	 cmp	 edi, 3
  000b0	75 08		 jne	 SHORT $LN4@StreamOutS

; 245  : 					uChar |= (((unsigned char)*iStream) & 0x7);

  000b2	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  000b5	83 e1 07	 and	 ecx, 7
$LN37@StreamOutS:
  000b8	0b c1		 or	 eax, ecx
$LN4@StreamOutS:

; 246  : 				Size++;
; 247  : 
; 248  : 				/* Write the character to the stream */
; 249  : 				if (StreamOutCharacter(oStream, oLen, uChar) == 0)

  000ba	50		 push	 eax
  000bb	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  000be	47		 inc	 edi
  000bf	6a 00		 push	 0
  000c1	e8 00 00 00 00	 call	 _StreamOutCharacter
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	85 c0		 test	 eax, eax
  000cb	0f 84 76 ff ff
	ff		 je	 $LN24@StreamOutS

; 250  : 					return -1;
; 251  : 
; 252  : 				/* Skip */
; 253  : 				bWritten += Size;
; 254  : 				iLen -= Size;

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _iLen$2$[ebp]
  000d4	03 df		 add	 ebx, edi
  000d6	2b cf		 sub	 ecx, edi

; 255  : 				iStream++;

  000d8	46		 inc	 esi

; 256  : 			}
; 257  : 			else

  000d9	eb 1b		 jmp	 SHORT $LN38@StreamOutS
$LN11@StreamOutS:

; 258  : 			{
; 259  : 				/* Write the character to the stream */
; 260  : 				if (StreamOutCharacter(oStream, oLen, (uint32_t)Character) == 0)

  000db	50		 push	 eax
  000dc	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  000df	6a 00		 push	 0
  000e1	e8 00 00 00 00	 call	 _StreamOutCharacter
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	85 c0		 test	 eax, eax
  000eb	0f 84 56 ff ff
	ff		 je	 $LN24@StreamOutS

; 261  : 					return -1;
; 262  : 
; 263  : 				/* Inc */
; 264  : 				bWritten++;
; 265  : 				iLen--;

  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _iLen$2$[ebp]
  000f4	43		 inc	 ebx
  000f5	49		 dec	 ecx
$LN38@StreamOutS:
  000f6	89 4d 08	 mov	 DWORD PTR _iLen$2$[ebp], ecx
  000f9	85 c9		 test	 ecx, ecx
  000fb	0f 85 5f ff ff
	ff		 jne	 $LL13@StreamOutS
$LN12@StreamOutS:
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : 
; 270  : 	/* Num of bytes copied */
; 271  : 	return bWritten;

  00103	8b c3		 mov	 eax, ebx
  00105	5b		 pop	 ebx

; 272  : }

  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_StreamOutString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutCharacter
_TEXT	SEGMENT
_oStream$ = 8						; size = 4
_uLen$1 = 12						; size = 4
_oLen$ = 12						; size = 4
_Character$ = 16					; size = 4
_StreamOutCharacter PROC				; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 159  : 	/* Sanity */
; 160  : 	if (*oLen == 0)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _oLen$[ebp]
  00007	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0000a	75 05		 jne	 SHORT $LN3@StreamOutC

; 161  : 		return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	5b		 pop	 ebx

; 181  : #else
; 182  : 		return VideoPutChar(Character);
; 183  : #endif
; 184  : 	}
; 185  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN3@StreamOutC:
  00011	57		 push	 edi

; 162  : 
; 163  : 	/* Do we have a stream to write to? */
; 164  : 	if (oStream) {

  00012	8b 7d 08	 mov	 edi, DWORD PTR _oStream$[ebp]
  00015	85 ff		 test	 edi, edi
  00017	74 26		 je	 SHORT $LN2@StreamOutC

; 165  : 		/* We cannot just copy an U32 character 
; 166  : 		 * to stream like this, we must encode it back */
; 167  : 		uint32_t uLen = 0;
; 168  : 		StreamCharacterToUtf8(Character, *oStream, &uLen);

  00019	8d 45 0c	 lea	 eax, DWORD PTR _uLen$1[ebp]
  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _uLen$1[ebp], 0
  00023	50		 push	 eax
  00024	ff 37		 push	 DWORD PTR [edi]
  00026	ff 75 10	 push	 DWORD PTR _Character$[ebp]
  00029	e8 00 00 00 00	 call	 _StreamCharacterToUtf8

; 169  : 		(*oStream) += uLen;

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _uLen$1[ebp]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	01 0f		 add	 DWORD PTR [edi], ecx

; 170  : 		*oLen -= uLen;

  00036	29 0b		 sub	 DWORD PTR [ebx], ecx

; 171  : 
; 172  : 		/* Done ! */
; 173  : 		return Character;

  00038	8b 45 10	 mov	 eax, DWORD PTR _Character$[ebp]
  0003b	5f		 pop	 edi
  0003c	5b		 pop	 ebx

; 181  : #else
; 182  : 		return VideoPutChar(Character);
; 183  : #endif
; 184  : 	}
; 185  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN2@StreamOutC:

; 174  : 	}
; 175  : 	else 
; 176  : 	{
; 177  : 		/* These routines need the 
; 178  : 		 * unicode-point */
; 179  : #ifndef LIBC_KERNEL
; 180  : 		return putchar(Character);

  0003f	ff 75 10	 push	 DWORD PTR _Character$[ebp]
  00042	e8 00 00 00 00	 call	 _putchar
  00047	83 c4 04	 add	 esp, 4
  0004a	5f		 pop	 edi
  0004b	5b		 pop	 ebx

; 181  : #else
; 182  : 		return VideoPutChar(Character);
; 183  : #endif
; 184  : 	}
; 185  : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_StreamOutCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamCharacterToUtf8
_TEXT	SEGMENT
_TmpBuffer$ = -12					; size = 10
_Character$ = 8						; size = 4
_oBuffer$ = 12						; size = 4
_Length$ = 16						; size = 4
_StreamCharacterToUtf8 PROC				; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 77   : 	/* Encode Buffer */
; 78   : 	char TmpBuffer[10] = { 0 };
; 79   : 	char* BufPtr = &TmpBuffer[0];
; 80   : 
; 81   : 	uint32_t NumBytes = 0;
; 82   : 	uint32_t Error = 0;
; 83   : 
; 84   : 	if (Character <= 0x7F)  /* 0XXX XXXX one byte */

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _Character$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 45 f4 00	 mov	 BYTE PTR _TmpBuffer$[ebp], 0
  00013	33 ff		 xor	 edi, edi
  00015	89 45 f5	 mov	 DWORD PTR _TmpBuffer$[ebp+1], eax
  00018	89 45 f9	 mov	 DWORD PTR _TmpBuffer$[ebp+5], eax
  0001b	88 45 fd	 mov	 BYTE PTR _TmpBuffer$[ebp+9], al
  0001e	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00021	77 0b		 ja	 SHORT $LN18@StreamChar

; 85   : 	{
; 86   : 		TmpBuffer[0] = (char)(Character & 0xFF);

  00023	88 4d f4	 mov	 BYTE PTR _TmpBuffer$[ebp], cl

; 87   : 		NumBytes = 1;

  00026	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00029	e9 bc 00 00 00	 jmp	 $LN21@StreamChar
$LN18@StreamChar:

; 88   : 	}
; 89   : 	else if (Character <= 0x7FF)  /* 110X XXXX  two bytes */

  0002e	81 f9 ff 07 00
	00		 cmp	 ecx, 2047		; 000007ffH
  00034	77 1d		 ja	 SHORT $LN16@StreamChar

; 90   : 	{
; 91   : 		TmpBuffer[0] = (char)(0xC0 | (Character >> 6));

  00036	8b c1		 mov	 eax, ecx

; 92   : 		TmpBuffer[1] = (char)(0x80 | (Character & 0x3F));
; 93   : 		NumBytes = 2;

  00038	be 02 00 00 00	 mov	 esi, 2
  0003d	c1 e8 06	 shr	 eax, 6
  00040	80 e1 3f	 and	 cl, 63			; 0000003fH
  00043	0c c0		 or	 al, -64			; ffffffc0H
  00045	80 c9 80	 or	 cl, -128		; ffffff80H
  00048	88 45 f4	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  0004b	88 4d f5	 mov	 BYTE PTR _TmpBuffer$[ebp+1], cl
  0004e	e9 97 00 00 00	 jmp	 $LN21@StreamChar
$LN16@StreamChar:

; 94   : 	}
; 95   : 	else if (Character <= 0xFFFF)  /* 1110 XXXX  three bytes */

  00053	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00059	77 4f		 ja	 SHORT $LN14@StreamChar

; 96   : 	{
; 97   : 		TmpBuffer[0] = (char)(0xE0 | (Character >> 12));

  0005b	8b c1		 mov	 eax, ecx

; 98   : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 99   : 		TmpBuffer[2] = (char)(0x80 | (Character & 0x3F));
; 100  : 		NumBytes = 3;

  0005d	be 03 00 00 00	 mov	 esi, 3
  00062	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00065	0c e0		 or	 al, -32			; ffffffe0H
  00067	88 45 f4	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  0006a	8b c1		 mov	 eax, ecx
  0006c	c1 e8 06	 shr	 eax, 6
  0006f	24 3f		 and	 al, 63			; 0000003fH
  00071	0c 80		 or	 al, -128		; ffffff80H
  00073	88 45 f5	 mov	 BYTE PTR _TmpBuffer$[ebp+1], al
  00076	8a c1		 mov	 al, cl
  00078	24 3f		 and	 al, 63			; 0000003fH
  0007a	0c 80		 or	 al, -128		; ffffff80H
  0007c	88 45 f6	 mov	 BYTE PTR _TmpBuffer$[ebp+2], al

; 101  : 
; 102  : 		/* Sanity no special characters */
; 103  : 		if (Character == 0xFFFE || Character == 0xFFFF)

  0007f	81 f9 fe ff 00
	00		 cmp	 ecx, 65534		; 0000fffeH
  00085	74 08		 je	 SHORT $LN5@StreamChar
  00087	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0008d	75 5b		 jne	 SHORT $LN21@StreamChar
$LN5@StreamChar:

; 128  : 	{
; 129  : 		TmpBuffer[0] = (char)(0xFC | (Character >> 30));
; 130  : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 24) & 0x3F));
; 131  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 18) & 0x3F));
; 132  : 		TmpBuffer[3] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 133  : 		TmpBuffer[4] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 134  : 		TmpBuffer[5] = (char)(0x80 | (Character & 0x3F));
; 135  : 		NumBytes = 6;
; 136  : 		Error = 1;
; 137  : 	}
; 138  : 	else
; 139  : 		Error = 1;

  0008f	bf 01 00 00 00	 mov	 edi, 1
$LN3@StreamChar:

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00094	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  00097	89 30		 mov	 DWORD PTR [eax], esi

; 147  : 
; 148  : 	/* Sanity */
; 149  : 	if (Error)

  00099	85 ff		 test	 edi, edi
  0009b	0f 84 98 00 00
	00		 je	 $LN2@StreamChar

; 150  : 		return -1;

  000a1	5f		 pop	 edi
  000a2	83 c8 ff	 or	 eax, -1
  000a5	5e		 pop	 esi

; 153  : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN14@StreamChar:

; 104  : 			Error = 1;
; 105  : 	}
; 106  : 	else if (Character <= 0x1FFFFF)  /* 1111 0XXX  four bytes */

  000aa	81 f9 ff ff 1f
	00		 cmp	 ecx, 2097151		; 001fffffH
  000b0	77 4f		 ja	 SHORT $LN10@StreamChar

; 107  : 	{
; 108  : 		TmpBuffer[0] = (char)(0xF0 | (Character >> 18));

  000b2	8b c1		 mov	 eax, ecx

; 109  : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 110  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 111  : 		TmpBuffer[3] = (char)(0x80 | (Character & 0x3F));
; 112  : 		NumBytes = 4;

  000b4	be 04 00 00 00	 mov	 esi, 4
  000b9	c1 e8 12	 shr	 eax, 18			; 00000012H
  000bc	0c f0		 or	 al, -16			; fffffff0H
  000be	88 45 f4	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  000c1	8b c1		 mov	 eax, ecx
  000c3	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000c6	24 3f		 and	 al, 63			; 0000003fH
  000c8	0c 80		 or	 al, -128		; ffffff80H
  000ca	88 45 f5	 mov	 BYTE PTR _TmpBuffer$[ebp+1], al
  000cd	8b c1		 mov	 eax, ecx
  000cf	c1 e8 06	 shr	 eax, 6
  000d2	24 3f		 and	 al, 63			; 0000003fH
  000d4	0c 80		 or	 al, -128		; ffffff80H
  000d6	88 45 f6	 mov	 BYTE PTR _TmpBuffer$[ebp+2], al
  000d9	8a c1		 mov	 al, cl
  000db	24 3f		 and	 al, 63			; 0000003fH
  000dd	0c 80		 or	 al, -128		; ffffff80H
  000df	88 45 f7	 mov	 BYTE PTR _TmpBuffer$[ebp+3], al

; 113  : 
; 114  : 		if (Character > 0x10FFFF)

  000e2	81 f9 ff ff 10
	00		 cmp	 ecx, 1114111		; 0010ffffH
  000e8	77 a5		 ja	 SHORT $LN5@StreamChar
$LN21@StreamChar:

; 140  : 
; 141  : 	/* Write buffer only if it's a valid byte sequence */
; 142  : 	if (!Error && oBuffer != NULL)

  000ea	8b 45 0c	 mov	 eax, DWORD PTR _oBuffer$[ebp]
  000ed	85 c0		 test	 eax, eax
  000ef	74 a3		 je	 SHORT $LN3@StreamChar

; 143  : 		memcpy(oBuffer, BufPtr, NumBytes);

  000f1	56		 push	 esi
  000f2	8d 4d f4	 lea	 ecx, DWORD PTR _TmpBuffer$[ebp]
  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _memcpy
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	eb 93		 jmp	 SHORT $LN3@StreamChar
$LN10@StreamChar:

; 115  : 			Error = 1;
; 116  : 	}
; 117  : 	else if (Character <= 0x3FFFFFF)  /* 1111 10XX  five bytes */

  00101	81 f9 ff ff ff
	03		 cmp	 ecx, 67108863		; 03ffffffH
  00107	77 12		 ja	 SHORT $LN7@StreamChar

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00109	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5

; 150  : 		return -1;

  00114	83 c8 ff	 or	 eax, -1

; 153  : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
$LN7@StreamChar:

; 118  : 	{
; 119  : 		TmpBuffer[0] = (char)(0xF8 | (Character >> 24));
; 120  : 		TmpBuffer[1] = (char)(0x80 | (Character >> 18));
; 121  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 122  : 		TmpBuffer[3] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 123  : 		TmpBuffer[4] = (char)(0x80 | (Character & 0x3F));
; 124  : 		NumBytes = 5;
; 125  : 		Error = 1;
; 126  : 	}
; 127  : 	else if (Character <= 0x7FFFFFFF)  /* 1111 110X  six bytes */

  0011b	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00121	0f 87 68 ff ff
	ff		 ja	 $LN5@StreamChar

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00127	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6

; 150  : 		return -1;

  00132	83 c8 ff	 or	 eax, -1

; 153  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
$LN2@StreamChar:
  00139	5f		 pop	 edi

; 151  : 	else
; 152  : 		return 0;

  0013a	33 c0		 xor	 eax, eax
  0013c	5e		 pop	 esi

; 153  : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
_StreamCharacterToUtf8 ENDP
_TEXT	ENDS
END
