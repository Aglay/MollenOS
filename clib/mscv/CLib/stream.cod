; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\stdio\stream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2352	DB	'-', 00H
	ORG $+2
$SG2355	DB	'+', 00H
	ORG $+2
$SG2358	DB	' ', 00H
	ORG $+2
$SG2397	DB	'(null)', 00H
	ORG $+1
?_nullstring@?1??streamout@@9@9 DD FLAT:$SG2397		; `streamout'::`2'::_nullstring
$SG2605	DB	'-', 00H
	ORG $+2
$SG2608	DB	'+', 00H
	ORG $+2
$SG2611	DB	' ', 00H
	ORG $+2
$SG2615	DB	'0', 00H
_DATA	ENDS
CONST	SEGMENT
?digits_l@?1??format_float@@9@9 DB '0123456789abcdef0x', 00H ; `format_float'::`2'::digits_l
	ORG $+1
?digits_u@?1??format_float@@9@9 DB '0123456789ABCDEF0X', 00H ; `format_float'::`2'::digits_u
	ORG $+1
?_nan@?1??format_float@@9@9 DB '#QNAN', 00H		; `format_float'::`2'::_nan
	ORG $+2
?_infinity@?1??format_float@@9@9 DB '#INF', 00H		; `format_float'::`2'::_infinity
	ORG $+3
?digits_l@?1??streamout@@9@9 DB '0123456789abcdef0x', 00H ; `streamout'::`2'::digits_l
	ORG $+1
?digits_u@?1??streamout@@9@9 DB '0123456789ABCDEF0X', 00H ; `streamout'::`2'::digits_u
CONST	ENDS
EXTRN	_putchar:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_char
_TEXT	SEGMENT
_streamout_char PROC					; COMDAT
; _out$ = ecx
; _cnt$ = edx
; _c$ = eax

; 73   : 	/* Sanity */
; 74   : 	if(*cnt == 0 && out != NULL)

  00000	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00003	75 07		 jne	 SHORT $LN3@streamout_
  00005	85 c9		 test	 ecx, ecx
  00007	74 12		 je	 SHORT $LN2@streamout_

; 75   : 		return 0;

  00009	33 c0		 xor	 eax, eax

; 87   : #else
; 88   : 		return video_putchar(c);
; 89   : #endif
; 90   : 	}
; 91   : }

  0000b	c3		 ret	 0
$LN3@streamout_:

; 76   : 
; 77   : 	if (out) {

  0000c	85 c9		 test	 ecx, ecx
  0000e	74 0b		 je	 SHORT $LN2@streamout_

; 78   : 		**out = (char)c;

  00010	56		 push	 esi
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	88 06		 mov	 BYTE PTR [esi], al

; 79   : 		++(*out);

  00015	ff 01		 inc	 DWORD PTR [ecx]

; 80   : 		*cnt -= 1;

  00017	ff 0a		 dec	 DWORD PTR [edx]
  00019	5e		 pop	 esi

; 87   : #else
; 88   : 		return video_putchar(c);
; 89   : #endif
; 90   : 	}
; 91   : }

  0001a	c3		 ret	 0
$LN2@streamout_:

; 81   : 		return c;
; 82   : 	}
; 83   : 	else 
; 84   : 	{
; 85   : #ifndef LIBC_KERNEL
; 86   : 		return putchar(c);

  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _putchar
  00021	83 c4 04	 add	 esp, 4

; 87   : #else
; 88   : 		return video_putchar(c);
; 89   : #endif
; 90   : 	}
; 91   : }

  00024	c3		 ret	 0
_streamout_char ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _streamout_astring
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_streamout_astring PROC					; COMDAT
; _string$ = ecx
; _count$ = eax

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax

; 95   : 	char chr;
; 96   : 	int written = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 97   : 
; 98   : 	while (count--)

  0000c	85 f6		 test	 esi, esi
  0000e	74 1b		 je	 SHORT $LN8@streamout_@2
$LL3@streamout_@2:

; 99   : 	{
; 100  : 		chr = *string++;

  00010	8a 07		 mov	 al, BYTE PTR [edi]

; 101  : 		if (streamout_char(out, cnt, chr) == 0) return -1;

  00012	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  00018	0f be c0	 movsx	 eax, al
  0001b	4e		 dec	 esi
  0001c	47		 inc	 edi
  0001d	e8 00 00 00 00	 call	 _streamout_char
  00022	85 c0		 test	 eax, eax
  00024	74 0c		 je	 SHORT $LN7@streamout_@2

; 102  : 		written++;

  00026	43		 inc	 ebx
  00027	85 f6		 test	 esi, esi
  00029	75 e5		 jne	 SHORT $LL3@streamout_@2
$LN8@streamout_@2:
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 103  : 	}
; 104  : 
; 105  : 	return written;

  0002d	8b c3		 mov	 eax, ebx
  0002f	5b		 pop	 ebx

; 106  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN7@streamout_@2:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 101  : 		if (streamout_char(out, cnt, chr) == 0) return -1;

  00034	83 c8 ff	 or	 eax, -1
  00037	5b		 pop	 ebx

; 106  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_streamout_astring ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _streamout_wstring
_TEXT	SEGMENT
_written$ = -4						; size = 4
_out$ = 8						; size = 4
_streamout_wstring PROC					; COMDAT
; _cnt$ = ebx
; _string$ = ecx
; _count$ = eax

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 110  : 	wchar_t chr;
; 111  : 	int written = 0;

  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _written$[ebp], 0

; 112  : 
; 113  : 	while (count--)

  00011	85 f6		 test	 esi, esi
  00013	74 1c		 je	 SHORT $LN8@streamout_@3
$LL3@streamout_@3:

; 114  : 	{
; 115  : 		chr = *string++;

  00015	0f b7 07	 movzx	 eax, WORD PTR [edi]

; 116  : 		{
; 117  : 			if (streamout_char(out, cnt, chr) == 0) return -1;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  0001b	8b d3		 mov	 edx, ebx
  0001d	4e		 dec	 esi
  0001e	83 c7 02	 add	 edi, 2
  00021	e8 00 00 00 00	 call	 _streamout_char
  00026	85 c0		 test	 eax, eax
  00028	74 10		 je	 SHORT $LN7@streamout_@3

; 118  : 			written++;

  0002a	ff 45 fc	 inc	 DWORD PTR _written$[ebp]
  0002d	85 f6		 test	 esi, esi
  0002f	75 e4		 jne	 SHORT $LL3@streamout_@3
$LN8@streamout_@3:

; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	return written;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _written$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 123  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN7@streamout_@3:
  0003a	5f		 pop	 edi

; 116  : 		{
; 117  : 			if (streamout_char(out, cnt, chr) == 0) return -1;

  0003b	83 c8 ff	 or	 eax, -1
  0003e	5e		 pop	 esi

; 123  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_streamout_wstring ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_format_float
EXTRN	__finite:PROC
EXTRN	__isnan:PROC
EXTRN	__fltused:DWORD
EXTRN	__aullrem:PROC
EXTRN	__ftol2:PROC
EXTRN	__CIpow:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	__CIlog10:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _format_float
_TEXT	SEGMENT
tv381 = -44						; size = 8
tv446 = -36						; size = 8
tv443 = -36						; size = 8
_fpval$ = -28						; size = 8
_padding$ = -20						; size = 4
_exponent$ = -16					; size = 4
_fpval2$ = -12						; size = 8
_sign$ = -8						; size = 4
_digits$ = -4						; size = 4
tv468 = 8						; size = 4
tv458 = 8						; size = 4
tv428 = 8						; size = 4
_chr$ = 8						; size = 1
_flags$ = 12						; size = 4
_precision$ = 16					; size = 4
_string$ = 20						; size = 4
_prefix$ = 24						; size = 4
_argptr$ = 28						; size = 4
_format_float PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx

; 128  : 	static const char digits_l[] = ("0123456789abcdef0x");
; 129  : 	static const char digits_u[] = ("0123456789ABCDEF0X");
; 130  : 	static const char _nan[] = ("#QNAN");
; 131  : 	static const char _infinity[] = ("#INF");
; 132  : 	const char *digits = digits_l;
; 133  : 	int exponent = 0, sign;
; 134  : 	long double fpval, fpval2;
; 135  : 	int padding = 0, num_digits, val32, base = 10;
; 136  : 
; 137  : 	/* Normalize the precision */
; 138  : 	if (precision < 0) precision = 6;

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_l@?1??format_float@@9@9
  00013	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _padding$[ebp], 0
  0001a	85 db		 test	 ebx, ebx
  0001c	79 09		 jns	 SHORT $LN37@format_flo
  0001e	c7 45 10 06 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 6
  00025	eb 12		 jmp	 SHORT $LN133@format_flo
$LN37@format_flo:

; 139  : 	else if (precision > 17)

  00027	83 fb 11	 cmp	 ebx, 17			; 00000011H
  0002a	7e 10		 jle	 SHORT $LN35@format_flo

; 140  : 	{
; 141  : 		padding = precision - 17;

  0002c	83 c3 ef	 add	 ebx, -17		; ffffffefH
  0002f	89 5d ec	 mov	 DWORD PTR _padding$[ebp], ebx

; 142  : 		precision = 17;

  00032	c7 45 10 11 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 17 ; 00000011H
$LN133@format_flo:
  00039	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
$LN35@format_flo:

; 143  : 	}
; 144  : 
; 145  : 	/* Get the float value and calculate the exponent */
; 146  : 	fpval = va_arg_ffp(*argptr, flags);

  0003c	8b 45 1c	 mov	 eax, DWORD PTR _argptr$[ebp]
  0003f	83 00 08	 add	 DWORD PTR [eax], 8
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00047	dd 55 e4	 fst	 QWORD PTR _fpval$[ebp]

; 147  : 	exponent = get_exp((double)fpval);

  0004a	d9 c0		 fld	 ST(0)
  0004c	d9 ee		 fldz
  0004e	d9 c0		 fld	 ST(0)
  00050	dd ea		 fucomp	 ST(2)
  00052	df e0		 fnstsw	 ax
  00054	dd d9		 fstp	 ST(1)
  00056	f6 c4 44	 test	 ah, 68			; 00000044H
  00059	7a 04		 jp	 SHORT $LN44@format_flo
  0005b	dd d9		 fstp	 ST(1)
  0005d	eb 10		 jmp	 SHORT $LN43@format_flo
$LN44@format_flo:
  0005f	d8 d9		 fcomp	 ST(1)
  00061	df e0		 fnstsw	 ax
  00063	f6 c4 41	 test	 ah, 65			; 00000041H
  00066	7b 02		 jnp	 SHORT $LN134@format_flo
  00068	d9 e0		 fchs
$LN134@format_flo:
  0006a	e8 00 00 00 00	 call	 __CIlog10
$LN43@format_flo:
  0006f	83 ec 08	 sub	 esp, 8
  00072	dd 1c 24	 fstp	 QWORD PTR [esp]
  00075	e8 00 00 00 00	 call	 _floor
  0007a	83 c4 08	 add	 esp, 8
  0007d	e8 00 00 00 00	 call	 __ftol2_sse

; 148  : 	sign = fpval < 0 ? -1 : 1;

  00082	d9 ee		 fldz
  00084	dd 45 e4	 fld	 QWORD PTR _fpval$[ebp]
  00087	8b f8		 mov	 edi, eax
  00089	d8 d1		 fcom	 ST(1)
  0008b	89 7d f0	 mov	 DWORD PTR _exponent$[ebp], edi
  0008e	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
  00095	df e0		 fnstsw	 ax
  00097	dd d9		 fstp	 ST(1)
  00099	f6 c4 05	 test	 ah, 5
  0009c	7b 07		 jnp	 SHORT $LN47@format_flo
  0009e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1
$LN47@format_flo:

; 149  : 
; 150  : 	switch (chr)

  000a5	0f be 45 08	 movsx	 eax, BYTE PTR _chr$[ebp]
  000a9	8b 75 14	 mov	 esi, DWORD PTR _string$[ebp]
  000ac	83 c0 bf	 add	 eax, -65		; ffffffbfH
  000af	83 f8 26	 cmp	 eax, 38			; 00000026H
  000b2	0f 87 cc 01 00
	00		 ja	 $LN87@format_flo
  000b8	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN68@format_flo[eax]
  000bf	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN136@format_flo[eax*4]
$LN32@format_flo:

; 151  : 	{
; 152  : 	case ('G'):
; 153  : 		digits = digits_u;

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN31@format_flo:

; 154  : 	case ('g'):
; 155  : 		if (precision > 0) precision--;

  000cd	85 db		 test	 ebx, ebx
  000cf	7e 04		 jle	 SHORT $LN30@format_flo
  000d1	4b		 dec	 ebx
  000d2	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
$LN30@format_flo:

; 156  : 		if (exponent < -4 || exponent >= precision) goto case_e;

  000d5	83 ff fc	 cmp	 edi, -4			; fffffffcH
  000d8	0f 8c 91 00 00
	00		 jl	 $case_e$2333
  000de	3b fb		 cmp	 edi, ebx
  000e0	0f 8d 89 00 00
	00		 jge	 $case_e$2333
  000e6	dd d8		 fstp	 ST(0)

; 157  : 
; 158  : 		/* Shift the decimal point and round */
; 159  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  000e8	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  000ee	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  000f1	e8 00 00 00 00	 call	 __CIpow
  000f6	db 45 f8	 fild	 DWORD PTR _sign$[ebp]
  000f9	83 ec 08	 sub	 esp, 8
  000fc	dc 4d e4	 fmul	 QWORD PTR _fpval$[ebp]
  000ff	de c9		 fmulp	 ST(1), ST(0)
  00101	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00107	dd 1c 24	 fstp	 QWORD PTR [esp]
  0010a	e8 00 00 00 00	 call	 _floor
  0010f	83 c4 08	 add	 esp, 8
  00112	dd 55 f4	 fst	 QWORD PTR _fpval2$[ebp]

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  00115	85 db		 test	 ebx, ebx
  00117	0f 84 98 01 00
	00		 je	 $LN104@format_flo
  0011d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
$LN27@format_flo:
  00123	d9 c1		 fld	 ST(1)
  00125	e8 00 00 00 00	 call	 __ftol2
  0012a	6a 00		 push	 0
  0012c	6a 0a		 push	 10			; 0000000aH
  0012e	52		 push	 edx
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 __aullrem
  00135	0b c2		 or	 eax, edx
  00137	75 05		 jne	 SHORT $LN108@format_flo

; 163  : 		{
; 164  : 			precision--;

  00139	4b		 dec	 ebx

; 165  : 			fpval2 /= 10;

  0013a	dc f9		 fdiv	 ST(1), ST(0)
  0013c	75 e5		 jne	 SHORT $LN27@format_flo
$LN108@format_flo:

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  0013e	dd d8		 fstp	 ST(0)

; 163  : 		{
; 164  : 			precision--;

  00140	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
$LN135@format_flo:

; 165  : 			fpval2 /= 10;

  00143	dd 5d f4	 fstp	 QWORD PTR _fpval2$[ebp]
$LN33@format_flo:

; 211  : 		break;
; 212  : 	}
; 213  : 
; 214  : 	/* Handle sign */
; 215  : 	if (fpval < 0)

  00146	d9 ee		 fldz
  00148	dd 45 e4	 fld	 QWORD PTR _fpval$[ebp]
  0014b	d8 d1		 fcom	 ST(1)
  0014d	df e0		 fnstsw	 ax
  0014f	dd d9		 fstp	 ST(1)
  00151	f6 c4 05	 test	 ah, 5
  00154	0f 8a 62 01 00
	00		 jp	 $LN18@format_flo

; 216  : 	{
; 217  : 		*prefix = ("-");

  0015a	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  0015d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2352
  00163	e9 73 01 00 00	 jmp	 $LN14@format_flo
$LN25@format_flo:

; 166  : 		}
; 167  : 		break;
; 168  : 
; 169  : 	case ('E'):
; 170  : 		digits = digits_u;

  00168	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$case_e$2333:

; 171  : 	case ('e'):
; 172  : case_e:
; 173  : 		/* Shift the decimal point and round */
; 174  : 		fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  0016f	da 4d f8	 fimul	 DWORD PTR _sign$[ebp]
  00172	8b cb		 mov	 ecx, ebx
  00174	2b cf		 sub	 ecx, edi
  00176	89 4d 08	 mov	 DWORD PTR tv468[ebp], ecx
  00179	dd 5d d4	 fstp	 QWORD PTR tv381[ebp]
  0017c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00182	db 45 08	 fild	 DWORD PTR tv468[ebp]
  00185	e8 00 00 00 00	 call	 __CIpow
  0018a	dc 4d d4	 fmul	 QWORD PTR tv381[ebp]
  0018d	83 ec 08	 sub	 esp, 8
  00190	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00196	dd 1c 24	 fstp	 QWORD PTR [esp]
  00199	e8 00 00 00 00	 call	 _floor

; 175  : 
; 176  : 		/* Compensate for changed exponent through rounding */
; 177  : 		if (fpval2 >= (unsigned __int64)pow(10., precision + 1))

  0019e	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  001a1	dd 5d f4	 fstp	 QWORD PTR _fpval2$[ebp]
  001a4	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001aa	89 55 08	 mov	 DWORD PTR tv458[ebp], edx
  001ad	db 45 08	 fild	 DWORD PTR tv458[ebp]
  001b0	83 c4 08	 add	 esp, 8
  001b3	e8 00 00 00 00	 call	 __CIpow
  001b8	e8 00 00 00 00	 call	 __ftol2
  001bd	89 45 dc	 mov	 DWORD PTR tv446[ebp], eax
  001c0	8b c2		 mov	 eax, edx
  001c2	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  001c8	89 55 e0	 mov	 DWORD PTR tv446[ebp+4], edx
  001cb	df 6d dc	 fild	 QWORD PTR tv446[ebp]
  001ce	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d3	89 45 e0	 mov	 DWORD PTR tv443[ebp+4], eax
  001d6	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv443[ebp], 0
  001dd	df 6d dc	 fild	 QWORD PTR tv443[ebp]
  001e0	d9 e0		 fchs
  001e2	de c1		 faddp	 ST(1), ST(0)
  001e4	dc 5d f4	 fcomp	 QWORD PTR _fpval2$[ebp]
  001e7	df e0		 fnstsw	 ax
  001e9	f6 c4 41	 test	 ah, 65			; 00000041H
  001ec	7a 31		 jp	 SHORT $LN23@format_flo

; 178  : 		{
; 179  : 			exponent++;
; 180  : 			fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  001ee	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001f4	47		 inc	 edi
  001f5	2b df		 sub	 ebx, edi
  001f7	89 5d 08	 mov	 DWORD PTR tv428[ebp], ebx
  001fa	db 45 08	 fild	 DWORD PTR tv428[ebp]
  001fd	89 7d f0	 mov	 DWORD PTR _exponent$[ebp], edi
  00200	e8 00 00 00 00	 call	 __CIpow
  00205	dc 4d d4	 fmul	 QWORD PTR tv381[ebp]
  00208	83 ec 08	 sub	 esp, 8
  0020b	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00211	dd 1c 24	 fstp	 QWORD PTR [esp]
  00214	e8 00 00 00 00	 call	 _floor
  00219	dd 5d f4	 fstp	 QWORD PTR _fpval2$[ebp]
  0021c	83 c4 08	 add	 esp, 8
$LN23@format_flo:

; 181  : 		}
; 182  : 
; 183  : 		val32 = exponent >= 0 ? exponent : -exponent;

  0021f	8b c7		 mov	 eax, edi
  00221	99		 cdq
  00222	8b c8		 mov	 ecx, eax
  00224	33 ca		 xor	 ecx, edx
  00226	2b ca		 sub	 ecx, edx

; 184  : 
; 185  : 		// FIXME: handle length of exponent field:
; 186  : 		// http://msdn.microsoft.com/de-de/library/0fatw238%28VS.80%29.aspx
; 187  : 		num_digits = 3;

  00228	bf 03 00 00 00	 mov	 edi, 3
  0022d	8d 49 00	 npad	 3
$LL22@format_flo:

; 188  : 		while (num_digits--)
; 189  : 		{
; 190  : 			*--(*string) = digits[val32 % 10];

  00230	ff 0e		 dec	 DWORD PTR [esi]
  00232	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00234	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00239	f7 e9		 imul	 ecx
  0023b	c1 fa 02	 sar	 edx, 2
  0023e	8b c2		 mov	 eax, edx
  00240	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00243	03 c2		 add	 eax, edx
  00245	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00248	03 d2		 add	 edx, edx
  0024a	2b ca		 sub	 ecx, edx
  0024c	4f		 dec	 edi
  0024d	8b 55 fc	 mov	 edx, DWORD PTR _digits$[ebp]
  00250	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00253	88 0b		 mov	 BYTE PTR [ebx], cl

; 191  : 			val32 /= 10;

  00255	8b c8		 mov	 ecx, eax
  00257	75 d7		 jne	 SHORT $LL22@format_flo

; 192  : 		}
; 193  : 
; 194  : 		/* Sign for the exponent */
; 195  : 		*--(*string) = (exponent >= 0 ? ('+') : ('-'));

  00259	ff 0e		 dec	 DWORD PTR [esi]
  0025b	39 7d f0	 cmp	 DWORD PTR _exponent$[ebp], edi
  0025e	8b 06		 mov	 eax, DWORD PTR [esi]

; 196  : 
; 197  : 		/* Add 'e' or 'E' separator */
; 198  : 		*--(*string) = digits[0xe];

  00260	8b 4d fc	 mov	 ecx, DWORD PTR _digits$[ebp]

; 199  : 		break;

  00263	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
  00266	0f 9c c2	 setl	 dl
  00269	8d 54 12 2b	 lea	 edx, DWORD PTR [edx+edx+43]
  0026d	88 10		 mov	 BYTE PTR [eax], dl
  0026f	ff 0e		 dec	 DWORD PTR [esi]
  00271	8b 06		 mov	 eax, DWORD PTR [esi]
  00273	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  00276	88 10		 mov	 BYTE PTR [eax], dl
  00278	e9 c9 fe ff ff	 jmp	 $LN33@format_flo
$LN88@format_flo:

; 200  : 
; 201  : 	case ('A'):
; 202  : 		digits = digits_u;

  0027d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN87@format_flo:
  00284	dd d8		 fstp	 ST(0)

; 203  : 	case ('a'):
; 204  : 		//            base = 16;
; 205  : 		// FIXME: TODO
; 206  : 
; 207  : 	case ('f'):
; 208  : 	default:
; 209  : 		/* Shift the decimal point and round */
; 210  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  00286	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0028c	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  0028f	e8 00 00 00 00	 call	 __CIpow
  00294	db 45 f8	 fild	 DWORD PTR _sign$[ebp]
  00297	83 ec 08	 sub	 esp, 8
  0029a	dc 4d e4	 fmul	 QWORD PTR _fpval$[ebp]
  0029d	de c9		 fmulp	 ST(1), ST(0)
  0029f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  002a5	dd 1c 24	 fstp	 QWORD PTR [esp]
  002a8	e8 00 00 00 00	 call	 _floor
  002ad	83 c4 08	 add	 esp, 8
  002b0	e9 8e fe ff ff	 jmp	 $LN135@format_flo
$LN104@format_flo:

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  002b5	dd d8		 fstp	 ST(0)

; 199  : 		break;

  002b7	e9 8a fe ff ff	 jmp	 $LN33@format_flo
$LN18@format_flo:

; 218  : 	}
; 219  : 	else if (flags & FLAG_FORCE_SIGN)

  002bc	8a 45 0c	 mov	 al, BYTE PTR _flags$[ebp]
  002bf	a8 02		 test	 al, 2
  002c1	74 0b		 je	 SHORT $LN16@format_flo

; 220  : 		*prefix = ("+");

  002c3	8b 4d 18	 mov	 ecx, DWORD PTR _prefix$[ebp]
  002c6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET $SG2355
  002cc	eb 0d		 jmp	 SHORT $LN14@format_flo
$LN16@format_flo:

; 221  : 	else if (flags & FLAG_FORCE_SIGNSP)

  002ce	a8 04		 test	 al, 4
  002d0	74 09		 je	 SHORT $LN14@format_flo

; 222  : 		*prefix = (" ");

  002d2	8b 55 18	 mov	 edx, DWORD PTR _prefix$[ebp]
  002d5	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET $SG2358
$LN14@format_flo:

; 223  : 
; 224  : 	/* Handle special cases first */
; 225  : 	if (_isnan((double)fpval))

  002db	83 ec 08	 sub	 esp, 8
  002de	dd 1c 24	 fstp	 QWORD PTR [esp]
  002e1	e8 00 00 00 00	 call	 __isnan
  002e6	83 c4 08	 add	 esp, 8
  002e9	85 c0		 test	 eax, eax
  002eb	74 1b		 je	 SHORT $LN13@format_flo

; 226  : 	{
; 227  : 		(*string) -= sizeof(_nan) / sizeof(char) - 1;

  002ed	83 06 fb	 add	 DWORD PTR [esi], -5	; fffffffbH
  002f0	8b 16		 mov	 edx, DWORD PTR [esi]

; 228  : 		strcpy((*string), _nan);

  002f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?_nan@?1??format_float@@9@9
$LL48@format_flo:
  002f7	8a 01		 mov	 al, BYTE PTR [ecx]
  002f9	88 02		 mov	 BYTE PTR [edx], al
  002fb	41		 inc	 ecx
  002fc	42		 inc	 edx
  002fd	84 c0		 test	 al, al
  002ff	75 f6		 jne	 SHORT $LL48@format_flo

; 229  : 		fpval2 = 1;

  00301	d9 e8		 fld1
  00303	e9 79 00 00 00	 jmp	 $LN62@format_flo
$LN13@format_flo:

; 230  : 	}
; 231  : 	else if (!_finite((double)fpval))

  00308	dd 45 e4	 fld	 QWORD PTR _fpval$[ebp]
  0030b	83 ec 08	 sub	 esp, 8
  0030e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00311	e8 00 00 00 00	 call	 __finite
  00316	83 c4 08	 add	 esp, 8
  00319	85 c0		 test	 eax, eax
  0031b	75 18		 jne	 SHORT $LN54@format_flo

; 232  : 	{
; 233  : 		(*string) -= sizeof(_infinity) / sizeof(char) - 1;

  0031d	83 06 fc	 add	 DWORD PTR [esi], -4	; fffffffcH
  00320	8b 16		 mov	 edx, DWORD PTR [esi]

; 234  : 		strcpy((*string), _infinity);

  00322	b9 00 00 00 00	 mov	 ecx, OFFSET ?_infinity@?1??format_float@@9@9
$LL49@format_flo:
  00327	8a 01		 mov	 al, BYTE PTR [ecx]
  00329	88 02		 mov	 BYTE PTR [edx], al
  0032b	41		 inc	 ecx
  0032c	42		 inc	 edx
  0032d	84 c0		 test	 al, al
  0032f	75 f6		 jne	 SHORT $LL49@format_flo

; 235  : 		fpval2 = 1;

  00331	d9 e8		 fld1

; 236  : 	}
; 237  : 	else

  00333	eb 4c		 jmp	 SHORT $LN62@format_flo
$LN54@format_flo:

; 238  : 	{
; 239  : 		/* Zero padding */
; 240  : 		while (padding-- > 0) *--(*string) = ('0');

  00335	8b 4d ec	 mov	 ecx, DWORD PTR _padding$[ebp]
  00338	85 c9		 test	 ecx, ecx
  0033a	7e 10		 jle	 SHORT $LN60@format_flo
  0033c	8d 64 24 00	 npad	 4
$LL9@format_flo:
  00340	ff 0e		 dec	 DWORD PTR [esi]
  00342	8b 06		 mov	 eax, DWORD PTR [esi]
  00344	49		 dec	 ecx
  00345	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  00348	85 c9		 test	 ecx, ecx
  0034a	7f f4		 jg	 SHORT $LL9@format_flo
$LN60@format_flo:

; 241  : 
; 242  : 		/* Digits after the decimal point */
; 243  : 		num_digits = precision;
; 244  : 		while (num_digits-- > 0)

  0034c	dd 45 f4	 fld	 QWORD PTR _fpval2$[ebp]
  0034f	8b fb		 mov	 edi, ebx
  00351	85 db		 test	 ebx, ebx
  00353	7e 30		 jle	 SHORT $LN66@format_flo
$LN7@format_flo:

; 245  : 		{
; 246  : 			*--(*string) = digits[(unsigned __int64)fpval2 % 10];

  00355	ff 0e		 dec	 DWORD PTR [esi]
  00357	d9 c0		 fld	 ST(0)
  00359	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0035b	4f		 dec	 edi
  0035c	e8 00 00 00 00	 call	 __ftol2
  00361	6a 00		 push	 0
  00363	6a 0a		 push	 10			; 0000000aH
  00365	52		 push	 edx
  00366	50		 push	 eax
  00367	e8 00 00 00 00	 call	 __aullrem

; 247  : 			fpval2 /= base;

  0036c	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4024000000000000
  00372	8b 4d fc	 mov	 ecx, DWORD PTR _digits$[ebp]
  00375	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00378	88 13		 mov	 BYTE PTR [ebx], dl
  0037a	85 ff		 test	 edi, edi
  0037c	7f d7		 jg	 SHORT $LN7@format_flo

; 241  : 
; 242  : 		/* Digits after the decimal point */
; 243  : 		num_digits = precision;
; 244  : 		while (num_digits-- > 0)

  0037e	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
$LN62@format_flo:

; 248  : 		}
; 249  : 	}
; 250  : 
; 251  : 	if (precision > 0 || flags & FLAG_SPECIAL)

  00381	85 db		 test	 ebx, ebx
  00383	7f 06		 jg	 SHORT $LN4@format_flo
$LN66@format_flo:
  00385	f6 45 0c 10	 test	 BYTE PTR _flags$[ebp], 16 ; 00000010H
  00389	74 07		 je	 SHORT $LN73@format_flo
$LN4@format_flo:

; 252  : 		*--(*string) = ('.');

  0038b	ff 0e		 dec	 DWORD PTR [esi]
  0038d	8b 06		 mov	 eax, DWORD PTR [esi]
  0038f	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
$LN73@format_flo:

; 259  : 	}
; 260  : 	while ((unsigned __int64)fpval2);

  00392	d9 c0		 fld	 ST(0)
  00394	e8 00 00 00 00	 call	 __ftol2
  00399	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
$LN3@format_flo:

; 253  : 
; 254  : 	/* Digits before the decimal point */
; 255  : 	do
; 256  : 	{
; 257  : 		*--(*string) = digits[(unsigned __int64)fpval2 % base];

  0039f	ff 0e		 dec	 DWORD PTR [esi]
  003a1	8b 3e		 mov	 edi, DWORD PTR [esi]
  003a3	6a 00		 push	 0
  003a5	6a 0a		 push	 10			; 0000000aH
  003a7	52		 push	 edx
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 __aullrem

; 258  : 		fpval2 /= base;

  003ae	dc f9		 fdiv	 ST(1), ST(0)
  003b0	8b 4d fc	 mov	 ecx, DWORD PTR _digits$[ebp]
  003b3	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  003b6	88 17		 mov	 BYTE PTR [edi], dl

; 259  : 	}
; 260  : 	while ((unsigned __int64)fpval2);

  003b8	d9 c1		 fld	 ST(1)
  003ba	e8 00 00 00 00	 call	 __ftol2
  003bf	8b c8		 mov	 ecx, eax
  003c1	0b ca		 or	 ecx, edx
  003c3	75 da		 jne	 SHORT $LN3@format_flo
  003c5	5f		 pop	 edi
  003c6	dd d9		 fstp	 ST(1)
  003c8	5e		 pop	 esi
  003c9	dd d8		 fstp	 ST(0)
  003cb	5b		 pop	 ebx

; 261  : 
; 262  : }

  003cc	8b e5		 mov	 esp, ebp
  003ce	5d		 pop	 ebp
  003cf	c3		 ret	 0
$LN136@format_flo:
  003d0	00 00 00 00	 DD	 $LN88@format_flo
  003d4	00 00 00 00	 DD	 $LN25@format_flo
  003d8	00 00 00 00	 DD	 $LN32@format_flo
  003dc	00 00 00 00	 DD	 $case_e$2333
  003e0	00 00 00 00	 DD	 $LN31@format_flo
  003e4	00 00 00 00	 DD	 $LN87@format_flo
$LN68@format_flo:
  003e8	00		 DB	 0
  003e9	05		 DB	 5
  003ea	05		 DB	 5
  003eb	05		 DB	 5
  003ec	01		 DB	 1
  003ed	05		 DB	 5
  003ee	02		 DB	 2
  003ef	05		 DB	 5
  003f0	05		 DB	 5
  003f1	05		 DB	 5
  003f2	05		 DB	 5
  003f3	05		 DB	 5
  003f4	05		 DB	 5
  003f5	05		 DB	 5
  003f6	05		 DB	 5
  003f7	05		 DB	 5
  003f8	05		 DB	 5
  003f9	05		 DB	 5
  003fa	05		 DB	 5
  003fb	05		 DB	 5
  003fc	05		 DB	 5
  003fd	05		 DB	 5
  003fe	05		 DB	 5
  003ff	05		 DB	 5
  00400	05		 DB	 5
  00401	05		 DB	 5
  00402	05		 DB	 5
  00403	05		 DB	 5
  00404	05		 DB	 5
  00405	05		 DB	 5
  00406	05		 DB	 5
  00407	05		 DB	 5
  00408	05		 DB	 5
  00409	05		 DB	 5
  0040a	05		 DB	 5
  0040b	05		 DB	 5
  0040c	03		 DB	 3
  0040d	05		 DB	 5
  0040e	04		 DB	 4
_format_float ENDP
_TEXT	ENDS
PUBLIC	_argptr$GSCopy$
PUBLIC	_out$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_streamout
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__aulldvrm:PROC
; Function compile flags: /Ogtp
;	COMDAT _streamout
_TEXT	SEGMENT
tv600 = -116						; size = 8
tv621 = -108						; size = 4
_digits$ = -108						; size = 4
_fieldwidth$ = -104					; size = 4
_out$GSCopy$ = -100					; size = 4
_cnt$ = -96						; size = 4
tv87 = -92						; size = 8
_len$ = -88						; size = 4
_written$ = -88						; size = 4
_prefix$ = -84						; size = 4
_chr$ = -80						; size = 1
_flags$ = -76						; size = 4
_string$ = -72						; size = 4
_written_all$ = -68					; size = 4
_argptr$GSCopy$ = -64					; size = 4
_precision$ = -60					; size = 4
_buffer$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_size$ = 12						; size = 4
_format$ = 16						; size = 4
_argptr$ = 20						; size = 4
_streamout PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _out$[ebp]

; 394  : 
; 395  : 		/* Handle the format specifier */
; 396  : 		digits = digits_l;
; 397  : 		string = &buffer[BUFFER_SIZE];

  00013	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00016	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	89 45 9c	 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  0001e	89 4d c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], ecx
  00021	89 55 a0	 mov	 DWORD PTR _cnt$[ebp], edx
  00024	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR _written$[ebp], 1
  0002b	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _written_all$[ebp], 0
  00032	c6 45 f9 00	 mov	 BYTE PTR _buffer$[ebp+49], 0
  00036	57		 push	 edi
$LL112@streamout:

; 286  : 	{
; 287  : 		chr = *format++;

  00037	8b 4d 10	 mov	 ecx, DWORD PTR _format$[ebp]
  0003a	8a 01		 mov	 al, BYTE PTR [ecx]
  0003c	41		 inc	 ecx
  0003d	89 4d 10	 mov	 DWORD PTR _format$[ebp], ecx

; 288  : 
; 289  : 		/* Check for end of format string */
; 290  : 		if (chr == '\0') break;

  00040	84 c0		 test	 al, al
  00042	0f 84 e0 05 00
	00		 je	 $LN111@streamout

; 291  : 
; 292  : 		/* Check for 'normal' character or double % */
; 293  : 		if ((chr != ('%')) ||
; 294  : 			(chr = *format++) == ('%'))

  00048	3c 25		 cmp	 al, 37			; 00000025H
  0004a	0f 85 b6 05 00
	00		 jne	 $LN108@streamout
  00050	8b d1		 mov	 edx, ecx
  00052	8a 02		 mov	 al, BYTE PTR [edx]
  00054	42		 inc	 edx
  00055	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al
  00058	89 55 10	 mov	 DWORD PTR _format$[ebp], edx
  0005b	3c 25		 cmp	 al, 37			; 00000025H
  0005d	0f 84 a3 05 00
	00		 je	 $LN108@streamout

; 299  : 			continue;
; 300  : 		}
; 301  : 
; 302  : 		/* Handle flags */
; 303  : 		flags = 0;

  00063	33 db		 xor	 ebx, ebx
  00065	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
$LL106@streamout:

; 304  : 		while (1)
; 305  : 		{
; 306  : 			if (chr == ('-')) flags |= FLAG_ALIGN_LEFT;

  00068	3c 2d		 cmp	 al, 45			; 0000002dH
  0006a	75 08		 jne	 SHORT $LN104@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  0006c	8a 02		 mov	 al, BYTE PTR [edx]
  0006e	83 cb 01	 or	 ebx, 1
  00071	42		 inc	 edx

; 313  : 		}

  00072	eb f4		 jmp	 SHORT $LL106@streamout
$LN104@streamout:

; 307  : 			else if (chr == ('+')) flags |= FLAG_FORCE_SIGN;

  00074	3c 2b		 cmp	 al, 43			; 0000002bH
  00076	75 08		 jne	 SHORT $LN102@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00078	8a 02		 mov	 al, BYTE PTR [edx]
  0007a	83 cb 02	 or	 ebx, 2
  0007d	42		 inc	 edx

; 313  : 		}

  0007e	eb e8		 jmp	 SHORT $LL106@streamout
$LN102@streamout:

; 308  : 			else if (chr == (' ')) flags |= FLAG_FORCE_SIGNSP;

  00080	3c 20		 cmp	 al, 32			; 00000020H
  00082	75 08		 jne	 SHORT $LN100@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00084	8a 02		 mov	 al, BYTE PTR [edx]
  00086	83 cb 04	 or	 ebx, 4
  00089	42		 inc	 edx

; 313  : 		}

  0008a	eb dc		 jmp	 SHORT $LL106@streamout
$LN100@streamout:

; 309  : 			else if (chr == ('0')) flags |= FLAG_PAD_ZERO;

  0008c	3c 30		 cmp	 al, 48			; 00000030H
  0008e	75 08		 jne	 SHORT $LN98@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00090	8a 02		 mov	 al, BYTE PTR [edx]
  00092	83 cb 08	 or	 ebx, 8
  00095	42		 inc	 edx

; 313  : 		}

  00096	eb d0		 jmp	 SHORT $LL106@streamout
$LN98@streamout:

; 310  : 			else if (chr == ('#')) flags |= FLAG_SPECIAL;

  00098	3c 23		 cmp	 al, 35			; 00000023H
  0009a	75 08		 jne	 SHORT $LN96@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  0009c	8a 02		 mov	 al, BYTE PTR [edx]
  0009e	83 cb 10	 or	 ebx, 16			; 00000010H
  000a1	42		 inc	 edx

; 313  : 		}

  000a2	eb c4		 jmp	 SHORT $LL106@streamout
$LN96@streamout:

; 311  : 			else break;
; 312  : 			chr = *format++;

  000a4	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al
  000a7	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx

; 314  : 
; 315  : 		/* Handle field width modifier */
; 316  : 		if (chr == ('*'))

  000aa	3c 2a		 cmp	 al, 42			; 0000002aH
  000ac	75 25		 jne	 SHORT $LN94@streamout

; 317  : 		{
; 318  : 			fieldwidth = va_arg(argptr, int);

  000ae	8b 75 c0	 mov	 esi, DWORD PTR _argptr$GSCopy$[ebp]
  000b1	8b 06		 mov	 eax, DWORD PTR [esi]
  000b3	83 c6 04	 add	 esi, 4
  000b6	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  000b9	89 45 98	 mov	 DWORD PTR _fieldwidth$[ebp], eax

; 319  : 			if (fieldwidth < 0)

  000bc	85 c0		 test	 eax, eax
  000be	79 0b		 jns	 SHORT $LN93@streamout

; 320  : 			{
; 321  : 				flags |= FLAG_ALIGN_LEFT;

  000c0	83 cb 01	 or	 ebx, 1

; 322  : 				fieldwidth = -fieldwidth;

  000c3	f7 d8		 neg	 eax
  000c5	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
  000c8	89 45 98	 mov	 DWORD PTR _fieldwidth$[ebp], eax
$LN93@streamout:

; 323  : 			}
; 324  : 			chr = *format++;

  000cb	8a 02		 mov	 al, BYTE PTR [edx]
  000cd	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al
  000d0	42		 inc	 edx

; 325  : 		}
; 326  : 		else

  000d1	eb 2b		 jmp	 SHORT $LN90@streamout
$LN94@streamout:

; 327  : 		{
; 328  : 			fieldwidth = 0;

  000d3	33 c9		 xor	 ecx, ecx
  000d5	89 4d 98	 mov	 DWORD PTR _fieldwidth$[ebp], ecx

; 329  : 			while (chr >= ('0') && chr <= ('9'))

  000d8	3c 30		 cmp	 al, 48			; 00000030H
  000da	7c 1f		 jl	 SHORT $LN185@streamout
  000dc	8d 64 24 00	 npad	 4
$LL91@streamout:
  000e0	3c 39		 cmp	 al, 57			; 00000039H
  000e2	7f 11		 jg	 SHORT $LN203@streamout

; 330  : 			{
; 331  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000e4	0f be c0	 movsx	 eax, al
  000e7	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000ea	8d 4c 48 d0	 lea	 ecx, DWORD PTR [eax+ecx*2-48]

; 332  : 				chr = *format++;

  000ee	8a 02		 mov	 al, BYTE PTR [edx]
  000f0	42		 inc	 edx
  000f1	3c 30		 cmp	 al, 48			; 00000030H
  000f3	7d eb		 jge	 SHORT $LL91@streamout
$LN203@streamout:

; 330  : 			{
; 331  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000f5	89 4d 98	 mov	 DWORD PTR _fieldwidth$[ebp], ecx

; 332  : 				chr = *format++;

  000f8	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al
$LN185@streamout:

; 329  : 			while (chr >= ('0') && chr <= ('9'))

  000fb	8b 75 c0	 mov	 esi, DWORD PTR _argptr$GSCopy$[ebp]
$LN90@streamout:

; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 		/* Handle precision modifier */
; 337  : 		if (chr == '.')

  000fe	3c 2e		 cmp	 al, 46			; 0000002eH
  00100	75 4d		 jne	 SHORT $LN89@streamout

; 338  : 		{
; 339  : 			chr = *format++;

  00102	8a 02		 mov	 al, BYTE PTR [edx]
  00104	42		 inc	 edx
  00105	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al

; 340  : 
; 341  : 			if (chr == ('*'))

  00108	3c 2a		 cmp	 al, 42			; 0000002aH
  0010a	75 23		 jne	 SHORT $LN88@streamout

; 342  : 			{
; 343  : 				precision = va_arg(argptr, int);
; 344  : 				chr = *format++;

  0010c	8a 02		 mov	 al, BYTE PTR [edx]
  0010e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00110	83 c6 04	 add	 esi, 4
  00113	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00116	42		 inc	 edx
$LN204@streamout:

; 352  : 					chr = *format++;

  00117	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al
  0011a	89 4d c4	 mov	 DWORD PTR _precision$[ebp], ecx
  0011d	8d 49 00	 npad	 3
$LL83@streamout:

; 357  : 
; 358  : 		/* Handle argument size prefix */
; 359  : 		do
; 360  : 		{
; 361  : 			if (chr == ('h')) flags |= FLAG_SHORT;

  00120	3c 68		 cmp	 al, 104			; 00000068H
  00122	75 34		 jne	 SHORT $LN80@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00124	8a 02		 mov	 al, BYTE PTR [edx]
  00126	81 cb 00 01 00
	00		 or	 ebx, 256		; 00000100H
  0012c	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  0012d	eb f1		 jmp	 SHORT $LL83@streamout
$LN88@streamout:

; 345  : 			}
; 346  : 			else
; 347  : 			{
; 348  : 				precision = 0;

  0012f	33 c9		 xor	 ecx, ecx
  00131	89 4d c4	 mov	 DWORD PTR _precision$[ebp], ecx

; 349  : 				while (chr >= ('0') && chr <= ('9'))

  00134	3c 30		 cmp	 al, 48			; 00000030H
  00136	7c e8		 jl	 SHORT $LL83@streamout
$LL86@streamout:
  00138	3c 39		 cmp	 al, 57			; 00000039H
  0013a	7f db		 jg	 SHORT $LN204@streamout

; 350  : 				{
; 351  : 					precision = precision * 10 + (chr - ('0'));

  0013c	0f be c0	 movsx	 eax, al
  0013f	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00142	8d 4c 48 d0	 lea	 ecx, DWORD PTR [eax+ecx*2-48]

; 352  : 					chr = *format++;

  00146	8a 02		 mov	 al, BYTE PTR [edx]
  00148	42		 inc	 edx
  00149	3c 30		 cmp	 al, 48			; 00000030H
  0014b	7d eb		 jge	 SHORT $LL86@streamout

; 353  : 				}
; 354  : 			}

  0014d	eb c8		 jmp	 SHORT $LN204@streamout
$LN89@streamout:

; 355  : 		}
; 356  : 		else precision = -1;

  0014f	c7 45 c4 ff ff
	ff ff		 mov	 DWORD PTR _precision$[ebp], -1
  00156	eb c8		 jmp	 SHORT $LL83@streamout
$LN80@streamout:

; 362  : 			else if (chr == ('w')) flags |= FLAG_WIDECHAR;

  00158	3c 77		 cmp	 al, 119			; 00000077H
  0015a	75 0b		 jne	 SHORT $LN78@streamout
$LN71@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  0015c	8a 02		 mov	 al, BYTE PTR [edx]
  0015e	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  00164	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00165	eb b9		 jmp	 SHORT $LL83@streamout
$LN78@streamout:

; 363  : 			else if (chr == ('L')) flags |= 0; // FIXME: long double

  00167	3c 4c		 cmp	 al, 76			; 0000004cH
  00169	74 6d		 je	 SHORT $LN62@streamout

; 364  : 			else if (chr == ('F')) flags |= 0; // FIXME: what is that?

  0016b	3c 46		 cmp	 al, 70			; 00000046H
  0016d	74 69		 je	 SHORT $LN62@streamout

; 365  : 			else if (chr == ('l'))

  0016f	3c 6c		 cmp	 al, 108			; 0000006cH
  00171	75 10		 jne	 SHORT $LN72@streamout

; 366  : 			{
; 367  : 				/* Check if this is the 2nd 'l' in a row */
; 368  : 				if (format[-2] == 'l') flags |= FLAG_INT64;

  00173	38 42 fe	 cmp	 BYTE PTR [edx-2], al
  00176	75 e4		 jne	 SHORT $LN71@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00178	8a 02		 mov	 al, BYTE PTR [edx]
  0017a	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  00180	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00181	eb 9d		 jmp	 SHORT $LL83@streamout
$LN72@streamout:

; 369  : 				else flags |= FLAG_LONG;
; 370  : 			}
; 371  : 			else if (chr == ('I'))

  00183	3c 49		 cmp	 al, 73			; 00000049H
  00185	75 59		 jne	 SHORT $LN206@streamout

; 372  : 			{
; 373  : 				if (format[0] == ('3') && format[1] == ('2'))

  00187	8a 0a		 mov	 cl, BYTE PTR [edx]
  00189	80 f9 33	 cmp	 cl, 51			; 00000033H
  0018c	75 0f		 jne	 SHORT $LN67@streamout
  0018e	80 7a 01 32	 cmp	 BYTE PTR [edx+1], 50	; 00000032H
  00192	75 09		 jne	 SHORT $LN67@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00194	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00197	83 c2 02	 add	 edx, 2
  0019a	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  0019b	eb 83		 jmp	 SHORT $LL83@streamout
$LN67@streamout:

; 374  : 				{
; 375  : 					format += 2;
; 376  : 				}
; 377  : 				else if (format[0] == ('6') && format[1] == ('4'))

  0019d	80 f9 36	 cmp	 cl, 54			; 00000036H
  001a0	75 18		 jne	 SHORT $LN65@streamout
  001a2	80 7a 01 34	 cmp	 BYTE PTR [edx+1], 52	; 00000034H
  001a6	75 12		 jne	 SHORT $LN65@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001a8	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  001ab	83 c2 02	 add	 edx, 2
  001ae	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  001b4	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001b5	e9 66 ff ff ff	 jmp	 $LL83@streamout
$LN65@streamout:

; 378  : 				{
; 379  : 					format += 2;
; 380  : 					flags |= FLAG_INT64;
; 381  : 				}
; 382  : 				else if (format[0] == ('x') || format[0] == ('X') ||
; 383  : 					format[0] == ('d') || format[0] == ('i') ||
; 384  : 					format[0] == ('u') || format[0] == ('o'))

  001ba	80 f9 78	 cmp	 cl, 120			; 00000078H
  001bd	74 19		 je	 SHORT $LN62@streamout
  001bf	80 f9 58	 cmp	 cl, 88			; 00000058H
  001c2	74 14		 je	 SHORT $LN62@streamout
  001c4	80 f9 64	 cmp	 cl, 100			; 00000064H
  001c7	74 0f		 je	 SHORT $LN62@streamout
  001c9	80 f9 69	 cmp	 cl, 105			; 00000069H
  001cc	74 0a		 je	 SHORT $LN62@streamout
  001ce	80 f9 75	 cmp	 cl, 117			; 00000075H
  001d1	74 05		 je	 SHORT $LN62@streamout
  001d3	80 f9 6f	 cmp	 cl, 111			; 0000006fH
  001d6	75 08		 jne	 SHORT $LN206@streamout
$LN62@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001d8	8a 02		 mov	 al, BYTE PTR [edx]
  001da	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001db	e9 40 ff ff ff	 jmp	 $LL83@streamout
$LN206@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001e0	88 45 b0	 mov	 BYTE PTR _chr$[ebp], al

; 398  : 		base = 10;
; 399  : 		prefix = 0;
; 400  : 		switch (chr)

  001e3	0f be c0	 movsx	 eax, al
  001e6	8d 7d f9	 lea	 edi, DWORD PTR _buffer$[ebp+49]
  001e9	83 c0 bf	 add	 eax, -65		; ffffffbfH
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?digits_l@?1??streamout@@9@9
  001f1	89 7d b8	 mov	 DWORD PTR _string$[ebp], edi
  001f4	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
  001f7	89 55 10	 mov	 DWORD PTR _format$[ebp], edx
  001fa	89 4d 94	 mov	 DWORD PTR _digits$[ebp], ecx
  001fd	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00202	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], 0
  00209	83 f8 37	 cmp	 eax, 55			; 00000037H
  0020c	0f 87 ee 03 00
	00		 ja	 $LN22@streamout
  00212	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN169@streamout[eax]
  00219	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN218@streamout[eax*4]
$LN57@streamout:

; 401  : 		{
; 402  : 		case ('n'):
; 403  : 			if (flags & FLAG_INT64)
; 404  : 				*va_arg(argptr, __int64*) = written_all;

  00220	83 c6 04	 add	 esi, 4
  00223	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00226	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  0022c	74 11		 je	 SHORT $LN56@streamout
  0022e	8b 45 bc	 mov	 eax, DWORD PTR _written_all$[ebp]
  00231	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00234	99		 cdq
  00235	89 06		 mov	 DWORD PTR [esi], eax
  00237	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0023a	e9 df 03 00 00	 jmp	 $LN152@streamout
$LN56@streamout:

; 405  : 			else if (flags & FLAG_SHORT)

  0023f	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00245	74 0f		 je	 SHORT $LN54@streamout

; 406  : 				*va_arg(argptr, short*) = (short)written_all;

  00247	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  0024a	66 8b 55 bc	 mov	 dx, WORD PTR _written_all$[ebp]
  0024e	66 89 11	 mov	 WORD PTR [ecx], dx

; 407  : 			else

  00251	e9 c8 03 00 00	 jmp	 $LN152@streamout
$LN54@streamout:

; 408  : 				*va_arg(argptr, int*) = written_all;

  00256	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00259	8b 4d bc	 mov	 ecx, DWORD PTR _written_all$[ebp]
  0025c	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 			continue;

  0025e	e9 bb 03 00 00	 jmp	 $LN152@streamout
$LN52@streamout:

; 410  : 
; 411  : 		case ('C'):
; 412  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  00263	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00269	75 09		 jne	 SHORT $case_char$2519
  0026b	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  00271	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
$case_char$2519:

; 413  : 			goto case_char;
; 414  : 
; 415  : 		case ('c'):
; 416  : case_char:
; 417  : 			string = buffer;
; 418  : 			len = 1;
; 419  :  			if (flags & FLAG_WIDECHAR)
; 420  :  			{
; 421  :  				((wchar_t*)string)[0] = (wchar_t)va_arg(argptr, int);

  00274	83 c6 04	 add	 esi, 4
  00277	8d 55 c8	 lea	 edx, DWORD PTR _buffer$[ebp]
  0027a	89 55 b8	 mov	 DWORD PTR _string$[ebp], edx
  0027d	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  00284	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00287	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  0028d	74 65		 je	 SHORT $LN49@streamout
  0028f	66 8b 46 fc	 mov	 ax, WORD PTR [esi-4]

; 422  :  				((wchar_t*)string)[1] = (wchar_t)('\0');

  00293	33 c9		 xor	 ecx, ecx
  00295	66 89 45 c8	 mov	 WORD PTR _buffer$[ebp], ax
  00299	66 89 4d ca	 mov	 WORD PTR _buffer$[ebp+2], cx
$LN199@streamout:

; 547  : 		}
; 548  : 
; 549  : 		/* Calculate padding */
; 550  : 		prefixlen = prefix ? strlen(prefix) : 0;

  0029d	33 db		 xor	 ebx, ebx
$LN124@streamout:

; 551  : 		if (precision < 0) precision = 0;

  0029f	8b 45 c4	 mov	 eax, DWORD PTR _precision$[ebp]
  002a2	85 c0		 test	 eax, eax
  002a4	79 05		 jns	 SHORT $LN21@streamout
  002a6	33 c0		 xor	 eax, eax
  002a8	89 45 c4	 mov	 DWORD PTR _precision$[ebp], eax
$LN21@streamout:

; 552  : 		padding = (int)(fieldwidth - len - prefixlen - precision);

  002ab	8b 75 98	 mov	 esi, DWORD PTR _fieldwidth$[ebp]
  002ae	2b f3		 sub	 esi, ebx
  002b0	2b 75 a8	 sub	 esi, DWORD PTR _len$[ebp]
  002b3	2b f0		 sub	 esi, eax

; 553  : 		if (padding < 0) padding = 0;

  002b5	79 02		 jns	 SHORT $LN20@streamout
  002b7	33 f6		 xor	 esi, esi
$LN20@streamout:

; 554  : 
; 555  : 		/* Optional left space padding */
; 556  : 		if ((flags & (FLAG_ALIGN_LEFT | FLAG_PAD_ZERO)) == 0)

  002b9	f6 45 b4 09	 test	 BYTE PTR _flags$[ebp], 9
  002bd	0f 85 6d 02 00
	00		 jne	 $LN187@streamout

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  002c3	85 f6		 test	 esi, esi
  002c5	0f 8e 65 02 00
	00		 jle	 $LN187@streamout
  002cb	8b 7d 9c	 mov	 edi, DWORD PTR _out$GSCopy$[ebp]
  002ce	8b ff		 npad	 2
$LL18@streamout:

; 559  : 			{
; 560  : 				if ((written = streamout_char(out, &cnt, (' '))) == 0) return -1;

  002d0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002d5	8d 55 a0	 lea	 edx, DWORD PTR _cnt$[ebp]
  002d8	8b cf		 mov	 ecx, edi
  002da	e8 00 00 00 00	 call	 _streamout_char
  002df	85 c0		 test	 eax, eax
  002e1	0f 84 5d 03 00
	00		 je	 $LN143@streamout

; 561  : 				written_all += written;

  002e7	01 45 bc	 add	 DWORD PTR _written_all$[ebp], eax
  002ea	4e		 dec	 esi
  002eb	85 f6		 test	 esi, esi
  002ed	7f e1		 jg	 SHORT $LL18@streamout

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  002ef	e9 3f 02 00 00	 jmp	 $LN189@streamout
$LN49@streamout:

; 423  :  			}
; 424  :  			else
; 425  :  			{
; 426  : 				((char*)string)[0] = (char)va_arg(argptr, int);

  002f4	8a 56 fc	 mov	 dl, BYTE PTR [esi-4]
  002f7	88 55 c8	 mov	 BYTE PTR _buffer$[ebp], dl

; 427  : 				((char*)string)[1] = (char)('\0');

  002fa	c6 45 c9 00	 mov	 BYTE PTR _buffer$[ebp+1], 0

; 428  : 			}
; 429  : 			break;

  002fe	eb 9d		 jmp	 SHORT $LN199@streamout
$LN47@streamout:

; 430  : 
; 431  : 		case ('Z'):
; 432  : 			nt_string = va_arg(argptr, void*);

  00300	83 c6 04	 add	 esi, 4
  00303	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00306	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]

; 433  : 			if (nt_string && (string = nt_string->Buffer))

  00309	85 f6		 test	 esi, esi
  0030b	74 53		 je	 SHORT $LN163@streamout
  0030d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00310	89 45 b8	 mov	 DWORD PTR _string$[ebp], eax
  00313	85 c0		 test	 eax, eax
  00315	74 49		 je	 SHORT $LN163@streamout

; 434  : 			{
; 435  : 				len = nt_string->Length;

  00317	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0031a	89 45 a8	 mov	 DWORD PTR _len$[ebp], eax

; 436  : 				if (flags & FLAG_WIDECHAR) len /= sizeof(wchar_t);

  0031d	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00323	0f 84 74 ff ff
	ff		 je	 $LN199@streamout
  00329	d1 6d a8	 shr	 DWORD PTR _len$[ebp], 1

; 437  : 				break;

  0032c	e9 6c ff ff ff	 jmp	 $LN199@streamout
$LN44@streamout:

; 438  : 			}
; 439  : 			string = 0;
; 440  : 			goto case_string;
; 441  : 
; 442  : 		case ('S'):
; 443  : 			string = va_arg(argptr, void*);

  00331	83 c6 04	 add	 esi, 4
  00334	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00337	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  0033a	89 75 b8	 mov	 DWORD PTR _string$[ebp], esi

; 444  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  0033d	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00343	75 17		 jne	 SHORT $case_string$2556
  00345	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  0034b	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx

; 445  : 			goto case_string;

  0034e	eb 0c		 jmp	 SHORT $case_string$2556
$LN42@streamout:

; 446  : 
; 447  : 		case ('s'):
; 448  : 			string = va_arg(argptr, void*);

  00350	83 c6 04	 add	 esi, 4
  00353	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00356	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00359	89 75 b8	 mov	 DWORD PTR _string$[ebp], esi
$case_string$2556:

; 449  : 
; 450  : case_string:
; 451  : 			if (!string)

  0035c	85 f6		 test	 esi, esi
  0035e	75 12		 jne	 SHORT $LN200@streamout
$LN163@streamout:

; 452  : 			{
; 453  : 				string = (char*)_nullstring;

  00360	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_nullstring@?1??streamout@@9@9

; 454  : 				flags &= ~FLAG_WIDECHAR;

  00366	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  0036c	89 75 b8	 mov	 DWORD PTR _string$[ebp], esi
  0036f	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
$LN200@streamout:

; 455  : 			}
; 456  : 
; 457  : // 			if (flags & FLAG_WIDECHAR)
; 458  : // 				len = wcsnlen((wchar_t*)string, (unsigned)precision);
; 459  : // 			else
; 460  : 				len = strlen((char*)string);

  00372	8b c6		 mov	 eax, esi
  00374	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL170@streamout:
  00377	8a 08		 mov	 cl, BYTE PTR [eax]
  00379	40		 inc	 eax
  0037a	84 c9		 test	 cl, cl
  0037c	75 f9		 jne	 SHORT $LL170@streamout
  0037e	2b c2		 sub	 eax, edx
  00380	89 45 a8	 mov	 DWORD PTR _len$[ebp], eax

; 461  : 			precision = 0;

  00383	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 0

; 462  : 			break;

  0038a	e9 0e ff ff ff	 jmp	 $LN199@streamout
$LN40@streamout:

; 463  : 
; 464  : 		case ('G'):
; 465  : 		case ('E'):
; 466  : 		case ('A'):
; 467  : 		case ('g'):
; 468  : 		case ('e'):
; 469  : 		case ('a'):
; 470  : 		case ('f'):
; 471  : #ifdef _UNICODE
; 472  : 			flags |= FLAG_WIDECHAR;
; 473  : #else
; 474  : 			flags &= ~FLAG_WIDECHAR;
; 475  : #endif
; 476  : 			/* Use external function, one for kernel one for user mode */
; 477  : 			format_float(chr, flags, precision, &string, &prefix, &argptr);

  0038f	8d 4d c0	 lea	 ecx, DWORD PTR _argptr$GSCopy$[ebp]
  00392	51		 push	 ecx
  00393	8b 4d c4	 mov	 ecx, DWORD PTR _precision$[ebp]
  00396	8d 55 ac	 lea	 edx, DWORD PTR _prefix$[ebp]
  00399	52		 push	 edx
  0039a	8b 55 b0	 mov	 edx, DWORD PTR _chr$[ebp]
  0039d	8d 45 b8	 lea	 eax, DWORD PTR _string$[ebp]
  003a0	50		 push	 eax
  003a1	51		 push	 ecx
  003a2	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  003a8	53		 push	 ebx
  003a9	52		 push	 edx
  003aa	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
  003ad	e8 00 00 00 00	 call	 _format_float

; 478  : 			len = strlen(string);

  003b2	8b 45 b8	 mov	 eax, DWORD PTR _string$[ebp]
  003b5	83 c4 18	 add	 esp, 24			; 00000018H
  003b8	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  003bb	eb 03 8d 49 00	 npad	 5
$LL171@streamout:
  003c0	8a 08		 mov	 cl, BYTE PTR [eax]
  003c2	40		 inc	 eax
  003c3	84 c9		 test	 cl, cl
  003c5	75 f9		 jne	 SHORT $LL171@streamout

; 479  : 			precision = 0;

  003c7	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 0

; 480  : 			break;

  003ce	e9 34 01 00 00	 jmp	 $LN216@streamout
$LN39@streamout:

; 481  : 
; 482  : 		case ('d'):
; 483  : 		case ('i'):
; 484  : 			val64 = (__int64)va_arg_f(argptr, flags);

  003d3	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  003d9	74 0d		 je	 SHORT $LN117@streamout
  003db	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003dd	83 c6 08	 add	 esi, 8
  003e0	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  003e3	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  003e6	eb 1c		 jmp	 SHORT $LN118@streamout
$LN117@streamout:
  003e8	83 c6 04	 add	 esi, 4
  003eb	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  003ee	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  003f4	74 06		 je	 SHORT $LN115@streamout
  003f6	0f bf 46 fc	 movsx	 eax, WORD PTR [esi-4]
  003fa	eb 03		 jmp	 SHORT $LN116@streamout
$LN115@streamout:
  003fc	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
$LN116@streamout:
  003ff	99		 cdq
  00400	8b c8		 mov	 ecx, eax
  00402	8b f2		 mov	 esi, edx
$LN118@streamout:

; 485  : 
; 486  : 			if ((__int64)val64 < 0)

  00404	85 f6		 test	 esi, esi
  00406	7f 19		 jg	 SHORT $LN38@streamout
  00408	7c 04		 jl	 SHORT $LN172@streamout
  0040a	85 c9		 test	 ecx, ecx
  0040c	73 13		 jae	 SHORT $LN38@streamout
$LN172@streamout:

; 487  : 			{
; 488  : 				val64 = -(__int64)val64;

  0040e	f7 d9		 neg	 ecx
  00410	83 d6 00	 adc	 esi, 0
  00413	f7 de		 neg	 esi

; 489  : 				prefix = ("-");

  00415	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2605
  0041c	e9 8a 00 00 00	 jmp	 $case_number$2612
$LN38@streamout:

; 490  : 			}
; 491  : 			else if (flags & FLAG_FORCE_SIGN)

  00421	f6 c3 02	 test	 bl, 2
  00424	74 0c		 je	 SHORT $LN36@streamout

; 492  : 				prefix = ("+");

  00426	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2608
  0042d	e9 79 00 00 00	 jmp	 $case_number$2612
$LN36@streamout:

; 493  : 			else if (flags & FLAG_FORCE_SIGNSP)

  00432	f6 c3 04	 test	 bl, 4
  00435	74 74		 je	 SHORT $case_number$2612

; 494  : 				prefix = (" ");

  00437	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2611

; 495  : 
; 496  : 			goto case_number;

  0043e	eb 6b		 jmp	 SHORT $case_number$2612
$LN33@streamout:

; 497  : 
; 498  : 		case ('o'):
; 499  : 			base = 8;

  00440	bf 08 00 00 00	 mov	 edi, 8

; 500  : 			if (flags & FLAG_SPECIAL)

  00445	f6 c3 10	 test	 bl, 16			; 00000010H
  00448	74 33		 je	 SHORT $case_unsigned$2617

; 501  : 			{
; 502  : 				prefix = ("0");
; 503  : 				if (precision > 0) precision--;

  0044a	83 7d c4 00	 cmp	 DWORD PTR _precision$[ebp], 0
  0044e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2615
  00455	7e 26		 jle	 SHORT $case_unsigned$2617
  00457	ff 4d c4	 dec	 DWORD PTR _precision$[ebp]

; 504  : 			}
; 505  : 			goto case_unsigned;

  0045a	eb 21		 jmp	 SHORT $case_unsigned$2617
$LN30@streamout:

; 506  : 
; 507  : 		case ('p'):
; 508  : 			precision = 2 * sizeof(void*);

  0045c	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 8

; 509  : 			flags &= ~FLAG_PAD_ZERO;

  00463	83 e3 f7	 and	 ebx, -9			; fffffff7H
$LN192@streamout:

; 510  : 			flags |= FLAG_INTPTR;
; 511  : 			/* Fall through */
; 512  : 
; 513  : 		case ('X'):
; 514  : 			digits = digits_u;

  00466	b9 00 00 00 00	 mov	 ecx, OFFSET ?digits_u@?1??streamout@@9@9
  0046b	89 4d 94	 mov	 DWORD PTR _digits$[ebp], ecx
$LN193@streamout:

; 515  : 			/* Fall through */
; 516  : 
; 517  : 		case ('x'):
; 518  : 			base = 16;

  0046e	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 519  : 			if (flags & FLAG_SPECIAL)

  00473	f6 c3 10	 test	 bl, 16			; 00000010H
  00476	74 05		 je	 SHORT $case_unsigned$2617

; 520  : 			{
; 521  : 				prefix = &digits[16];

  00478	03 cf		 add	 ecx, edi
  0047a	89 4d ac	 mov	 DWORD PTR _prefix$[ebp], ecx
$case_unsigned$2617:

; 522  : 			}
; 523  : 
; 524  : 		case ('u'):
; 525  : case_unsigned:
; 526  : 			val64 = va_arg_fu(argptr, flags);

  0047d	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00483	74 0d		 je	 SHORT $LN121@streamout
  00485	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00487	83 c6 08	 add	 esi, 8
  0048a	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  0048d	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00490	eb 19		 jmp	 SHORT $case_number$2612
$LN121@streamout:
  00492	83 c6 04	 add	 esi, 4
  00495	89 75 c0	 mov	 DWORD PTR _argptr$GSCopy$[ebp], esi
  00498	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0049e	74 06		 je	 SHORT $LN119@streamout
  004a0	0f b7 4e fc	 movzx	 ecx, WORD PTR [esi-4]
  004a4	eb 03		 jmp	 SHORT $LN120@streamout
$LN119@streamout:
  004a6	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
$LN120@streamout:
  004a9	33 f6		 xor	 esi, esi
$case_number$2612:

; 527  : 
; 528  : case_number:
; 529  : 			flags &= ~FLAG_WIDECHAR;

  004ab	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH

; 530  : 			if (precision < 0) precision = 1;

  004b1	83 7d c4 00	 cmp	 DWORD PTR _precision$[ebp], 0
  004b5	89 5d b4	 mov	 DWORD PTR _flags$[ebp], ebx
  004b8	7d 07		 jge	 SHORT $LN133@streamout
  004ba	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 1
$LN133@streamout:

; 531  : 
; 532  : 			/* Gather digits in reverse order */
; 533  : 			while (val64)

  004c1	8b c1		 mov	 eax, ecx
  004c3	0b c6		 or	 eax, esi
  004c5	74 33		 je	 SHORT $LN23@streamout
  004c7	8b c7		 mov	 eax, edi
  004c9	99		 cdq
  004ca	8b f8		 mov	 edi, eax
  004cc	89 55 90	 mov	 DWORD PTR tv600[ebp+4], edx
  004cf	90		 npad	 1
$LL24@streamout:

; 534  : 			{
; 535  : 				*--string = digits[val64 % base];

  004d0	8b 55 90	 mov	 edx, DWORD PTR tv600[ebp+4]
  004d3	ff 4d b8	 dec	 DWORD PTR _string$[ebp]
  004d6	52		 push	 edx
  004d7	57		 push	 edi
  004d8	56		 push	 esi
  004d9	51		 push	 ecx
  004da	e8 00 00 00 00	 call	 __aulldvrm
  004df	8b 75 94	 mov	 esi, DWORD PTR _digits$[ebp]
  004e2	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  004e5	8b 75 b8	 mov	 esi, DWORD PTR _string$[ebp]

; 536  : 				val64 /= base;
; 537  : 				precision--;

  004e8	ff 4d c4	 dec	 DWORD PTR _precision$[ebp]
  004eb	88 0e		 mov	 BYTE PTR [esi], cl
  004ed	8b c8		 mov	 ecx, eax
  004ef	8b f2		 mov	 esi, edx
  004f1	8b d1		 mov	 edx, ecx
  004f3	0b d6		 or	 edx, esi
  004f5	89 5d a8	 mov	 DWORD PTR tv87[ebp+4], ebx
  004f8	75 d6		 jne	 SHORT $LL24@streamout
$LN23@streamout:

; 538  : 			}
; 539  : 
; 540  : 			len = strlen(string);

  004fa	8b 45 b8	 mov	 eax, DWORD PTR _string$[ebp]
  004fd	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL173@streamout:
  00500	8a 08		 mov	 cl, BYTE PTR [eax]
  00502	40		 inc	 eax
  00503	84 c9		 test	 cl, cl
  00505	75 f9		 jne	 SHORT $LL173@streamout
$LN216@streamout:
  00507	2b c2		 sub	 eax, edx
  00509	89 45 a8	 mov	 DWORD PTR _len$[ebp], eax

; 547  : 		}
; 548  : 
; 549  : 		/* Calculate padding */
; 550  : 		prefixlen = prefix ? strlen(prefix) : 0;

  0050c	8b 45 ac	 mov	 eax, DWORD PTR _prefix$[ebp]
  0050f	85 c0		 test	 eax, eax
  00511	0f 84 86 fd ff
	ff		 je	 $LN199@streamout
  00517	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0051a	8d 9b 00 00 00
	00		 npad	 6
$LL174@streamout:
  00520	8a 08		 mov	 cl, BYTE PTR [eax]
  00522	40		 inc	 eax
  00523	84 c9		 test	 cl, cl
  00525	75 f9		 jne	 SHORT $LL174@streamout
  00527	2b c2		 sub	 eax, edx
  00529	8b d8		 mov	 ebx, eax
  0052b	e9 6f fd ff ff	 jmp	 $LN124@streamout
$LN187@streamout:

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  00530	8b 7d 9c	 mov	 edi, DWORD PTR _out$GSCopy$[ebp]
$LN189@streamout:

; 562  : 			}
; 563  : 		}
; 564  : 
; 565  : 		/* Optional prefix */
; 566  : 		if (prefix)

  00533	83 7d ac 00	 cmp	 DWORD PTR _prefix$[ebp], 0
  00537	74 1e		 je	 SHORT $LN14@streamout

; 567  : 		{
; 568  : 			written = streamout_string(out, &cnt, prefix, prefixlen);

  00539	8b 4d ac	 mov	 ecx, DWORD PTR _prefix$[ebp]
  0053c	8d 45 a0	 lea	 eax, DWORD PTR _cnt$[ebp]
  0053f	50		 push	 eax
  00540	57		 push	 edi
  00541	8b c3		 mov	 eax, ebx
  00543	e8 00 00 00 00	 call	 _streamout_astring
  00548	83 c4 08	 add	 esp, 8

; 569  : 			if (written == -1) return -1;

  0054b	83 f8 ff	 cmp	 eax, -1
  0054e	0f 84 f0 00 00
	00		 je	 $LN143@streamout

; 570  : 			written_all += written;

  00554	01 45 bc	 add	 DWORD PTR _written_all$[ebp], eax
$LN14@streamout:

; 571  : 		}
; 572  : 
; 573  : 		/* Optional left '0' padding */
; 574  : 		if ((flags & FLAG_ALIGN_LEFT) == 0) precision += padding;

  00557	8b 5d b4	 mov	 ebx, DWORD PTR _flags$[ebp]
  0055a	83 e3 01	 and	 ebx, 1
  0055d	89 5d 94	 mov	 DWORD PTR tv621[ebp], ebx
  00560	75 03		 jne	 SHORT $LN190@streamout
  00562	01 75 c4	 add	 DWORD PTR _precision$[ebp], esi
$LN190@streamout:

; 575  : 		while (precision-- > 0)

  00565	83 7d c4 00	 cmp	 DWORD PTR _precision$[ebp], 0
  00569	7e 28		 jle	 SHORT $LN148@streamout
  0056b	eb 03 8d 49 00	 npad	 5
$LL11@streamout:
  00570	ff 4d c4	 dec	 DWORD PTR _precision$[ebp]

; 576  : 		{
; 577  : 			if ((written = streamout_char(out, &cnt, ('0'))) == 0) return -1;

  00573	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00578	8d 55 a0	 lea	 edx, DWORD PTR _cnt$[ebp]
  0057b	8b cf		 mov	 ecx, edi
  0057d	e8 00 00 00 00	 call	 _streamout_char
  00582	85 c0		 test	 eax, eax
  00584	0f 84 ba 00 00
	00		 je	 $LN143@streamout

; 578  : 			written_all += written;

  0058a	01 45 bc	 add	 DWORD PTR _written_all$[ebp], eax
  0058d	83 7d c4 00	 cmp	 DWORD PTR _precision$[ebp], 0
  00591	7f dd		 jg	 SHORT $LL11@streamout
$LN148@streamout:

; 579  : 		}
; 580  : 
; 581  : 		/* Output the string */
; 582  : 		if (flags & FLAG_WIDECHAR)

  00593	f7 45 b4 00 02
	00 00		 test	 DWORD PTR _flags$[ebp], 512 ; 00000200H

; 583  : 			written = streamout_wstring(out, &cnt, (wchar_t*)string, len);

  0059a	8b 45 a8	 mov	 eax, DWORD PTR _len$[ebp]
  0059d	74 17		 je	 SHORT $LN8@streamout
  0059f	8b 7d 9c	 mov	 edi, DWORD PTR _out$GSCopy$[ebp]
  005a2	8b 4d b8	 mov	 ecx, DWORD PTR _string$[ebp]
  005a5	57		 push	 edi
  005a6	8d 5d a0	 lea	 ebx, DWORD PTR _cnt$[ebp]
  005a9	e8 00 00 00 00	 call	 _streamout_wstring

; 584  : 		else

  005ae	8b 5d 94	 mov	 ebx, DWORD PTR tv621[ebp]
  005b1	83 c4 04	 add	 esp, 4
  005b4	eb 13		 jmp	 SHORT $LN217@streamout
$LN8@streamout:

; 585  : 			written = streamout_astring(out, &cnt, (char*)string, len);

  005b6	8d 4d a0	 lea	 ecx, DWORD PTR _cnt$[ebp]
  005b9	51		 push	 ecx
  005ba	8b 4d b8	 mov	 ecx, DWORD PTR _string$[ebp]
  005bd	57		 push	 edi
  005be	e8 00 00 00 00	 call	 _streamout_astring
  005c3	8b 7d 9c	 mov	 edi, DWORD PTR _out$GSCopy$[ebp]
  005c6	83 c4 08	 add	 esp, 8
$LN217@streamout:
  005c9	89 45 a8	 mov	 DWORD PTR _written$[ebp], eax

; 586  : 		if (written == -1) return -1;

  005cc	83 f8 ff	 cmp	 eax, -1
  005cf	74 73		 je	 SHORT $LN143@streamout

; 587  : 		written_all += written;

  005d1	01 45 bc	 add	 DWORD PTR _written_all$[ebp], eax

; 588  : 
; 589  : #if 0 && SUPPORT_FLOAT
; 590  : 		/* Optional right '0' padding */
; 591  : 		while (precision-- > 0)
; 592  : 		{
; 593  : 			if ((written = streamout_char(out, &cnt, ('0'))) == 0) return -1;
; 594  : 			written_all += written;
; 595  : 			len++;
; 596  : 		}
; 597  : #endif
; 598  : 
; 599  : 		/* Optional right padding */
; 600  : 		if (flags & FLAG_ALIGN_LEFT)

  005d4	85 db		 test	 ebx, ebx
  005d6	74 46		 je	 SHORT $LN152@streamout

; 601  : 		{
; 602  : 			while (padding-- > 0)

  005d8	85 f6		 test	 esi, esi
  005da	7e 42		 jle	 SHORT $LN152@streamout
  005dc	8d 64 24 00	 npad	 4
$LL4@streamout:

; 603  : 			{
; 604  : 				if ((written = streamout_char(out, &cnt, (' '))) == 0) return -1;

  005e0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  005e5	8d 55 a0	 lea	 edx, DWORD PTR _cnt$[ebp]
  005e8	8b cf		 mov	 ecx, edi
  005ea	4e		 dec	 esi
  005eb	e8 00 00 00 00	 call	 _streamout_char
  005f0	89 45 a8	 mov	 DWORD PTR _written$[ebp], eax
  005f3	85 c0		 test	 eax, eax
  005f5	74 4d		 je	 SHORT $LN143@streamout

; 605  : 				written_all += written;

  005f7	01 45 bc	 add	 DWORD PTR _written_all$[ebp], eax
  005fa	85 f6		 test	 esi, esi
  005fc	7f e2		 jg	 SHORT $LL4@streamout

; 606  : 			}
; 607  : 		}
; 608  : 
; 609  : 	}

  005fe	eb 1e		 jmp	 SHORT $LN152@streamout
$LN22@streamout:

; 541  : 			break;
; 542  : 
; 543  : 		default:
; 544  : 			/* Treat anything else as a new character */
; 545  : 			format--;

  00600	4a		 dec	 edx
  00601	89 55 10	 mov	 DWORD PTR _format$[ebp], edx

; 546  : 			continue;

  00604	eb 18		 jmp	 SHORT $LN152@streamout
$LN108@streamout:

; 295  : 		{
; 296  : 			/* Write the character to the stream */
; 297  : 			if ((written = streamout_char(out, &cnt, chr)) == 0) return -1;

  00606	8b 4d 9c	 mov	 ecx, DWORD PTR _out$GSCopy$[ebp]
  00609	0f be c0	 movsx	 eax, al
  0060c	8d 55 a0	 lea	 edx, DWORD PTR _cnt$[ebp]
  0060f	e8 00 00 00 00	 call	 _streamout_char
  00614	89 45 a8	 mov	 DWORD PTR _written$[ebp], eax
  00617	85 c0		 test	 eax, eax
  00619	74 29		 je	 SHORT $LN143@streamout

; 298  : 			written_all += written;

  0061b	01 45 bc	 add	 DWORD PTR _written_all$[ebp], eax
$LN152@streamout:

; 269  : 	static const char digits_l[] = "0123456789abcdef0x";
; 270  : 	static const char digits_u[] = "0123456789ABCDEF0X";
; 271  : 	static const char *_nullstring = "(null)";
; 272  : 	char buffer[BUFFER_SIZE + 1];
; 273  : 	uint32_t cnt = size;
; 274  : 	char chr, *string;
; 275  : 	STRING *nt_string;
; 276  : 	const char *digits, *prefix;
; 277  : 	int base, fieldwidth, precision, padding;
; 278  : 	size_t prefixlen, len;
; 279  : 	int written = 1, written_all = 0;
; 280  : 	unsigned int flags;
; 281  : 	unsigned __int64 val64;
; 282  : 
; 283  : 	buffer[BUFFER_SIZE] = '\0';
; 284  : 
; 285  : 	while (written >= 0)

  0061e	83 7d a8 00	 cmp	 DWORD PTR _written$[ebp], 0
  00622	0f 8d 0f fa ff
	ff		 jge	 $LL112@streamout
$LN111@streamout:

; 610  : 
; 611  : 	if (written == -1) return -1;

  00628	83 c8 ff	 or	 eax, -1
  0062b	39 45 a8	 cmp	 DWORD PTR _written$[ebp], eax
  0062e	74 03		 je	 SHORT $LN113@streamout

; 612  : 
; 613  : 	return written_all;

  00630	8b 45 bc	 mov	 eax, DWORD PTR _written_all$[ebp]
$LN113@streamout:
  00633	5f		 pop	 edi
  00634	5e		 pop	 esi
  00635	5b		 pop	 ebx

; 614  : }

  00636	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00639	33 cd		 xor	 ecx, ebp
  0063b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00640	8b e5		 mov	 esp, ebp
  00642	5d		 pop	 ebp
  00643	c3		 ret	 0
$LN143@streamout:
  00644	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00647	5f		 pop	 edi
  00648	5e		 pop	 esi
  00649	33 cd		 xor	 ecx, ebp
  0064b	83 c8 ff	 or	 eax, -1
  0064e	5b		 pop	 ebx
  0064f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00654	8b e5		 mov	 esp, ebp
  00656	5d		 pop	 ebp
  00657	c3		 ret	 0
$LN218@streamout:
  00658	00 00 00 00	 DD	 $LN40@streamout
  0065c	00 00 00 00	 DD	 $LN52@streamout
  00660	00 00 00 00	 DD	 $LN44@streamout
  00664	00 00 00 00	 DD	 $LN192@streamout
  00668	00 00 00 00	 DD	 $LN47@streamout
  0066c	00 00 00 00	 DD	 $case_char$2519
  00670	00 00 00 00	 DD	 $LN39@streamout
  00674	00 00 00 00	 DD	 $LN57@streamout
  00678	00 00 00 00	 DD	 $LN33@streamout
  0067c	00 00 00 00	 DD	 $LN30@streamout
  00680	00 00 00 00	 DD	 $LN42@streamout
  00684	00 00 00 00	 DD	 $case_unsigned$2617
  00688	00 00 00 00	 DD	 $LN193@streamout
  0068c	00 00 00 00	 DD	 $LN22@streamout
$LN169@streamout:
  00690	00		 DB	 0
  00691	0d		 DB	 13			; 0000000dH
  00692	01		 DB	 1
  00693	0d		 DB	 13			; 0000000dH
  00694	00		 DB	 0
  00695	0d		 DB	 13			; 0000000dH
  00696	00		 DB	 0
  00697	0d		 DB	 13			; 0000000dH
  00698	0d		 DB	 13			; 0000000dH
  00699	0d		 DB	 13			; 0000000dH
  0069a	0d		 DB	 13			; 0000000dH
  0069b	0d		 DB	 13			; 0000000dH
  0069c	0d		 DB	 13			; 0000000dH
  0069d	0d		 DB	 13			; 0000000dH
  0069e	0d		 DB	 13			; 0000000dH
  0069f	0d		 DB	 13			; 0000000dH
  006a0	0d		 DB	 13			; 0000000dH
  006a1	0d		 DB	 13			; 0000000dH
  006a2	02		 DB	 2
  006a3	0d		 DB	 13			; 0000000dH
  006a4	0d		 DB	 13			; 0000000dH
  006a5	0d		 DB	 13			; 0000000dH
  006a6	0d		 DB	 13			; 0000000dH
  006a7	03		 DB	 3
  006a8	0d		 DB	 13			; 0000000dH
  006a9	04		 DB	 4
  006aa	0d		 DB	 13			; 0000000dH
  006ab	0d		 DB	 13			; 0000000dH
  006ac	0d		 DB	 13			; 0000000dH
  006ad	0d		 DB	 13			; 0000000dH
  006ae	0d		 DB	 13			; 0000000dH
  006af	0d		 DB	 13			; 0000000dH
  006b0	00		 DB	 0
  006b1	0d		 DB	 13			; 0000000dH
  006b2	05		 DB	 5
  006b3	06		 DB	 6
  006b4	00		 DB	 0
  006b5	00		 DB	 0
  006b6	00		 DB	 0
  006b7	0d		 DB	 13			; 0000000dH
  006b8	06		 DB	 6
  006b9	0d		 DB	 13			; 0000000dH
  006ba	0d		 DB	 13			; 0000000dH
  006bb	0d		 DB	 13			; 0000000dH
  006bc	0d		 DB	 13			; 0000000dH
  006bd	07		 DB	 7
  006be	08		 DB	 8
  006bf	09		 DB	 9
  006c0	0d		 DB	 13			; 0000000dH
  006c1	0d		 DB	 13			; 0000000dH
  006c2	0a		 DB	 10			; 0000000aH
  006c3	0d		 DB	 13			; 0000000dH
  006c4	0b		 DB	 11			; 0000000bH
  006c5	0d		 DB	 13			; 0000000dH
  006c6	0d		 DB	 13			; 0000000dH
  006c7	0c		 DB	 12			; 0000000cH
_streamout ENDP
_TEXT	ENDS
END
