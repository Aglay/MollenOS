; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdio\stream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2756	DB	'-', 00H
	ORG $+2
$SG2759	DB	'+', 00H
	ORG $+2
$SG2762	DB	' ', 00H
	ORG $+2
?_nullstring@?1??streamout@@9@9 DD FLAT:$SG2801		; `streamout'::`2'::_nullstring
$SG2801	DB	'(null)', 00H
	ORG $+1
$SG3019	DB	'-', 00H
	ORG $+2
$SG3022	DB	'+', 00H
	ORG $+2
$SG3025	DB	' ', 00H
	ORG $+2
$SG3029	DB	'0', 00H
_DATA	ENDS
CONST	SEGMENT
?digits_l@?1??format_float@@9@9 DB '0123456789abcdef0x', 00H ; `format_float'::`2'::digits_l
	ORG $+1
?digits_u@?1??format_float@@9@9 DB '0123456789ABCDEF0X', 00H ; `format_float'::`2'::digits_u
	ORG $+1
?_nan@?1??format_float@@9@9 DB '#QNAN', 00H		; `format_float'::`2'::_nan
	ORG $+2
?_infinity@?1??format_float@@9@9 DB '#INF', 00H		; `format_float'::`2'::_infinity
	ORG $+3
?digits_l@?1??streamout@@9@9 DB '0123456789abcdef0x', 00H ; `streamout'::`2'::digits_l
	ORG $+1
?digits_u@?1??streamout@@9@9 DB '0123456789ABCDEF0X', 00H ; `streamout'::`2'::digits_u
CONST	ENDS
PUBLIC	_StreamCharacterToUtf8
PUBLIC	_format_float
PUBLIC	_streamout
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	_putchar:PROC
EXTRN	__finite:PROC
EXTRN	__isnan:PROC
EXTRN	_wcsnlen:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__aullrem:PROC
EXTRN	__dtoul3:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__ultod3:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout
_TEXT	SEGMENT
tv632 = -128						; size = 8
_val64$2$ = -124					; size = 4
_string$ = -124						; size = 4
tv767 = -120						; size = 4
tv765 = -120						; size = 4
_flags$1$ = -120					; size = 4
tv700 = -116						; size = 4
_base$1$ = -116						; size = 4
_digits$1$ = -112					; size = 4
_uLen$1 = -112						; size = 4
tv699 = -108						; size = 4
_prefixlen$1$ = -108					; size = 4
_prefix$ = -108						; size = 4
_chr$ = -104						; size = 1
_cnt$ = -100						; size = 4
_prefix$1$ = -96					; size = 4
_out$GSCopy$1$ = -92					; size = 4
_format$GSCopy$1$ = -88					; size = 4
_padding$2$ = -84					; size = 4
_string$1$ = -80					; size = 4
_precision$2$ = -76					; size = 4
_written_all$1$ = -72					; size = 4
_val64$1$ = -68						; size = 4
_written$4$ = -68					; size = 4
_argptr$GSCopy$1$ = -64					; size = 4
_argptr$GSCopy$ = -60					; size = 4
_buffer$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_size$ = 12						; size = 4
_format$ = 16						; size = 4
_argptr$ = 20						; size = 4
_streamout PROC						; COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 14	 mov	 eax, DWORD PTR _argptr$[ebp]

; 443  : 	static const char digits_l[] = "0123456789abcdef0x";
; 444  : 	static const char digits_u[] = "0123456789ABCDEF0X";
; 445  : 	static const char *_nullstring = "(null)";
; 446  : 	char buffer[BUFFER_SIZE + 1];
; 447  : 	uint32_t cnt = size;
; 448  : 	char chr, *string;
; 449  : 	STRING *nt_string;
; 450  : 	const char *digits, *prefix;
; 451  : 	int base, fieldwidth, precision, padding;
; 452  : 	size_t prefixlen, len;
; 453  : 	int written = 1, written_all = 0;

  00016	ba 01 00 00 00	 mov	 edx, 1
  0001b	53		 push	 ebx
  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _out$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  00023	57		 push	 edi
  00024	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  00027	33 ff		 xor	 edi, edi
  00029	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0002f	89 5d a4	 mov	 DWORD PTR _out$GSCopy$1$[ebp], ebx
  00032	89 45 9c	 mov	 DWORD PTR _cnt$[ebp], eax
  00035	89 55 bc	 mov	 DWORD PTR _written$4$[ebp], edx
  00038	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi

; 454  : 	unsigned int flags;
; 455  : 	unsigned __int64 val64;
; 456  : 
; 457  : 	buffer[BUFFER_SIZE] = '\0';

  0003b	c6 45 f9 00	 mov	 BYTE PTR _buffer$[ebp+49], 0
  0003f	90		 npad	 1
$LL120@streamout:

; 461  : 	{
; 462  : 		/* Get character and advance */
; 463  : 		chr = *format++;

  00040	8a 06		 mov	 al, BYTE PTR [esi]
  00042	46		 inc	 esi

; 464  : 
; 465  : 		/* Check for end of format string */
; 466  : 		if (chr == '\0') 

  00043	84 c0		 test	 al, al
  00045	0f 84 13 07 00
	00		 je	 $LN119@streamout

; 467  : 			break;
; 468  : 
; 469  : 		/* Check for 'normal' character or double % */
; 470  : 		if ((chr != ('%')) ||
; 471  : 			(chr = *format++) == ('%'))

  0004b	3c 25		 cmp	 al, 37			; 00000025H
  0004d	0f 85 55 06 00
	00		 jne	 $LN116@streamout
  00053	8a 06		 mov	 al, BYTE PTR [esi]
  00055	46		 inc	 esi
  00056	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  00059	3c 25		 cmp	 al, 37			; 00000025H
  0005b	0f 84 47 06 00
	00		 je	 $LN116@streamout

; 521  : 			continue;
; 522  : 		}
; 523  : 
; 524  : 		/* Handle flags-characters */
; 525  : 		flags = 0;

  00061	33 db		 xor	 ebx, ebx
$LL104@streamout:

; 526  : 		while (1)
; 527  : 		{
; 528  : 			if (chr == ('-')) flags |= FLAG_ALIGN_LEFT;

  00063	3c 2d		 cmp	 al, 45			; 0000002dH
  00065	75 0b		 jne	 SHORT $LN102@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00067	8a 06		 mov	 al, BYTE PTR [esi]
  00069	83 cb 01	 or	 ebx, 1
  0006c	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  0006f	46		 inc	 esi

; 535  : 		}

  00070	eb f1		 jmp	 SHORT $LL104@streamout
$LN102@streamout:

; 529  : 			else if (chr == ('+')) flags |= FLAG_FORCE_SIGN;

  00072	3c 2b		 cmp	 al, 43			; 0000002bH
  00074	75 0b		 jne	 SHORT $LN100@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00076	8a 06		 mov	 al, BYTE PTR [esi]
  00078	83 cb 02	 or	 ebx, 2
  0007b	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  0007e	46		 inc	 esi

; 535  : 		}

  0007f	eb e2		 jmp	 SHORT $LL104@streamout
$LN100@streamout:

; 530  : 			else if (chr == (' ')) flags |= FLAG_FORCE_SIGNSP;

  00081	3c 20		 cmp	 al, 32			; 00000020H
  00083	75 0b		 jne	 SHORT $LN98@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00085	8a 06		 mov	 al, BYTE PTR [esi]
  00087	83 cb 04	 or	 ebx, 4
  0008a	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  0008d	46		 inc	 esi

; 535  : 		}

  0008e	eb d3		 jmp	 SHORT $LL104@streamout
$LN98@streamout:

; 531  : 			else if (chr == ('0')) flags |= FLAG_PAD_ZERO;

  00090	3c 30		 cmp	 al, 48			; 00000030H
  00092	75 0b		 jne	 SHORT $LN96@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  00094	8a 06		 mov	 al, BYTE PTR [esi]
  00096	83 cb 08	 or	 ebx, 8
  00099	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  0009c	46		 inc	 esi

; 535  : 		}

  0009d	eb c4		 jmp	 SHORT $LL104@streamout
$LN96@streamout:

; 532  : 			else if (chr == ('#')) flags |= FLAG_SPECIAL;

  0009f	3c 23		 cmp	 al, 35			; 00000023H
  000a1	75 0b		 jne	 SHORT $LN94@streamout

; 533  : 			else break;
; 534  : 			chr = *format++;

  000a3	8a 06		 mov	 al, BYTE PTR [esi]
  000a5	83 cb 10	 or	 ebx, 16			; 00000010H
  000a8	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  000ab	46		 inc	 esi

; 535  : 		}

  000ac	eb b5		 jmp	 SHORT $LL104@streamout
$LN94@streamout:

; 536  : 
; 537  : 		/* Handle field width modifier */
; 538  : 		if (chr == ('*'))

  000ae	3c 2a		 cmp	 al, 42			; 0000002aH
  000b0	75 26		 jne	 SHORT $LN92@streamout

; 539  : 		{
; 540  : 			fieldwidth = va_arg(argptr, int);

  000b2	8b 7d c0	 mov	 edi, DWORD PTR _argptr$GSCopy$1$[ebp]
  000b5	83 c7 04	 add	 edi, 4
  000b8	89 7d c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edi
  000bb	89 7d c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edi
  000be	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  000c1	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx

; 541  : 			if (fieldwidth < 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	79 08		 jns	 SHORT $LN91@streamout

; 542  : 			{
; 543  : 				flags |= FLAG_ALIGN_LEFT;

  000c8	83 cb 01	 or	 ebx, 1

; 544  : 				fieldwidth = -fieldwidth;

  000cb	f7 d9		 neg	 ecx
  000cd	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx
$LN91@streamout:

; 545  : 			}
; 546  : 			chr = *format++;

  000d0	8a 06		 mov	 al, BYTE PTR [esi]
  000d2	46		 inc	 esi
  000d3	88 45 98	 mov	 BYTE PTR _chr$[ebp], al

; 547  : 		}
; 548  : 		else

  000d6	eb 29		 jmp	 SHORT $LN88@streamout
$LN92@streamout:

; 549  : 		{
; 550  : 			fieldwidth = 0;

  000d8	33 c9		 xor	 ecx, ecx
  000da	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx

; 551  : 			while (chr >= ('0') && chr <= ('9'))

  000dd	3c 30		 cmp	 al, 48			; 00000030H
  000df	7c 1d		 jl	 SHORT $LN254@streamout
$LL89@streamout:
  000e1	3c 39		 cmp	 al, 57			; 00000039H
  000e3	7f 16		 jg	 SHORT $LN250@streamout

; 552  : 			{
; 553  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000e5	0f be c0	 movsx	 eax, al
  000e8	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000eb	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  000ee	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 554  : 				chr = *format++;

  000f1	8a 06		 mov	 al, BYTE PTR [esi]
  000f3	46		 inc	 esi
  000f4	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  000f7	3c 30		 cmp	 al, 48			; 00000030H
  000f9	7d e6		 jge	 SHORT $LL89@streamout
$LN250@streamout:
  000fb	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx
$LN254@streamout:
  000fe	8b 7d c0	 mov	 edi, DWORD PTR _argptr$GSCopy$1$[ebp]
$LN88@streamout:

; 555  : 			}
; 556  : 		}
; 557  : 
; 558  : 		/* Handle precision modifier */
; 559  : 		if (chr == '.')

  00101	3c 2e		 cmp	 al, 46			; 0000002eH
  00103	75 4a		 jne	 SHORT $LN87@streamout

; 560  : 		{
; 561  : 			chr = *format++;

  00105	8a 06		 mov	 al, BYTE PTR [esi]
  00107	46		 inc	 esi
  00108	88 45 98	 mov	 BYTE PTR _chr$[ebp], al

; 562  : 
; 563  : 			if (chr == ('*'))

  0010b	3c 2a		 cmp	 al, 42			; 0000002aH
  0010d	75 14		 jne	 SHORT $LN86@streamout

; 564  : 			{
; 565  : 				precision = va_arg(argptr, int);
; 566  : 				chr = *format++;

  0010f	8a 06		 mov	 al, BYTE PTR [esi]
  00111	83 c7 04	 add	 edi, 4
  00114	89 7d c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edi
  00117	46		 inc	 esi
  00118	89 7d c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edi
  0011b	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  0011e	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]

; 567  : 			}
; 568  : 			else

  00121	eb 2f		 jmp	 SHORT $LN266@streamout
$LN86@streamout:

; 569  : 			{
; 570  : 				precision = 0;

  00123	33 ff		 xor	 edi, edi
  00125	89 7d b4	 mov	 DWORD PTR _precision$2$[ebp], edi

; 571  : 				while (chr >= ('0') && chr <= ('9'))

  00128	3c 30		 cmp	 al, 48			; 00000030H
  0012a	7c 29		 jl	 SHORT $LL81@streamout
  0012c	8d 64 24 00	 npad	 4
$LL84@streamout:
  00130	3c 39		 cmp	 al, 57			; 00000039H
  00132	7f 21		 jg	 SHORT $LL81@streamout

; 572  : 				{
; 573  : 					precision = precision * 10 + (chr - ('0'));

  00134	0f be c0	 movsx	 eax, al
  00137	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  0013a	8d 79 e8	 lea	 edi, DWORD PTR [ecx-24]
  0013d	8d 3c 78	 lea	 edi, DWORD PTR [eax+edi*2]

; 574  : 					chr = *format++;

  00140	8a 06		 mov	 al, BYTE PTR [esi]
  00142	46		 inc	 esi
  00143	89 7d b4	 mov	 DWORD PTR _precision$2$[ebp], edi
  00146	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  00149	3c 30		 cmp	 al, 48			; 00000030H
  0014b	7d e3		 jge	 SHORT $LL84@streamout

; 575  : 				}
; 576  : 			}

  0014d	eb 06		 jmp	 SHORT $LL81@streamout
$LN87@streamout:

; 577  : 		}
; 578  : 		else precision = -1;

  0014f	83 cf ff	 or	 edi, -1
$LN266@streamout:
  00152	89 7d b4	 mov	 DWORD PTR _precision$2$[ebp], edi
$LL81@streamout:

; 579  : 
; 580  : 		/* Handle argument size prefix */
; 581  : 		do
; 582  : 		{
; 583  : 			if (chr == ('h')) flags |= FLAG_SHORT;

  00155	3c 68		 cmp	 al, 104			; 00000068H
  00157	75 0e		 jne	 SHORT $LN78@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  00159	8a 06		 mov	 al, BYTE PTR [esi]
  0015b	81 cb 00 01 00
	00		 or	 ebx, 256		; 00000100H
  00161	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  00164	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  00165	eb ee		 jmp	 SHORT $LL81@streamout
$LN78@streamout:

; 584  : 			else if (chr == ('w')) flags |= FLAG_WIDECHAR;

  00167	3c 77		 cmp	 al, 119			; 00000077H
  00169	75 0e		 jne	 SHORT $LN76@streamout
$LN69@streamout:

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  0016b	8a 06		 mov	 al, BYTE PTR [esi]
  0016d	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  00173	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  00176	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  00177	eb dc		 jmp	 SHORT $LL81@streamout
$LN76@streamout:

; 585  : 			else if (chr == ('L')) flags |= 0; // FIXME: long double

  00179	3c 4c		 cmp	 al, 76			; 0000004cH
  0017b	74 73		 je	 SHORT $LN60@streamout

; 586  : 			else if (chr == ('F')) flags |= 0; // FIXME: what is that?

  0017d	3c 46		 cmp	 al, 70			; 00000046H
  0017f	74 6f		 je	 SHORT $LN60@streamout

; 587  : 			else if (chr == ('l'))

  00181	3c 6c		 cmp	 al, 108			; 0000006cH
  00183	75 13		 jne	 SHORT $LN70@streamout

; 588  : 			{
; 589  : 				/* Check if this is the 2nd 'l' in a row */
; 590  : 				if (format[-2] == 'l') flags |= FLAG_INT64;

  00185	38 46 fe	 cmp	 BYTE PTR [esi-2], al
  00188	75 e1		 jne	 SHORT $LN69@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  0018a	8a 06		 mov	 al, BYTE PTR [esi]
  0018c	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  00192	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  00195	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  00196	eb bd		 jmp	 SHORT $LL81@streamout
$LN70@streamout:

; 591  : 				else flags |= FLAG_LONG;
; 592  : 			}
; 593  : 			else if (chr == ('I'))

  00198	3c 49		 cmp	 al, 73			; 00000049H
  0019a	75 5f		 jne	 SHORT $LN79@streamout

; 594  : 			{
; 595  : 				if (format[0] == ('3') && format[1] == ('2'))

  0019c	8a 0e		 mov	 cl, BYTE PTR [esi]
  0019e	80 f9 33	 cmp	 cl, 51			; 00000033H
  001a1	75 12		 jne	 SHORT $LN65@streamout
  001a3	80 7e 01 32	 cmp	 BYTE PTR [esi+1], 50	; 00000032H
  001a7	75 0c		 jne	 SHORT $LN65@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  001a9	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001ac	83 c6 02	 add	 esi, 2
  001af	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  001b2	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  001b3	eb a0		 jmp	 SHORT $LL81@streamout
$LN65@streamout:

; 596  : 				{
; 597  : 					format += 2;
; 598  : 				}
; 599  : 				else if (format[0] == ('6') && format[1] == ('4'))

  001b5	80 f9 36	 cmp	 cl, 54			; 00000036H
  001b8	75 18		 jne	 SHORT $LN63@streamout
  001ba	80 7e 01 34	 cmp	 BYTE PTR [esi+1], 52	; 00000034H
  001be	75 12		 jne	 SHORT $LN63@streamout

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  001c0	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001c3	83 c6 02	 add	 esi, 2
  001c6	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  001cc	88 45 98	 mov	 BYTE PTR _chr$[ebp], al
  001cf	46		 inc	 esi

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  001d0	eb 83		 jmp	 SHORT $LL81@streamout
$LN63@streamout:

; 600  : 				{
; 601  : 					format += 2;
; 602  : 					flags |= FLAG_INT64;
; 603  : 				}
; 604  : 				else if (format[0] == ('x') || format[0] == ('X') ||
; 605  : 					format[0] == ('d') || format[0] == ('i') ||
; 606  : 					format[0] == ('u') || format[0] == ('o'))

  001d2	80 f9 78	 cmp	 cl, 120			; 00000078H
  001d5	74 19		 je	 SHORT $LN60@streamout
  001d7	80 f9 58	 cmp	 cl, 88			; 00000058H
  001da	74 14		 je	 SHORT $LN60@streamout
  001dc	80 f9 64	 cmp	 cl, 100			; 00000064H
  001df	74 0f		 je	 SHORT $LN60@streamout
  001e1	80 f9 69	 cmp	 cl, 105			; 00000069H
  001e4	74 0a		 je	 SHORT $LN60@streamout
  001e6	80 f9 75	 cmp	 cl, 117			; 00000075H
  001e9	74 05		 je	 SHORT $LN60@streamout
  001eb	80 f9 6f	 cmp	 cl, 111			; 0000006fH
  001ee	75 0b		 jne	 SHORT $LN79@streamout
$LN60@streamout:

; 607  : 				{
; 608  : 					flags |= FLAG_INTPTR;
; 609  : 				}
; 610  : 				else break;
; 611  : 			}
; 612  : 			else break;
; 613  : 			chr = *format++;

  001f0	8a 06		 mov	 al, BYTE PTR [esi]
  001f2	46		 inc	 esi
  001f3	88 45 98	 mov	 BYTE PTR _chr$[ebp], al

; 614  : 		}
; 615  : 		while (USE_MULTISIZE);

  001f6	e9 5a ff ff ff	 jmp	 $LL81@streamout
$LN79@streamout:

; 616  : 
; 617  : 		/* Handle the format specifier */
; 618  : 		digits = digits_l;
; 619  : 		string = &buffer[BUFFER_SIZE];
; 620  : 		base = 10;
; 621  : 		prefix = 0;
; 622  : 		switch (chr)

  001fb	0f be c0	 movsx	 eax, al
  001fe	8d 4d f9	 lea	 ecx, DWORD PTR _buffer$[ebp+49]
  00201	83 c0 bf	 add	 eax, -65		; ffffffbfH
  00204	89 75 a8	 mov	 DWORD PTR _format$GSCopy$1$[ebp], esi
  00207	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??streamout@@9@9
  0020e	89 4d b0	 mov	 DWORD PTR _string$1$[ebp], ecx
  00211	89 4d 84	 mov	 DWORD PTR _string$[ebp], ecx
  00214	c7 45 8c 0a 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 10 ; 0000000aH
  0021b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], 0
  00222	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], 0
  00229	83 f8 37	 cmp	 eax, 55			; 00000037H
  0022c	0f 87 6d 04 00
	00		 ja	 $LN22@streamout
  00232	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN224@streamout[eax]
  00239	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN275@streamout[eax*4]
$LN55@streamout:

; 623  : 		{
; 624  : 		case ('n'):
; 625  : 			if (flags & FLAG_INT64)
; 626  : 				*va_arg(argptr, __int64*) = written_all;

  00240	8b 7d b8	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  00243	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00249	74 1f		 je	 SHORT $LN54@streamout
  0024b	8b 4d c0	 mov	 ecx, DWORD PTR _argptr$GSCopy$1$[ebp]
  0024e	8b c7		 mov	 eax, edi
  00250	83 c1 04	 add	 ecx, 4
  00253	99		 cdq
  00254	89 4d c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], ecx
  00257	89 4d c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], ecx
  0025a	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0025d	89 01		 mov	 DWORD PTR [ecx], eax
  0025f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00262	8b 55 bc	 mov	 edx, DWORD PTR _written$4$[ebp]
  00265	e9 d4 04 00 00	 jmp	 $LN165@streamout
$LN54@streamout:

; 627  : 			else if (flags & FLAG_SHORT)
; 628  : 				*va_arg(argptr, short*) = (short)written_all;

  0026a	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  0026d	83 c0 04	 add	 eax, 4
  00270	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  00273	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  00276	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00279	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0027f	74 08		 je	 SHORT $LN52@streamout
  00281	66 89 38	 mov	 WORD PTR [eax], di

; 629  : 			else

  00284	e9 b5 04 00 00	 jmp	 $LN165@streamout
$LN52@streamout:

; 630  : 				*va_arg(argptr, int*) = written_all;

  00289	89 38		 mov	 DWORD PTR [eax], edi

; 631  : 			continue;

  0028b	e9 ae 04 00 00	 jmp	 $LN165@streamout
$LN50@streamout:

; 632  : 
; 633  : 		case ('C'):
; 634  : 		case ('c'):
; 635  : 			string = buffer;

  00290	8d 45 c8	 lea	 eax, DWORD PTR _buffer$[ebp]

; 636  : 			len = 1;
; 637  : 
; 638  : 			/* Get character */
; 639  : 			uint32_t uChar = (uint32_t)va_arg(argptr, int);
; 640  : 			uint32_t uLen = 0;

  00293	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _uLen$1[ebp], 0
  0029a	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax

; 641  : 
; 642  : 			/* Stream it out */
; 643  : 			StreamCharacterToUtf8(uChar, string, &uLen);

  0029d	8d 4d 90	 lea	 ecx, DWORD PTR _uLen$1[ebp]
  002a0	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  002a3	83 c0 04	 add	 eax, 4
  002a6	51		 push	 ecx
  002a7	8d 4d c8	 lea	 ecx, DWORD PTR _buffer$[ebp]
  002aa	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  002ad	51		 push	 ecx
  002ae	ff 70 fc	 push	 DWORD PTR [eax-4]
  002b1	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  002b4	e8 00 00 00 00	 call	 _StreamCharacterToUtf8

; 644  : 
; 645  : 			/* Null terminate */
; 646  : 			((char*)string)[uLen] = (char)('\0');

  002b9	8b 7d 90	 mov	 edi, DWORD PTR _uLen$1[ebp]
  002bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bf	c6 44 3d c8 00	 mov	 BYTE PTR _buffer$[ebp+edi], 0
$LN252@streamout:
  002c4	8b 4d b4	 mov	 ecx, DWORD PTR _precision$2$[ebp]
$LN133@streamout:

; 768  : 		}
; 769  : 
; 770  : 		/* Calculate padding */
; 771  : 		prefixlen = prefix ? strlen(prefix) : 0;

  002c7	33 d2		 xor	 edx, edx
$LN270@streamout:

; 772  : 		if (precision < 0) precision = 0;

  002c9	33 c0		 xor	 eax, eax
  002cb	89 55 94	 mov	 DWORD PTR _prefixlen$1$[ebp], edx
  002ce	85 c9		 test	 ecx, ecx
  002d0	0f 48 c8	 cmovs	 ecx, eax

; 773  : 		padding = (int)(fieldwidth - len - prefixlen - precision);

  002d3	8b 45 ac	 mov	 eax, DWORD PTR _padding$2$[ebp]
  002d6	2b c2		 sub	 eax, edx
  002d8	89 4d b4	 mov	 DWORD PTR _precision$2$[ebp], ecx
  002db	2b c7		 sub	 eax, edi
  002dd	2b c1		 sub	 eax, ecx

; 774  : 		if (padding < 0) padding = 0;

  002df	b9 00 00 00 00	 mov	 ecx, 0
  002e4	0f 48 c1	 cmovs	 eax, ecx
  002e7	89 45 ac	 mov	 DWORD PTR _padding$2$[ebp], eax

; 775  : 
; 776  : 		/* Optional left space padding */
; 777  : 		if ((flags & (FLAG_ALIGN_LEFT | FLAG_PAD_ZERO)) == 0)

  002ea	f6 c3 09	 test	 bl, 9
  002ed	75 2e		 jne	 SHORT $LN16@streamout

; 778  : 		{
; 779  : 			for (; padding > 0; padding--)

  002ef	85 c0		 test	 eax, eax
  002f1	7e 2a		 jle	 SHORT $LN16@streamout
$LL18@streamout:

; 780  : 			{
; 781  : 				if ((written = StreamOutCharacter(out, &cnt, (' '))) == 0) return -1;

  002f3	6a 20		 push	 32			; 00000020H
  002f5	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  002f8	50		 push	 eax
  002f9	ff 75 a4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  002fc	e8 00 00 00 00	 call	 _StreamOutCharacter
  00301	83 c4 0c	 add	 esp, 12			; 0000000cH
  00304	85 c0		 test	 eax, eax
  00306	0f 84 3e 04 00
	00		 je	 $LN154@streamout

; 782  : 				written_all += written;

  0030c	01 45 b8	 add	 DWORD PTR _written_all$1$[ebp], eax
  0030f	8b 45 ac	 mov	 eax, DWORD PTR _padding$2$[ebp]
  00312	48		 dec	 eax
  00313	89 45 ac	 mov	 DWORD PTR _padding$2$[ebp], eax
  00316	85 c0		 test	 eax, eax
  00318	7f d9		 jg	 SHORT $LL18@streamout
  0031a	8b 55 94	 mov	 edx, DWORD PTR _prefixlen$1$[ebp]
$LN16@streamout:

; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 		/* Optional prefix */
; 787  : 		if (prefix)

  0031d	8b 45 a0	 mov	 eax, DWORD PTR _prefix$1$[ebp]
  00320	85 c0		 test	 eax, eax
  00322	74 1d		 je	 SHORT $LN14@streamout

; 788  : 		{
; 789  : 			written = streamout_string(out, &cnt, prefix, prefixlen);

  00324	52		 push	 edx
  00325	50		 push	 eax
  00326	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  00329	50		 push	 eax
  0032a	ff 75 a4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  0032d	e8 00 00 00 00	 call	 _StreamOutString
  00332	83 c4 10	 add	 esp, 16			; 00000010H

; 790  : 			if (written == -1) return -1;

  00335	83 f8 ff	 cmp	 eax, -1
  00338	0f 84 0c 04 00
	00		 je	 $LN154@streamout

; 791  : 			written_all += written;

  0033e	01 45 b8	 add	 DWORD PTR _written_all$1$[ebp], eax
$LN14@streamout:

; 792  : 		}
; 793  : 
; 794  : 		/* Optional left '0' padding */
; 795  : 		if ((flags & FLAG_ALIGN_LEFT) == 0) precision += padding;

  00341	8b c3		 mov	 eax, ebx
  00343	83 e0 01	 and	 eax, 1
  00346	89 45 88	 mov	 DWORD PTR tv767[ebp], eax
  00349	8b 45 b4	 mov	 eax, DWORD PTR _precision$2$[ebp]
  0034c	75 03		 jne	 SHORT $LN145@streamout
  0034e	03 45 ac	 add	 eax, DWORD PTR _padding$2$[ebp]
$LN145@streamout:

; 796  : 		while (precision-- > 0)

  00351	85 c0		 test	 eax, eax
  00353	7e 27		 jle	 SHORT $LN160@streamout
$LL11@streamout:
  00355	48		 dec	 eax
  00356	89 45 b4	 mov	 DWORD PTR _precision$2$[ebp], eax

; 797  : 		{
; 798  : 			if ((written = StreamOutCharacter(out, &cnt, ('0'))) == 0) return -1;

  00359	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  0035c	6a 30		 push	 48			; 00000030H
  0035e	50		 push	 eax
  0035f	ff 75 a4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  00362	e8 00 00 00 00	 call	 _StreamOutCharacter
  00367	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036a	85 c0		 test	 eax, eax
  0036c	0f 84 d8 03 00
	00		 je	 $LN154@streamout

; 799  : 			written_all += written;

  00372	01 45 b8	 add	 DWORD PTR _written_all$1$[ebp], eax
  00375	8b 45 b4	 mov	 eax, DWORD PTR _precision$2$[ebp]
  00378	85 c0		 test	 eax, eax
  0037a	7f d9		 jg	 SHORT $LL11@streamout
$LN160@streamout:

; 800  : 		}
; 801  : 
; 802  : 		/* Output the string */
; 803  : 		if (flags & FLAG_WIDECHAR)
; 804  : 			written = StreamOutWString(out, &cnt, (wchar_t*)string, len);

  0037c	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  0037f	57		 push	 edi
  00380	ff 75 b0	 push	 DWORD PTR _string$1$[ebp]
  00383	50		 push	 eax
  00384	ff 75 a4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  00387	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  0038d	0f 84 ac 02 00
	00		 je	 $LN8@streamout
  00393	e8 00 00 00 00	 call	 _StreamOutWString
  00398	8b d0		 mov	 edx, eax
  0039a	89 55 bc	 mov	 DWORD PTR _written$4$[ebp], edx

; 805  : 		else

  0039d	e9 a7 02 00 00	 jmp	 $LN271@streamout
$LN49@streamout:

; 647  : 			len = (size_t)uLen;
; 648  : 			
; 649  : 			/* Done */
; 650  : 			break;
; 651  : 
; 652  : 		case ('Z'):
; 653  : 			nt_string = va_arg(argptr, void*);

  003a2	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  003a5	83 c0 04	 add	 eax, 4
  003a8	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  003ab	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  003ae	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 654  : 			if (nt_string && (string = nt_string->Buffer))

  003b1	85 c9		 test	 ecx, ecx
  003b3	74 58		 je	 SHORT $LN210@streamout
  003b5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  003b8	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
  003bb	85 c0		 test	 eax, eax
  003bd	74 4e		 je	 SHORT $LN210@streamout

; 655  : 			{
; 656  : 				len = nt_string->Length;

  003bf	0f b7 39	 movzx	 edi, WORD PTR [ecx]

; 657  : 				if (flags & FLAG_WIDECHAR) len /= sizeof(wchar_t);

  003c2	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  003c8	0f 84 f6 fe ff
	ff		 je	 $LN252@streamout
  003ce	d1 ef		 shr	 edi, 1

; 658  : 				break;

  003d0	e9 ef fe ff ff	 jmp	 $LN252@streamout
$LN46@streamout:

; 659  : 			}
; 660  : 			string = 0;
; 661  : 			goto case_string;
; 662  : 
; 663  : 		case ('S'):
; 664  : 			string = va_arg(argptr, void*);

  003d5	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  003d8	83 c0 04	 add	 eax, 4
  003db	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  003de	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  003e1	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  003e4	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax

; 665  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  003e7	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  003ed	75 1a		 jne	 SHORT $case_string$276
  003ef	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H

; 666  : 			goto case_string;

  003f5	eb 12		 jmp	 SHORT $case_string$276
$LN44@streamout:

; 667  : 
; 668  : 		case ('s'):
; 669  : 			string = va_arg(argptr, void*);

  003f7	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  003fa	83 c0 04	 add	 eax, 4
  003fd	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  00400	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  00403	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00406	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
$case_string$276:

; 670  : 
; 671  : case_string:
; 672  : 			if (!string)

  00409	85 c0		 test	 eax, eax
  0040b	75 0e		 jne	 SHORT $LN43@streamout
$LN210@streamout:

; 673  : 			{
; 674  : 				string = (char*)_nullstring;

  0040d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_nullstring@?1??streamout@@9@9

; 675  : 				flags &= ~FLAG_WIDECHAR;

  00412	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  00418	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
$LN43@streamout:

; 676  : 			}
; 677  : 
; 678  :  			if (flags & FLAG_WIDECHAR)

  0041b	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00421	74 13		 je	 SHORT $LN42@streamout

; 679  :  				len = wcsnlen((wchar_t*)string, (unsigned)precision);

  00423	57		 push	 edi
  00424	50		 push	 eax
  00425	e8 00 00 00 00	 call	 _wcsnlen
  0042a	83 c4 08	 add	 esp, 8
  0042d	8b f8		 mov	 edi, eax

; 682  : 			precision = 0;

  0042f	33 c9		 xor	 ecx, ecx

; 683  : 			break;

  00431	e9 91 fe ff ff	 jmp	 $LN133@streamout
$LN42@streamout:

; 680  :  			else
; 681  : 				len = strlen((char*)string);

  00436	8b f8		 mov	 edi, eax
  00438	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0043b	eb 03 8d 49 00	 npad	 5
$LL225@streamout:
  00440	8a 07		 mov	 al, BYTE PTR [edi]
  00442	47		 inc	 edi
  00443	84 c0		 test	 al, al
  00445	75 f9		 jne	 SHORT $LL225@streamout
  00447	2b f9		 sub	 edi, ecx

; 682  : 			precision = 0;

  00449	33 c9		 xor	 ecx, ecx

; 683  : 			break;

  0044b	e9 77 fe ff ff	 jmp	 $LN133@streamout
$LN40@streamout:

; 684  : 
; 685  : 		case ('G'):
; 686  : 		case ('E'):
; 687  : 		case ('A'):
; 688  : 		case ('g'):
; 689  : 		case ('e'):
; 690  : 		case ('a'):
; 691  : 		case ('f'):
; 692  : #ifdef _UNICODE
; 693  : 			flags |= FLAG_WIDECHAR;
; 694  : #else
; 695  : 			flags &= ~FLAG_WIDECHAR;
; 696  : #endif
; 697  : 			/* Use external function, one for kernel one for user mode */
; 698  : 			format_float(chr, flags, precision, &string, &prefix, &argptr);

  00450	8d 45 c4	 lea	 eax, DWORD PTR _argptr$GSCopy$[ebp]
  00453	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  00459	50		 push	 eax
  0045a	8d 45 94	 lea	 eax, DWORD PTR _prefix$[ebp]
  0045d	50		 push	 eax
  0045e	8d 45 84	 lea	 eax, DWORD PTR _string$[ebp]
  00461	50		 push	 eax
  00462	57		 push	 edi
  00463	53		 push	 ebx
  00464	ff 75 98	 push	 DWORD PTR _chr$[ebp]
  00467	e8 00 00 00 00	 call	 _format_float

; 699  : 			len = strlen(string);

  0046c	8b 45 84	 mov	 eax, DWORD PTR _string$[ebp]
  0046f	83 c4 18	 add	 esp, 24			; 00000018H
  00472	8b f8		 mov	 edi, eax
  00474	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
  00477	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0047a	8d 9b 00 00 00
	00		 npad	 6
$LL226@streamout:
  00480	8a 07		 mov	 al, BYTE PTR [edi]
  00482	47		 inc	 edi
  00483	84 c0		 test	 al, al
  00485	75 f9		 jne	 SHORT $LL226@streamout

; 700  : 			precision = 0;
; 701  : 			break;

  00487	8b 55 94	 mov	 edx, DWORD PTR _prefix$[ebp]
  0048a	2b f9		 sub	 edi, ecx
  0048c	8b 45 c4	 mov	 eax, DWORD PTR _argptr$GSCopy$[ebp]
  0048f	33 c9		 xor	 ecx, ecx
  00491	89 55 a0	 mov	 DWORD PTR _prefix$1$[ebp], edx
  00494	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  00497	e9 83 01 00 00	 jmp	 $LN56@streamout
$LN39@streamout:

; 702  : 
; 703  : 		case ('d'):
; 704  : 		case ('i'):
; 705  : 			val64 = (__int64)va_arg_f(argptr, flags);

  0049c	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  0049f	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  004a5	74 16		 je	 SHORT $LN127@streamout
  004a7	8b 10		 mov	 edx, DWORD PTR [eax]
  004a9	83 c0 08	 add	 eax, 8
  004ac	89 55 bc	 mov	 DWORD PTR _val64$1$[ebp], edx
  004af	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  004b2	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  004b5	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  004b8	8b 45 bc	 mov	 eax, DWORD PTR _val64$1$[ebp]
  004bb	eb 1e		 jmp	 SHORT $LN267@streamout
$LN127@streamout:
  004bd	83 c0 04	 add	 eax, 4
  004c0	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  004c3	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  004c6	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  004cc	74 06		 je	 SHORT $LN125@streamout
  004ce	0f bf 40 fc	 movsx	 eax, WORD PTR [eax-4]
  004d2	eb 03		 jmp	 SHORT $LN126@streamout
$LN125@streamout:
  004d4	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
$LN126@streamout:
  004d7	99		 cdq
  004d8	89 45 bc	 mov	 DWORD PTR _val64$1$[ebp], eax
$LN267@streamout:
  004db	89 55 84	 mov	 DWORD PTR _val64$2$[ebp], edx

; 706  : 
; 707  : 			if ((__int64)val64 < 0)

  004de	85 d2		 test	 edx, edx
  004e0	7f 19		 jg	 SHORT $LN38@streamout
  004e2	7c 04		 jl	 SHORT $LN227@streamout
  004e4	85 c0		 test	 eax, eax
  004e6	73 13		 jae	 SHORT $LN38@streamout
$LN227@streamout:

; 708  : 			{
; 709  : 				val64 = -(__int64)val64;

  004e8	f7 d8		 neg	 eax

; 710  : 				prefix = ("-");

  004ea	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3019
  004f1	83 d2 00	 adc	 edx, 0
  004f4	f7 da		 neg	 edx
  004f6	e9 a1 00 00 00	 jmp	 $LN273@streamout
$LN38@streamout:

; 711  : 			}
; 712  : 			else if (flags & FLAG_FORCE_SIGN)

  004fb	f6 c3 02	 test	 bl, 2
  004fe	74 0c		 je	 SHORT $LN36@streamout

; 713  : 				prefix = ("+");

  00500	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3022
  00507	e9 96 00 00 00	 jmp	 $case_number$277
$LN36@streamout:

; 714  : 			else if (flags & FLAG_FORCE_SIGNSP)

  0050c	f6 c3 04	 test	 bl, 4
  0050f	0f 84 8d 00 00
	00		 je	 $case_number$277

; 715  : 				prefix = (" ");

  00515	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3025

; 716  : 
; 717  : 			goto case_number;

  0051c	e9 81 00 00 00	 jmp	 $case_number$277
$LN33@streamout:

; 718  : 
; 719  : 		case ('o'):
; 720  : 			base = 8;

  00521	c7 45 8c 08 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 8

; 721  : 			if (flags & FLAG_SPECIAL)

  00528	f6 c3 10	 test	 bl, 16			; 00000010H
  0052b	74 35		 je	 SHORT $case_unsigned$278

; 722  : 			{
; 723  : 				prefix = ("0");

  0052d	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG3029

; 724  : 				if (precision > 0) precision--;

  00534	85 ff		 test	 edi, edi
  00536	7e 2a		 jle	 SHORT $case_unsigned$278
  00538	4f		 dec	 edi

; 725  : 			}
; 726  : 			goto case_unsigned;

  00539	eb 27		 jmp	 SHORT $case_unsigned$278
$LN30@streamout:

; 727  : 
; 728  : 		case ('p'):
; 729  : 			precision = 2 * sizeof(void*);

  0053b	bf 08 00 00 00	 mov	 edi, 8

; 730  : 			flags &= ~FLAG_PAD_ZERO;

  00540	83 e3 f7	 and	 ebx, -9			; fffffff7H
$LN29@streamout:

; 731  : 			flags |= FLAG_INTPTR;
; 732  : 			/* Fall through */
; 733  : 
; 734  : 		case ('X'):
; 735  : 			digits = digits_u;

  00543	b8 00 00 00 00	 mov	 eax, OFFSET ?digits_u@?1??streamout@@9@9
  00548	89 45 90	 mov	 DWORD PTR _digits$1$[ebp], eax
  0054b	eb 03		 jmp	 SHORT $LN28@streamout
$LN255@streamout:
  0054d	8b 45 90	 mov	 eax, DWORD PTR _digits$1$[ebp]
$LN28@streamout:

; 736  : 			/* Fall through */
; 737  : 
; 738  : 		case ('x'):
; 739  : 			base = 16;

  00550	c7 45 8c 10 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 16 ; 00000010H

; 740  : 			if (flags & FLAG_SPECIAL)

  00557	f6 c3 10	 test	 bl, 16			; 00000010H
  0055a	74 06		 je	 SHORT $case_unsigned$278

; 741  : 			{
; 742  : 				prefix = &digits[16];

  0055c	83 c0 10	 add	 eax, 16			; 00000010H
  0055f	89 45 a0	 mov	 DWORD PTR _prefix$1$[ebp], eax
$case_unsigned$278:

; 743  : 			}
; 744  : 
; 745  : 		case ('u'):
; 746  : case_unsigned:
; 747  : 			val64 = va_arg_fu(argptr, flags);

  00562	8b 45 c0	 mov	 eax, DWORD PTR _argptr$GSCopy$1$[ebp]
  00565	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  0056b	74 13		 je	 SHORT $LN131@streamout
  0056d	8b 10		 mov	 edx, DWORD PTR [eax]
  0056f	83 c0 08	 add	 eax, 8
  00572	89 55 bc	 mov	 DWORD PTR _val64$1$[ebp], edx
  00575	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  00578	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  0057b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0057e	eb 1f		 jmp	 SHORT $LN268@streamout
$LN131@streamout:
  00580	83 c0 04	 add	 eax, 4
  00583	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  00586	89 45 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], eax
  00589	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0058f	74 06		 je	 SHORT $LN129@streamout
  00591	0f b7 40 fc	 movzx	 eax, WORD PTR [eax-4]
  00595	eb 03		 jmp	 SHORT $LN269@streamout
$LN129@streamout:
  00597	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
$LN269@streamout:
  0059a	33 d2		 xor	 edx, edx
$LN273@streamout:
  0059c	89 45 bc	 mov	 DWORD PTR _val64$1$[ebp], eax
$LN268@streamout:
  0059f	89 55 84	 mov	 DWORD PTR _val64$2$[ebp], edx
$case_number$277:

; 748  : 
; 749  : case_number:
; 750  : 			flags &= ~FLAG_WIDECHAR;

  005a2	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH

; 751  : 			if (precision < 0) precision = 1;

  005a8	b8 01 00 00 00	 mov	 eax, 1
  005ad	85 ff		 test	 edi, edi
  005af	89 5d 88	 mov	 DWORD PTR _flags$1$[ebp], ebx
  005b2	0f 48 f8	 cmovs	 edi, eax

; 752  : 
; 753  : 			/* Gather digits in reverse order */
; 754  : 			while (val64)

  005b5	8b 45 bc	 mov	 eax, DWORD PTR _val64$1$[ebp]
  005b8	0b c2		 or	 eax, edx
  005ba	89 7d b4	 mov	 DWORD PTR _precision$2$[ebp], edi
  005bd	74 4a		 je	 SHORT $LN23@streamout
  005bf	8b 45 8c	 mov	 eax, DWORD PTR _base$1$[ebp]
  005c2	8b 75 b0	 mov	 esi, DWORD PTR _string$1$[ebp]
  005c5	8b 5d bc	 mov	 ebx, DWORD PTR _val64$1$[ebp]
  005c8	99		 cdq
  005c9	8b c8		 mov	 ecx, eax
  005cb	8b c2		 mov	 eax, edx
  005cd	8b 55 84	 mov	 edx, DWORD PTR _val64$2$[ebp]
  005d0	89 4d 8c	 mov	 DWORD PTR tv700[ebp], ecx
  005d3	89 45 94	 mov	 DWORD PTR tv699[ebp], eax
$LL24@streamout:

; 755  : 			{
; 756  : 				*--string = digits[val64 % base];

  005d6	50		 push	 eax
  005d7	51		 push	 ecx
  005d8	52		 push	 edx
  005d9	53		 push	 ebx
  005da	4e		 dec	 esi
  005db	e8 00 00 00 00	 call	 __aulldvrm
  005e0	89 5d 84	 mov	 DWORD PTR tv632[ebp+4], ebx

; 757  : 				val64 /= base;
; 758  : 				precision--;

  005e3	4f		 dec	 edi
  005e4	8b d8		 mov	 ebx, eax
  005e6	8b 45 90	 mov	 eax, DWORD PTR _digits$1$[ebp]
  005e9	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  005ec	8b 4d 8c	 mov	 ecx, DWORD PTR tv700[ebp]
  005ef	88 06		 mov	 BYTE PTR [esi], al
  005f1	8b c3		 mov	 eax, ebx
  005f3	0b c2		 or	 eax, edx
  005f5	8b 45 94	 mov	 eax, DWORD PTR tv699[ebp]
  005f8	75 dc		 jne	 SHORT $LL24@streamout
  005fa	8b 5d 88	 mov	 ebx, DWORD PTR _flags$1$[ebp]
  005fd	89 75 b0	 mov	 DWORD PTR _string$1$[ebp], esi
  00600	8b 75 a8	 mov	 esi, DWORD PTR _format$GSCopy$1$[ebp]
  00603	8b 4d b0	 mov	 ecx, DWORD PTR _string$1$[ebp]
  00606	89 7d b4	 mov	 DWORD PTR _precision$2$[ebp], edi
$LN23@streamout:

; 759  : 			}
; 760  : 
; 761  : 			len = strlen(string);

  00609	8b f9		 mov	 edi, ecx
  0060b	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0060e	8b ff		 npad	 2
$LL228@streamout:
  00610	8a 07		 mov	 al, BYTE PTR [edi]
  00612	47		 inc	 edi
  00613	84 c0		 test	 al, al
  00615	75 f9		 jne	 SHORT $LL228@streamout
  00617	8b 55 a0	 mov	 edx, DWORD PTR _prefix$1$[ebp]
  0061a	2b f9		 sub	 edi, ecx
  0061c	8b 4d b4	 mov	 ecx, DWORD PTR _precision$2$[ebp]
$LN56@streamout:

; 768  : 		}
; 769  : 
; 770  : 		/* Calculate padding */
; 771  : 		prefixlen = prefix ? strlen(prefix) : 0;

  0061f	85 d2		 test	 edx, edx
  00621	0f 84 a0 fc ff
	ff		 je	 $LN133@streamout
  00627	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0062a	89 45 88	 mov	 DWORD PTR tv765[ebp], eax
  0062d	8d 49 00	 npad	 3
$LL229@streamout:
  00630	8a 02		 mov	 al, BYTE PTR [edx]
  00632	42		 inc	 edx
  00633	84 c0		 test	 al, al
  00635	75 f9		 jne	 SHORT $LL229@streamout
  00637	2b 55 88	 sub	 edx, DWORD PTR tv765[ebp]
  0063a	e9 8a fc ff ff	 jmp	 $LN270@streamout
$LN8@streamout:

; 806  : 			written = StreamOutString(out, &cnt, (char*)string, len);

  0063f	e8 00 00 00 00	 call	 _StreamOutString
  00644	8b d0		 mov	 edx, eax
  00646	89 45 bc	 mov	 DWORD PTR _written$4$[ebp], eax
$LN271@streamout:
  00649	83 c4 10	 add	 esp, 16			; 00000010H

; 807  : 		if (written == -1) return -1;

  0064c	83 fa ff	 cmp	 edx, -1
  0064f	0f 84 f5 00 00
	00		 je	 $LN154@streamout

; 808  : 		written_all += written;

  00655	8b 7d b8	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  00658	03 fa		 add	 edi, edx

; 809  : 
; 810  : #if 0 && SUPPORT_FLOAT
; 811  : 		/* Optional right '0' padding */
; 812  : 		while (precision-- > 0)
; 813  : 		{
; 814  : 			if ((written = StreamOutCharacter(out, &cnt, ('0'))) == 0) return -1;
; 815  : 			written_all += written;
; 816  : 			len++;
; 817  : 		}
; 818  : #endif
; 819  : 
; 820  : 		/* Optional right padding */
; 821  : 		if (flags & FLAG_ALIGN_LEFT)

  0065a	83 7d 88 00	 cmp	 DWORD PTR tv767[ebp], 0
  0065e	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00661	0f 84 d7 00 00
	00		 je	 $LN165@streamout

; 822  : 		{
; 823  : 			while (padding-- > 0)

  00667	8b 5d ac	 mov	 ebx, DWORD PTR _padding$2$[ebp]
  0066a	85 db		 test	 ebx, ebx
  0066c	0f 8e cc 00 00
	00		 jle	 $LN165@streamout
$LL4@streamout:

; 824  : 			{
; 825  : 				if ((written = StreamOutCharacter(out, &cnt, (' '))) == 0) return -1;

  00672	6a 20		 push	 32			; 00000020H
  00674	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  00677	4b		 dec	 ebx
  00678	50		 push	 eax
  00679	ff 75 a4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  0067c	e8 00 00 00 00	 call	 _StreamOutCharacter
  00681	8b d0		 mov	 edx, eax
  00683	83 c4 0c	 add	 esp, 12			; 0000000cH
  00686	89 55 bc	 mov	 DWORD PTR _written$4$[ebp], edx
  00689	85 d2		 test	 edx, edx
  0068b	0f 84 b9 00 00
	00		 je	 $LN154@streamout

; 826  : 				written_all += written;

  00691	03 fa		 add	 edi, edx
  00693	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00696	85 db		 test	 ebx, ebx
  00698	7f d8		 jg	 SHORT $LL4@streamout

; 827  : 			}
; 828  : 		}
; 829  : 
; 830  : 	}

  0069a	e9 9f 00 00 00	 jmp	 $LN165@streamout
$LN22@streamout:

; 762  : 			break;
; 763  : 
; 764  : 		default:
; 765  : 			/* Treat anything else as a new character */
; 766  : 			format--;
; 767  : 			continue;

  0069f	8b 7d b8	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  006a2	4e		 dec	 esi
  006a3	e9 96 00 00 00	 jmp	 $LN165@streamout
$LN116@streamout:

; 472  : 		{
; 473  : 			/* Sanity */
; 474  : 			if (IsUTF8(chr))

  006a8	8a c8		 mov	 cl, al
  006aa	80 e1 c0	 and	 cl, 192			; 000000c0H
  006ad	80 f9 80	 cmp	 cl, 128			; 00000080H
  006b0	75 6d		 jne	 SHORT $LN115@streamout

; 475  : 			{
; 476  : 				/* Build UTF-8 */
; 477  : 				uint32_t uChar = (uint32_t)chr;
; 478  : 				uint32_t Size = 0;
; 479  : 
; 480  : 				/* Iterate */
; 481  : 				while (*format && IsUTF8(*format))

  006b2	8a 16		 mov	 dl, BYTE PTR [esi]
  006b4	33 db		 xor	 ebx, ebx
  006b6	0f be c8	 movsx	 ecx, al
  006b9	84 d2		 test	 dl, dl
  006bb	74 1b		 je	 SHORT $LN251@streamout
  006bd	8d 49 00	 npad	 3
$LL114@streamout:
  006c0	8a c2		 mov	 al, dl
  006c2	24 c0		 and	 al, 192			; 000000c0H
  006c4	3c 80		 cmp	 al, 128			; 00000080H
  006c6	75 10		 jne	 SHORT $LN251@streamout

; 482  : 				{
; 483  : 					/* Move */
; 484  : 					uChar <<= 6;
; 485  : 
; 486  : 					/* Add */
; 487  : 					uChar += (unsigned char)*format;
; 488  : 
; 489  : 					/* Inc */
; 490  : 					Size++;
; 491  : 					format++;

  006c8	46		 inc	 esi
  006c9	c1 e1 06	 shl	 ecx, 6
  006cc	0f b6 c2	 movzx	 eax, dl
  006cf	43		 inc	 ebx
  006d0	03 c8		 add	 ecx, eax
  006d2	8a 16		 mov	 dl, BYTE PTR [esi]
  006d4	84 d2		 test	 dl, dl
  006d6	75 e8		 jne	 SHORT $LL114@streamout
$LN251@streamout:

; 492  : 				}
; 493  : 
; 494  : 				/* Move */
; 495  : 				uChar <<= 6;

  006d8	c1 e1 06	 shl	 ecx, 6

; 496  : 
; 497  : 				/* Add the last byte */
; 498  : 				if (Size == 1)

  006db	83 fb 01	 cmp	 ebx, 1
  006de	75 08		 jne	 SHORT $LN112@streamout

; 499  : 					uChar |= (((unsigned char)*format) & 0x1F);

  006e0	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006e3	83 e0 1f	 and	 eax, 31			; 0000001fH
  006e6	eb 18		 jmp	 SHORT $LN272@streamout
$LN112@streamout:

; 500  : 				else if (Size == 2)

  006e8	83 fb 02	 cmp	 ebx, 2
  006eb	75 08		 jne	 SHORT $LN110@streamout

; 501  : 					uChar |= (((unsigned char)*format) & 0xF);

  006ed	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006f0	83 e0 0f	 and	 eax, 15			; 0000000fH
  006f3	eb 0b		 jmp	 SHORT $LN272@streamout
$LN110@streamout:

; 502  : 				else if (Size == 3)

  006f5	83 fb 03	 cmp	 ebx, 3
  006f8	75 08		 jne	 SHORT $LN108@streamout

; 503  : 					uChar |= (((unsigned char)*format) & 0x7);

  006fa	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006fd	83 e0 07	 and	 eax, 7
$LN272@streamout:
  00700	0b c8		 or	 ecx, eax
$LN108@streamout:

; 504  : 
; 505  : 				/* Write the character to the stream */
; 506  : 				if ((written = StreamOutCharacter(out, &cnt, uChar)) == 0)

  00702	8b 5d a4	 mov	 ebx, DWORD PTR _out$GSCopy$1$[ebp]
  00705	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  00708	51		 push	 ecx
  00709	50		 push	 eax
  0070a	53		 push	 ebx
  0070b	e8 00 00 00 00	 call	 _StreamOutCharacter
  00710	8b d0		 mov	 edx, eax
  00712	83 c4 0c	 add	 esp, 12			; 0000000cH
  00715	89 55 bc	 mov	 DWORD PTR _written$4$[ebp], edx
  00718	85 d2		 test	 edx, edx
  0071a	74 2e		 je	 SHORT $LN154@streamout

; 508  : 
; 509  : 				/* Skip */
; 510  : 				format++;

  0071c	46		 inc	 esi

; 511  : 			}
; 512  : 			else

  0071d	eb 1a		 jmp	 SHORT $LN105@streamout
$LN115@streamout:

; 513  : 			{
; 514  : 				/* Write the character to the stream */
; 515  : 				if ((written = StreamOutCharacter(out, &cnt, (uint32_t)chr)) == 0)

  0071f	0f be c0	 movsx	 eax, al
  00722	50		 push	 eax
  00723	8d 45 9c	 lea	 eax, DWORD PTR _cnt$[ebp]
  00726	50		 push	 eax
  00727	53		 push	 ebx
  00728	e8 00 00 00 00	 call	 _StreamOutCharacter
  0072d	8b d0		 mov	 edx, eax
  0072f	89 45 bc	 mov	 DWORD PTR _written$4$[ebp], eax
  00732	83 c4 0c	 add	 esp, 12			; 0000000cH
  00735	85 d2		 test	 edx, edx
  00737	74 11		 je	 SHORT $LN154@streamout
$LN105@streamout:

; 516  : 					return -1;
; 517  : 			}
; 518  : 
; 519  : 			/* Done */
; 520  : 			written_all += written;

  00739	03 fa		 add	 edi, edx
  0073b	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
$LN165@streamout:

; 458  : 
; 459  : 	/* Iterate String */
; 460  : 	while (written >= 0)

  0073e	85 d2		 test	 edx, edx
  00740	78 1c		 js	 SHORT $LN119@streamout
  00742	8b 5d a4	 mov	 ebx, DWORD PTR _out$GSCopy$1$[ebp]
  00745	e9 f6 f8 ff ff	 jmp	 $LL120@streamout
$LN154@streamout:
  0074a	5f		 pop	 edi
  0074b	5e		 pop	 esi

; 507  : 					return -1;

  0074c	83 c8 ff	 or	 eax, -1
  0074f	5b		 pop	 ebx

; 831  : 
; 832  : 	if (written == -1) return -1;
; 833  : 
; 834  : 	return written_all;
; 835  : }

  00750	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00753	33 cd		 xor	 ecx, ebp
  00755	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0075a	8b e5		 mov	 esp, ebp
  0075c	5d		 pop	 ebp
  0075d	c3		 ret	 0
$LN119@streamout:
  0075e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00761	83 c8 ff	 or	 eax, -1
  00764	3b d0		 cmp	 edx, eax
  00766	0f 44 f8	 cmove	 edi, eax
  00769	33 cd		 xor	 ecx, ebp
  0076b	8b c7		 mov	 eax, edi
  0076d	5f		 pop	 edi
  0076e	5e		 pop	 esi
  0076f	5b		 pop	 ebx
  00770	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00775	8b e5		 mov	 esp, ebp
  00777	5d		 pop	 ebp
  00778	c3		 ret	 0
  00779	8d 49 00	 npad	 3
$LN275@streamout:
  0077c	00 00 00 00	 DD	 $LN40@streamout
  00780	00 00 00 00	 DD	 $LN50@streamout
  00784	00 00 00 00	 DD	 $LN46@streamout
  00788	00 00 00 00	 DD	 $LN29@streamout
  0078c	00 00 00 00	 DD	 $LN49@streamout
  00790	00 00 00 00	 DD	 $LN39@streamout
  00794	00 00 00 00	 DD	 $LN55@streamout
  00798	00 00 00 00	 DD	 $LN33@streamout
  0079c	00 00 00 00	 DD	 $LN30@streamout
  007a0	00 00 00 00	 DD	 $LN44@streamout
  007a4	00 00 00 00	 DD	 $case_unsigned$278
  007a8	00 00 00 00	 DD	 $LN255@streamout
  007ac	00 00 00 00	 DD	 $LN22@streamout
$LN224@streamout:
  007b0	00		 DB	 0
  007b1	0c		 DB	 12			; 0000000cH
  007b2	01		 DB	 1
  007b3	0c		 DB	 12			; 0000000cH
  007b4	00		 DB	 0
  007b5	0c		 DB	 12			; 0000000cH
  007b6	00		 DB	 0
  007b7	0c		 DB	 12			; 0000000cH
  007b8	0c		 DB	 12			; 0000000cH
  007b9	0c		 DB	 12			; 0000000cH
  007ba	0c		 DB	 12			; 0000000cH
  007bb	0c		 DB	 12			; 0000000cH
  007bc	0c		 DB	 12			; 0000000cH
  007bd	0c		 DB	 12			; 0000000cH
  007be	0c		 DB	 12			; 0000000cH
  007bf	0c		 DB	 12			; 0000000cH
  007c0	0c		 DB	 12			; 0000000cH
  007c1	0c		 DB	 12			; 0000000cH
  007c2	02		 DB	 2
  007c3	0c		 DB	 12			; 0000000cH
  007c4	0c		 DB	 12			; 0000000cH
  007c5	0c		 DB	 12			; 0000000cH
  007c6	0c		 DB	 12			; 0000000cH
  007c7	03		 DB	 3
  007c8	0c		 DB	 12			; 0000000cH
  007c9	04		 DB	 4
  007ca	0c		 DB	 12			; 0000000cH
  007cb	0c		 DB	 12			; 0000000cH
  007cc	0c		 DB	 12			; 0000000cH
  007cd	0c		 DB	 12			; 0000000cH
  007ce	0c		 DB	 12			; 0000000cH
  007cf	0c		 DB	 12			; 0000000cH
  007d0	00		 DB	 0
  007d1	0c		 DB	 12			; 0000000cH
  007d2	01		 DB	 1
  007d3	05		 DB	 5
  007d4	00		 DB	 0
  007d5	00		 DB	 0
  007d6	00		 DB	 0
  007d7	0c		 DB	 12			; 0000000cH
  007d8	05		 DB	 5
  007d9	0c		 DB	 12			; 0000000cH
  007da	0c		 DB	 12			; 0000000cH
  007db	0c		 DB	 12			; 0000000cH
  007dc	0c		 DB	 12			; 0000000cH
  007dd	06		 DB	 6
  007de	07		 DB	 7
  007df	08		 DB	 8
  007e0	0c		 DB	 12			; 0000000cH
  007e1	0c		 DB	 12			; 0000000cH
  007e2	09		 DB	 9
  007e3	0c		 DB	 12			; 0000000cH
  007e4	0a		 DB	 10			; 0000000aH
  007e5	0c		 DB	 12			; 0000000cH
  007e6	0c		 DB	 12			; 0000000cH
  007e7	0b		 DB	 11			; 0000000bH
_streamout ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _format_float
_TEXT	SEGMENT
tv570 = -44						; size = 8
tv516 = -44						; size = 8
tv490 = -44						; size = 8
tv366 = -44						; size = 8
tv578 = -36						; size = 8
_fpval$1$ = -28						; size = 8
_padding$1$ = -20					; size = 4
_fpval2$1$ = -16					; size = 8
tv535 = -16						; size = 8
tv85 = -16						; size = 8
_fpval2$ = -16						; size = 8
_sign$1$ = -12						; size = 4
_exponent$1$ = -8					; size = 4
_digits$1$ = -4						; size = 4
_num_digits$2$ = 8					; size = 4
_val32$1$ = 8						; size = 4
_chr$ = 8						; size = 1
_flags$ = 12						; size = 4
_precision$ = 16					; size = 4
_num_digits$1$ = 20					; size = 4
_string$ = 20						; size = 4
_prefix$ = 24						; size = 4
_argptr$ = 28						; size = 4
_format_float PROC					; COMDAT

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 302  : 	static const char digits_l[] = ("0123456789abcdef0x");
; 303  : 	static const char digits_u[] = ("0123456789ABCDEF0X");
; 304  : 	static const char _nan[] = ("#QNAN");
; 305  : 	static const char _infinity[] = ("#INF");
; 306  : 	const char *digits = digits_l;
; 307  : 	int exponent = 0, sign;
; 308  : 	long double fpval, fpval2;
; 309  : 	int padding = 0, num_digits, val32, base = 10;

  00007	33 f6		 xor	 esi, esi
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??format_float@@9@9
  00010	89 75 ec	 mov	 DWORD PTR _padding$1$[ebp], esi

; 310  : 
; 311  : 	/* Normalize the precision */
; 312  : 	if (precision < 0) precision = 6;

  00013	8b 75 10	 mov	 esi, DWORD PTR _precision$[ebp]
  00016	57		 push	 edi
  00017	85 f6		 test	 esi, esi
  00019	79 07		 jns	 SHORT $LN37@format_flo
  0001b	be 06 00 00 00	 mov	 esi, 6
  00020	eb 10		 jmp	 SHORT $LN84@format_flo
$LN37@format_flo:

; 313  : 	else if (precision > 17)

  00022	83 fe 11	 cmp	 esi, 17			; 00000011H
  00025	7e 0e		 jle	 SHORT $LN35@format_flo

; 314  : 	{
; 315  : 		padding = precision - 17;

  00027	83 c6 ef	 add	 esi, -17		; ffffffefH
  0002a	89 75 ec	 mov	 DWORD PTR _padding$1$[ebp], esi

; 316  : 		precision = 17;

  0002d	be 11 00 00 00	 mov	 esi, 17			; 00000011H
$LN84@format_flo:
  00032	89 75 10	 mov	 DWORD PTR _precision$[ebp], esi
$LN35@format_flo:

; 317  : 	}
; 318  : 
; 319  : 	/* Get the float value and calculate the exponent */
; 320  : 	fpval = va_arg_ffp(*argptr, flags);

  00035	8b 45 1c	 mov	 eax, DWORD PTR _argptr$[ebp]
  00038	0f 57 c9	 xorps	 xmm1, xmm1
  0003b	83 00 08	 add	 DWORD PTR [eax], 8
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	f2 0f 10 40 f8	 movsd	 xmm0, QWORD PTR [eax-8]

; 321  : 	exponent = get_exp((double)fpval);

  00045	66 0f 2e c1	 ucomisd xmm0, xmm1
  00049	f2 0f 11 45 e4	 movsd	 QWORD PTR _fpval$1$[ebp], xmm0
  0004e	9f		 lahf
  0004f	f6 c4 44	 test	 ah, 68			; 00000044H
  00052	7a 07		 jp	 SHORT $LN44@format_flo
  00054	f2 0f 11 4d f0	 movsd	 QWORD PTR tv85[ebp], xmm1
  00059	eb 18		 jmp	 SHORT $LN43@format_flo
$LN44@format_flo:
  0005b	66 0f 2f c1	 comisd	 xmm0, xmm1
  0005f	73 08		 jae	 SHORT $LN85@format_flo
  00061	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
$LN85@format_flo:
  00069	e8 00 00 00 00	 call	 __libm_sse2_log10_precise
  0006e	f2 0f 11 45 f0	 movsd	 QWORD PTR tv85[ebp], xmm0
$LN43@format_flo:
  00073	dd 45 f0	 fld	 QWORD PTR tv85[ebp]
  00076	83 ec 08	 sub	 esp, 8
  00079	dd 1c 24	 fstp	 QWORD PTR [esp]
  0007c	e8 00 00 00 00	 call	 _floor

; 322  : 	sign = fpval < 0 ? -1 : 1;

  00081	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _fpval$1$[ebp]
  00086	33 d2		 xor	 edx, edx

; 323  : 
; 324  : 	switch (chr)

  00088	8b 45 08	 mov	 eax, DWORD PTR _chr$[ebp]
  0008b	83 c4 08	 add	 esp, 8
  0008e	8b 7d 14	 mov	 edi, DWORD PTR _string$[ebp]
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	66 0f 2f c8	 comisd	 xmm1, xmm0
  00098	0f be c0	 movsx	 eax, al
  0009b	dd 5d dc	 fstp	 QWORD PTR tv578[ebp]
  0009e	f2 0f 2c 4d dc	 cvttsd2si ecx, QWORD PTR tv578[ebp]
  000a3	0f 96 c2	 setbe	 dl
  000a6	83 c0 bf	 add	 eax, -65		; ffffffbfH
  000a9	8d 14 55 ff ff
	ff ff		 lea	 edx, DWORD PTR [edx*2-1]
  000b0	89 55 f4	 mov	 DWORD PTR _sign$1$[ebp], edx
  000b3	89 4d f8	 mov	 DWORD PTR _exponent$1$[ebp], ecx
  000b6	83 f8 26	 cmp	 eax, 38			; 00000026H
  000b9	0f 87 11 02 00
	00		 ja	 $LN19@format_flo
  000bf	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN82@format_flo[eax]
  000c6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN87@format_flo[eax*4]
$LN32@format_flo:

; 325  : 	{
; 326  : 	case ('G'):
; 327  : 		digits = digits_u;

  000cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN31@format_flo:

; 328  : 	case ('g'):
; 329  : 		if (precision > 0) precision--;

  000d4	85 f6		 test	 esi, esi
  000d6	7e 04		 jle	 SHORT $LN30@format_flo
  000d8	4e		 dec	 esi
  000d9	89 75 10	 mov	 DWORD PTR _precision$[ebp], esi
$LN30@format_flo:

; 330  : 		if (exponent < -4 || exponent >= precision) goto case_e;

  000dc	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  000df	0f 8c a2 00 00
	00		 jl	 $case_e$88
  000e5	3b ce		 cmp	 ecx, esi
  000e7	0f 8d 9a 00 00
	00		 jge	 $case_e$88

; 331  : 
; 332  : 		/* Shift the decimal point and round */
; 333  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  000ed	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  000f5	66 0f 6e ce	 movd	 xmm1, esi
  000f9	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000fd	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00102	66 0f 6e 4d f4	 movd	 xmm1, DWORD PTR _sign$1$[ebp]
  00107	83 ec 08	 sub	 esp, 8
  0010a	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0010e	f2 0f 59 4d e4	 mulsd	 xmm1, QWORD PTR _fpval$1$[ebp]
  00113	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00117	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0011f	f2 0f 11 45 d4	 movsd	 QWORD PTR tv570[ebp], xmm0
  00124	dd 45 d4	 fld	 QWORD PTR tv570[ebp]
  00127	dd 1c 24	 fstp	 QWORD PTR [esp]
  0012a	e8 00 00 00 00	 call	 _floor
  0012f	83 c4 08	 add	 esp, 8
  00132	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]

; 334  : 
; 335  : 		/* Skip trailing zeroes */
; 336  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  00135	85 f6		 test	 esi, esi
  00137	0f 84 db 01 00
	00		 je	 $LN83@format_flo
  0013d	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR _fpval2$[ebp]
  00142	f2 0f 11 4d f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm1
$LL27@format_flo:
  00147	66 0f 28 c1	 movapd	 xmm0, xmm1
  0014b	e8 00 00 00 00	 call	 __dtoul3
  00150	6a 00		 push	 0
  00152	6a 0a		 push	 10			; 0000000aH
  00154	52		 push	 edx
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 __aullrem
  0015b	0b c2		 or	 eax, edx
  0015d	0f 85 bf 01 00
	00		 jne	 $LN33@format_flo

; 337  : 		{
; 338  : 			precision--;
; 339  : 			fpval2 /= 10;

  00163	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR _fpval2$1$[ebp]
  00168	4e		 dec	 esi
  00169	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@4024000000000000
  00171	89 75 10	 mov	 DWORD PTR _precision$[ebp], esi
  00174	f2 0f 11 4d f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm1
  00179	75 cc		 jne	 SHORT $LL27@format_flo

; 340  : 		}
; 341  : 		break;

  0017b	e9 a2 01 00 00	 jmp	 $LN33@format_flo
$LN25@format_flo:

; 342  : 
; 343  : 	case ('E'):
; 344  : 		digits = digits_u;

  00180	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$case_e$88:
  00187	66 0f 6e ca	 movd	 xmm1, edx

; 345  : 	case ('e'):
; 346  : case_e:
; 347  : 		/* Shift the decimal point and round */
; 348  : 		fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  0018b	8b c6		 mov	 eax, esi
  0018d	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00191	2b c1		 sub	 eax, ecx
  00193	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00197	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  0019f	f2 0f 11 4d d4	 movsd	 QWORD PTR tv366[ebp], xmm1
  001a4	66 0f 6e c8	 movd	 xmm1, eax
  001a8	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001ac	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  001b1	f2 0f 59 45 d4	 mulsd	 xmm0, QWORD PTR tv366[ebp]
  001b6	83 ec 08	 sub	 esp, 8
  001b9	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001c1	f2 0f 11 45 f0	 movsd	 QWORD PTR tv535[ebp], xmm0
  001c6	dd 45 f0	 fld	 QWORD PTR tv535[ebp]
  001c9	dd 1c 24	 fstp	 QWORD PTR [esp]
  001cc	e8 00 00 00 00	 call	 _floor

; 349  : 
; 350  : 		/* Compensate for changed exponent through rounding */
; 351  : 		if (fpval2 >= (unsigned __int64)pow(10., precision + 1))

  001d1	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  001d9	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001dc	66 0f 6e c8	 movd	 xmm1, eax
  001e0	83 c4 08	 add	 esp, 8
  001e3	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001e7	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]
  001ea	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  001ef	e8 00 00 00 00	 call	 __dtoul3
  001f4	8b c8		 mov	 ecx, eax
  001f6	e8 00 00 00 00	 call	 __ultod3
  001fb	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR _fpval2$[ebp]
  00200	66 0f 2f c8	 comisd	 xmm1, xmm0
  00204	f2 0f 11 4d f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm1
  00209	72 52		 jb	 SHORT $LN23@format_flo

; 352  : 		{
; 353  : 			exponent++;

  0020b	f2 0f 2c 4d dc	 cvttsd2si ecx, QWORD PTR tv578[ebp]

; 354  : 			fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  00210	8b c6		 mov	 eax, esi
  00212	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  0021a	41		 inc	 ecx
  0021b	2b c1		 sub	 eax, ecx
  0021d	89 4d f8	 mov	 DWORD PTR _exponent$1$[ebp], ecx
  00220	66 0f 6e c8	 movd	 xmm1, eax
  00224	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00228	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  0022d	f2 0f 59 45 d4	 mulsd	 xmm0, QWORD PTR tv366[ebp]
  00232	83 ec 08	 sub	 esp, 8
  00235	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0023d	f2 0f 11 45 d4	 movsd	 QWORD PTR tv516[ebp], xmm0
  00242	dd 45 d4	 fld	 QWORD PTR tv516[ebp]
  00245	dd 1c 24	 fstp	 QWORD PTR [esp]
  00248	e8 00 00 00 00	 call	 _floor
  0024d	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]
  00250	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$[ebp]
  00255	83 c4 08	 add	 esp, 8
  00258	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
$LN23@format_flo:

; 355  : 		}
; 356  : 
; 357  : 		val32 = exponent >= 0 ? exponent : -exponent;

  0025d	8b 45 f8	 mov	 eax, DWORD PTR _exponent$1$[ebp]
  00260	99		 cdq
  00261	8b c8		 mov	 ecx, eax

; 358  : 
; 359  : 		// FIXME: handle length of exponent field:
; 360  : 		// http://msdn.microsoft.com/de-de/library/0fatw238%28VS.80%29.aspx
; 361  : 		num_digits = 3;
; 362  : 		while (num_digits--)

  00263	b8 03 00 00 00	 mov	 eax, 3
  00268	33 ca		 xor	 ecx, edx
  0026a	2b ca		 sub	 ecx, edx
  0026c	89 4d 08	 mov	 DWORD PTR _val32$1$[ebp], ecx
  0026f	90		 npad	 1
$LL22@format_flo:
  00270	48		 dec	 eax

; 363  : 		{
; 364  : 			*--(*string) = digits[val32 % 10];

  00271	ff 0f		 dec	 DWORD PTR [edi]
  00273	89 45 14	 mov	 DWORD PTR _num_digits$1$[ebp], eax
  00276	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0027b	f7 e9		 imul	 ecx
  0027d	8b 37		 mov	 esi, DWORD PTR [edi]
  0027f	c1 fa 02	 sar	 edx, 2
  00282	8b ca		 mov	 ecx, edx
  00284	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00287	03 ca		 add	 ecx, edx
  00289	8b 55 08	 mov	 edx, DWORD PTR _val32$1$[ebp]

; 365  : 			val32 /= 10;

  0028c	89 4d 08	 mov	 DWORD PTR _val32$1$[ebp], ecx
  0028f	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00292	03 c0		 add	 eax, eax
  00294	2b d0		 sub	 edx, eax
  00296	8b 45 fc	 mov	 eax, DWORD PTR _digits$1$[ebp]
  00299	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0029c	88 06		 mov	 BYTE PTR [esi], al
  0029e	8b 45 14	 mov	 eax, DWORD PTR _num_digits$1$[ebp]
  002a1	85 c0		 test	 eax, eax
  002a3	75 cb		 jne	 SHORT $LL22@format_flo

; 366  : 		}
; 367  : 
; 368  : 		/* Sign for the exponent */
; 369  : 		*--(*string) = (exponent >= 0 ? ('+') : ('-'));

  002a5	ff 0f		 dec	 DWORD PTR [edi]
  002a7	39 45 f8	 cmp	 DWORD PTR _exponent$1$[ebp], eax
  002aa	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 370  : 
; 371  : 		/* Add 'e' or 'E' separator */
; 372  : 		*--(*string) = digits[0xe];
; 373  : 		break;

  002ac	8b 75 10	 mov	 esi, DWORD PTR _precision$[ebp]
  002af	0f 9c c0	 setl	 al
  002b2	8d 04 45 2b 00
	00 00		 lea	 eax, DWORD PTR [eax*2+43]
  002b9	88 01		 mov	 BYTE PTR [ecx], al
  002bb	ff 0f		 dec	 DWORD PTR [edi]
  002bd	8b 45 fc	 mov	 eax, DWORD PTR _digits$1$[ebp]
  002c0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002c2	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  002c5	88 01		 mov	 BYTE PTR [ecx], al
  002c7	eb 59		 jmp	 SHORT $LN33@format_flo
$LN20@format_flo:

; 374  : 
; 375  : 	case ('A'):
; 376  : 		digits = digits_u;

  002c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN19@format_flo:

; 377  : 	case ('a'):
; 378  : 		//            base = 16;
; 379  : 		// FIXME: TODO
; 380  : 
; 381  : 	case ('f'):
; 382  : 	default:
; 383  : 		/* Shift the decimal point and round */
; 384  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  002d0	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  002d8	66 0f 6e ce	 movd	 xmm1, esi
  002dc	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002e0	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  002e5	66 0f 6e 4d f4	 movd	 xmm1, DWORD PTR _sign$1$[ebp]
  002ea	83 ec 08	 sub	 esp, 8
  002ed	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002f1	f2 0f 59 4d e4	 mulsd	 xmm1, QWORD PTR _fpval$1$[ebp]
  002f6	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  002fa	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00302	f2 0f 11 45 d4	 movsd	 QWORD PTR tv490[ebp], xmm0
  00307	dd 45 d4	 fld	 QWORD PTR tv490[ebp]
  0030a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0030d	e8 00 00 00 00	 call	 _floor
  00312	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]
  00315	83 c4 08	 add	 esp, 8
$LN83@format_flo:
  00318	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$[ebp]
  0031d	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
$LN33@format_flo:

; 385  : 		break;
; 386  : 	}
; 387  : 
; 388  : 	/* Handle sign */
; 389  : 	if (fpval < 0)

  00322	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _fpval$1$[ebp]
  00327	0f 57 c9	 xorps	 xmm1, xmm1
  0032a	66 0f 2f c8	 comisd	 xmm1, xmm0
  0032e	76 0b		 jbe	 SHORT $LN18@format_flo

; 390  : 	{
; 391  : 		*prefix = ("-");

  00330	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00333	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2756
  00339	eb 1f		 jmp	 SHORT $LN14@format_flo
$LN18@format_flo:

; 392  : 	}
; 393  : 	else if (flags & FLAG_FORCE_SIGN)

  0033b	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0033e	a8 02		 test	 al, 2
  00340	74 0b		 je	 SHORT $LN16@format_flo

; 394  : 		*prefix = ("+");

  00342	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00345	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2759
  0034b	eb 0d		 jmp	 SHORT $LN14@format_flo
$LN16@format_flo:

; 395  : 	else if (flags & FLAG_FORCE_SIGNSP)

  0034d	a8 04		 test	 al, 4
  0034f	74 09		 je	 SHORT $LN14@format_flo

; 396  : 		*prefix = (" ");

  00351	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00354	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2762
$LN14@format_flo:

; 397  : 
; 398  : 	/* Handle special cases first */
; 399  : 	if (_isnan((double)fpval))

  0035a	83 ec 08	 sub	 esp, 8
  0035d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00362	e8 00 00 00 00	 call	 __isnan
  00367	83 c4 08	 add	 esp, 8
  0036a	85 c0		 test	 eax, eax
  0036c	74 2a		 je	 SHORT $LN13@format_flo

; 400  : 	{
; 401  : 		(*string) -= sizeof(_nan) / sizeof(char) - 1;

  0036e	83 07 fb	 add	 DWORD PTR [edi], -5	; fffffffbH

; 402  : 		strcpy((*string), _nan);

  00371	b9 00 00 00 00	 mov	 ecx, OFFSET ?_nan@?1??format_float@@9@9
  00376	8b 17		 mov	 edx, DWORD PTR [edi]
$LL46@format_flo:
  00378	8a 01		 mov	 al, BYTE PTR [ecx]
  0037a	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0037d	88 02		 mov	 BYTE PTR [edx], al
  0037f	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00382	84 c0		 test	 al, al
  00384	75 f2		 jne	 SHORT $LL46@format_flo

; 403  : 		fpval2 = 1;

  00386	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0038e	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
  00393	e9 a1 00 00 00	 jmp	 $LN60@format_flo
$LN13@format_flo:

; 404  : 	}
; 405  : 	else if (!_finite((double)fpval))

  00398	f2 0f 10 55 e4	 movsd	 xmm2, QWORD PTR _fpval$1$[ebp]
  0039d	83 ec 08	 sub	 esp, 8
  003a0	f2 0f 11 14 24	 movsd	 QWORD PTR [esp], xmm2
  003a5	e8 00 00 00 00	 call	 __finite
  003aa	83 c4 08	 add	 esp, 8
  003ad	85 c0		 test	 eax, eax
  003af	75 2c		 jne	 SHORT $LN52@format_flo

; 406  : 	{
; 407  : 		(*string) -= sizeof(_infinity) / sizeof(char) - 1;

  003b1	83 07 fc	 add	 DWORD PTR [edi], -4	; fffffffcH

; 408  : 		strcpy((*string), _infinity);

  003b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?_infinity@?1??format_float@@9@9
  003b9	8b 17		 mov	 edx, DWORD PTR [edi]
  003bb	eb 03 8d 49 00	 npad	 5
$LL47@format_flo:
  003c0	8a 01		 mov	 al, BYTE PTR [ecx]
  003c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  003c5	88 02		 mov	 BYTE PTR [edx], al
  003c7	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003ca	84 c0		 test	 al, al
  003cc	75 f2		 jne	 SHORT $LL47@format_flo

; 409  : 		fpval2 = 1;

  003ce	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  003d6	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0

; 410  : 	}
; 411  : 	else

  003db	eb 5c		 jmp	 SHORT $LN60@format_flo
$LN52@format_flo:

; 412  : 	{
; 413  : 		/* Zero padding */
; 414  : 		while (padding-- > 0) *--(*string) = ('0');

  003dd	8b 4d ec	 mov	 ecx, DWORD PTR _padding$1$[ebp]
  003e0	85 c9		 test	 ecx, ecx
  003e2	7e 0c		 jle	 SHORT $LN58@format_flo
$LL9@format_flo:
  003e4	ff 0f		 dec	 DWORD PTR [edi]
  003e6	49		 dec	 ecx
  003e7	8b 07		 mov	 eax, DWORD PTR [edi]
  003e9	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  003ec	85 c9		 test	 ecx, ecx
  003ee	7f f4		 jg	 SHORT $LL9@format_flo
$LN58@format_flo:

; 415  : 
; 416  : 		/* Digits after the decimal point */
; 417  : 		num_digits = precision;

  003f0	8b c6		 mov	 eax, esi

; 418  : 		while (num_digits-- > 0)

  003f2	85 f6		 test	 esi, esi
  003f4	7e 49		 jle	 SHORT $LN80@format_flo
  003f6	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  003fb	eb 03 8d 49 00	 npad	 5
$LL7@format_flo:

; 419  : 		{
; 420  : 			*--(*string) = digits[(unsigned __int64)fpval2 % 10];

  00400	ff 0f		 dec	 DWORD PTR [edi]
  00402	48		 dec	 eax
  00403	8b 37		 mov	 esi, DWORD PTR [edi]
  00405	89 45 08	 mov	 DWORD PTR _num_digits$2$[ebp], eax
  00408	e8 00 00 00 00	 call	 __dtoul3
  0040d	6a 00		 push	 0
  0040f	6a 0a		 push	 10			; 0000000aH
  00411	52		 push	 edx
  00412	50		 push	 eax
  00413	e8 00 00 00 00	 call	 __aullrem

; 421  : 			fpval2 /= base;

  00418	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  0041d	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00425	8b 4d fc	 mov	 ecx, DWORD PTR _digits$1$[ebp]
  00428	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0042b	88 06		 mov	 BYTE PTR [esi], al
  0042d	8b 45 08	 mov	 eax, DWORD PTR _num_digits$2$[ebp]
  00430	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
  00435	85 c0		 test	 eax, eax
  00437	7f c7		 jg	 SHORT $LL7@format_flo
$LN60@format_flo:

; 422  : 		}
; 423  : 	}
; 424  : 
; 425  : 	if (precision > 0 || flags & FLAG_SPECIAL)

  00439	83 7d 10 00	 cmp	 DWORD PTR _precision$[ebp], 0
  0043d	7f 06		 jg	 SHORT $LN4@format_flo
$LN80@format_flo:
  0043f	f6 45 0c 10	 test	 BYTE PTR _flags$[ebp], 16 ; 00000010H
  00443	74 07		 je	 SHORT $LN81@format_flo
$LN4@format_flo:

; 426  : 		*--(*string) = ('.');

  00445	ff 0f		 dec	 DWORD PTR [edi]
  00447	8b 07		 mov	 eax, DWORD PTR [edi]
  00449	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
$LN81@format_flo:
  0044c	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  00451	e8 00 00 00 00	 call	 __dtoul3
  00456	8b c8		 mov	 ecx, eax
$LL3@format_flo:

; 427  : 
; 428  : 	/* Digits before the decimal point */
; 429  : 	do
; 430  : 	{
; 431  : 		*--(*string) = digits[(unsigned __int64)fpval2 % base];

  00458	ff 0f		 dec	 DWORD PTR [edi]
  0045a	8b 37		 mov	 esi, DWORD PTR [edi]
  0045c	6a 00		 push	 0
  0045e	6a 0a		 push	 10			; 0000000aH
  00460	52		 push	 edx
  00461	51		 push	 ecx
  00462	e8 00 00 00 00	 call	 __aullrem

; 432  : 		fpval2 /= base;

  00467	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  0046c	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00474	8b 4d fc	 mov	 ecx, DWORD PTR _digits$1$[ebp]
  00477	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0047a	88 06		 mov	 BYTE PTR [esi], al
  0047c	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0

; 433  : 	}
; 434  : 	while ((unsigned __int64)fpval2);

  00481	e8 00 00 00 00	 call	 __dtoul3
  00486	8b c8		 mov	 ecx, eax
  00488	0b c2		 or	 eax, edx
  0048a	75 cc		 jne	 SHORT $LL3@format_flo
  0048c	5f		 pop	 edi
  0048d	5e		 pop	 esi

; 435  : 
; 436  : }

  0048e	8b e5		 mov	 esp, ebp
  00490	5d		 pop	 ebp
  00491	c3		 ret	 0
  00492	8b ff		 npad	 2
$LN87@format_flo:
  00494	00 00 00 00	 DD	 $LN20@format_flo
  00498	00 00 00 00	 DD	 $LN25@format_flo
  0049c	00 00 00 00	 DD	 $LN32@format_flo
  004a0	00 00 00 00	 DD	 $case_e$88
  004a4	00 00 00 00	 DD	 $LN31@format_flo
  004a8	00 00 00 00	 DD	 $LN19@format_flo
$LN82@format_flo:
  004ac	00		 DB	 0
  004ad	05		 DB	 5
  004ae	05		 DB	 5
  004af	05		 DB	 5
  004b0	01		 DB	 1
  004b1	05		 DB	 5
  004b2	02		 DB	 2
  004b3	05		 DB	 5
  004b4	05		 DB	 5
  004b5	05		 DB	 5
  004b6	05		 DB	 5
  004b7	05		 DB	 5
  004b8	05		 DB	 5
  004b9	05		 DB	 5
  004ba	05		 DB	 5
  004bb	05		 DB	 5
  004bc	05		 DB	 5
  004bd	05		 DB	 5
  004be	05		 DB	 5
  004bf	05		 DB	 5
  004c0	05		 DB	 5
  004c1	05		 DB	 5
  004c2	05		 DB	 5
  004c3	05		 DB	 5
  004c4	05		 DB	 5
  004c5	05		 DB	 5
  004c6	05		 DB	 5
  004c7	05		 DB	 5
  004c8	05		 DB	 5
  004c9	05		 DB	 5
  004ca	05		 DB	 5
  004cb	05		 DB	 5
  004cc	05		 DB	 5
  004cd	05		 DB	 5
  004ce	05		 DB	 5
  004cf	05		 DB	 5
  004d0	03		 DB	 3
  004d1	05		 DB	 5
  004d2	04		 DB	 4
_format_float ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutWString
_TEXT	SEGMENT
_oStream$ = 8						; size = 4
_oLen$ = 12						; size = 4
_iStream$ = 16						; size = 4
_iLen$ = 20						; size = 4
_StreamOutWString PROC					; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 277  : 	/* Vars */
; 278  : 	wchar_t Character;
; 279  : 	int bWritten = 0;
; 280  : 
; 281  : 	/* Iterate count */
; 282  : 	while (iLen--)

  00005	8b 75 14	 mov	 esi, DWORD PTR _iLen$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	85 f6		 test	 esi, esi
  0000d	74 22		 je	 SHORT $LN8@StreamOutW
  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _iStream$[ebp]
$LL3@StreamOutW:

; 283  : 	{
; 284  : 		/* Get char */
; 285  : 		Character = *iStream++;

  00012	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00015	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]

; 286  : 
; 287  : 		/* Just write it, this function will do neccessary conversions */
; 288  : 		if (StreamOutCharacter(oStream, oLen, Character) == 0)

  00018	50		 push	 eax
  00019	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  0001c	4e		 dec	 esi
  0001d	ff 75 08	 push	 DWORD PTR _oStream$[ebp]
  00020	e8 00 00 00 00	 call	 _StreamOutCharacter
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	85 c0		 test	 eax, eax
  0002a	74 0c		 je	 SHORT $LN7@StreamOutW

; 290  : 
; 291  : 		/* Inc */
; 292  : 		bWritten++;

  0002c	47		 inc	 edi
  0002d	85 f6		 test	 esi, esi
  0002f	75 e1		 jne	 SHORT $LL3@StreamOutW
$LN8@StreamOutW:

; 293  : 	}
; 294  : 
; 295  : 	/* Num of chars copied */
; 296  : 	return bWritten;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 297  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN7@StreamOutW:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 289  : 			return -1;

  0003a	83 c8 ff	 or	 eax, -1
  0003d	5b		 pop	 ebx

; 297  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_StreamOutWString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutString
_TEXT	SEGMENT
_iLen$2$ = 8						; size = 4
_oStream$ = 8						; size = 4
_oLen$ = 12						; size = 4
_iStream$ = 16						; size = 4
_iLen$ = 20						; size = 4
_StreamOutString PROC					; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 	char Character;
; 191  : 	int bWritten = 0;
; 192  : 
; 193  : 	/* Sanity */
; 194  : 	if (oStream)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _oStream$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 40		 je	 SHORT $LN22@StreamOutS

; 195  : 	{
; 196  : 		while (iLen) {

  0000f	8b 75 14	 mov	 esi, DWORD PTR _iLen$[ebp]
  00012	85 f6		 test	 esi, esi
  00014	0f 84 e7 00 00
	00		 je	 $LN12@StreamOutS
  0001a	8b 7d 10	 mov	 edi, DWORD PTR _iStream$[ebp]
  0001d	8d 49 00	 npad	 3
$LL17@StreamOutS:

; 197  : 			Character = *iStream++;

  00020	8a 07		 mov	 al, BYTE PTR [edi]
  00022	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]

; 198  : 			
; 199  : 			/* Write the character to the stream */
; 200  : 			if (StreamOutCharacter(oStream, oLen, (uint32_t)Character) == 0)

  00025	0f be c0	 movsx	 eax, al
  00028	50		 push	 eax
  00029	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _StreamOutCharacter
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN24@StreamOutS

; 202  : 
; 203  : 			/* Inc */
; 204  : 			bWritten++;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _oStream$[ebp]
  0003c	43		 inc	 ebx

; 205  : 			iLen--;

  0003d	4e		 dec	 esi
  0003e	75 e0		 jne	 SHORT $LL17@StreamOutS

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : 
; 270  : 	/* Num of bytes copied */
; 271  : 	return bWritten;

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	8b c3		 mov	 eax, ebx
  00044	5b		 pop	 ebx

; 272  : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN24@StreamOutS:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 201  : 				return -1;

  00049	83 c8 ff	 or	 eax, -1
  0004c	5b		 pop	 ebx

; 272  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN22@StreamOutS:

; 206  : 		}
; 207  : 	}
; 208  : 	else
; 209  : 	{
; 210  : 		/* Iterate chars */
; 211  : 		while (iLen)

  0004f	8b 45 14	 mov	 eax, DWORD PTR _iLen$[ebp]
  00052	89 45 08	 mov	 DWORD PTR _iLen$2$[ebp], eax
  00055	85 c0		 test	 eax, eax
  00057	0f 84 a4 00 00
	00		 je	 $LN12@StreamOutS
  0005d	8b 75 10	 mov	 esi, DWORD PTR _iStream$[ebp]
$LL13@StreamOutS:

; 212  : 		{
; 213  : 			Character = *iStream++;

  00060	8a 0e		 mov	 cl, BYTE PTR [esi]
  00062	46		 inc	 esi

; 214  : 			
; 215  : 			/* Sanity */
; 216  : 			if (IsUTF8(Character))

  00063	8a c1		 mov	 al, cl
  00065	24 c0		 and	 al, 192			; 000000c0H
  00067	3c 80		 cmp	 al, 128			; 00000080H

; 217  : 			{
; 218  : 				/* Build UTF-8 */
; 219  : 				uint32_t uChar = (uint32_t)Character;

  00069	0f be c1	 movsx	 eax, cl
  0006c	75 6d		 jne	 SHORT $LN11@StreamOutS

; 220  : 				uint32_t Size = 0;
; 221  : 
; 222  : 				/* Iterate */
; 223  : 				while (*iStream && IsUTF8(*iStream))

  0006e	8a 16		 mov	 dl, BYTE PTR [esi]
  00070	33 ff		 xor	 edi, edi
  00072	84 d2		 test	 dl, dl
  00074	74 1a		 je	 SHORT $LN36@StreamOutS
$LL10@StreamOutS:
  00076	8a ca		 mov	 cl, dl
  00078	80 e1 c0	 and	 cl, 192			; 000000c0H
  0007b	80 f9 80	 cmp	 cl, 128			; 00000080H
  0007e	75 10		 jne	 SHORT $LN36@StreamOutS

; 224  : 				{
; 225  : 					/* Move */
; 226  : 					uChar <<= 6;
; 227  : 
; 228  : 					/* Add */
; 229  : 					uChar += (unsigned char)*iStream;
; 230  : 
; 231  : 					/* Inc */
; 232  : 					Size++;
; 233  : 					iStream++;

  00080	46		 inc	 esi
  00081	c1 e0 06	 shl	 eax, 6
  00084	0f b6 ca	 movzx	 ecx, dl
  00087	47		 inc	 edi
  00088	03 c1		 add	 eax, ecx
  0008a	8a 16		 mov	 dl, BYTE PTR [esi]
  0008c	84 d2		 test	 dl, dl
  0008e	75 e6		 jne	 SHORT $LL10@StreamOutS
$LN36@StreamOutS:

; 234  : 				}
; 235  : 
; 236  : 				/* Move */
; 237  : 				uChar <<= 6;

  00090	c1 e0 06	 shl	 eax, 6

; 238  : 
; 239  : 				/* Add the last byte */
; 240  : 				if (Size == 1)

  00093	83 ff 01	 cmp	 edi, 1
  00096	75 08		 jne	 SHORT $LN8@StreamOutS

; 241  : 					uChar |= (((unsigned char)*iStream) & 0x1F);

  00098	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  0009b	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0009e	eb 18		 jmp	 SHORT $LN37@StreamOutS
$LN8@StreamOutS:

; 242  : 				else if (Size == 2)

  000a0	83 ff 02	 cmp	 edi, 2
  000a3	75 08		 jne	 SHORT $LN6@StreamOutS

; 243  : 					uChar |= (((unsigned char)*iStream) & 0xF);

  000a5	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  000a8	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000ab	eb 0b		 jmp	 SHORT $LN37@StreamOutS
$LN6@StreamOutS:

; 244  : 				else if (Size == 3)

  000ad	83 ff 03	 cmp	 edi, 3
  000b0	75 08		 jne	 SHORT $LN4@StreamOutS

; 245  : 					uChar |= (((unsigned char)*iStream) & 0x7);

  000b2	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  000b5	83 e1 07	 and	 ecx, 7
$LN37@StreamOutS:
  000b8	0b c1		 or	 eax, ecx
$LN4@StreamOutS:

; 246  : 				Size++;
; 247  : 
; 248  : 				/* Write the character to the stream */
; 249  : 				if (StreamOutCharacter(oStream, oLen, uChar) == 0)

  000ba	50		 push	 eax
  000bb	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  000be	47		 inc	 edi
  000bf	6a 00		 push	 0
  000c1	e8 00 00 00 00	 call	 _StreamOutCharacter
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	85 c0		 test	 eax, eax
  000cb	0f 84 76 ff ff
	ff		 je	 $LN24@StreamOutS

; 250  : 					return -1;
; 251  : 
; 252  : 				/* Skip */
; 253  : 				bWritten += Size;
; 254  : 				iLen -= Size;

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _iLen$2$[ebp]
  000d4	03 df		 add	 ebx, edi
  000d6	2b cf		 sub	 ecx, edi

; 255  : 				iStream++;

  000d8	46		 inc	 esi

; 256  : 			}
; 257  : 			else

  000d9	eb 1b		 jmp	 SHORT $LN38@StreamOutS
$LN11@StreamOutS:

; 258  : 			{
; 259  : 				/* Write the character to the stream */
; 260  : 				if (StreamOutCharacter(oStream, oLen, (uint32_t)Character) == 0)

  000db	50		 push	 eax
  000dc	ff 75 0c	 push	 DWORD PTR _oLen$[ebp]
  000df	6a 00		 push	 0
  000e1	e8 00 00 00 00	 call	 _StreamOutCharacter
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	85 c0		 test	 eax, eax
  000eb	0f 84 56 ff ff
	ff		 je	 $LN24@StreamOutS

; 261  : 					return -1;
; 262  : 
; 263  : 				/* Inc */
; 264  : 				bWritten++;
; 265  : 				iLen--;

  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _iLen$2$[ebp]
  000f4	43		 inc	 ebx
  000f5	49		 dec	 ecx
$LN38@StreamOutS:
  000f6	89 4d 08	 mov	 DWORD PTR _iLen$2$[ebp], ecx
  000f9	85 c9		 test	 ecx, ecx
  000fb	0f 85 5f ff ff
	ff		 jne	 $LL13@StreamOutS
$LN12@StreamOutS:
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : 
; 270  : 	/* Num of bytes copied */
; 271  : 	return bWritten;

  00103	8b c3		 mov	 eax, ebx
  00105	5b		 pop	 ebx

; 272  : }

  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_StreamOutString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutCharacter
_TEXT	SEGMENT
_oStream$ = 8						; size = 4
_uLen$1 = 12						; size = 4
_oLen$ = 12						; size = 4
_Character$ = 16					; size = 4
_StreamOutCharacter PROC				; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 159  : 	/* Sanity */
; 160  : 	if (*oLen == 0)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _oLen$[ebp]
  00007	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0000a	75 05		 jne	 SHORT $LN3@StreamOutC

; 161  : 		return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	5b		 pop	 ebx

; 181  : #else
; 182  : 		return VideoPutChar(Character);
; 183  : #endif
; 184  : 	}
; 185  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN3@StreamOutC:
  00011	57		 push	 edi

; 162  : 
; 163  : 	/* Do we have a stream to write to? */
; 164  : 	if (oStream) {

  00012	8b 7d 08	 mov	 edi, DWORD PTR _oStream$[ebp]
  00015	85 ff		 test	 edi, edi
  00017	74 26		 je	 SHORT $LN2@StreamOutC

; 165  : 		/* We cannot just copy an U32 character 
; 166  : 		 * to stream like this, we must encode it back */
; 167  : 		uint32_t uLen = 0;
; 168  : 		StreamCharacterToUtf8(Character, *oStream, &uLen);

  00019	8d 45 0c	 lea	 eax, DWORD PTR _uLen$1[ebp]
  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _uLen$1[ebp], 0
  00023	50		 push	 eax
  00024	ff 37		 push	 DWORD PTR [edi]
  00026	ff 75 10	 push	 DWORD PTR _Character$[ebp]
  00029	e8 00 00 00 00	 call	 _StreamCharacterToUtf8

; 169  : 		(*oStream) += uLen;

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _uLen$1[ebp]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	01 0f		 add	 DWORD PTR [edi], ecx

; 170  : 		*oLen -= uLen;

  00036	29 0b		 sub	 DWORD PTR [ebx], ecx

; 171  : 
; 172  : 		/* Done ! */
; 173  : 		return Character;

  00038	8b 45 10	 mov	 eax, DWORD PTR _Character$[ebp]
  0003b	5f		 pop	 edi
  0003c	5b		 pop	 ebx

; 181  : #else
; 182  : 		return VideoPutChar(Character);
; 183  : #endif
; 184  : 	}
; 185  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN2@StreamOutC:

; 174  : 	}
; 175  : 	else 
; 176  : 	{
; 177  : 		/* These routines need the 
; 178  : 		 * unicode-point */
; 179  : #ifndef LIBC_KERNEL
; 180  : 		return putchar(Character);

  0003f	ff 75 10	 push	 DWORD PTR _Character$[ebp]
  00042	e8 00 00 00 00	 call	 _putchar
  00047	83 c4 04	 add	 esp, 4
  0004a	5f		 pop	 edi
  0004b	5b		 pop	 ebx

; 181  : #else
; 182  : 		return VideoPutChar(Character);
; 183  : #endif
; 184  : 	}
; 185  : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_StreamOutCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamCharacterToUtf8
_TEXT	SEGMENT
_TmpBuffer$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_Character$ = 8						; size = 4
_oBuffer$ = 12						; size = 4
_Length$ = 16						; size = 4
_StreamCharacterToUtf8 PROC				; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 77   : 	/* Encode Buffer */
; 78   : 	char TmpBuffer[10] = { 0 };
; 79   : 	char* BufPtr = &TmpBuffer[0];
; 80   : 
; 81   : 	uint32_t NumBytes = 0;
; 82   : 	uint32_t Error = 0;
; 83   : 
; 84   : 	if (Character <= 0x7F)  /* 0XXX XXXX one byte */

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _Character$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	8b 55 0c	 mov	 edx, DWORD PTR _oBuffer$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 10	 mov	 ebx, DWORD PTR _Length$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	33 f6		 xor	 esi, esi
  00021	c6 45 f0 00	 mov	 BYTE PTR _TmpBuffer$[ebp], 0
  00025	33 ff		 xor	 edi, edi
  00027	66 0f d6 45 f1	 movq	 QWORD PTR _TmpBuffer$[ebp+1], xmm0
  0002c	c6 45 f9 00	 mov	 BYTE PTR _TmpBuffer$[ebp+9], 0
  00030	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00033	77 0b		 ja	 SHORT $LN18@StreamChar

; 85   : 	{
; 86   : 		TmpBuffer[0] = (char)(Character & 0xFF);

  00035	88 4d f0	 mov	 BYTE PTR _TmpBuffer$[ebp], cl

; 87   : 		NumBytes = 1;

  00038	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0003b	e9 c4 00 00 00	 jmp	 $LN21@StreamChar
$LN18@StreamChar:

; 88   : 	}
; 89   : 	else if (Character <= 0x7FF)  /* 110X XXXX  two bytes */

  00040	81 f9 ff 07 00
	00		 cmp	 ecx, 2047		; 000007ffH
  00046	77 1d		 ja	 SHORT $LN16@StreamChar

; 90   : 	{
; 91   : 		TmpBuffer[0] = (char)(0xC0 | (Character >> 6));

  00048	8b c1		 mov	 eax, ecx

; 92   : 		TmpBuffer[1] = (char)(0x80 | (Character & 0x3F));
; 93   : 		NumBytes = 2;

  0004a	be 02 00 00 00	 mov	 esi, 2
  0004f	c1 e8 06	 shr	 eax, 6
  00052	80 e1 3f	 and	 cl, 63			; 0000003fH
  00055	0c c0		 or	 al, -64			; ffffffc0H
  00057	80 c9 80	 or	 cl, -128		; ffffff80H
  0005a	88 45 f0	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  0005d	88 4d f1	 mov	 BYTE PTR _TmpBuffer$[ebp+1], cl
  00060	e9 9f 00 00 00	 jmp	 $LN21@StreamChar
$LN16@StreamChar:

; 94   : 	}
; 95   : 	else if (Character <= 0xFFFF)  /* 1110 XXXX  three bytes */

  00065	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0006b	77 57		 ja	 SHORT $LN14@StreamChar

; 96   : 	{
; 97   : 		TmpBuffer[0] = (char)(0xE0 | (Character >> 12));

  0006d	8b c1		 mov	 eax, ecx

; 98   : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 99   : 		TmpBuffer[2] = (char)(0x80 | (Character & 0x3F));
; 100  : 		NumBytes = 3;

  0006f	be 03 00 00 00	 mov	 esi, 3
  00074	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00077	0c e0		 or	 al, -32			; ffffffe0H
  00079	88 45 f0	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  0007c	8b c1		 mov	 eax, ecx
  0007e	c1 e8 06	 shr	 eax, 6
  00081	24 3f		 and	 al, 63			; 0000003fH
  00083	0c 80		 or	 al, -128		; ffffff80H
  00085	88 45 f1	 mov	 BYTE PTR _TmpBuffer$[ebp+1], al
  00088	8a c1		 mov	 al, cl
  0008a	24 3f		 and	 al, 63			; 0000003fH
  0008c	0c 80		 or	 al, -128		; ffffff80H
  0008e	88 45 f2	 mov	 BYTE PTR _TmpBuffer$[ebp+2], al

; 101  : 
; 102  : 		/* Sanity no special characters */
; 103  : 		if (Character == 0xFFFE || Character == 0xFFFF)

  00091	81 f9 fe ff 00
	00		 cmp	 ecx, 65534		; 0000fffeH
  00097	74 08		 je	 SHORT $LN5@StreamChar
  00099	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0009f	75 63		 jne	 SHORT $LN21@StreamChar
$LN5@StreamChar:

; 128  : 	{
; 129  : 		TmpBuffer[0] = (char)(0xFC | (Character >> 30));
; 130  : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 24) & 0x3F));
; 131  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 18) & 0x3F));
; 132  : 		TmpBuffer[3] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 133  : 		TmpBuffer[4] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 134  : 		TmpBuffer[5] = (char)(0x80 | (Character & 0x3F));
; 135  : 		NumBytes = 6;
; 136  : 		Error = 1;
; 137  : 	}
; 138  : 	else
; 139  : 		Error = 1;

  000a1	bf 01 00 00 00	 mov	 edi, 1
$LN3@StreamChar:

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  000a6	89 33		 mov	 DWORD PTR [ebx], esi

; 147  : 
; 148  : 	/* Sanity */
; 149  : 	if (Error)

  000a8	85 ff		 test	 edi, edi
  000aa	0f 84 b0 00 00
	00		 je	 $LN2@StreamChar

; 150  : 		return -1;

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	83 c8 ff	 or	 eax, -1
  000b5	5b		 pop	 ebx

; 151  : 	else
; 152  : 		return 0;
; 153  : }

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b9	33 cd		 xor	 ecx, ebp
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN14@StreamChar:

; 104  : 			Error = 1;
; 105  : 	}
; 106  : 	else if (Character <= 0x1FFFFF)  /* 1111 0XXX  four bytes */

  000c4	81 f9 ff ff 1f
	00		 cmp	 ecx, 2097151		; 001fffffH
  000ca	77 4c		 ja	 SHORT $LN10@StreamChar

; 107  : 	{
; 108  : 		TmpBuffer[0] = (char)(0xF0 | (Character >> 18));

  000cc	8b c1		 mov	 eax, ecx

; 109  : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 110  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 111  : 		TmpBuffer[3] = (char)(0x80 | (Character & 0x3F));
; 112  : 		NumBytes = 4;

  000ce	be 04 00 00 00	 mov	 esi, 4
  000d3	c1 e8 12	 shr	 eax, 18			; 00000012H
  000d6	0c f0		 or	 al, -16			; fffffff0H
  000d8	88 45 f0	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  000db	8b c1		 mov	 eax, ecx
  000dd	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000e0	24 3f		 and	 al, 63			; 0000003fH
  000e2	0c 80		 or	 al, -128		; ffffff80H
  000e4	88 45 f1	 mov	 BYTE PTR _TmpBuffer$[ebp+1], al
  000e7	8b c1		 mov	 eax, ecx
  000e9	c1 e8 06	 shr	 eax, 6
  000ec	24 3f		 and	 al, 63			; 0000003fH
  000ee	0c 80		 or	 al, -128		; ffffff80H
  000f0	88 45 f2	 mov	 BYTE PTR _TmpBuffer$[ebp+2], al
  000f3	8a c1		 mov	 al, cl
  000f5	24 3f		 and	 al, 63			; 0000003fH
  000f7	0c 80		 or	 al, -128		; ffffff80H
  000f9	88 45 f3	 mov	 BYTE PTR _TmpBuffer$[ebp+3], al

; 113  : 
; 114  : 		if (Character > 0x10FFFF)

  000fc	81 f9 ff ff 10
	00		 cmp	 ecx, 1114111		; 0010ffffH
  00102	77 9d		 ja	 SHORT $LN5@StreamChar
$LN21@StreamChar:

; 140  : 
; 141  : 	/* Write buffer only if it's a valid byte sequence */
; 142  : 	if (!Error && oBuffer != NULL)

  00104	85 d2		 test	 edx, edx
  00106	74 9e		 je	 SHORT $LN3@StreamChar

; 143  : 		memcpy(oBuffer, BufPtr, NumBytes);

  00108	56		 push	 esi
  00109	8d 45 f0	 lea	 eax, DWORD PTR _TmpBuffer$[ebp]
  0010c	50		 push	 eax
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 _memcpy
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
  00116	eb 8e		 jmp	 SHORT $LN3@StreamChar
$LN10@StreamChar:

; 115  : 			Error = 1;
; 116  : 	}
; 117  : 	else if (Character <= 0x3FFFFFF)  /* 1111 10XX  five bytes */

  00118	81 f9 ff ff ff
	03		 cmp	 ecx, 67108863		; 03ffffffH
  0011e	77 1a		 ja	 SHORT $LN7@StreamChar

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	c7 03 05 00 00
	00		 mov	 DWORD PTR [ebx], 5

; 150  : 		return -1;

  00128	83 c8 ff	 or	 eax, -1
  0012b	5b		 pop	 ebx

; 151  : 	else
; 152  : 		return 0;
; 153  : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	33 cd		 xor	 ecx, ebp
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN7@StreamChar:

; 118  : 	{
; 119  : 		TmpBuffer[0] = (char)(0xF8 | (Character >> 24));
; 120  : 		TmpBuffer[1] = (char)(0x80 | (Character >> 18));
; 121  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 122  : 		TmpBuffer[3] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 123  : 		TmpBuffer[4] = (char)(0x80 | (Character & 0x3F));
; 124  : 		NumBytes = 5;
; 125  : 		Error = 1;
; 126  : 	}
; 127  : 	else if (Character <= 0x7FFFFFFF)  /* 1111 110X  six bytes */

  0013a	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00140	0f 87 5b ff ff
	ff		 ja	 $LN5@StreamChar

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	c7 03 06 00 00
	00		 mov	 DWORD PTR [ebx], 6

; 150  : 		return -1;

  0014e	83 c8 ff	 or	 eax, -1
  00151	5b		 pop	 ebx

; 151  : 	else
; 152  : 		return 0;
; 153  : }

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
$LN2@StreamChar:
  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	33 c0		 xor	 eax, eax
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	33 cd		 xor	 ecx, ebp
  00169	5b		 pop	 ebx
  0016a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
_StreamCharacterToUtf8 ENDP
_TEXT	ENDS
END
