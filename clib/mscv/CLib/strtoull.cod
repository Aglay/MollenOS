; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strtoull.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoull
EXTRN	___errno:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldvrm:PROC
EXTRN	___osctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoull.c
;	COMDAT _strtoull
_TEXT	SEGMENT
tv184 = -36						; size = 4
tv183 = -32						; size = 4
_cutlim$1$ = -28					; size = 4
tv326 = -24						; size = 8
_cutoff$2$ = -20					; size = 4
_neg$1$ = -16						; size = 4
_cutoff$1$ = -12					; size = 4
_any$1$ = -8						; size = 4
_c$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoull PROC						; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi

; 17   :   const char *s = nptr;

  00007	8b 75 08	 mov	 esi, DWORD PTR _nptr$[ebp]
  0000a	57		 push	 edi

; 18   :   unsigned long long acc;
; 19   :   int c;
; 20   :   unsigned long long cutoff;
; 21   :   int neg = 0, any, cutlim;

  0000b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 0
$LL25@strtoull:

; 22   : 
; 23   :   /*
; 24   :    * See strtol for comments as to the logic used.
; 25   :    */
; 26   :   do {
; 27   :     c = *s++;

  00012	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00015	46		 inc	 esi

; 28   :   } while (isspace(c));

  00016	0f b6 c8	 movzx	 ecx, al
  00019	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
  0001c	f6 81 00 00 00
	00 20		 test	 BYTE PTR ___osctype[ecx], 32 ; 00000020H
  00023	75 ed		 jne	 SHORT $LL25@strtoull

; 29   :   if (c == '-')

  00025	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00028	75 09		 jne	 SHORT $LN22@strtoull

; 30   :   {
; 31   :     neg = 1;

  0002a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 1

; 32   :     c = *s++;

  00031	eb 05		 jmp	 SHORT $LN40@strtoull
$LN22@strtoull:

; 33   :   }
; 34   :   else if (c == '+')

  00033	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00036	75 07		 jne	 SHORT $LN20@strtoull
$LN40@strtoull:

; 35   :     c = *s++;

  00038	0f be 06	 movsx	 eax, BYTE PTR [esi]
  0003b	46		 inc	 esi
  0003c	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
$LN20@strtoull:

; 36   :   if ((base == 0 || base == 16) &&
; 37   :       c == '0' && (*s == 'x' || *s == 'X'))

  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _base$[ebp]
  00042	85 c9		 test	 ecx, ecx
  00044	74 05		 je	 SHORT $LN18@strtoull
  00046	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00049	75 22		 jne	 SHORT $LN19@strtoull
$LN18@strtoull:
  0004b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0004e	75 1d		 jne	 SHORT $LN19@strtoull
  00050	8a 16		 mov	 dl, BYTE PTR [esi]
  00052	80 fa 78	 cmp	 dl, 120			; 00000078H
  00055	74 05		 je	 SHORT $LN17@strtoull
  00057	80 fa 58	 cmp	 dl, 88			; 00000058H
  0005a	75 11		 jne	 SHORT $LN19@strtoull
$LN17@strtoull:

; 38   :   {
; 39   :     c = s[1];

  0005c	0f be 46 01	 movsx	 eax, BYTE PTR [esi+1]

; 40   :     s += 2;
; 41   :     base = 16;

  00060	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00065	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
  00068	83 c6 02	 add	 esi, 2

; 42   :   }
; 43   :   if (base == 0)

  0006b	eb 11		 jmp	 SHORT $LN41@strtoull
$LN19@strtoull:
  0006d	85 c9		 test	 ecx, ecx
  0006f	75 10		 jne	 SHORT $LN16@strtoull

; 44   :     base = c == '0' ? 8 : 10;

  00071	83 f8 30	 cmp	 eax, 48			; 00000030H
  00074	0f 95 c1	 setne	 cl
  00077	8d 0c 4d 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+8]
$LN41@strtoull:
  0007e	89 4d 10	 mov	 DWORD PTR _base$[ebp], ecx
$LN16@strtoull:

; 45   :   cutoff = (unsigned long long)ULLONG_MAX / (unsigned long long)base;

  00081	8b c1		 mov	 eax, ecx
  00083	99		 cdq
  00084	53		 push	 ebx
  00085	8b c8		 mov	 ecx, eax
  00087	8b c2		 mov	 eax, edx
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	6a ff		 push	 -1
  0008d	6a ff		 push	 -1
  0008f	89 4d dc	 mov	 DWORD PTR tv184[ebp], ecx
  00092	89 45 e0	 mov	 DWORD PTR tv183[ebp], eax
  00095	e8 00 00 00 00	 call	 __aulldvrm
  0009a	89 5d ec	 mov	 DWORD PTR tv326[ebp+4], ebx

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  0009d	33 ff		 xor	 edi, edi
  0009f	8b 5d fc	 mov	 ebx, DWORD PTR _c$1$[ebp]
  000a2	89 4d e4	 mov	 DWORD PTR _cutlim$1$[ebp], ecx
  000a5	33 c9		 xor	 ecx, ecx
  000a7	89 55 ec	 mov	 DWORD PTR _cutoff$2$[ebp], edx
  000aa	33 d2		 xor	 edx, edx
  000ac	89 45 f4	 mov	 DWORD PTR _cutoff$1$[ebp], eax
  000af	89 55 f8	 mov	 DWORD PTR _any$1$[ebp], edx
$LL15@strtoull:

; 48   :   {
; 49   :     if (isdigit(c))

  000b2	0f b6 c3	 movzx	 eax, bl
  000b5	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ___osctype[eax]
  000bb	a8 04		 test	 al, 4
  000bd	74 05		 je	 SHORT $LN12@strtoull

; 50   :       c -= '0';

  000bf	83 eb 30	 sub	 ebx, 48			; 00000030H
  000c2	eb 15		 jmp	 SHORT $LN9@strtoull
$LN12@strtoull:

; 51   :     else if (isalpha(c))

  000c4	a8 03		 test	 al, 3
  000c6	74 70		 je	 SHORT $LN32@strtoull

; 52   :       c -= isupper(c) ? 'A' - 10 : 'a' - 10;

  000c8	24 01		 and	 al, 1
  000ca	0f b6 c0	 movzx	 eax, al
  000cd	f7 d8		 neg	 eax
  000cf	1b c0		 sbb	 eax, eax
  000d1	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000d4	83 c0 57	 add	 eax, 87			; 00000057H
  000d7	2b d8		 sub	 ebx, eax
$LN9@strtoull:

; 53   :     else
; 54   :       break;
; 55   :     if (c >= base)

  000d9	3b 5d 10	 cmp	 ebx, DWORD PTR _base$[ebp]
  000dc	7d 5a		 jge	 SHORT $LN32@strtoull

; 56   :       break;
; 57   :     if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000de	85 d2		 test	 edx, edx
  000e0	78 47		 js	 SHORT $LN6@strtoull
  000e2	8b 55 ec	 mov	 edx, DWORD PTR _cutoff$2$[ebp]
  000e5	3b fa		 cmp	 edi, edx
  000e7	77 40		 ja	 SHORT $LN6@strtoull
  000e9	8b 45 f4	 mov	 eax, DWORD PTR _cutoff$1$[ebp]
  000ec	72 04		 jb	 SHORT $LN37@strtoull
  000ee	3b c8		 cmp	 ecx, eax
  000f0	77 37		 ja	 SHORT $LN6@strtoull
$LN37@strtoull:
  000f2	3b c8		 cmp	 ecx, eax
  000f4	75 09		 jne	 SHORT $LN7@strtoull
  000f6	3b fa		 cmp	 edi, edx
  000f8	75 05		 jne	 SHORT $LN7@strtoull
  000fa	3b 5d e4	 cmp	 ebx, DWORD PTR _cutlim$1$[ebp]
  000fd	7f 2a		 jg	 SHORT $LN6@strtoull
$LN7@strtoull:

; 59   :     else {
; 60   :       any = 1;
; 61   :       acc *= base;

  000ff	57		 push	 edi
  00100	51		 push	 ecx
  00101	ff 75 e0	 push	 DWORD PTR tv183[ebp]
  00104	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _any$1$[ebp], 1
  0010b	ff 75 dc	 push	 DWORD PTR tv184[ebp]
  0010e	e8 00 00 00 00	 call	 __allmul
  00113	8b c8		 mov	 ecx, eax
  00115	8b fa		 mov	 edi, edx

; 62   :       acc += c;

  00117	8b c3		 mov	 eax, ebx
  00119	0f be 1e	 movsx	 ebx, BYTE PTR [esi]
  0011c	99		 cdq
  0011d	03 c8		 add	 ecx, eax
  0011f	13 fa		 adc	 edi, edx
  00121	ba 01 00 00 00	 mov	 edx, 1
  00126	46		 inc	 esi
  00127	eb 89		 jmp	 SHORT $LL15@strtoull
$LN6@strtoull:

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  00129	0f be 1e	 movsx	 ebx, BYTE PTR [esi]

; 58   :       any = -1;

  0012c	83 ca ff	 or	 edx, -1
  0012f	89 55 f8	 mov	 DWORD PTR _any$1$[ebp], edx
  00132	46		 inc	 esi
  00133	e9 7a ff ff ff	 jmp	 $LL15@strtoull
$LN32@strtoull:
  00138	5b		 pop	 ebx

; 63   :     }
; 64   :   }
; 65   :   if (any < 0)

  00139	85 d2		 test	 edx, edx
  0013b	79 16		 jns	 SHORT $LN4@strtoull

; 66   :   {
; 67   :     acc = ULLONG_MAX;

  0013d	83 cf ff	 or	 edi, -1

; 68   :     errno = ERANGE;

  00140	e8 00 00 00 00	 call	 ___errno
  00145	8b 55 f8	 mov	 edx, DWORD PTR _any$1$[ebp]
  00148	83 c9 ff	 or	 ecx, -1
  0014b	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00151	eb 0d		 jmp	 SHORT $LN2@strtoull
$LN4@strtoull:

; 69   :   }
; 70   :   else if (neg)

  00153	83 7d f0 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  00157	74 07		 je	 SHORT $LN2@strtoull

; 71   :     acc = 0-acc;

  00159	f7 d9		 neg	 ecx
  0015b	83 d7 00	 adc	 edi, 0
  0015e	f7 df		 neg	 edi
$LN2@strtoull:

; 72   :   if (endptr != 0)

  00160	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  00163	85 c0		 test	 eax, eax
  00165	74 0c		 je	 SHORT $LN38@strtoull

; 73   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  00167	85 d2		 test	 edx, edx
  00169	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  0016c	75 03		 jne	 SHORT $LN29@strtoull
  0016e	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
$LN29@strtoull:
  00171	89 10		 mov	 DWORD PTR [eax], edx
$LN38@strtoull:

; 74   :   return acc;

  00173	8b d7		 mov	 edx, edi
  00175	8b c1		 mov	 eax, ecx
  00177	5f		 pop	 edi
  00178	5e		 pop	 esi

; 75   : }

  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
_strtoull ENDP
_TEXT	ENDS
END
