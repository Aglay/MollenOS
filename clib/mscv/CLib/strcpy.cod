; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strcpy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strcpy
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strcpy.c
;	COMDAT _strcpy
_TEXT	SEGMENT
_to$ = 8						; size = 4
_from$ = 12						; size = 4
_strcpy	PROC						; COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	char *dst = to;

  00003	8b 45 08	 mov	 eax, DWORD PTR _to$[ebp]
  00006	56		 push	 esi

; 26   : 	const char *src = from;

  00007	8b 75 0c	 mov	 esi, DWORD PTR _from$[ebp]

; 27   : 	long *aligned_dst;
; 28   : 	const long *aligned_src;
; 29   : 
; 30   : 	/* If SRC or DEST is unaligned, then copy bytes.  */
; 31   : 	if (!UNALIGNED (src, dst))

  0000a	8b d0		 mov	 edx, eax
  0000c	0b d6		 or	 edx, esi
  0000e	8b c8		 mov	 ecx, eax
  00010	f6 c2 03	 test	 dl, 3
  00013	75 3d		 jne	 SHORT $LN11@strcpy

; 32   : 	{
; 33   : 		aligned_dst = (long*)dst;
; 34   : 		aligned_src = (long*)src;
; 35   : 
; 36   : 		/* SRC and DEST are both "long int" aligned, try to do "long int"
; 37   : 			sized copies.  */
; 38   : 		while (!DETECTNULL(*aligned_src))

  00015	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	8b d9		 mov	 ebx, ecx
  0001b	8d b9 ff fe fe
	fe		 lea	 edi, DWORD PTR [ecx-16843009]
  00021	f7 d3		 not	 ebx
  00023	23 fb		 and	 edi, ebx
  00025	8b d0		 mov	 edx, eax
  00027	f7 c7 80 80 80
	80		 test	 edi, -2139062144	; 80808080H
  0002d	75 1f		 jne	 SHORT $LN3@strcpy
  0002f	90		 npad	 1
$LL4@strcpy:

; 39   : 		{
; 40   : 			*aligned_dst++ = *aligned_src++;

  00030	83 c6 04	 add	 esi, 4
  00033	89 0a		 mov	 DWORD PTR [edx], ecx
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	8b d9		 mov	 ebx, ecx
  00039	8d b9 ff fe fe
	fe		 lea	 edi, DWORD PTR [ecx-16843009]
  0003f	f7 d3		 not	 ebx
  00041	23 fb		 and	 edi, ebx
  00043	83 c2 04	 add	 edx, 4
  00046	f7 c7 80 80 80
	80		 test	 edi, -2139062144	; 80808080H
  0004c	74 e2		 je	 SHORT $LL4@strcpy
$LN3@strcpy:
  0004e	5f		 pop	 edi

; 41   : 		}
; 42   : 
; 43   : 		dst = (char*)aligned_dst;

  0004f	8b ca		 mov	 ecx, edx
  00051	5b		 pop	 ebx
$LN11@strcpy:

; 44   : 		src = (char*)aligned_src;
; 45   : 	}
; 46   : 
; 47   : 	while ((*dst++ = *src++))

  00052	2b f1		 sub	 esi, ecx
$LL2@strcpy:
  00054	8a 14 0e	 mov	 dl, BYTE PTR [esi+ecx]
  00057	88 11		 mov	 BYTE PTR [ecx], dl
  00059	41		 inc	 ecx
  0005a	84 d2		 test	 dl, dl
  0005c	75 f6		 jne	 SHORT $LL2@strcpy
  0005e	5e		 pop	 esi

; 48   : 	;
; 49   : 	return to;
; 50   : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_strcpy	ENDP
_TEXT	ENDS
END
