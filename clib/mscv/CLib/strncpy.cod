; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strncpy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strncpy
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strncpy.c
;	COMDAT _strncpy
_TEXT	SEGMENT
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_num$ = 16						; size = 4
_strncpy PROC						; COMDAT

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	char *dst = destination;
; 25   : 	const char *src = source;
; 26   : 	long *aligned_dst;
; 27   : 	const long *aligned_src;
; 28   : 
; 29   : 	/* If SRC and DEST is aligned and count large enough, then copy words.  */
; 30   : 	if (!UNALIGNED (src, dst) && !TOO_SMALL (num))

  00003	8b 55 10	 mov	 edx, DWORD PTR _num$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _destination$[ebp]
  0000a	8b c3		 mov	 eax, ebx
  0000c	56		 push	 esi
  0000d	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00010	0b c6		 or	 eax, esi
  00012	57		 push	 edi
  00013	8b fb		 mov	 edi, ebx
  00015	a8 03		 test	 al, 3
  00017	75 30		 jne	 SHORT $LN12@strncpy
  00019	83 fa 10	 cmp	 edx, 16			; 00000010H
  0001c	72 2b		 jb	 SHORT $LN12@strncpy
  0001e	8b ff		 npad	 2
$LL7@strncpy:

; 31   : 	{
; 32   : 		aligned_dst = (long*)dst;
; 33   : 		aligned_src = (long*)src;
; 34   : 
; 35   : 		/* SRC and DEST are both "long int" aligned, try to do "long int"
; 36   : 		sized copies.  */
; 37   : 		while (num >= sizeof (long int) && !DETECTNULL(*aligned_src))

  00020	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00022	8b c3		 mov	 eax, ebx
  00024	f7 d0		 not	 eax
  00026	8d 8b ff fe fe
	fe		 lea	 ecx, DWORD PTR [ebx-16843009]
  0002c	23 c8		 and	 ecx, eax
  0002e	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00034	75 10		 jne	 SHORT $LN6@strncpy

; 38   : 	{
; 39   : 		num -= sizeof (long int);

  00036	83 ea 04	 sub	 edx, 4

; 40   : 		*aligned_dst++ = *aligned_src++;

  00039	89 1f		 mov	 DWORD PTR [edi], ebx
  0003b	83 c7 04	 add	 edi, 4
  0003e	83 c6 04	 add	 esi, 4
  00041	83 fa 04	 cmp	 edx, 4
  00044	73 da		 jae	 SHORT $LL7@strncpy
$LN6@strncpy:

; 41   : 	}
; 42   : 
; 43   : 		dst = (char*)aligned_dst;
; 44   : 		src = (char*)aligned_src;

  00046	8b 5d 08	 mov	 ebx, DWORD PTR _destination$[ebp]
$LN12@strncpy:

; 45   : 	}
; 46   : 
; 47   : 	while (num > 0)

  00049	85 d2		 test	 edx, edx
  0004b	74 2d		 je	 SHORT $LN25@strncpy
  0004d	2b f7		 sub	 esi, edi
  0004f	90		 npad	 1
$LL5@strncpy:

; 48   : 	{
; 49   : 		--num;
; 50   : 		if ((*dst++ = *src++) == '\0')

  00050	8a 0c 3e	 mov	 cl, BYTE PTR [esi+edi]
  00053	4a		 dec	 edx
  00054	88 0f		 mov	 BYTE PTR [edi], cl
  00056	47		 inc	 edi
  00057	84 c9		 test	 cl, cl
  00059	74 0b		 je	 SHORT $LN14@strncpy

; 45   : 	}
; 46   : 
; 47   : 	while (num > 0)

  0005b	85 d2		 test	 edx, edx
  0005d	75 f1		 jne	 SHORT $LL5@strncpy

; 55   : 	*dst++ = '\0';
; 56   : 
; 57   : 	return destination;

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	8b c3		 mov	 eax, ebx
  00063	5b		 pop	 ebx

; 58   : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN14@strncpy:

; 51   : 	break;
; 52   : 	}
; 53   : 
; 54   : 	while (num-- > 0)

  00066	85 d2		 test	 edx, edx
  00068	74 10		 je	 SHORT $LN25@strncpy
  0006a	8b ca		 mov	 ecx, edx
  0006c	33 c0		 xor	 eax, eax
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	f3 ab		 rep stosd
  00073	8b ca		 mov	 ecx, edx
  00075	83 e1 03	 and	 ecx, 3
  00078	f3 aa		 rep stosb
$LN25@strncpy:

; 55   : 	*dst++ = '\0';
; 56   : 
; 57   : 	return destination;

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	8b c3		 mov	 eax, ebx
  0007e	5b		 pop	 ebx

; 58   : }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_strncpy ENDP
_TEXT	ENDS
END
