; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\stdio\vfprintf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG1710	DB	'r+', 00H
	ORG $+1
$SG1711	DB	'c:/system/mlog.txt', 00H
_DATA	ENDS
PUBLIC	_vfprintf
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_free:PROC
EXTRN	_fwrite:PROC
EXTRN	_vsprintf:PROC
EXTRN	_malloc:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\vfprintf.c
;	COMDAT _vfprintf
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_format$ = 12						; size = 4
_ap$ = 16						; size = 4
_vfprintf PROC						; COMDAT

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 13   : 	//Step 1. Combine string and arguments
; 14   : 	char *Out = (char*)malloc(256);

  00005	68 00 01 00 00	 push	 256			; 00000100H
  0000a	e8 00 00 00 00	 call	 _malloc

; 15   : 	memset(Out, 0, 256);

  0000f	68 00 01 00 00	 push	 256			; 00000100H
  00014	8b f0		 mov	 esi, eax
  00016	6a 00		 push	 0
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memset

; 16   : 
; 17   : 	//Use sprintf that for this
; 18   : 	vsprintf(Out, format, ap);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _ap$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _format$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _vsprintf

; 19   : 
; 20   : 	//If we have a valid stream, write to that.
; 21   : 	if(stream != NULL)

  0002c	8b 7d 08	 mov	 edi, DWORD PTR _stream$[ebp]
  0002f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00032	85 ff		 test	 edi, edi
  00034	74 2f		 je	 SHORT $LN3@vfprintf

; 22   : 		fwrite(Out, strlen(Out), 1, stream);

  00036	8b c6		 mov	 eax, esi
  00038	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0003b	eb 03 8d 49 00	 npad	 5
$LL6@vfprintf:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $LL6@vfprintf
  00047	57		 push	 edi
  00048	2b c2		 sub	 eax, edx
  0004a	6a 01		 push	 1
  0004c	50		 push	 eax
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 _fwrite
  00053	83 c4 10	 add	 esp, 16			; 00000010H

; 36   : 	}
; 37   : 
; 38   : 	//Cleanup
; 39   : 	free(Out);

  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _free
  0005c	83 c4 04	 add	 esp, 4
  0005f	5f		 pop	 edi

; 40   : 	return 0;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 41   : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN3@vfprintf:

; 23   : 	else
; 24   : 	{
; 25   : 		//Ok, writing to sys-log
; 26   : 		FILE *temp = fopen("c:/system/mlog.txt", "r+");

  00065	68 00 00 00 00	 push	 OFFSET $SG1710
  0006a	68 00 00 00 00	 push	 OFFSET $SG1711
  0006f	e8 00 00 00 00	 call	 _fopen
  00074	8b f8		 mov	 edi, eax
  00076	83 c4 08	 add	 esp, 8

; 27   : 
; 28   : 		if(temp == NULL)

  00079	85 ff		 test	 edi, edi
  0007b	75 07		 jne	 SHORT $LN1@vfprintf

; 29   : 			return 1;

  0007d	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi

; 41   : }

  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN1@vfprintf:

; 30   : 
; 31   : 		//Write data
; 32   : 		fwrite(Out, strlen(Out), 1, temp);

  00084	8b c6		 mov	 eax, esi
  00086	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL7@vfprintf:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $LL7@vfprintf
  00097	57		 push	 edi
  00098	2b c2		 sub	 eax, edx
  0009a	6a 01		 push	 1
  0009c	50		 push	 eax
  0009d	56		 push	 esi
  0009e	e8 00 00 00 00	 call	 _fwrite

; 33   : 
; 34   : 		//Cleanup
; 35   : 		fclose(temp);

  000a3	57		 push	 edi
  000a4	e8 00 00 00 00	 call	 _fclose
  000a9	83 c4 14	 add	 esp, 20			; 00000014H

; 36   : 	}
; 37   : 
; 38   : 	//Cleanup
; 39   : 	free(Out);

  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 _free
  000b2	83 c4 04	 add	 esp, 4
  000b5	5f		 pop	 edi

; 40   : 	return 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	5e		 pop	 esi

; 41   : }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_vfprintf ENDP
_TEXT	ENDS
END
