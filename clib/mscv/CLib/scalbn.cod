; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\math\scalbn.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_two54	DQ	04350000000000000r		; 1.80144e+016
_twom54	DQ	03c90000000000000r		; 5.55112e-017
_huge	DQ	07e37e43c8800759cr		; 1e+300
_tiny	DQ	001a56e1fc2f8f359r		; 1e-300
CONST	ENDS
PUBLIC	_scalbn
PUBLIC	__real@01a56e1fc2f8f359
PUBLIC	__real@3c90000000000000
PUBLIC	__real@4350000000000000
PUBLIC	__real@7e37e43c8800759c
EXTRN	_copysign:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@4350000000000000
CONST	SEGMENT
__real@4350000000000000 DQ 04350000000000000r	; 1.80144e+016
CONST	ENDS
;	COMDAT __real@3c90000000000000
CONST	SEGMENT
__real@3c90000000000000 DQ 03c90000000000000r	; 5.55112e-017
CONST	ENDS
;	COMDAT __real@01a56e1fc2f8f359
CONST	SEGMENT
__real@01a56e1fc2f8f359 DQ 001a56e1fc2f8f359r	; 1e-300
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\math\scalbn.c
;	COMDAT _scalbn
_TEXT	SEGMENT
_x$ = 8							; size = 8
_n$ = 16						; size = 4
_scalbn	PROC						; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	int  k,hx,lx;
; 32   : 	hx = __HI(x);
; 33   : 	lx = __LO(x);
; 34   : 	k = (hx&0x7ff00000)>>20;		/* extract exponent */

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp+4]
  00006	8b c1		 mov	 eax, ecx

; 35   : 	if (k==0) {				/* 0 or subnormal x */

  00008	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  0000b	c1 f8 14	 sar	 eax, 20			; 00000014H
  0000e	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00013	75 44		 jne	 SHORT $LN12@scalbn

; 36   : 		if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */

  00015	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0001b	0b 4d 08	 or	 ecx, DWORD PTR _x$[ebp]
  0001e	0f 84 89 00 00
	00		 je	 $LN13@scalbn

; 37   : 		x *= two54; 

  00024	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _x$[ebp]
  00029	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4350000000000000
  00031	f2 0f 11 45 08	 movsd	 QWORD PTR _x$[ebp], xmm0

; 38   : 		hx = __HI(x);
; 39   : 		k = ((hx&0x7ff00000)>>20) - 54; 

  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp+4]
  00039	8b c1		 mov	 eax, ecx
  0003b	c1 f8 14	 sar	 eax, 20			; 00000014H
  0003e	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00043	83 e8 36	 sub	 eax, 54			; 00000036H

; 40   : 		if (n< -50000) return tiny*x; 	/*underflow*/

  00046	81 fa b0 3c ff
	ff		 cmp	 edx, -50000		; ffff3cb0H
  0004c	7d 10		 jge	 SHORT $LN7@scalbn
  0004e	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00051	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@01a56e1fc2f8f359

; 54   : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN12@scalbn:

; 40   : 		if (n< -50000) return tiny*x; 	/*underflow*/

  00059	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _x$[ebp]
$LN7@scalbn:

; 41   : 	}
; 42   : 	if (k==0x7ff) return x+x;		/* NaN or Inf */

  0005e	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00063	75 07		 jne	 SHORT $LN6@scalbn
  00065	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00068	dc c0		 fadd	 ST(0), ST(0)

; 54   : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN6@scalbn:

; 43   : 	k = k+n; 

  0006c	03 c2		 add	 eax, edx

; 44   : 	if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */

  0006e	3d fe 07 00 00	 cmp	 eax, 2046		; 000007feH
  00073	7e 26		 jle	 SHORT $LN5@scalbn
  00075	83 ec 10	 sub	 esp, 16			; 00000010H
  00078	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
$LN14@scalbn:
  0007e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@7e37e43c8800759c
  00086	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0008b	e8 00 00 00 00	 call	 _copysign
  00090	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@7e37e43c8800759c
  00096	83 c4 10	 add	 esp, 16			; 00000010H

; 54   : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN5@scalbn:

; 45   : 	if (k > 0) 				/* normal result */

  0009b	85 c0		 test	 eax, eax
  0009d	7e 13		 jle	 SHORT $LN4@scalbn

; 46   : 	{__HI(x) = (hx&0x800fffff)|(k<<20); return x;}

  0009f	c1 e0 14	 shl	 eax, 20			; 00000014H
  000a2	81 e1 ff ff 0f
	80		 and	 ecx, -2146435073	; 800fffffH
  000a8	0b c1		 or	 eax, ecx
  000aa	89 45 0c	 mov	 DWORD PTR _x$[ebp+4], eax
$LN13@scalbn:
  000ad	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 54   : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN4@scalbn:

; 47   : 	if (k <= -54)

  000b2	83 f8 ca	 cmp	 eax, -54		; ffffffcaH
  000b5	7f 2e		 jg	 SHORT $LN1@scalbn

; 48   : 		if (n > 50000) 	/* in case integer overflow in n+k */
; 49   : 			return huge*copysign(huge,x);	/*overflow*/

  000b7	83 ec 10	 sub	 esp, 16			; 00000010H
  000ba	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  000c0	81 fa 50 c3 00
	00		 cmp	 edx, 50000		; 0000c350H
  000c6	7f b6		 jg	 SHORT $LN14@scalbn

; 50   : 		else return tiny*copysign(tiny,x); 	/*underflow*/

  000c8	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@01a56e1fc2f8f359
  000d0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d5	e8 00 00 00 00	 call	 _copysign
  000da	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@01a56e1fc2f8f359
  000e0	83 c4 10	 add	 esp, 16			; 00000010H

; 54   : }

  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN1@scalbn:

; 51   : 		k += 54;				/* subnormal result */
; 52   : 		__HI(x) = (hx&0x800fffff)|(k<<20);

  000e5	83 c0 36	 add	 eax, 54			; 00000036H
  000e8	81 e1 ff ff 0f
	80		 and	 ecx, -2146435073	; 800fffffH
  000ee	c1 e0 14	 shl	 eax, 20			; 00000014H
  000f1	0b c1		 or	 eax, ecx
  000f3	89 45 0c	 mov	 DWORD PTR _x$[ebp+4], eax

; 53   : 		return x*twom54;

  000f6	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000f9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3c90000000000000

; 54   : }

  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
_scalbn	ENDP
_TEXT	ENDS
END
