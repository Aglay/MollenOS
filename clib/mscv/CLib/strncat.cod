; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strncat.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strncat
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strncat.c
;	COMDAT _strncat
_TEXT	SEGMENT
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_num$ = 16						; size = 4
_strncat PROC						; COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	char *s = destination;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _destination$[ebp]
  00006	56		 push	 esi
  00007	8b c1		 mov	 eax, ecx

; 27   : 
; 28   : 	/* Skip over the data in s1 as quickly as possible.  */
; 29   : 	if (ALIGNED (destination))

  00009	f6 c1 03	 test	 cl, 3
  0000c	75 2c		 jne	 SHORT $LN6@strncat

; 30   : 	{
; 31   : 		unsigned long *aligned_s1 = (unsigned long *)destination;
; 32   : 		
; 33   : 		while (!DETECTNULL (*aligned_s1))

  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	8d b2 ff fe fe
	fe		 lea	 esi, DWORD PTR [edx-16843009]
  00016	f7 d2		 not	 edx
  00018	23 f2		 and	 esi, edx
  0001a	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  00020	75 18		 jne	 SHORT $LN6@strncat
$LL7@strncat:
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 34   : 			aligned_s1++;

  00025	83 c1 04	 add	 ecx, 4
  00028	8d b2 ff fe fe
	fe		 lea	 esi, DWORD PTR [edx-16843009]
  0002e	f7 d2		 not	 edx
  00030	23 f2		 and	 esi, edx
  00032	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  00038	74 e8		 je	 SHORT $LL7@strncat
$LN6@strncat:

; 35   : 
; 36   : 		destination = (char *)aligned_s1;
; 37   : 	}
; 38   : 
; 39   : 	while (*destination)

  0003a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0003d	74 07		 je	 SHORT $LN13@strncat
  0003f	90		 npad	 1
$LL5@strncat:

; 40   : 		destination++;

  00040	41		 inc	 ecx
  00041	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00044	75 fa		 jne	 SHORT $LL5@strncat
$LN13@strncat:

; 41   : 
; 42   : 	/* s1 now points to the its trailing null character, now copy
; 43   : 		up to N bytes from S2 into S1 stopping if a NULL is encountered
; 44   : 		in S2.
; 45   : 
; 46   : 		It is not safe to use strncpy here since it copies EXACTLY N
; 47   : 		characters, NULL padding if necessary.  */
; 48   : 	while (num-- != 0 && (*destination++ = *source++))

  00046	8b 75 10	 mov	 esi, DWORD PTR _num$[ebp]
  00049	85 f6		 test	 esi, esi
  0004b	74 19		 je	 SHORT $LN16@strncat

; 49   : 	{
; 50   : 		if (num == 0)

  0004d	57		 push	 edi
  0004e	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00051	2b f9		 sub	 edi, ecx
$LL3@strncat:

; 41   : 
; 42   : 	/* s1 now points to the its trailing null character, now copy
; 43   : 		up to N bytes from S2 into S1 stopping if a NULL is encountered
; 44   : 		in S2.
; 45   : 
; 46   : 		It is not safe to use strncpy here since it copies EXACTLY N
; 47   : 		characters, NULL padding if necessary.  */
; 48   : 	while (num-- != 0 && (*destination++ = *source++))

  00053	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  00056	88 11		 mov	 BYTE PTR [ecx], dl
  00058	4e		 dec	 esi
  00059	41		 inc	 ecx
  0005a	84 d2		 test	 dl, dl
  0005c	74 07		 je	 SHORT $LN19@strncat

; 49   : 	{
; 50   : 		if (num == 0)

  0005e	85 f6		 test	 esi, esi
  00060	75 f1		 jne	 SHORT $LL3@strncat

; 51   : 			*destination = '\0';

  00062	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN19@strncat:
  00065	5f		 pop	 edi
$LN16@strncat:
  00066	5e		 pop	 esi

; 52   : 	}
; 53   : 	
; 54   : 	return s;
; 55   : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_strncat ENDP
_TEXT	ENDS
END
