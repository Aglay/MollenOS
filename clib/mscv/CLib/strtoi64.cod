; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strtoi64.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___tolower
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\include\ctype.h
;	COMDAT ___tolower
_TEXT	SEGMENT
_c$ = 8							; size = 1
___tolower PROC						; COMDAT

; 61   : __inline unsigned char __tolower(unsigned char c) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   :         return isupper(c) ? c - ('A' - 'a') : c;

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _c$[ebp]
  00007	f6 80 00 00 00
	00 01		 test	 BYTE PTR __ctype[eax], 1
  0000e	74 03		 je	 SHORT $LN4@tolower
  00010	83 c0 20	 add	 eax, 32			; 00000020H
$LN4@tolower:

; 63   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___tolower ENDP
_TEXT	ENDS
PUBLIC	_strtoi64
EXTRN	___errno:PROC
EXTRN	__allmul:PROC
EXTRN	__alldiv:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strtoi64.c
;	COMDAT _strtoi64
_TEXT	SEGMENT
_ret$ = -16						; size = 8
_negative$ = -8						; size = 4
_v$1399 = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoi64 PROC						; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 9    : 	BOOL negative = FALSE;
; 10   : 	__int64 ret = 0;
; 11   : 
; 12   : 	while(isspace((unsigned char)*nptr)) nptr++;

  00006	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
  00009	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 f6		 xor	 esi, esi
  00010	33 ff		 xor	 edi, edi
  00012	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  00019	89 7d f8	 mov	 DWORD PTR _negative$[ebp], edi
  0001c	89 75 f0	 mov	 DWORD PTR _ret$[ebp], esi
  0001f	74 0e		 je	 SHORT $LN24@strtoi64
$LL25@strtoi64:
  00021	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  00025	42		 inc	 edx
  00026	f6 81 00 00 00
	00 20		 test	 BYTE PTR __ctype[ecx], 32 ; 00000020H
  0002d	75 f2		 jne	 SHORT $LL25@strtoi64
$LN24@strtoi64:

; 13   : 
; 14   : 	if(*nptr == '-') {

  0002f	8a 02		 mov	 al, BYTE PTR [edx]
  00031	3c 2d		 cmp	 al, 45			; 0000002dH
  00033	75 0c		 jne	 SHORT $LN23@strtoi64

; 15   : 		negative = TRUE;

  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1

; 16   : 		nptr++;

  0003c	8b 7d f8	 mov	 edi, DWORD PTR _negative$[ebp]
  0003f	eb 04		 jmp	 SHORT $LN55@strtoi64
$LN23@strtoi64:

; 17   : 	} else if(*nptr == '+')

  00041	3c 2b		 cmp	 al, 43			; 0000002bH
  00043	75 01		 jne	 SHORT $LN47@strtoi64
$LN55@strtoi64:

; 18   : 		nptr++;

  00045	42		 inc	 edx
$LN47@strtoi64:

; 19   : 
; 20   : 	if((base==0 || base==16) && *nptr=='0' && tolower(*(nptr+1))=='x') {

  00046	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
  00049	3b c6		 cmp	 eax, esi
  0004b	74 05		 je	 SHORT $LN19@strtoi64
  0004d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00050	75 26		 jne	 SHORT $LN20@strtoi64
$LN19@strtoi64:
  00052	80 3a 30	 cmp	 BYTE PTR [edx], 48	; 00000030H
  00055	75 21		 jne	 SHORT $LN20@strtoi64
  00057	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  0005b	f6 81 00 00 00
	00 01		 test	 BYTE PTR __ctype[ecx], 1
  00062	74 03		 je	 SHORT $LN30@strtoi64
  00064	83 c1 20	 add	 ecx, 32			; 00000020H
$LN30@strtoi64:
  00067	80 f9 78	 cmp	 cl, 120			; 00000078H
  0006a	75 0c		 jne	 SHORT $LN20@strtoi64

; 21   : 		base = 16;

  0006c	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H

; 22   : 		nptr += 2;

  00073	83 c2 02	 add	 edx, 2

; 23   : 	}
; 24   : 
; 25   : 	if(base == 0) {

  00076	eb 13		 jmp	 SHORT $LN56@strtoi64
$LN20@strtoi64:
  00078	3b c6		 cmp	 eax, esi
  0007a	75 12		 jne	 SHORT $LN17@strtoi64

; 26   : 		if(*nptr=='0')

  0007c	33 c0		 xor	 eax, eax
  0007e	80 3a 30	 cmp	 BYTE PTR [edx], 48	; 00000030H
  00081	0f 95 c0	 setne	 al
  00084	8d 44 00 08	 lea	 eax, DWORD PTR [eax+eax+8]
  00088	89 45 10	 mov	 DWORD PTR _base$[ebp], eax
$LN56@strtoi64:
  0008b	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
$LN17@strtoi64:

; 27   : 			base = 8;
; 28   : 		else
; 29   : 			base = 10;
; 30   : 	}
; 31   : 
; 32   : 	while(*nptr) {

  0008e	8a 0a		 mov	 cl, BYTE PTR [edx]
  00090	84 c9		 test	 cl, cl
  00092	0f 84 44 01 00
	00		 je	 $LN53@strtoi64
  00098	53		 push	 ebx
  00099	eb 0b		 jmp	 SHORT $LN15@strtoi64
  0009b	eb 03 8d 49 00	 npad	 5
$LL50@strtoi64:
  000a0	8b 7d f8	 mov	 edi, DWORD PTR _negative$[ebp]
  000a3	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
$LN15@strtoi64:

; 33   : 		char cur = tolower(*nptr);

  000a6	0f b6 d9	 movzx	 ebx, cl
  000a9	f6 83 00 00 00
	00 01		 test	 BYTE PTR __ctype[ebx], 1
  000b0	74 03		 je	 SHORT $LN34@strtoi64
  000b2	80 c1 20	 add	 cl, 32			; 00000020H
$LN34@strtoi64:

; 34   : 		int v;
; 35   : 
; 36   : 		if(isdigit((unsigned char)cur)) {

  000b5	0f b6 d9	 movzx	 ebx, cl
  000b8	f6 83 00 00 00
	00 04		 test	 BYTE PTR __ctype[ebx], 4
  000bf	74 13		 je	 SHORT $LN13@strtoi64

; 37   : 			if(cur >= '0'+base)

  000c1	0f be c9	 movsx	 ecx, cl
  000c4	8d 58 30	 lea	 ebx, DWORD PTR [eax+48]
  000c7	3b cb		 cmp	 ecx, ebx
  000c9	0f 8d 0c 01 00
	00		 jge	 $LN54@strtoi64

; 38   : 				break;
; 39   : 			v = cur-'0';

  000cf	83 c1 d0	 add	 ecx, -48		; ffffffd0H

; 40   : 		} else {

  000d2	eb 1a		 jmp	 SHORT $LN57@strtoi64
$LN13@strtoi64:

; 41   : 			if(cur<'a' || cur>='a'+base-10)

  000d4	80 f9 61	 cmp	 cl, 97			; 00000061H
  000d7	0f 8c fe 00 00
	00		 jl	 $LN54@strtoi64
  000dd	0f be c9	 movsx	 ecx, cl
  000e0	8d 58 57	 lea	 ebx, DWORD PTR [eax+87]
  000e3	3b cb		 cmp	 ecx, ebx
  000e5	0f 8d f0 00 00
	00		 jge	 $LN54@strtoi64

; 42   : 				break;
; 43   : 			v = cur-'a'+10;

  000eb	83 c1 a9	 add	 ecx, -87		; ffffffa9H
$LN57@strtoi64:
  000ee	89 4d fc	 mov	 DWORD PTR _v$1399[ebp], ecx

; 44   : 		}
; 45   : 
; 46   : 		if(negative)

  000f1	85 ff		 test	 edi, edi
  000f3	74 05		 je	 SHORT $LN8@strtoi64

; 47   : 			v = -v;

  000f5	f7 d9		 neg	 ecx
  000f7	89 4d fc	 mov	 DWORD PTR _v$1399[ebp], ecx
$LN8@strtoi64:

; 48   : 
; 49   : 		nptr++;

  000fa	42		 inc	 edx
  000fb	89 55 08	 mov	 DWORD PTR _nptr$[ebp], edx

; 50   : 
; 51   : 		if(!negative && (ret > _I64_MAX / base || ret * base > _I64_MAX-v)) {

  000fe	99		 cdq
  000ff	85 ff		 test	 edi, edi
  00101	75 60		 jne	 SHORT $LN41@strtoi64
  00103	8b fa		 mov	 edi, edx
  00105	57		 push	 edi
  00106	8b d8		 mov	 ebx, eax
  00108	53		 push	 ebx
  00109	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0010e	6a ff		 push	 -1
  00110	e8 00 00 00 00	 call	 __alldiv
  00115	3b f2		 cmp	 esi, edx
  00117	7f 31		 jg	 SHORT $LN48@strtoi64
  00119	7c 05		 jl	 SHORT $LN51@strtoi64
  0011b	39 45 f0	 cmp	 DWORD PTR _ret$[ebp], eax
  0011e	77 2a		 ja	 SHORT $LN48@strtoi64
$LN51@strtoi64:
  00120	8b 55 f0	 mov	 edx, DWORD PTR _ret$[ebp]
  00123	56		 push	 esi
  00124	52		 push	 edx
  00125	57		 push	 edi
  00126	53		 push	 ebx
  00127	e8 00 00 00 00	 call	 __allmul
  0012c	8b d8		 mov	 ebx, eax
  0012e	8b 45 fc	 mov	 eax, DWORD PTR _v$1399[ebp]
  00131	8b ca		 mov	 ecx, edx
  00133	99		 cdq
  00134	83 cf ff	 or	 edi, -1
  00137	2b f8		 sub	 edi, eax
  00139	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0013e	1b f2		 sbb	 esi, edx
  00140	3b ce		 cmp	 ecx, esi
  00142	7c 7e		 jl	 SHORT $LN4@strtoi64
  00144	7f 04		 jg	 SHORT $LN48@strtoi64
  00146	3b df		 cmp	 ebx, edi
  00148	76 78		 jbe	 SHORT $LN4@strtoi64
$LN48@strtoi64:

; 52   : 			ret = _I64_MAX;

  0014a	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
  00151	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH

; 53   : 			*__errno() = ERANGE;

  00156	e8 00 00 00 00	 call	 ___errno
  0015b	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00161	eb 68		 jmp	 SHORT $LN2@strtoi64
$LN41@strtoi64:

; 54   : 		} else if(negative && (ret < _I64_MIN / base || ret * base < _I64_MIN-v)) {

  00163	8b da		 mov	 ebx, edx
  00165	53		 push	 ebx
  00166	8b f8		 mov	 edi, eax
  00168	57		 push	 edi
  00169	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0016e	6a 00		 push	 0
  00170	e8 00 00 00 00	 call	 __alldiv
  00175	3b f2		 cmp	 esi, edx
  00177	7c 30		 jl	 SHORT $LN49@strtoi64
  00179	7f 05		 jg	 SHORT $LN52@strtoi64
  0017b	39 45 f0	 cmp	 DWORD PTR _ret$[ebp], eax
  0017e	72 29		 jb	 SHORT $LN49@strtoi64
$LN52@strtoi64:
  00180	8b 45 f0	 mov	 eax, DWORD PTR _ret$[ebp]
  00183	56		 push	 esi
  00184	50		 push	 eax
  00185	53		 push	 ebx
  00186	57		 push	 edi
  00187	e8 00 00 00 00	 call	 __allmul
  0018c	8b d8		 mov	 ebx, eax
  0018e	8b 45 fc	 mov	 eax, DWORD PTR _v$1399[ebp]
  00191	8b ca		 mov	 ecx, edx
  00193	99		 cdq
  00194	33 ff		 xor	 edi, edi
  00196	2b f8		 sub	 edi, eax
  00198	be 00 00 00 80	 mov	 esi, -2147483648	; 80000000H
  0019d	1b f2		 sbb	 esi, edx
  0019f	3b ce		 cmp	 ecx, esi
  001a1	7f 1f		 jg	 SHORT $LN4@strtoi64
  001a3	7c 04		 jl	 SHORT $LN49@strtoi64
  001a5	3b df		 cmp	 ebx, edi
  001a7	73 19		 jae	 SHORT $LN4@strtoi64
$LN49@strtoi64:

; 55   : 			ret = _I64_MIN;

  001a9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  001b0	be 00 00 00 80	 mov	 esi, -2147483648	; 80000000H

; 56   : 			*__errno() = ERANGE;

  001b5	e8 00 00 00 00	 call	 ___errno
  001ba	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H

; 57   : 		} else

  001c0	eb 09		 jmp	 SHORT $LN2@strtoi64
$LN4@strtoi64:

; 58   : 			ret = ret*base + v;

  001c2	03 c3		 add	 eax, ebx
  001c4	13 d1		 adc	 edx, ecx
  001c6	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax
  001c9	8b f2		 mov	 esi, edx
$LN2@strtoi64:

; 27   : 			base = 8;
; 28   : 		else
; 29   : 			base = 10;
; 30   : 	}
; 31   : 
; 32   : 	while(*nptr) {

  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
  001ce	8a 09		 mov	 cl, BYTE PTR [ecx]
  001d0	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
  001d3	84 c9		 test	 cl, cl
  001d5	0f 85 c5 fe ff
	ff		 jne	 $LL50@strtoi64
$LN54@strtoi64:
  001db	5b		 pop	 ebx
$LN53@strtoi64:

; 59   : 	}
; 60   : 
; 61   : 	if(endptr)

  001dc	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  001df	85 c0		 test	 eax, eax
  001e1	74 02		 je	 SHORT $LN46@strtoi64

; 62   : 		*endptr = (char*)nptr;

  001e3	89 10		 mov	 DWORD PTR [eax], edx
$LN46@strtoi64:

; 63   : 
; 64   : 	return ret;

  001e5	8b 45 f0	 mov	 eax, DWORD PTR _ret$[ebp]
  001e8	5f		 pop	 edi
  001e9	8b d6		 mov	 edx, esi
  001eb	5e		 pop	 esi

; 65   : }

  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
_strtoi64 ENDP
_TEXT	ENDS
END
