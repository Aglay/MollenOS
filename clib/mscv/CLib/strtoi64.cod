; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strtoi64.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoi64
PUBLIC	___tolower
EXTRN	___errno:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\ctype.h
;	COMDAT ___tolower
_TEXT	SEGMENT
_c$ = 8							; size = 1
___tolower PROC						; COMDAT

; 61   : __inline unsigned char __tolower(unsigned char c) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   :         return isupper(c) ? c - ('A' - 'a') : c;

  00003	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00006	0f b6 c0	 movzx	 eax, al
  00009	f6 80 00 00 00
	00 01		 test	 BYTE PTR __ctype[eax], 1
  00010	74 03		 je	 SHORT $LN4@tolower
  00012	83 c0 20	 add	 eax, 32			; 00000020H
$LN4@tolower:

; 63   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
___tolower ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoi64.c
; File c:\users\philip\documents\github\mollenos\clib\include\ctype.h
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoi64.c
; File c:\users\philip\documents\github\mollenos\clib\include\ctype.h
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoi64.c
;	COMDAT _strtoi64
_TEXT	SEGMENT
_ret$ = -16						; size = 8
tv163 = -12						; size = 4
tv133 = -12						; size = 4
tv164 = -8						; size = 4
tv132 = -8						; size = 4
_negative$1$ = -4					; size = 4
tv174 = 8						; size = 4
_ret$2$ = 8						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoi64 PROC						; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 9    : 	BOOL negative = FALSE;
; 10   : 	__int64 ret = 0;
; 11   : 
; 12   : 	while(isspace((unsigned char)*nptr)) nptr++;

  00008	8b 75 08	 mov	 esi, DWORD PTR _nptr$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	89 45 fc	 mov	 DWORD PTR _negative$1$[ebp], eax
  00010	0f 57 c0	 xorps	 xmm0, xmm0
  00013	57		 push	 edi
  00014	66 0f 13 45 f0	 movlpd	 QWORD PTR _ret$[ebp], xmm0
  00019	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0001c	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  00023	74 19		 je	 SHORT $LN24@strtoi64
  00025	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL25@strtoi64:
  00030	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00034	46		 inc	 esi
  00035	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  0003c	75 f2		 jne	 SHORT $LL25@strtoi64
$LN24@strtoi64:

; 13   : 
; 14   : 	if(*nptr == '-') {

  0003e	8a 06		 mov	 al, BYTE PTR [esi]
  00040	3c 2d		 cmp	 al, 45			; 0000002dH
  00042	75 0a		 jne	 SHORT $LN23@strtoi64

; 15   : 		negative = TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	89 45 fc	 mov	 DWORD PTR _negative$1$[ebp], eax

; 16   : 		nptr++;

  0004c	eb 04		 jmp	 SHORT $LN52@strtoi64
$LN23@strtoi64:

; 17   : 	} else if(*nptr == '+')

  0004e	3c 2b		 cmp	 al, 43			; 0000002bH
  00050	75 01		 jne	 SHORT $LN21@strtoi64
$LN52@strtoi64:

; 18   : 		nptr++;

  00052	46		 inc	 esi
$LN21@strtoi64:

; 20   : 	if((base==0 || base==16) && *nptr=='0' && tolower(*(nptr+1))=='x') {

  00053	8b 55 10	 mov	 edx, DWORD PTR _base$[ebp]
  00056	85 d2		 test	 edx, edx
  00058	74 05		 je	 SHORT $LN19@strtoi64
  0005a	83 fa 10	 cmp	 edx, 16			; 00000010H
  0005d	75 23		 jne	 SHORT $LN20@strtoi64
$LN19@strtoi64:
  0005f	80 3e 30	 cmp	 BYTE PTR [esi], 48	; 00000030H
  00062	75 1e		 jne	 SHORT $LN20@strtoi64
; File c:\users\philip\documents\github\mollenos\clib\include\ctype.h

; 62   :         return isupper(c) ? c - ('A' - 'a') : c;

  00064	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00068	f6 80 00 00 00
	00 01		 test	 BYTE PTR __ctype[eax], 1
  0006f	74 03		 je	 SHORT $LN30@strtoi64
  00071	83 c0 20	 add	 eax, 32			; 00000020H
$LN30@strtoi64:
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoi64.c

; 20   : 	if((base==0 || base==16) && *nptr=='0' && tolower(*(nptr+1))=='x') {

  00074	3c 78		 cmp	 al, 120			; 00000078H
  00076	75 0a		 jne	 SHORT $LN20@strtoi64

; 21   : 		base = 16;

  00078	ba 10 00 00 00	 mov	 edx, 16			; 00000010H

; 22   : 		nptr += 2;

  0007d	83 c6 02	 add	 esi, 2

; 23   : 	}
; 24   : 
; 25   : 	if(base == 0) {

  00080	eb 11		 jmp	 SHORT $LN53@strtoi64
$LN20@strtoi64:
  00082	85 d2		 test	 edx, edx
  00084	75 10		 jne	 SHORT $LN17@strtoi64

; 26   : 		if(*nptr=='0')

  00086	80 3e 30	 cmp	 BYTE PTR [esi], 48	; 00000030H
  00089	0f 95 c2	 setne	 dl
  0008c	8d 14 55 08 00
	00 00		 lea	 edx, DWORD PTR [edx*2+8]
$LN53@strtoi64:
  00093	89 55 10	 mov	 DWORD PTR _base$[ebp], edx
$LN17@strtoi64:

; 27   : 			base = 8;
; 28   : 		else
; 29   : 			base = 10;
; 30   : 	}
; 31   : 
; 32   : 	while(*nptr) {

  00096	8a 06		 mov	 al, BYTE PTR [esi]
  00098	8b 5d f4	 mov	 ebx, DWORD PTR _ret$[ebp+4]
  0009b	8b 7d f0	 mov	 edi, DWORD PTR _ret$[ebp]
  0009e	84 c0		 test	 al, al
  000a0	0f 84 3a 01 00
	00		 je	 $LN38@strtoi64
  000a6	89 5d 08	 mov	 DWORD PTR _ret$2$[ebp], ebx
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL15@strtoi64:
; File c:\users\philip\documents\github\mollenos\clib\include\ctype.h

; 62   :         return isupper(c) ? c - ('A' - 'a') : c;

  000b0	0f b6 c8	 movzx	 ecx, al
  000b3	f6 81 00 00 00
	00 01		 test	 BYTE PTR __ctype[ecx], 1
  000ba	74 02		 je	 SHORT $LN34@strtoi64
  000bc	04 20		 add	 al, 32			; 00000020H
$LN34@strtoi64:
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoi64.c

; 36   : 		if(isdigit((unsigned char)cur)) {

  000be	0f b6 c8	 movzx	 ecx, al
  000c1	f6 81 00 00 00
	00 04		 test	 BYTE PTR __ctype[ecx], 4
  000c8	74 13		 je	 SHORT $LN13@strtoi64

; 37   : 			if(cur >= '0'+base)

  000ca	0f be c8	 movsx	 ecx, al
  000cd	8d 42 30	 lea	 eax, DWORD PTR [edx+48]
  000d0	3b c8		 cmp	 ecx, eax
  000d2	0f 8d 08 01 00
	00		 jge	 $LN38@strtoi64

; 38   : 				break;
; 39   : 			v = cur-'0';

  000d8	8d 59 d0	 lea	 ebx, DWORD PTR [ecx-48]

; 40   : 		} else {

  000db	eb 19		 jmp	 SHORT $LN11@strtoi64
$LN13@strtoi64:

; 41   : 			if(cur<'a' || cur>='a'+base-10)

  000dd	3c 61		 cmp	 al, 97			; 00000061H
  000df	0f 8c fb 00 00
	00		 jl	 $LN38@strtoi64
  000e5	0f be c8	 movsx	 ecx, al
  000e8	8d 42 57	 lea	 eax, DWORD PTR [edx+87]
  000eb	3b c8		 cmp	 ecx, eax
  000ed	0f 8d ed 00 00
	00		 jge	 $LN38@strtoi64

; 42   : 				break;
; 43   : 			v = cur-'a'+10;

  000f3	8d 59 a9	 lea	 ebx, DWORD PTR [ecx-87]
$LN11@strtoi64:

; 44   : 		}
; 45   : 
; 46   : 		if(negative)

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _negative$1$[ebp]
  000f9	85 c0		 test	 eax, eax
  000fb	74 02		 je	 SHORT $LN8@strtoi64

; 47   : 			v = -v;

  000fd	f7 db		 neg	 ebx
$LN8@strtoi64:

; 48   : 
; 49   : 		nptr++;

  000ff	46		 inc	 esi

; 50   : 
; 51   : 		if(!negative && (ret > _I64_MAX / base || ret * base > _I64_MAX-v)) {

  00100	85 c0		 test	 eax, eax
  00102	8b c2		 mov	 eax, edx
  00104	99		 cdq
  00105	8b c8		 mov	 ecx, eax
  00107	8b c2		 mov	 eax, edx
  00109	50		 push	 eax
  0010a	51		 push	 ecx
  0010b	75 59		 jne	 SHORT $LN45@strtoi64
  0010d	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00112	6a ff		 push	 -1
  00114	89 4d f4	 mov	 DWORD PTR tv133[ebp], ecx
  00117	89 45 f8	 mov	 DWORD PTR tv132[ebp], eax
  0011a	e8 00 00 00 00	 call	 __alldiv
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _ret$2$[ebp]
  00122	3b ca		 cmp	 ecx, edx
  00124	7f 36		 jg	 SHORT $LN47@strtoi64
  00126	7c 04		 jl	 SHORT $LN46@strtoi64
  00128	3b f8		 cmp	 edi, eax
  0012a	77 30		 ja	 SHORT $LN47@strtoi64
$LN46@strtoi64:
  0012c	51		 push	 ecx
  0012d	57		 push	 edi
  0012e	ff 75 f8	 push	 DWORD PTR tv132[ebp]
  00131	ff 75 f4	 push	 DWORD PTR tv133[ebp]
  00134	e8 00 00 00 00	 call	 __allmul
  00139	8b c8		 mov	 ecx, eax
  0013b	89 55 08	 mov	 DWORD PTR tv174[ebp], edx
  0013e	8b c3		 mov	 eax, ebx
  00140	99		 cdq
  00141	8b da		 mov	 ebx, edx
  00143	8b f8		 mov	 edi, eax
  00145	83 ca ff	 or	 edx, -1
  00148	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0014d	2b d7		 sub	 edx, edi
  0014f	1b c3		 sbb	 eax, ebx
  00151	39 45 08	 cmp	 DWORD PTR tv174[ebp], eax
  00154	7c 5e		 jl	 SHORT $LN49@strtoi64
  00156	7f 04		 jg	 SHORT $LN47@strtoi64
  00158	3b ca		 cmp	 ecx, edx
  0015a	76 58		 jbe	 SHORT $LN49@strtoi64
$LN47@strtoi64:

; 52   : 			ret = _I64_MAX;

  0015c	83 cf ff	 or	 edi, -1
  0015f	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH

; 53   : 			*__errno() = ERANGE;

  00164	eb 5f		 jmp	 SHORT $LN54@strtoi64
$LN45@strtoi64:

; 54   : 		} else if(negative && (ret < _I64_MIN / base || ret * base < _I64_MIN-v)) {

  00166	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0016b	6a 00		 push	 0
  0016d	89 4d f8	 mov	 DWORD PTR tv164[ebp], ecx
  00170	89 45 f4	 mov	 DWORD PTR tv163[ebp], eax
  00173	e8 00 00 00 00	 call	 __alldiv
  00178	8b 4d 08	 mov	 ecx, DWORD PTR _ret$2$[ebp]
  0017b	3b ca		 cmp	 ecx, edx
  0017d	7c 3f		 jl	 SHORT $LN3@strtoi64
  0017f	7f 04		 jg	 SHORT $LN48@strtoi64
  00181	3b f8		 cmp	 edi, eax
  00183	72 39		 jb	 SHORT $LN3@strtoi64
$LN48@strtoi64:
  00185	51		 push	 ecx
  00186	57		 push	 edi
  00187	ff 75 f4	 push	 DWORD PTR tv163[ebp]
  0018a	ff 75 f8	 push	 DWORD PTR tv164[ebp]
  0018d	e8 00 00 00 00	 call	 __allmul
  00192	8b c8		 mov	 ecx, eax
  00194	89 55 08	 mov	 DWORD PTR tv174[ebp], edx
  00197	8b c3		 mov	 eax, ebx
  00199	99		 cdq
  0019a	8b da		 mov	 ebx, edx
  0019c	8b f8		 mov	 edi, eax
  0019e	33 d2		 xor	 edx, edx
  001a0	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  001a5	2b d7		 sub	 edx, edi
  001a7	1b c3		 sbb	 eax, ebx
  001a9	39 45 08	 cmp	 DWORD PTR tv174[ebp], eax
  001ac	7c 10		 jl	 SHORT $LN3@strtoi64
  001ae	7f 04		 jg	 SHORT $LN49@strtoi64
  001b0	3b ca		 cmp	 ecx, edx
  001b2	72 0a		 jb	 SHORT $LN3@strtoi64
$LN49@strtoi64:

; 57   : 		} else
; 58   : 			ret = ret*base + v;

  001b4	03 f9		 add	 edi, ecx
  001b6	13 5d 08	 adc	 ebx, DWORD PTR tv174[ebp]
  001b9	89 5d 08	 mov	 DWORD PTR _ret$2$[ebp], ebx
  001bc	eb 15		 jmp	 SHORT $LN2@strtoi64
$LN3@strtoi64:

; 55   : 			ret = _I64_MIN;

  001be	33 ff		 xor	 edi, edi
  001c0	bb 00 00 00 80	 mov	 ebx, -2147483648	; 80000000H
$LN54@strtoi64:
  001c5	89 5d 08	 mov	 DWORD PTR _ret$2$[ebp], ebx

; 56   : 			*__errno() = ERANGE;

  001c8	e8 00 00 00 00	 call	 ___errno
  001cd	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
$LN2@strtoi64:

; 27   : 			base = 8;
; 28   : 		else
; 29   : 			base = 10;
; 30   : 	}
; 31   : 
; 32   : 	while(*nptr) {

  001d3	8a 06		 mov	 al, BYTE PTR [esi]
  001d5	8b 55 10	 mov	 edx, DWORD PTR _base$[ebp]
  001d8	84 c0		 test	 al, al
  001da	0f 85 d0 fe ff
	ff		 jne	 $LL15@strtoi64
$LN38@strtoi64:

; 59   : 	}
; 60   : 
; 61   : 	if(endptr)

  001e0	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]

; 63   : 
; 64   : 	return ret;

  001e3	8b d3		 mov	 edx, ebx
  001e5	85 c0		 test	 eax, eax
  001e7	74 02		 je	 SHORT $LN50@strtoi64

; 62   : 		*endptr = (char*)nptr;

  001e9	89 30		 mov	 DWORD PTR [eax], esi
$LN50@strtoi64:

; 63   : 
; 64   : 	return ret;

  001eb	8b c7		 mov	 eax, edi
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx

; 65   : }

  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
_strtoi64 ENDP
_TEXT	ENDS
END
