; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\atoi64.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_atoi64
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\atoi64.c
;	COMDAT _atoi64
_TEXT	SEGMENT
_neg$ = -4						; size = 4
_s$ = 8							; size = 4
_nptr$ = 8						; size = 4
_atoi64	PROC						; COMDAT

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10   :   char *s = (char *)nptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]

; 11   :   __int64 acc = 0;

  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	89 45 08	 mov	 DWORD PTR _s$[ebp], eax

; 12   :   int neg = 0;

  0000f	89 4d fc	 mov	 DWORD PTR _neg$[ebp], ecx

; 13   : 
; 14   :   if (nptr == NULL)

  00012	3b c1		 cmp	 eax, ecx
  00014	75 09		 jne	 SHORT $LN12@atoi64

; 15   :     return 0;

  00016	33 c0		 xor	 eax, eax
  00018	33 d2		 xor	 edx, edx
  0001a	5e		 pop	 esi

; 36   : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN12@atoi64:
  0001f	57		 push	 edi

; 16   : 
; 17   :   while(isspace((int)*s))

  00020	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  00023	b2 20		 mov	 dl, 32			; 00000020H
  00025	84 97 00 00 00
	00		 test	 BYTE PTR __ctype[edi], dl
  0002b	74 13		 je	 SHORT $LN7@atoi64
  0002d	8d 49 00	 npad	 3
$LL8@atoi64:
  00030	0f b6 78 01	 movzx	 edi, BYTE PTR [eax+1]

; 18   :     s++;

  00034	40		 inc	 eax
  00035	84 97 00 00 00
	00		 test	 BYTE PTR __ctype[edi], dl
  0003b	75 f3		 jne	 SHORT $LL8@atoi64
  0003d	89 45 08	 mov	 DWORD PTR _s$[ebp], eax
$LN7@atoi64:

; 19   :   if (*s == '-')

  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00045	75 09		 jne	 SHORT $LN6@atoi64

; 20   :     {
; 21   :       neg = 1;

  00047	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _neg$[ebp], 1

; 22   :       s++;

  0004e	eb 05		 jmp	 SHORT $LN16@atoi64
$LN6@atoi64:

; 23   :     }
; 24   :   else if (*s == '+')

  00050	80 fa 2b	 cmp	 dl, 43			; 0000002bH
  00053	75 04		 jne	 SHORT $LN13@atoi64
$LN16@atoi64:

; 25   :     s++;

  00055	40		 inc	 eax
  00056	89 45 08	 mov	 DWORD PTR _s$[ebp], eax
$LN13@atoi64:

; 26   : 
; 27   :   while (isdigit((int)*s))

  00059	8a 00		 mov	 al, BYTE PTR [eax]
  0005b	0f b6 d0	 movzx	 edx, al
  0005e	f6 82 00 00 00
	00 04		 test	 BYTE PTR __ctype[edx], 4
  00065	74 3a		 je	 SHORT $LN2@atoi64
  00067	53		 push	 ebx
$LL3@atoi64:

; 28   :     {
; 29   :       acc = 10 * acc + ((int)*s - '0');

  00068	0f be c0	 movsx	 eax, al
  0006b	83 e8 30	 sub	 eax, 48			; 00000030H
  0006e	99		 cdq
  0006f	8b f8		 mov	 edi, eax
  00071	8b c6		 mov	 eax, esi
  00073	8b d9		 mov	 ebx, ecx
  00075	0f a4 c1 02	 shld	 ecx, eax, 2
  00079	03 c0		 add	 eax, eax
  0007b	03 c0		 add	 eax, eax
  0007d	03 f0		 add	 esi, eax

; 30   :       s++;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00082	13 cb		 adc	 ecx, ebx
  00084	0f a4 f1 01	 shld	 ecx, esi, 1
  00088	03 f6		 add	 esi, esi
  0008a	03 f7		 add	 esi, edi
  0008c	13 ca		 adc	 ecx, edx
  0008e	40		 inc	 eax
  0008f	89 45 08	 mov	 DWORD PTR _s$[ebp], eax
  00092	8a 00		 mov	 al, BYTE PTR [eax]
  00094	0f b6 d0	 movzx	 edx, al
  00097	f6 82 00 00 00
	00 04		 test	 BYTE PTR __ctype[edx], 4
  0009e	75 c8		 jne	 SHORT $LL3@atoi64
  000a0	5b		 pop	 ebx
$LN2@atoi64:

; 31   :     }
; 32   : 
; 33   :   if (neg)

  000a1	83 7d fc 00	 cmp	 DWORD PTR _neg$[ebp], 0
  000a5	5f		 pop	 edi
  000a6	74 07		 je	 SHORT $LN1@atoi64

; 34   :     acc *= -1;

  000a8	f7 de		 neg	 esi
  000aa	83 d1 00	 adc	 ecx, 0
  000ad	f7 d9		 neg	 ecx
$LN1@atoi64:

; 35   :   return acc;

  000af	8b c6		 mov	 eax, esi
  000b1	8b d1		 mov	 edx, ecx
  000b3	5e		 pop	 esi

; 36   : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
_atoi64	ENDP
_TEXT	ENDS
END
