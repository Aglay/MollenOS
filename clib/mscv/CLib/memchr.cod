; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\memchr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_memchr
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\memchr.c
;	COMDAT _memchr
_TEXT	SEGMENT
_src_void$ = 8						; size = 4
_c$ = 12						; size = 4
_length$ = 16						; size = 4
_memchr	PROC						; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	const unsigned char *src = (const unsigned char *)src_void;

  00003	8b 45 08	 mov	 eax, DWORD PTR _src_void$[ebp]

; 74   : 	unsigned char d = (unsigned char)c;
; 75   : 	unsigned long *asrc;
; 76   : 	unsigned long  mask;
; 77   : 	int i;
; 78   : 
; 79   : 	while (_memchrUNALIGNED (src))

  00006	8b 55 10	 mov	 edx, DWORD PTR _length$[ebp]
  00009	53		 push	 ebx
  0000a	8a 5d 0c	 mov	 bl, BYTE PTR _c$[ebp]
  0000d	a8 03		 test	 al, 3
  0000f	74 10		 je	 SHORT $LN13@memchr
$LL14@memchr:

; 80   : 	{
; 81   : 		if (!length--)

  00011	8b ca		 mov	 ecx, edx
  00013	4a		 dec	 edx
  00014	85 c9		 test	 ecx, ecx
  00016	74 62		 je	 SHORT $LN28@memchr

; 82   : 			return NULL;
; 83   : 
; 84   : 		if (*src == d)

  00018	38 18		 cmp	 BYTE PTR [eax], bl
  0001a	74 60		 je	 SHORT $LN15@memchr

; 85   : 			return (void *)src;
; 86   : 
; 87   : 		src++;

  0001c	40		 inc	 eax
  0001d	a8 03		 test	 al, 3
  0001f	75 f0		 jne	 SHORT $LL14@memchr
$LN13@memchr:

; 88   : 	}
; 89   : 
; 90   : 	if (!TOO_SMALL (length))

  00021	83 fa 04	 cmp	 edx, 4
  00024	72 3f		 jb	 SHORT $LN20@memchr

; 91   : 	{
; 92   : 		/* If we get this far, we know that length is large and src is
; 93   : 			word-aligned. */
; 94   : 		/* The fast code reads the source one word at a time and only
; 95   : 			performs the bytewise search on word-sized segments if they
; 96   : 			contain the search character, which is detected by XORing
; 97   : 			the word-sized segment with a word-sized block of the search
; 98   : 			character and then detecting for the presence of NUL in the
; 99   : 			result.  */
; 100  : 		asrc = (unsigned long *) src;

  00026	56		 push	 esi
  00027	8b f0		 mov	 esi, eax

; 101  : 		mask = d << 8 | d;

  00029	0f b6 c3	 movzx	 eax, bl
  0002c	8b c8		 mov	 ecx, eax
  0002e	c1 e1 08	 shl	 ecx, 8
  00031	0b c8		 or	 ecx, eax

; 102  : 		mask = mask << 16 | mask;

  00033	8b c1		 mov	 eax, ecx
  00035	c1 e0 10	 shl	 eax, 16			; 00000010H
  00038	57		 push	 edi
  00039	0b c8		 or	 ecx, eax
  0003b	eb 03 8d 49 00	 npad	 5
$LL6@memchr:

; 103  : 
; 104  : 		for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
; 105  : 			mask = (mask << i) | mask;
; 106  : 
; 107  : 		while (length >= LBLOCKSIZE)
; 108  : 		{
; 109  : 			if (DETECTCHAR (*asrc, mask))

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	33 c1		 xor	 eax, ecx
  00044	8d b8 ff fe fe
	fe		 lea	 edi, DWORD PTR [eax-16843009]
  0004a	f7 d0		 not	 eax
  0004c	23 f8		 and	 edi, eax
  0004e	f7 c7 80 80 80
	80		 test	 edi, -2139062144	; 80808080H
  00054	75 0b		 jne	 SHORT $LN23@memchr

; 110  : 			break;
; 111  : 			length -= LBLOCKSIZE;

  00056	83 ea 04	 sub	 edx, 4

; 112  : 			asrc++;

  00059	83 c6 04	 add	 esi, 4
  0005c	83 fa 04	 cmp	 edx, 4
  0005f	73 df		 jae	 SHORT $LL6@memchr
$LN23@memchr:
  00061	5f		 pop	 edi

; 113  : 		}
; 114  : 
; 115  : 		/* If there are fewer than LBLOCKSIZE characters left,
; 116  : 			then we resort to the bytewise loop.  */
; 117  : 
; 118  : 		src = (unsigned char *) asrc;

  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi
$LN20@memchr:

; 119  : 	}
; 120  : 
; 121  : 	while (length--)

  00065	85 d2		 test	 edx, edx
  00067	74 11		 je	 SHORT $LN28@memchr
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL3@memchr:
  00070	4a		 dec	 edx

; 122  : 	{
; 123  : 		if (*src == d)

  00071	38 18		 cmp	 BYTE PTR [eax], bl
  00073	74 07		 je	 SHORT $LN15@memchr

; 124  : 		return (void *) src;
; 125  : 		src++;

  00075	40		 inc	 eax
  00076	85 d2		 test	 edx, edx
  00078	75 f6		 jne	 SHORT $LL3@memchr
$LN28@memchr:

; 126  : 	}
; 127  : 
; 128  : 	return NULL;

  0007a	33 c0		 xor	 eax, eax
$LN15@memchr:
  0007c	5b		 pop	 ebx

; 129  : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_memchr	ENDP
_TEXT	ENDS
END
