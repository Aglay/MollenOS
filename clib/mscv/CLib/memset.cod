; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\memset.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_memset
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\memset.c
;	COMDAT _memset
_TEXT	SEGMENT
_buffer$1$ = -4						; size = 4
_dest$ = 8						; size = 4
_c$ = 12						; size = 4
_count$ = 16						; size = 4
_memset	PROC						; COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 15   : 	char *s = (char *)dest;

  00004	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 16   : 	int i;
; 17   : 	unsigned long buffer;
; 18   : 	unsigned long *aligned_addr;
; 19   : 	unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an

  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]

; 20   : 					unsigned variable.  */
; 21   : 
; 22   : 	while (UNALIGNED (s))

  0000a	8b 55 10	 mov	 edx, DWORD PTR _count$[ebp]
  0000d	53		 push	 ebx
  0000e	8b d8		 mov	 ebx, eax
  00010	56		 push	 esi
  00011	0f b6 f1	 movzx	 esi, cl
  00014	a8 03		 test	 al, 3
  00016	74 13		 je	 SHORT $LN13@memset
$LL14@memset:

; 23   : 	{
; 24   : 		if (count--)

  00018	8b c2		 mov	 eax, edx
  0001a	4a		 dec	 edx
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 86 00 00
	00		 je	 $LN12@memset

; 25   : 			*s++ = (char) c;

  00023	88 0b		 mov	 BYTE PTR [ebx], cl
  00025	43		 inc	 ebx
  00026	f6 c3 03	 test	 bl, 3
  00029	75 ed		 jne	 SHORT $LL14@memset
$LN13@memset:
  0002b	57		 push	 edi

; 26   : 		else
; 27   : 			return dest;
; 28   : 	}
; 29   : 
; 30   : 	if (!TOO_SMALL (count))

  0002c	83 fa 04	 cmp	 edx, 4
  0002f	72 57		 jb	 SHORT $LN3@memset

; 34   : 
; 35   : 		/* Store D into each char sized location in BUFFER so that
; 36   : 			we can set large blocks quickly.  */
; 37   : 		buffer = (d << 8) | d;

  00031	8b fe		 mov	 edi, esi
  00033	c1 e7 08	 shl	 edi, 8
  00036	0b fe		 or	 edi, esi

; 38   : 		buffer |= (buffer << 16);

  00038	8b c7		 mov	 eax, edi
  0003a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0003d	0b f8		 or	 edi, eax
  0003f	89 7d fc	 mov	 DWORD PTR _buffer$1$[ebp], edi

; 39   : 		for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
; 40   : 			buffer = (buffer << i) | buffer;
; 41   : 
; 42   : 		/* Unroll the loop.  */
; 43   : 		while (count >= LBLOCKSIZE*4)

  00042	83 fa 10	 cmp	 edx, 16			; 00000010H
  00045	72 26		 jb	 SHORT $LN20@memset

; 31   : 	{
; 32   : 		/* If we get this far, we know that n is large and s is word-aligned. */
; 33   : 		aligned_addr = (unsigned long *) s;

  00047	8b f2		 mov	 esi, edx
  00049	8b c7		 mov	 eax, edi
  0004b	c1 ee 04	 shr	 esi, 4
  0004e	8b fb		 mov	 edi, ebx
  00050	8b ce		 mov	 ecx, esi
  00052	81 e1 ff ff ff
	0f		 and	 ecx, 268435455		; 0fffffffH
  00058	c1 e1 02	 shl	 ecx, 2
  0005b	f3 ab		 rep stosd

; 39   : 		for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
; 40   : 			buffer = (buffer << i) | buffer;
; 41   : 
; 42   : 		/* Unroll the loop.  */
; 43   : 		while (count >= LBLOCKSIZE*4)

  0005d	8b c6		 mov	 eax, esi
  0005f	c1 e0 04	 shl	 eax, 4
  00062	03 d8		 add	 ebx, eax
$LL6@memset:

; 44   : 		{
; 45   : 			*aligned_addr++ = buffer;
; 46   : 			*aligned_addr++ = buffer;
; 47   : 			*aligned_addr++ = buffer;
; 48   : 			*aligned_addr++ = buffer;
; 49   : 			count -= 4*LBLOCKSIZE;

  00064	83 ea 10	 sub	 edx, 16			; 00000010H
  00067	4e		 dec	 esi
  00068	75 fa		 jne	 SHORT $LL6@memset
  0006a	8b 7d fc	 mov	 edi, DWORD PTR _buffer$1$[ebp]
$LN20@memset:

; 50   : 		}
; 51   : 
; 52   : 		while (count >= LBLOCKSIZE)

  0006d	83 fa 04	 cmp	 edx, 4
  00070	72 16		 jb	 SHORT $LN3@memset
  00072	8b f2		 mov	 esi, edx
  00074	8b c7		 mov	 eax, edi
  00076	c1 ee 02	 shr	 esi, 2
  00079	8b fb		 mov	 edi, ebx
  0007b	8b ce		 mov	 ecx, esi
  0007d	f3 ab		 rep stosd
  0007f	8d 1c b3	 lea	 ebx, DWORD PTR [ebx+esi*4]
$LL4@memset:

; 53   : 		{
; 54   : 			*aligned_addr++ = buffer;
; 55   : 			count -= LBLOCKSIZE;

  00082	83 ea 04	 sub	 edx, 4
  00085	4e		 dec	 esi
  00086	75 fa		 jne	 SHORT $LL4@memset
$LN3@memset:

; 56   : 		}
; 57   : 		/* Pick up the remainder with a bytewise loop.  */
; 58   : 		s = (char*)aligned_addr;
; 59   : 	}
; 60   : 
; 61   : 	while (count--)

  00088	85 d2		 test	 edx, edx
  0008a	74 1c		 je	 SHORT $LN2@memset
  0008c	0f b6 45 0c	 movzx	 eax, BYTE PTR _c$[ebp]
  00090	8b ca		 mov	 ecx, edx
  00092	8b f1		 mov	 esi, ecx
  00094	69 c0 01 01 01
	01		 imul	 eax, 16843009		; 01010101H
  0009a	c1 e9 02	 shr	 ecx, 2
  0009d	8b fb		 mov	 edi, ebx
  0009f	f3 ab		 rep stosd
  000a1	8b ce		 mov	 ecx, esi
  000a3	83 e1 03	 and	 ecx, 3
  000a6	f3 aa		 rep stosb
$LN2@memset:
  000a8	5f		 pop	 edi
$LN12@memset:

; 62   : 		*s++ = (char) c;
; 63   : 
; 64   : 	return dest;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 65   : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_memset	ENDP
_TEXT	ENDS
END
