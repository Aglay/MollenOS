; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strlen.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strlen
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strlen.c
;	COMDAT _strlen
_TEXT	SEGMENT
_str$ = 8						; size = 4
_strlen	PROC						; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	const char *start = str;

  00003	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00006	8b d0		 mov	 edx, eax

; 32   : 	unsigned long *aligned_addr;
; 33   : 
; 34   : 	/* Align the pointer, so we can search a word at a time.  */
; 35   : 	while (UNALIGNED (str))

  00008	a8 03		 test	 al, 3
  0000a	74 0e		 je	 SHORT $LN6@strlen
  0000c	8d 64 24 00	 npad	 4
$LL7@strlen:

; 36   : 	{
; 37   : 		if (!*str)

  00010	80 38 00	 cmp	 BYTE PTR [eax], 0
  00013	74 42		 je	 SHORT $LN1@strlen

; 38   : 			return str - start;
; 39   : 		str++;

  00015	40		 inc	 eax
  00016	a8 03		 test	 al, 3
  00018	75 f6		 jne	 SHORT $LL7@strlen
$LN6@strlen:

; 40   : 	}
; 41   : 
; 42   : 	/* If the string is word-aligned, we can check for the presence of
; 43   : 		a null in each word-sized block.  */
; 44   : 	aligned_addr = (unsigned long *)str;

  0001a	8b c8		 mov	 ecx, eax

; 45   : 	while (!DETECTNULL (*aligned_addr))

  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	56		 push	 esi
  0001f	8d b0 ff fe fe
	fe		 lea	 esi, DWORD PTR [eax-16843009]
  00025	f7 d0		 not	 eax
  00027	23 f0		 and	 esi, eax
  00029	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  0002f	75 18		 jne	 SHORT $LN3@strlen
$LL4@strlen:
  00031	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 46   : 	aligned_addr++;

  00034	83 c1 04	 add	 ecx, 4
  00037	8d b0 ff fe fe
	fe		 lea	 esi, DWORD PTR [eax-16843009]
  0003d	f7 d0		 not	 eax
  0003f	23 f0		 and	 esi, eax
  00041	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  00047	74 e8		 je	 SHORT $LL4@strlen
$LN3@strlen:

; 47   : 
; 48   : 	/* Once a null is detected, we check each byte in that block for a
; 49   : 		precise position of the null.  */
; 50   : 	str = (char *) aligned_addr;
; 51   : 
; 52   : 	while (*str)

  00049	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0004c	8b c1		 mov	 eax, ecx
  0004e	5e		 pop	 esi
  0004f	74 06		 je	 SHORT $LN1@strlen
$LL2@strlen:

; 53   : 		str++;

  00051	40		 inc	 eax
  00052	80 38 00	 cmp	 BYTE PTR [eax], 0
  00055	75 fa		 jne	 SHORT $LL2@strlen
$LN1@strlen:

; 54   : 
; 55   : 	return str - start;

  00057	2b c2		 sub	 eax, edx

; 56   : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_strlen	ENDP
_TEXT	ENDS
END
