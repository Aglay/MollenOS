; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strstr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\str-two-way.h
;	COMDAT _critical_factorization
_TEXT	SEGMENT
_max_suffix$ = -12					; size = 4
_max_suffix_rev$ = -8					; size = 4
_b$ = -1						; size = 1
_needle$ = 8						; size = 4
_needle_len$ = 12					; size = 4
_period$ = 16						; size = 4
_critical_factorization PROC				; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _needle_len$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR _needle$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 94   :   /* Index of last byte of left half, or SIZE_MAX.  */
; 95   :   size_t max_suffix, max_suffix_rev;
; 96   :   size_t j; /* Index into NEEDLE for current candidate suffix.  */
; 97   :   size_t k; /* Offset into current period.  */
; 98   :   size_t p; /* Intermediate period.  */
; 99   :   unsigned char a, b; /* Current comparison bytes.  */
; 100  : 
; 101  :   /* Invariants:
; 102  :      0 <= j < NEEDLE_LEN - 1
; 103  :      -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)
; 104  :      min(max_suffix, max_suffix_rev) < global period of NEEDLE
; 105  :      1 <= p <= global period of NEEDLE
; 106  :      p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]
; 107  :      1 <= k <= p
; 108  :   */
; 109  : 
; 110  :   /* Perform lexicographic search.  */
; 111  :   max_suffix = SIZE_MAX;
; 112  :   j = 0;
; 113  :   k = p = 1;

  0000f	bf 01 00 00 00	 mov	 edi, 1
  00014	33 f6		 xor	 esi, esi
  00016	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _max_suffix$[ebp], -1
  0001d	8b c7		 mov	 eax, edi

; 114  :   while (j + k < needle_len)

  0001f	3b cf		 cmp	 ecx, edi
  00021	76 4e		 jbe	 SHORT $LN16@critical_f
$LL17@critical_f:

; 115  :     {
; 116  :       a = CANON_ELEMENT (needle[j + k]);
; 117  :       b = CANON_ELEMENT (needle[(size_t)(max_suffix + k)]);

  00023	8b 5d f4	 mov	 ebx, DWORD PTR _max_suffix$[ebp]
  00026	03 d8		 add	 ebx, eax
  00028	0f b6 1c 13	 movzx	 ebx, BYTE PTR [ebx+edx]
  0002c	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]

; 118  :       if (a < b)

  0002f	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00032	88 5d ff	 mov	 BYTE PTR _b$[ebp], bl
  00035	3a d3		 cmp	 dl, bl
  00037	73 0e		 jae	 SHORT $LN24@critical_f

; 119  : 	{
; 120  : 	  /* Suffix is smaller, period is entire prefix so far.  */
; 121  : 	  j += k;

  00039	8b f1		 mov	 esi, ecx

; 122  : 	  k = 1;
; 123  : 	  p = j - max_suffix;

  0003b	8b fe		 mov	 edi, esi
  0003d	2b 7d f4	 sub	 edi, DWORD PTR _max_suffix$[ebp]
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	eb 1d		 jmp	 SHORT $LN10@critical_f
$LN24@critical_f:

; 124  : 	}
; 125  :       else if (a == b)

  00047	75 10		 jne	 SHORT $LN13@critical_f

; 126  : 	{
; 127  : 	  /* Advance through repetition of the current period.  */
; 128  : 	  if (k != p)

  00049	3b c7		 cmp	 eax, edi
  0004b	74 03		 je	 SHORT $LN12@critical_f

; 129  : 	    ++k;

  0004d	40		 inc	 eax

; 130  : 	  else

  0004e	eb 14		 jmp	 SHORT $LN10@critical_f
$LN12@critical_f:

; 131  : 	    {
; 132  : 	      j += p;

  00050	03 f7		 add	 esi, edi

; 133  : 	      k = 1;

  00052	b8 01 00 00 00	 mov	 eax, 1

; 134  : 	    }
; 135  : 	}
; 136  :       else /* b < a */

  00057	eb 0b		 jmp	 SHORT $LN10@critical_f
$LN13@critical_f:

; 137  : 	{
; 138  : 	  /* Suffix is larger, start over from current location.  */
; 139  : 	  max_suffix = j++;
; 140  : 	  k = p = 1;

  00059	bf 01 00 00 00	 mov	 edi, 1
  0005e	89 75 f4	 mov	 DWORD PTR _max_suffix$[ebp], esi
  00061	46		 inc	 esi
  00062	8b c7		 mov	 eax, edi
$LN10@critical_f:

; 114  :   while (j + k < needle_len)

  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _needle_len$[ebp]
  00067	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]
  0006a	3b d1		 cmp	 edx, ecx
  0006c	8b 55 08	 mov	 edx, DWORD PTR _needle$[ebp]
  0006f	72 b2		 jb	 SHORT $LL17@critical_f
$LN16@critical_f:

; 141  : 	}
; 142  :     }
; 143  :   *period = p;

  00071	8b 45 10	 mov	 eax, DWORD PTR _period$[ebp]
  00074	89 38		 mov	 DWORD PTR [eax], edi

; 144  : 
; 145  :   /* Perform reverse lexicographic search.  */
; 146  :   max_suffix_rev = SIZE_MAX;
; 147  :   j = 0;
; 148  :   k = p = 1;

  00076	bf 01 00 00 00	 mov	 edi, 1
  0007b	33 f6		 xor	 esi, esi
  0007d	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _max_suffix_rev$[ebp], -1
  00084	8b c7		 mov	 eax, edi

; 149  :   while (j + k < needle_len)

  00086	3b cf		 cmp	 ecx, edi
  00088	76 52		 jbe	 SHORT $LN8@critical_f
  0008a	eb 07		 jmp	 SHORT $LN9@critical_f
  0008c	8d 64 24 00	 npad	 4
$LL22@critical_f:
  00090	8b 55 08	 mov	 edx, DWORD PTR _needle$[ebp]
$LN9@critical_f:

; 150  :     {
; 151  :       a = CANON_ELEMENT (needle[j + k]);
; 152  :       b = CANON_ELEMENT (needle[max_suffix_rev + k]);

  00093	8b 5d f8	 mov	 ebx, DWORD PTR _max_suffix_rev$[ebp]
  00096	03 d8		 add	 ebx, eax
  00098	0f b6 1c 13	 movzx	 ebx, BYTE PTR [ebx+edx]
  0009c	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]

; 153  :       if (b < a)

  0009f	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  000a2	88 5d ff	 mov	 BYTE PTR _b$[ebp], bl
  000a5	3a d3		 cmp	 dl, bl
  000a7	76 0e		 jbe	 SHORT $LN25@critical_f

; 154  : 	{
; 155  : 	  /* Suffix is smaller, period is entire prefix so far.  */
; 156  : 	  j += k;

  000a9	8b f1		 mov	 esi, ecx

; 157  : 	  k = 1;
; 158  : 	  p = j - max_suffix_rev;

  000ab	8b fe		 mov	 edi, esi
  000ad	2b 7d f8	 sub	 edi, DWORD PTR _max_suffix_rev$[ebp]
  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	eb 1d		 jmp	 SHORT $LN2@critical_f
$LN25@critical_f:

; 159  : 	}
; 160  :       else if (a == b)

  000b7	75 10		 jne	 SHORT $LN5@critical_f

; 161  : 	{
; 162  : 	  /* Advance through repetition of the current period.  */
; 163  : 	  if (k != p)

  000b9	3b c7		 cmp	 eax, edi
  000bb	74 03		 je	 SHORT $LN4@critical_f

; 164  : 	    ++k;

  000bd	40		 inc	 eax

; 165  : 	  else

  000be	eb 14		 jmp	 SHORT $LN2@critical_f
$LN4@critical_f:

; 166  : 	    {
; 167  : 	      j += p;

  000c0	03 f7		 add	 esi, edi

; 168  : 	      k = 1;

  000c2	b8 01 00 00 00	 mov	 eax, 1

; 169  : 	    }
; 170  : 	}
; 171  :       else /* a < b */

  000c7	eb 0b		 jmp	 SHORT $LN2@critical_f
$LN5@critical_f:

; 172  : 	{
; 173  : 	  /* Suffix is larger, start over from current location.  */
; 174  : 	  max_suffix_rev = j++;
; 175  : 	  k = p = 1;

  000c9	bf 01 00 00 00	 mov	 edi, 1
  000ce	89 75 f8	 mov	 DWORD PTR _max_suffix_rev$[ebp], esi
  000d1	46		 inc	 esi
  000d2	8b c7		 mov	 eax, edi
$LN2@critical_f:

; 149  :   while (j + k < needle_len)

  000d4	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000d7	3b 4d 0c	 cmp	 ecx, DWORD PTR _needle_len$[ebp]
  000da	72 b4		 jb	 SHORT $LL22@critical_f
$LN8@critical_f:

; 176  : 	}
; 177  :     }
; 178  : 
; 179  :   /* Choose the longer suffix.  Return the first byte of the right
; 180  :      half, rather than the last byte of the left half.  */
; 181  :   if (max_suffix_rev + 1 < max_suffix + 1)

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _max_suffix_rev$[ebp]
  000df	8b 4d f4	 mov	 ecx, DWORD PTR _max_suffix$[ebp]
  000e2	40		 inc	 eax
  000e3	41		 inc	 ecx
  000e4	3b c1		 cmp	 eax, ecx
  000e6	73 09		 jae	 SHORT $LN1@critical_f

; 182  :     return max_suffix + 1;

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	8b c1		 mov	 eax, ecx
  000ec	5b		 pop	 ebx

; 184  :   return max_suffix_rev + 1;
; 185  : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN1@critical_f:

; 183  :   *period = p;

  000f1	8b 55 10	 mov	 edx, DWORD PTR _period$[ebp]
  000f4	89 3a		 mov	 DWORD PTR [edx], edi
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 184  :   return max_suffix_rev + 1;
; 185  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_critical_factorization ENDP
_TEXT	ENDS
EXTRN	_memchr:PROC
; Function compile flags: /Ogtp
;	COMDAT _two_way_short_needle
_TEXT	SEGMENT
_period$ = -8						; size = 4
_suffix$ = -4						; size = 4
_haystack$ = 8						; size = 4
_haystack_len$ = 12					; size = 4
_needle$ = 16						; size = 4
_needle_len$ = 20					; size = 4
_two_way_short_needle PROC				; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b 5d 14	 mov	 ebx, DWORD PTR _needle_len$[ebp]
  0000a	56		 push	 esi

; 201  :   size_t i; /* Index into current byte of NEEDLE.  */
; 202  :   size_t j; /* Index into current window of HAYSTACK.  */
; 203  :   size_t period; /* The period of the right half of needle.  */
; 204  :   size_t suffix; /* The index of the right half of needle.  */
; 205  : 
; 206  :   /* Factor the needle into two halves, such that the left half is
; 207  :      smaller than the global period, and the right half is
; 208  :      periodic (with a period as large as NEEDLE_LEN - suffix).  */
; 209  :   suffix = critical_factorization (needle, needle_len, &period);

  0000b	8b 75 10	 mov	 esi, DWORD PTR _needle$[ebp]
  0000e	57		 push	 edi
  0000f	8d 45 f8	 lea	 eax, DWORD PTR _period$[ebp]
  00012	50		 push	 eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _critical_factorization

; 210  : 
; 211  :   /* Perform the search.  Each iteration compares the right half
; 212  :      first.  */
; 213  :   if (CMP_FUNC (needle, needle + period, suffix) == 0)

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _period$[ebp]
  0001d	8b f8		 mov	 edi, eax
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	03 ce		 add	 ecx, esi
  00024	89 7d fc	 mov	 DWORD PTR _suffix$[ebp], edi
  00027	83 ff 04	 cmp	 edi, 4
  0002a	72 18		 jb	 SHORT $LN39@two_way_sh
  0002c	8d 64 24 00	 npad	 4
$LL28@two_way_sh:
  00030	8b 16		 mov	 edx, DWORD PTR [esi]
  00032	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00034	75 42		 jne	 SHORT $LN20@two_way_sh
  00036	83 e8 04	 sub	 eax, 4
  00039	83 c1 04	 add	 ecx, 4
  0003c	83 c6 04	 add	 esi, 4
  0003f	83 f8 04	 cmp	 eax, 4
  00042	73 ec		 jae	 SHORT $LL28@two_way_sh
$LN39@two_way_sh:
  00044	85 c0		 test	 eax, eax
  00046	0f 84 f4 00 00
	00		 je	 $LN55@two_way_sh
  0004c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0004e	3a 16		 cmp	 dl, BYTE PTR [esi]
  00050	75 26		 jne	 SHORT $LN20@two_way_sh
  00052	83 f8 01	 cmp	 eax, 1
  00055	0f 86 e5 00 00
	00		 jbe	 $LN55@two_way_sh
  0005b	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0005e	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  00061	75 15		 jne	 SHORT $LN20@two_way_sh
  00063	83 f8 02	 cmp	 eax, 2
  00066	0f 86 d4 00 00
	00		 jbe	 $LN55@two_way_sh
  0006c	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0006f	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00072	0f 84 c8 00 00
	00		 je	 $LN55@two_way_sh
$LN20@two_way_sh:

; 245  : 	    }
; 246  : 	}
; 247  :     }
; 248  :   else
; 249  :     {
; 250  :       /* The two halves of needle are distinct; no extra memory is
; 251  : 	 required, and any mismatch results in a maximal shift.  */
; 252  :       period = MAX (suffix, needle_len - suffix) + 1;

  00078	8b c3		 mov	 eax, ebx
  0007a	2b c7		 sub	 eax, edi
  0007c	3b f8		 cmp	 edi, eax
  0007e	72 02		 jb	 SHORT $LN26@two_way_sh
  00080	8b c7		 mov	 eax, edi
$LN26@two_way_sh:

; 253  :       j = 0;
; 254  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  00082	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  00085	40		 inc	 eax
  00086	89 45 f8	 mov	 DWORD PTR _period$[ebp], eax
  00089	8b 45 0c	 mov	 eax, DWORD PTR _haystack_len$[ebp]
  0008c	8b cb		 mov	 ecx, ebx
  0008e	2b c8		 sub	 ecx, eax
  00090	51		 push	 ecx
  00091	33 f6		 xor	 esi, esi
  00093	03 d0		 add	 edx, eax
  00095	56		 push	 esi
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 _memchr
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	85 c0		 test	 eax, eax
  000a1	0f 85 90 00 00
	00		 jne	 $LN18@two_way_sh
$LL9@two_way_sh:
  000a7	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000aa	89 45 0c	 mov	 DWORD PTR _haystack_len$[ebp], eax
  000ad	85 c0		 test	 eax, eax
  000af	0f 84 82 00 00
	00		 je	 $LN18@two_way_sh

; 255  : 	{
; 256  : 	  /* Scan for matches in right half.  */
; 257  : 	  i = suffix;

  000b5	8b c7		 mov	 eax, edi

; 258  : 	  while (i < needle_len && (CANON_ELEMENT (needle[i])
; 259  : 				    == CANON_ELEMENT (haystack[i + j])))

  000b7	3b fb		 cmp	 edi, ebx
  000b9	73 1b		 jae	 SHORT $LN48@two_way_sh
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _haystack$[ebp]
  000be	03 ce		 add	 ecx, esi
$LL7@two_way_sh:
  000c0	8b 55 10	 mov	 edx, DWORD PTR _needle$[ebp]
  000c3	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  000c6	3a 14 01	 cmp	 dl, BYTE PTR [ecx+eax]
  000c9	75 07		 jne	 SHORT $LN6@two_way_sh

; 260  : 	    ++i;

  000cb	40		 inc	 eax
  000cc	3b c3		 cmp	 eax, ebx
  000ce	72 f0		 jb	 SHORT $LL7@two_way_sh

; 261  : 	  if (needle_len <= i)

  000d0	eb 04		 jmp	 SHORT $LN48@two_way_sh
$LN6@two_way_sh:
  000d2	3b d8		 cmp	 ebx, eax
  000d4	77 39		 ja	 SHORT $LN5@two_way_sh
$LN48@two_way_sh:

; 262  : 	    {
; 263  : 	      /* Scan for matches in left half.  */
; 264  : 	      i = suffix - 1;

  000d6	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]

; 265  : 	      while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])
; 266  : 				       == CANON_ELEMENT (haystack[i + j])))

  000d9	83 f8 ff	 cmp	 eax, -1
  000dc	74 17		 je	 SHORT $LN56@two_way_sh
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _haystack$[ebp]
  000e1	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
$LL4@two_way_sh:
  000e4	8b 55 10	 mov	 edx, DWORD PTR _needle$[ebp]
  000e7	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  000ea	3a 0c 07	 cmp	 cl, BYTE PTR [edi+eax]
  000ed	75 13		 jne	 SHORT $LN3@two_way_sh

; 267  : 		--i;

  000ef	48		 dec	 eax
  000f0	83 f8 ff	 cmp	 eax, -1
  000f3	75 ef		 jne	 SHORT $LL4@two_way_sh
$LN56@two_way_sh:

; 269  : 		return (RETURN_TYPE) (haystack + j);

  000f5	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  000f8	5f		 pop	 edi
  000f9	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 277  : }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
$LN3@two_way_sh:

; 268  : 	      if (i == SIZE_MAX)

  00102	83 f8 ff	 cmp	 eax, -1
  00105	74 ee		 je	 SHORT $LN56@two_way_sh

; 270  : 	      j += period;

  00107	03 75 f8	 add	 esi, DWORD PTR _period$[ebp]

; 271  : 	    }
; 272  : 	  else

  0010a	8b 7d fc	 mov	 edi, DWORD PTR _suffix$[ebp]
  0010d	eb 06		 jmp	 SHORT $LN1@two_way_sh
$LN5@two_way_sh:

; 273  : 	    j += i - suffix + 1;

  0010f	2b c7		 sub	 eax, edi
  00111	8d 74 06 01	 lea	 esi, DWORD PTR [esi+eax+1]
$LN1@two_way_sh:

; 253  :       j = 0;
; 254  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  00115	8b 45 0c	 mov	 eax, DWORD PTR _haystack_len$[ebp]
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _haystack$[ebp]
  0011b	8b d6		 mov	 edx, esi
  0011d	2b d0		 sub	 edx, eax
  0011f	03 d3		 add	 edx, ebx
  00121	52		 push	 edx
  00122	03 c8		 add	 ecx, eax
  00124	6a 00		 push	 0
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 _memchr
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012f	85 c0		 test	 eax, eax
  00131	0f 84 70 ff ff
	ff		 je	 $LL9@two_way_sh
$LN18@two_way_sh:
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi

; 274  : 	}
; 275  :     }
; 276  :   return NULL;

  00139	33 c0		 xor	 eax, eax
  0013b	5b		 pop	 ebx

; 277  : }

  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
$LN55@two_way_sh:

; 214  :     {
; 215  :       /* Entire needle is periodic; a mismatch can only advance by the
; 216  : 	 period, so use memory to avoid rescanning known occurrences
; 217  : 	 of the period.  */
; 218  :       size_t memory = 0;
; 219  :       j = 0;
; 220  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  00140	8b 45 0c	 mov	 eax, DWORD PTR _haystack_len$[ebp]
  00143	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  00146	8b cb		 mov	 ecx, ebx
  00148	2b c8		 sub	 ecx, eax
  0014a	51		 push	 ecx
  0014b	33 ff		 xor	 edi, edi
  0014d	03 d0		 add	 edx, eax
  0014f	57		 push	 edi
  00150	52		 push	 edx
  00151	33 f6		 xor	 esi, esi
  00153	e8 00 00 00 00	 call	 _memchr
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	85 c0		 test	 eax, eax
  0015d	75 d8		 jne	 SHORT $LN18@two_way_sh
  0015f	90		 npad	 1
$LL19@two_way_sh:
  00160	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  00163	89 45 0c	 mov	 DWORD PTR _haystack_len$[ebp], eax
  00166	85 c0		 test	 eax, eax
  00168	74 cd		 je	 SHORT $LN18@two_way_sh

; 221  : 	{
; 222  : 	  /* Scan for matches in right half.  */
; 223  : 	  i = MAX (suffix, memory);

  0016a	8b 45 fc	 mov	 eax, DWORD PTR _suffix$[ebp]
  0016d	3b c6		 cmp	 eax, esi
  0016f	73 02		 jae	 SHORT $LN23@two_way_sh
  00171	8b c6		 mov	 eax, esi
$LN23@two_way_sh:

; 224  : 	  while (i < needle_len && (CANON_ELEMENT (needle[i])
; 225  : 				    == CANON_ELEMENT (haystack[i + j])))

  00173	3b c3		 cmp	 eax, ebx
  00175	73 1f		 jae	 SHORT $LN47@two_way_sh
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _haystack$[ebp]
  0017a	03 cf		 add	 ecx, edi
  0017c	8d 64 24 00	 npad	 4
$LL17@two_way_sh:
  00180	8b 55 10	 mov	 edx, DWORD PTR _needle$[ebp]
  00183	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  00186	3a 14 01	 cmp	 dl, BYTE PTR [ecx+eax]
  00189	75 07		 jne	 SHORT $LN16@two_way_sh

; 226  : 	    ++i;

  0018b	40		 inc	 eax
  0018c	3b c3		 cmp	 eax, ebx
  0018e	72 f0		 jb	 SHORT $LL17@two_way_sh

; 227  : 	  if (needle_len <= i)

  00190	eb 04		 jmp	 SHORT $LN47@two_way_sh
$LN16@two_way_sh:
  00192	3b d8		 cmp	 ebx, eax
  00194	77 36		 ja	 SHORT $LN15@two_way_sh
$LN47@two_way_sh:

; 228  : 	    {
; 229  : 	      /* Scan for matches in left half.  */
; 230  : 	      i = suffix - 1;

  00196	8b 4d fc	 mov	 ecx, DWORD PTR _suffix$[ebp]
  00199	49		 dec	 ecx

; 231  : 	      while (memory < i + 1 && (CANON_ELEMENT (needle[i])
; 232  : 					== CANON_ELEMENT (haystack[i + j])))

  0019a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0019d	3b f0		 cmp	 esi, eax
  0019f	73 1a		 jae	 SHORT $LN13@two_way_sh
  001a1	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  001a4	03 d7		 add	 edx, edi
$LL14@two_way_sh:
  001a6	8b 5d 10	 mov	 ebx, DWORD PTR _needle$[ebp]
  001a9	8a 5c 03 ff	 mov	 bl, BYTE PTR [ebx+eax-1]
  001ad	3a 1c 0a	 cmp	 bl, BYTE PTR [edx+ecx]
  001b0	75 06		 jne	 SHORT $LN53@two_way_sh

; 233  : 		--i;

  001b2	48		 dec	 eax
  001b3	49		 dec	 ecx
  001b4	3b f0		 cmp	 esi, eax
  001b6	72 ee		 jb	 SHORT $LL14@two_way_sh
$LN53@two_way_sh:

; 231  : 	      while (memory < i + 1 && (CANON_ELEMENT (needle[i])
; 232  : 					== CANON_ELEMENT (haystack[i + j])))

  001b8	8b 5d 14	 mov	 ebx, DWORD PTR _needle_len$[ebp]
$LN13@two_way_sh:

; 234  : 	      if (i + 1 < memory + 1)

  001bb	41		 inc	 ecx
  001bc	46		 inc	 esi
  001bd	3b ce		 cmp	 ecx, esi
  001bf	72 3f		 jb	 SHORT $LN41@two_way_sh

; 236  : 	      /* No match, so remember how many repetitions of period
; 237  : 		 on the right half were scanned.  */
; 238  : 	      j += period;

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _period$[ebp]

; 239  : 	      memory = needle_len - period;

  001c4	8b f3		 mov	 esi, ebx
  001c6	03 f8		 add	 edi, eax
  001c8	2b f0		 sub	 esi, eax

; 240  : 	    }
; 241  : 	  else

  001ca	eb 09		 jmp	 SHORT $LN11@two_way_sh
$LN15@two_way_sh:

; 242  : 	    {
; 243  : 	      j += i - suffix + 1;

  001cc	2b 45 fc	 sub	 eax, DWORD PTR _suffix$[ebp]

; 244  : 	      memory = 0;

  001cf	33 f6		 xor	 esi, esi
  001d1	8d 7c 07 01	 lea	 edi, DWORD PTR [edi+eax+1]
$LN11@two_way_sh:

; 214  :     {
; 215  :       /* Entire needle is periodic; a mismatch can only advance by the
; 216  : 	 period, so use memory to avoid rescanning known occurrences
; 217  : 	 of the period.  */
; 218  :       size_t memory = 0;
; 219  :       j = 0;
; 220  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  001d5	8b 45 0c	 mov	 eax, DWORD PTR _haystack_len$[ebp]
  001d8	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  001db	8b cf		 mov	 ecx, edi
  001dd	2b c8		 sub	 ecx, eax
  001df	03 cb		 add	 ecx, ebx
  001e1	51		 push	 ecx
  001e2	03 d0		 add	 edx, eax
  001e4	6a 00		 push	 0
  001e6	52		 push	 edx
  001e7	e8 00 00 00 00	 call	 _memchr
  001ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ef	85 c0		 test	 eax, eax
  001f1	0f 84 69 ff ff
	ff		 je	 $LL19@two_way_sh

; 274  : 	}
; 275  :     }
; 276  :   return NULL;

  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	33 c0		 xor	 eax, eax
  001fb	5b		 pop	 ebx

; 277  : }

  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c3		 ret	 0
$LN41@two_way_sh:

; 235  : 		return (RETURN_TYPE) (haystack + j);

  00200	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00203	03 c7		 add	 eax, edi
  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	5b		 pop	 ebx

; 277  : }

  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c3		 ret	 0
_two_way_short_needle ENDP
_TEXT	ENDS
PUBLIC	_needle$GSCopy$
PUBLIC	_haystack_len$GSCopy$
PUBLIC	_haystack$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _two_way_long_needle
_TEXT	SEGMENT
_j$ = -1052						; size = 4
_period$ = -1048					; size = 4
_suffix$ = -1044					; size = 4
_needle$GSCopy$ = -1040					; size = 4
_haystack_len$GSCopy$ = -1036				; size = 4
_haystack$GSCopy$ = -1032				; size = 4
_shift_table$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_haystack$ = 8						; size = 4
_needle$ = 12						; size = 4
_two_way_long_needle PROC				; COMDAT
; _haystack_len$ = ecx
; _needle_len$ = esi

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 318  :     {
; 319  :       /* Entire needle is periodic; a mismatch can only advance by the
; 320  : 	 period, so use memory to avoid rescanning known occurrences
; 321  : 	 of the period.  */
; 322  :       size_t memory = 0;
; 323  :       size_t shift;
; 324  :       j = 0;
; 325  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  00013	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00016	53		 push	 ebx
  00017	8b d9		 mov	 ebx, ecx
  00019	57		 push	 edi
  0001a	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _period$[ebp]
  00020	51		 push	 ecx
  00021	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _haystack$GSCopy$[ebp], eax
  00027	8b 45 0c	 mov	 eax, DWORD PTR _needle$[ebp]
  0002a	56		 push	 esi
  0002b	50		 push	 eax

; 357  : 		return (RETURN_TYPE) (haystack + j);

  0002c	89 9d f4 fb ff
	ff		 mov	 DWORD PTR _haystack_len$GSCopy$[ebp], ebx
  00032	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _needle$GSCopy$[ebp], eax
  00038	e8 00 00 00 00	 call	 _critical_factorization
  0003d	8b d0		 mov	 edx, eax
  0003f	8b c6		 mov	 eax, esi
  00041	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00046	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _shift_table$[ebp]
  0004c	f3 ab		 rep stosd
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	33 c0		 xor	 eax, eax
  00053	89 95 ec fb ff
	ff		 mov	 DWORD PTR _suffix$[ebp], edx
  00059	85 f6		 test	 esi, esi
  0005b	74 1e		 je	 SHORT $LN24@two_way_lo
  0005d	8d 49 00	 npad	 3
$LL26@two_way_lo:

; 295  :   size_t i; /* Index into current byte of NEEDLE.  */
; 296  :   size_t j; /* Index into current window of HAYSTACK.  */
; 297  :   size_t period; /* The period of the right half of needle.  */
; 298  :   size_t suffix; /* The index of the right half of needle.  */
; 299  :   size_t shift_table[1U << CHAR_BIT]; /* See below.  */
; 300  : 
; 301  :   /* Factor the needle into two halves, such that the left half is
; 302  :      smaller than the global period, and the right half is
; 303  :      periodic (with a period as large as NEEDLE_LEN - suffix).  */
; 304  :   suffix = critical_factorization (needle, needle_len, &period);
; 305  : 
; 306  :   /* Populate shift_table.  For each possible byte value c,
; 307  :      shift_table[c] is the distance from the last occurrence of c to
; 308  :      the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.
; 309  :      shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */
; 310  :   for (i = 0; i < 1U << CHAR_BIT; i++)
; 311  :     shift_table[i] = needle_len;
; 312  :   for (i = 0; i < needle_len; i++)
; 313  :     shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;

  00060	8b bd f0 fb ff
	ff		 mov	 edi, DWORD PTR _needle$GSCopy$[ebp]
  00066	0f b6 3c 07	 movzx	 edi, BYTE PTR [edi+eax]
  0006a	8b ce		 mov	 ecx, esi
  0006c	2b c8		 sub	 ecx, eax
  0006e	49		 dec	 ecx
  0006f	40		 inc	 eax
  00070	89 8c bd fc fb
	ff ff		 mov	 DWORD PTR _shift_table$[ebp+edi*4], ecx
  00077	3b c6		 cmp	 eax, esi
  00079	72 e5		 jb	 SHORT $LL26@two_way_lo
$LN24@two_way_lo:

; 314  : 
; 315  :   /* Perform the search.  Each iteration compares the right half
; 316  :      first.  */
; 317  :   if (CMP_FUNC (needle, needle + period, suffix) == 0)

  0007b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _period$[ebp]
  00081	8b bd f0 fb ff
	ff		 mov	 edi, DWORD PTR _needle$GSCopy$[ebp]
  00087	03 cf		 add	 ecx, edi
  00089	8b c2		 mov	 eax, edx
  0008b	83 fa 04	 cmp	 edx, 4
  0008e	72 14		 jb	 SHORT $LN52@two_way_lo
$LL37@two_way_lo:
  00090	8b 17		 mov	 edx, DWORD PTR [edi]
  00092	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00094	75 42		 jne	 SHORT $LN66@two_way_lo
  00096	83 e8 04	 sub	 eax, 4
  00099	83 c1 04	 add	 ecx, 4
  0009c	83 c7 04	 add	 edi, 4
  0009f	83 f8 04	 cmp	 eax, 4
  000a2	73 ec		 jae	 SHORT $LL37@two_way_lo
$LN52@two_way_lo:
  000a4	85 c0		 test	 eax, eax
  000a6	0f 84 42 01 00
	00		 je	 $LN73@two_way_lo
  000ac	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ae	3a 17		 cmp	 dl, BYTE PTR [edi]
  000b0	75 26		 jne	 SHORT $LN66@two_way_lo
  000b2	83 f8 01	 cmp	 eax, 1
  000b5	0f 86 33 01 00
	00		 jbe	 $LN73@two_way_lo
  000bb	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000be	3a 57 01	 cmp	 dl, BYTE PTR [edi+1]
  000c1	75 15		 jne	 SHORT $LN66@two_way_lo
  000c3	83 f8 02	 cmp	 eax, 2
  000c6	0f 86 22 01 00
	00		 jbe	 $LN73@two_way_lo
  000cc	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  000cf	3a 47 02	 cmp	 al, BYTE PTR [edi+2]
  000d2	0f 84 16 01 00
	00		 je	 $LN73@two_way_lo
$LN66@two_way_lo:

; 367  : 	    }
; 368  : 	}
; 369  :     }
; 370  :   else
; 371  :     {
; 372  :       /* The two halves of needle are distinct; no extra memory is
; 373  : 	 required, and any mismatch results in a maximal shift.  */
; 374  :       size_t shift;
; 375  :       period = MAX (suffix, needle_len - suffix) + 1;

  000d8	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _suffix$[ebp]
  000de	8b c6		 mov	 eax, esi
  000e0	2b c1		 sub	 eax, ecx
  000e2	3b c8		 cmp	 ecx, eax
  000e4	72 02		 jb	 SHORT $LN35@two_way_lo
  000e6	8b c1		 mov	 eax, ecx
$LN35@two_way_lo:

; 376  :       j = 0;
; 377  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  000e8	8b ce		 mov	 ecx, esi
  000ea	2b cb		 sub	 ecx, ebx
  000ec	03 9d f8 fb ff
	ff		 add	 ebx, DWORD PTR _haystack$GSCopy$[ebp]
  000f2	51		 push	 ecx
  000f3	33 ff		 xor	 edi, edi
  000f5	40		 inc	 eax
  000f6	57		 push	 edi
  000f7	53		 push	 ebx
  000f8	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _period$[ebp], eax
  000fe	e8 00 00 00 00	 call	 _memchr
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	85 c0		 test	 eax, eax
  00108	0f 85 ce 00 00
	00		 jne	 $LN21@two_way_lo
  0010e	8b ff		 npad	 2
$LL10@two_way_lo:
  00110	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00113	89 8d f4 fb ff
	ff		 mov	 DWORD PTR _haystack_len$GSCopy$[ebp], ecx
  00119	85 c9		 test	 ecx, ecx
  0011b	0f 84 bb 00 00
	00		 je	 $LN21@two_way_lo

; 378  : 	{
; 379  : 	  /* Check the last byte first; if it does not match, then
; 380  : 	     shift to the next possible match location.  */
; 381  : 	  shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];

  00121	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _haystack$GSCopy$[ebp]
  00127	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  0012a	0f b6 44 38 ff	 movzx	 eax, BYTE PTR [eax+edi-1]
  0012f	8b 84 85 fc fb
	ff ff		 mov	 eax, DWORD PTR _shift_table$[ebp+eax*4]

; 382  : 	  if (0 < shift)

  00136	85 c0		 test	 eax, eax
  00138	74 07		 je	 SHORT $LN8@two_way_lo

; 383  : 	    {
; 384  : 	      j += shift;

  0013a	03 f8		 add	 edi, eax

; 385  : 	      continue;

  0013c	e9 7f 00 00 00	 jmp	 $LN1@two_way_lo
$LN8@two_way_lo:

; 386  : 	    }
; 387  : 	  /* Scan for matches in right half.  The last byte has
; 388  : 	     already been matched, by virtue of the shift table.  */
; 389  : 	  i = suffix;

  00141	8b 9d ec fb ff
	ff		 mov	 ebx, DWORD PTR _suffix$[ebp]

; 390  : 	  while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
; 391  : 					== CANON_ELEMENT (haystack[i + j])))

  00147	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  0014a	8b c3		 mov	 eax, ebx
  0014c	3b d9		 cmp	 ebx, ecx
  0014e	73 21		 jae	 SHORT $LN72@two_way_lo
  00150	03 d7		 add	 edx, edi
$LL7@two_way_lo:
  00152	8b 9d f0 fb ff
	ff		 mov	 ebx, DWORD PTR _needle$GSCopy$[ebp]
  00158	8a 1c 03	 mov	 bl, BYTE PTR [ebx+eax]
  0015b	3a 1c 02	 cmp	 bl, BYTE PTR [edx+eax]
  0015e	75 05		 jne	 SHORT $LN70@two_way_lo

; 392  : 	    ++i;

  00160	40		 inc	 eax
  00161	3b c1		 cmp	 eax, ecx
  00163	72 ed		 jb	 SHORT $LL7@two_way_lo
$LN70@two_way_lo:

; 390  : 	  while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
; 391  : 					== CANON_ELEMENT (haystack[i + j])))

  00165	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _haystack$GSCopy$[ebp]
  0016b	8b 9d ec fb ff
	ff		 mov	 ebx, DWORD PTR _suffix$[ebp]
$LN72@two_way_lo:

; 393  : 	  if (needle_len - 1 <= i)

  00171	3b c8		 cmp	 ecx, eax
  00173	77 3f		 ja	 SHORT $LN5@two_way_lo

; 394  : 	    {
; 395  : 	      /* Scan for matches in left half.  */
; 396  : 	      i = suffix - 1;

  00175	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]

; 397  : 	      while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])
; 398  : 				       == CANON_ELEMENT (haystack[i + j])))

  00178	83 f8 ff	 cmp	 eax, -1
  0017b	74 17		 je	 SHORT $LN53@two_way_lo
  0017d	8d 0c 3a	 lea	 ecx, DWORD PTR [edx+edi]
$LL4@two_way_lo:
  00180	8b 9d f0 fb ff
	ff		 mov	 ebx, DWORD PTR _needle$GSCopy$[ebp]
  00186	8a 1c 03	 mov	 bl, BYTE PTR [ebx+eax]
  00189	3a 1c 01	 cmp	 bl, BYTE PTR [ecx+eax]
  0018c	75 19		 jne	 SHORT $LN3@two_way_lo

; 399  : 		--i;

  0018e	48		 dec	 eax
  0018f	83 f8 ff	 cmp	 eax, -1
  00192	75 ec		 jne	 SHORT $LL4@two_way_lo
$LN53@two_way_lo:

; 401  : 		return (RETURN_TYPE) (haystack + j);

  00194	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00197	5f		 pop	 edi
  00198	5b		 pop	 ebx

; 409  : }

  00199	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019c	33 cd		 xor	 ecx, ebp
  0019e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
$LN3@two_way_lo:

; 400  : 	      if (i == SIZE_MAX)

  001a7	83 f8 ff	 cmp	 eax, -1
  001aa	74 e8		 je	 SHORT $LN53@two_way_lo

; 402  : 	      j += period;

  001ac	03 bd e8 fb ff
	ff		 add	 edi, DWORD PTR _period$[ebp]

; 403  : 	    }
; 404  : 	  else

  001b2	eb 06		 jmp	 SHORT $LN74@two_way_lo
$LN5@two_way_lo:

; 405  : 	    j += i - suffix + 1;

  001b4	2b c3		 sub	 eax, ebx
  001b6	8d 7c 07 01	 lea	 edi, DWORD PTR [edi+eax+1]
$LN74@two_way_lo:
  001ba	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _haystack_len$GSCopy$[ebp]
$LN1@two_way_lo:

; 376  :       j = 0;
; 377  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  001c0	8b c6		 mov	 eax, esi
  001c2	2b c1		 sub	 eax, ecx
  001c4	03 c7		 add	 eax, edi
  001c6	50		 push	 eax
  001c7	03 ca		 add	 ecx, edx
  001c9	6a 00		 push	 0
  001cb	51		 push	 ecx
  001cc	e8 00 00 00 00	 call	 _memchr
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 34 ff ff
	ff		 je	 $LL10@two_way_lo
$LN21@two_way_lo:
  001dc	5f		 pop	 edi

; 406  : 	}
; 407  :     }
; 408  :   return NULL;

  001dd	33 c0		 xor	 eax, eax
  001df	5b		 pop	 ebx

; 409  : }

  001e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e3	33 cd		 xor	 ecx, ebp
  001e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
$LN73@two_way_lo:

; 318  :     {
; 319  :       /* Entire needle is periodic; a mismatch can only advance by the
; 320  : 	 period, so use memory to avoid rescanning known occurrences
; 321  : 	 of the period.  */
; 322  :       size_t memory = 0;
; 323  :       size_t shift;
; 324  :       j = 0;
; 325  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  001ee	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _haystack_len$GSCopy$[ebp]
  001f4	8b ce		 mov	 ecx, esi
  001f6	2b c8		 sub	 ecx, eax
  001f8	03 85 f8 fb ff
	ff		 add	 eax, DWORD PTR _haystack$GSCopy$[ebp]
  001fe	51		 push	 ecx
  001ff	33 db		 xor	 ebx, ebx
  00201	53		 push	 ebx
  00202	50		 push	 eax
  00203	33 ff		 xor	 edi, edi
  00205	89 9d e4 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], ebx
  0020b	e8 00 00 00 00	 call	 _memchr
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH
  00213	85 c0		 test	 eax, eax
  00215	75 c5		 jne	 SHORT $LN21@two_way_lo
  00217	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL22@two_way_lo:
  00220	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00223	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _haystack_len$GSCopy$[ebp], eax
  00229	85 c0		 test	 eax, eax
  0022b	74 af		 je	 SHORT $LN21@two_way_lo

; 326  : 	{
; 327  : 	  /* Check the last byte first; if it does not match, then
; 328  : 	     shift to the next possible match location.  */
; 329  : 	  shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];

  0022d	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _haystack$GSCopy$[ebp]
  00233	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00236	0f b6 54 19 ff	 movzx	 edx, BYTE PTR [ecx+ebx-1]
  0023b	8b 84 95 fc fb
	ff ff		 mov	 eax, DWORD PTR _shift_table$[ebp+edx*4]

; 330  : 	  if (0 < shift)

  00242	85 c0		 test	 eax, eax
  00244	74 1b		 je	 SHORT $LN20@two_way_lo

; 331  : 	    {
; 332  : 	      if (memory && shift < period)

  00246	85 ff		 test	 edi, edi
  00248	74 0e		 je	 SHORT $LN19@two_way_lo
  0024a	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _period$[ebp]
  00250	3b c1		 cmp	 eax, ecx
  00252	73 04		 jae	 SHORT $LN19@two_way_lo

; 333  : 		{
; 334  : 		  /* Since needle is periodic, but the last period has
; 335  : 		     a byte out of place, there can be no match until
; 336  : 		     after the mismatch.  */
; 337  : 		  shift = needle_len - period;

  00254	8b c6		 mov	 eax, esi
  00256	2b c1		 sub	 eax, ecx
$LN19@two_way_lo:

; 338  : 		}
; 339  : 	      memory = 0;

  00258	33 ff		 xor	 edi, edi

; 340  : 	      j += shift;

  0025a	03 d8		 add	 ebx, eax

; 341  : 	      continue;

  0025c	e9 87 00 00 00	 jmp	 $LN75@two_way_lo
$LN20@two_way_lo:

; 342  : 	    }
; 343  : 	  /* Scan for matches in right half.  The last byte has
; 344  : 	     already been matched, by virtue of the shift table.  */
; 345  : 	  i = MAX (suffix, memory);

  00261	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _suffix$[ebp]
  00267	8b c7		 mov	 eax, edi
  00269	3b cf		 cmp	 ecx, edi
  0026b	72 02		 jb	 SHORT $LN33@two_way_lo
  0026d	8b c1		 mov	 eax, ecx
$LN33@two_way_lo:

; 346  : 	  while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
; 347  : 					== CANON_ELEMENT (haystack[i + j])))

  0026f	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00272	3b c2		 cmp	 eax, edx
  00274	73 26		 jae	 SHORT $LN17@two_way_lo
  00276	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _haystack$GSCopy$[ebp]
  0027c	03 d3		 add	 edx, ebx
  0027e	8b ff		 npad	 2
$LL18@two_way_lo:
  00280	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _needle$GSCopy$[ebp]
  00286	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  00289	3a 0c 02	 cmp	 cl, BYTE PTR [edx+eax]
  0028c	75 08		 jne	 SHORT $LN67@two_way_lo

; 348  : 	    ++i;

  0028e	40		 inc	 eax
  0028f	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  00292	3b c1		 cmp	 eax, ecx
  00294	72 ea		 jb	 SHORT $LL18@two_way_lo
$LN67@two_way_lo:

; 346  : 	  while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
; 347  : 					== CANON_ELEMENT (haystack[i + j])))

  00296	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _suffix$[ebp]
$LN17@two_way_lo:

; 349  : 	  if (needle_len - 1 <= i)

  0029c	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  0029f	3b d0		 cmp	 edx, eax
  002a1	77 3d		 ja	 SHORT $LN16@two_way_lo

; 350  : 	    {
; 351  : 	      /* Scan for matches in left half.  */
; 352  : 	      i = suffix - 1;

  002a3	49		 dec	 ecx

; 353  : 	      while (memory < i + 1 && (CANON_ELEMENT (needle[i])
; 354  : 					== CANON_ELEMENT (haystack[i + j])))

  002a4	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  002a7	3b f8		 cmp	 edi, eax
  002a9	73 21		 jae	 SHORT $LN71@two_way_lo
  002ab	03 9d f8 fb ff
	ff		 add	 ebx, DWORD PTR _haystack$GSCopy$[ebp]
$LL15@two_way_lo:
  002b1	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _needle$GSCopy$[ebp]
  002b7	8a 54 02 ff	 mov	 dl, BYTE PTR [edx+eax-1]
  002bb	3a 14 0b	 cmp	 dl, BYTE PTR [ebx+ecx]
  002be	75 06		 jne	 SHORT $LN65@two_way_lo

; 355  : 		--i;

  002c0	48		 dec	 eax
  002c1	49		 dec	 ecx
  002c2	3b f8		 cmp	 edi, eax
  002c4	72 eb		 jb	 SHORT $LL15@two_way_lo
$LN65@two_way_lo:

; 353  : 	      while (memory < i + 1 && (CANON_ELEMENT (needle[i])
; 354  : 					== CANON_ELEMENT (haystack[i + j])))

  002c6	8b 9d e4 fb ff
	ff		 mov	 ebx, DWORD PTR _j$[ebp]
$LN71@two_way_lo:

; 356  : 	      if (i + 1 < memory + 1)

  002cc	47		 inc	 edi
  002cd	41		 inc	 ecx
  002ce	3b cf		 cmp	 ecx, edi
  002d0	72 54		 jb	 SHORT $LN54@two_way_lo

; 358  : 	      /* No match, so remember how many repetitions of period
; 359  : 		 on the right half were scanned.  */
; 360  : 	      j += period;

  002d2	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _period$[ebp]

; 361  : 	      memory = needle_len - period;

  002d8	8b fe		 mov	 edi, esi
  002da	03 d8		 add	 ebx, eax
  002dc	2b f8		 sub	 edi, eax

; 362  : 	    }
; 363  : 	  else

  002de	eb 08		 jmp	 SHORT $LN75@two_way_lo
$LN16@two_way_lo:

; 364  : 	    {
; 365  : 	      j += i - suffix + 1;

  002e0	2b c1		 sub	 eax, ecx
  002e2	8d 5c 03 01	 lea	 ebx, DWORD PTR [ebx+eax+1]

; 366  : 	      memory = 0;

  002e6	33 ff		 xor	 edi, edi
$LN75@two_way_lo:

; 318  :     {
; 319  :       /* Entire needle is periodic; a mismatch can only advance by the
; 320  : 	 period, so use memory to avoid rescanning known occurrences
; 321  : 	 of the period.  */
; 322  :       size_t memory = 0;
; 323  :       size_t shift;
; 324  :       j = 0;
; 325  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  002e8	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _haystack_len$GSCopy$[ebp]
  002ee	8b ce		 mov	 ecx, esi
  002f0	2b c8		 sub	 ecx, eax
  002f2	03 85 f8 fb ff
	ff		 add	 eax, DWORD PTR _haystack$GSCopy$[ebp]
  002f8	03 cb		 add	 ecx, ebx
  002fa	51		 push	 ecx
  002fb	6a 00		 push	 0
  002fd	50		 push	 eax

; 364  : 	    {
; 365  : 	      j += i - suffix + 1;

  002fe	89 9d e4 fb ff
	ff		 mov	 DWORD PTR _j$[ebp], ebx
  00304	e8 00 00 00 00	 call	 _memchr
  00309	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030c	85 c0		 test	 eax, eax
  0030e	0f 84 0c ff ff
	ff		 je	 $LL22@two_way_lo

; 406  : 	}
; 407  :     }
; 408  :   return NULL;

  00314	5f		 pop	 edi
  00315	33 c0		 xor	 eax, eax
  00317	5b		 pop	 ebx

; 409  : }

  00318	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031b	33 cd		 xor	 ecx, ebp
  0031d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00322	8b e5		 mov	 esp, ebp
  00324	5d		 pop	 ebp
  00325	c3		 ret	 0
$LN54@two_way_lo:

; 357  : 		return (RETURN_TYPE) (haystack + j);

  00326	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _haystack$GSCopy$[ebp]

; 409  : }

  0032c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032f	03 c3		 add	 eax, ebx
  00331	5f		 pop	 edi
  00332	33 cd		 xor	 ecx, ebp
  00334	5b		 pop	 ebx
  00335	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c3		 ret	 0
_two_way_long_needle ENDP
_TEXT	ENDS
PUBLIC	_strstr
EXTRN	_strchr:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strstr.c
;	COMDAT _strstr
_TEXT	SEGMENT
_searchee$ = 8						; size = 4
_lookfor$ = 12						; size = 4
_strstr	PROC						; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 48   : 	/* Larger code size, but guaranteed linear performance.  */
; 49   : 	const char *haystack = searchee;
; 50   : 	const char *needle = lookfor;
; 51   : 	size_t needle_len; /* Length of NEEDLE.  */
; 52   : 	size_t haystack_len; /* Known minimum length of HAYSTACK.  */
; 53   : 	int ok = 1; /* True if NEEDLE is prefix of HAYSTACK.  */
; 54   : 
; 55   : 	/* Determine length of NEEDLE, and in the process, make sure
; 56   : 		HAYSTACK is at least as long (no point processing all of a long
; 57   : 		NEEDLE if HAYSTACK is too short).  */
; 58   : 	while (*haystack && *needle)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _searchee$[ebp]
  00007	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _lookfor$[ebp]
  0000f	8b c7		 mov	 eax, edi
  00011	ba 01 00 00 00	 mov	 edx, 1
  00016	74 2a		 je	 SHORT $LN6@strstr
  00018	8b f3		 mov	 esi, ebx
  0001a	2b f7		 sub	 esi, edi
  0001c	8d 64 24 00	 npad	 4
$LL7@strstr:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	84 c9		 test	 cl, cl
  00024	74 28		 je	 SHORT $LN5@strstr

; 59   : 		ok &= *haystack++ == *needle++;

  00026	8a 1c 06	 mov	 bl, BYTE PTR [esi+eax]
  00029	40		 inc	 eax
  0002a	3a d9		 cmp	 bl, cl
  0002c	75 07		 jne	 SHORT $LN10@strstr
  0002e	b9 01 00 00 00	 mov	 ecx, 1
  00033	eb 02		 jmp	 SHORT $LN11@strstr
$LN10@strstr:
  00035	33 c9		 xor	 ecx, ecx
$LN11@strstr:

; 48   : 	/* Larger code size, but guaranteed linear performance.  */
; 49   : 	const char *haystack = searchee;
; 50   : 	const char *needle = lookfor;
; 51   : 	size_t needle_len; /* Length of NEEDLE.  */
; 52   : 	size_t haystack_len; /* Known minimum length of HAYSTACK.  */
; 53   : 	int ok = 1; /* True if NEEDLE is prefix of HAYSTACK.  */
; 54   : 
; 55   : 	/* Determine length of NEEDLE, and in the process, make sure
; 56   : 		HAYSTACK is at least as long (no point processing all of a long
; 57   : 		NEEDLE if HAYSTACK is too short).  */
; 58   : 	while (*haystack && *needle)

  00037	8b 5d 08	 mov	 ebx, DWORD PTR _searchee$[ebp]

; 59   : 		ok &= *haystack++ == *needle++;

  0003a	23 d1		 and	 edx, ecx
  0003c	80 3c 06 00	 cmp	 BYTE PTR [esi+eax], 0
  00040	75 de		 jne	 SHORT $LL7@strstr
$LN6@strstr:

; 60   : 	
; 61   : 	if (*needle)

  00042	80 38 00	 cmp	 BYTE PTR [eax], 0
  00045	74 07		 je	 SHORT $LN5@strstr

; 62   : 		return NULL;

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	33 c0		 xor	 eax, eax
  0004b	5b		 pop	 ebx

; 83   : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN5@strstr:

; 63   : 	
; 64   : 	if (ok)

  0004e	85 d2		 test	 edx, edx
  00050	74 07		 je	 SHORT $LN4@strstr

; 65   : 		return (char *) searchee;

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	8b c3		 mov	 eax, ebx
  00056	5b		 pop	 ebx

; 83   : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@strstr:

; 66   : 
; 67   : 	/* Reduce the size of haystack using strchr, since it has a smaller
; 68   : 		linear coefficient than the Two-Way algorithm.  */
; 69   : 	needle_len = needle - lookfor;

  00059	2b c7		 sub	 eax, edi
  0005b	8b f0		 mov	 esi, eax

; 70   : 	haystack = strchr (searchee + 1, *lookfor);

  0005d	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00060	50		 push	 eax
  00061	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _strchr
  0006a	83 c4 08	 add	 esp, 8

; 71   : 	if (!haystack || needle_len == 1)

  0006d	85 c0		 test	 eax, eax
  0006f	74 39		 je	 SHORT $LN8@strstr
  00071	83 fe 01	 cmp	 esi, 1
  00074	74 34		 je	 SHORT $LN8@strstr

; 72   : 		return (char *) haystack;
; 73   : 	
; 74   : 	haystack_len = (haystack > searchee + needle_len ? 1
; 75   : 			: needle_len + searchee - haystack);

  00076	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  00079	3b c2		 cmp	 eax, edx
  0007b	76 07		 jbe	 SHORT $LN12@strstr
  0007d	b9 01 00 00 00	 mov	 ecx, 1
  00082	eb 06		 jmp	 SHORT $LN13@strstr
$LN12@strstr:
  00084	8b ce		 mov	 ecx, esi
  00086	2b c8		 sub	 ecx, eax
  00088	03 cb		 add	 ecx, ebx
$LN13@strstr:

; 76   : 
; 77   : 	/* Perform the search.  */
; 78   : 	if (needle_len < LONG_NEEDLE_THRESHOLD)

  0008a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0008d	73 11		 jae	 SHORT $LN1@strstr

; 79   : 		return two_way_short_needle ((const unsigned char *) haystack, haystack_len,
; 80   : 									 (const unsigned char *) lookfor, needle_len);

  0008f	56		 push	 esi
  00090	57		 push	 edi
  00091	51		 push	 ecx
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _two_way_short_needle
  00098	83 c4 10	 add	 esp, 16			; 00000010H
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx

; 83   : }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN1@strstr:

; 81   : 	return two_way_long_needle ((const unsigned char *) haystack, haystack_len,
; 82   : 					(const unsigned char *) lookfor, needle_len);

  000a0	57		 push	 edi
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _two_way_long_needle
  000a7	83 c4 08	 add	 esp, 8
$LN8@strstr:
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx

; 83   : }

  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_strstr	ENDP
_TEXT	ENDS
END
