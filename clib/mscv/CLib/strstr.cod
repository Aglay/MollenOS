; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strstr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strstr
EXTRN	_memchr:PROC
EXTRN	_strchr:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\str-two-way.h
;	COMDAT _two_way_long_needle
_TEXT	SEGMENT
_shift_table$ = -1044					; size = 1024
_haystack_len$2$ = -20					; size = 4
tv721 = -16						; size = 4
tv720 = -16						; size = 4
_period$2$ = -12					; size = 4
_period$ = -12						; size = 4
_j$1$ = -8						; size = 4
_haystack_len$4$ = -8					; size = 4
_suffix$1$ = -4						; size = 4
_haystack$ = 8						; size = 4
_haystack_len$ = 12					; size = 4
tv719 = 16						; size = 4
_needle$ = 16						; size = 4
_needle_len$ = 20					; size = 4
_two_way_long_needle PROC				; COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	53		 push	 ebx

; 295  :   size_t i; /* Index into current byte of NEEDLE.  */
; 296  :   size_t j; /* Index into current window of HAYSTACK.  */
; 297  :   size_t period; /* The period of the right half of needle.  */
; 298  :   size_t suffix; /* The index of the right half of needle.  */
; 299  :   size_t shift_table[1U << CHAR_BIT]; /* See below.  */
; 300  : 
; 301  :   /* Factor the needle into two halves, such that the left half is
; 302  :      smaller than the global period, and the right half is
; 303  :      periodic (with a period as large as NEEDLE_LEN - suffix).  */
; 304  :   suffix = critical_factorization (needle, needle_len, &period);

  0000a	8b 5d 14	 mov	 ebx, DWORD PTR _needle_len$[ebp]
  0000d	8d 45 f4	 lea	 eax, DWORD PTR _period$[ebp]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	50		 push	 eax
  00013	53		 push	 ebx
  00014	ff 75 10	 push	 DWORD PTR _needle$[ebp]
  00017	e8 00 00 00 00	 call	 _critical_factorization
  0001c	8b f0		 mov	 esi, eax

; 305  : 
; 306  :   /* Populate shift_table.  For each possible byte value c,
; 307  :      shift_table[c] is the distance from the last occurrence of c to
; 308  :      the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.
; 309  :      shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */
; 310  :   for (i = 0; i < 1U << CHAR_BIT; i++)
; 311  :     shift_table[i] = needle_len;

  0001e	8d bd ec fb ff
	ff		 lea	 edi, DWORD PTR _shift_table$[ebp]
  00024	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00029	89 75 fc	 mov	 DWORD PTR _suffix$1$[ebp], esi
  0002c	8b c3		 mov	 eax, ebx
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	f3 ab		 rep stosd
  00033	8b 7d 10	 mov	 edi, DWORD PTR _needle$[ebp]

; 312  :   for (i = 0; i < needle_len; i++)

  00036	33 d2		 xor	 edx, edx
  00038	85 db		 test	 ebx, ebx
  0003a	74 19		 je	 SHORT $LN24@two_way_lo
  0003c	8d 64 24 00	 npad	 4
$LL26@two_way_lo:

; 313  :     shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;

  00040	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00044	8b cb		 mov	 ecx, ebx
  00046	2b ca		 sub	 ecx, edx
  00048	42		 inc	 edx
  00049	49		 dec	 ecx
  0004a	89 8c 85 ec fb
	ff ff		 mov	 DWORD PTR _shift_table$[ebp+eax*4], ecx
  00051	3b d3		 cmp	 edx, ebx
  00053	72 eb		 jb	 SHORT $LL26@two_way_lo
$LN24@two_way_lo:

; 314  : 
; 315  :   /* Perform the search.  Each iteration compares the right half
; 316  :      first.  */
; 317  :   if (CMP_FUNC (needle, needle + period, suffix) == 0)

  00055	8b 55 f4	 mov	 edx, DWORD PTR _period$[ebp]
  00058	8b cf		 mov	 ecx, edi
  0005a	03 d7		 add	 edx, edi
  0005c	83 ee 04	 sub	 esi, 4
  0005f	72 11		 jb	 SHORT $LN73@two_way_lo
$LL74@two_way_lo:
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	3b 02		 cmp	 eax, DWORD PTR [edx]
  00065	75 14		 jne	 SHORT $LN72@two_way_lo
  00067	83 c1 04	 add	 ecx, 4
  0006a	83 c2 04	 add	 edx, 4
  0006d	83 ee 04	 sub	 esi, 4
  00070	73 ef		 jae	 SHORT $LL74@two_way_lo
$LN73@two_way_lo:
  00072	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00075	0f 84 1b 01 00
	00		 je	 $LN71@two_way_lo
$LN72@two_way_lo:
  0007b	8a 01		 mov	 al, BYTE PTR [ecx]
  0007d	3a 02		 cmp	 al, BYTE PTR [edx]
  0007f	75 37		 jne	 SHORT $LN23@two_way_lo
  00081	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00084	0f 84 0c 01 00
	00		 je	 $LN71@two_way_lo
  0008a	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0008d	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00090	75 26		 jne	 SHORT $LN23@two_way_lo
  00092	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00095	0f 84 fb 00 00
	00		 je	 $LN71@two_way_lo
  0009b	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0009e	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  000a1	75 15		 jne	 SHORT $LN23@two_way_lo
  000a3	83 fe ff	 cmp	 esi, -1
  000a6	0f 84 ea 00 00
	00		 je	 $LN71@two_way_lo
  000ac	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  000af	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  000b2	0f 84 de 00 00
	00		 je	 $LN71@two_way_lo
$LN23@two_way_lo:

; 367  : 	    }
; 368  : 	}
; 369  :     }
; 370  :   else
; 371  :     {
; 372  :       /* The two halves of needle are distinct; no extra memory is
; 373  : 	 required, and any mismatch results in a maximal shift.  */
; 374  :       size_t shift;
; 375  :       period = MAX (suffix, needle_len - suffix) + 1;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _suffix$1$[ebp]
  000bb	8b c3		 mov	 eax, ebx
  000bd	2b c2		 sub	 eax, edx
  000bf	8b ca		 mov	 ecx, edx
  000c1	3b d0		 cmp	 edx, eax
  000c3	0f 42 c8	 cmovb	 ecx, eax

; 376  :       j = 0;

  000c6	33 f6		 xor	 esi, esi
  000c8	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000cb	89 45 f4	 mov	 DWORD PTR _period$2$[ebp], eax

; 377  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  000ce	8b c3		 mov	 eax, ebx
  000d0	2b 45 0c	 sub	 eax, DWORD PTR _haystack_len$[ebp]
  000d3	50		 push	 eax
  000d4	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  000d7	03 45 0c	 add	 eax, DWORD PTR _haystack_len$[ebp]
  000da	56		 push	 esi
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memchr
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	85 c0		 test	 eax, eax
  000e6	0f 85 a1 00 00
	00		 jne	 $LN70@two_way_lo
  000ec	8d 64 24 00	 npad	 4
$LL10@two_way_lo:
  000f0	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000f3	89 45 f8	 mov	 DWORD PTR _haystack_len$4$[ebp], eax
  000f6	85 c0		 test	 eax, eax
  000f8	0f 84 8f 00 00
	00		 je	 $LN70@two_way_lo

; 378  : 	{
; 379  : 	  /* Check the last byte first; if it does not match, then
; 380  : 	     shift to the next possible match location.  */
; 381  : 	  shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];

  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _haystack$[ebp]
  00101	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00104	0f b6 44 18 ff	 movzx	 eax, BYTE PTR [eax+ebx-1]
  00109	8b 84 85 ec fb
	ff ff		 mov	 eax, DWORD PTR _shift_table$[ebp+eax*4]

; 382  : 	  if (0 < shift)

  00110	85 c0		 test	 eax, eax
  00112	75 56		 jne	 SHORT $LN79@two_way_lo

; 383  : 	    {
; 384  : 	      j += shift;
; 385  : 	      continue;
; 386  : 	    }
; 387  : 	  /* Scan for matches in right half.  The last byte has
; 388  : 	     already been matched, by virtue of the shift table.  */
; 389  : 	  i = suffix;

  00114	8b 45 fc	 mov	 eax, DWORD PTR _suffix$1$[ebp]

; 390  : 	  while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
; 391  : 					== CANON_ELEMENT (haystack[i + j])))

  00117	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  0011a	3b d0		 cmp	 edx, eax
  0011c	76 1b		 jbe	 SHORT $LN81@two_way_lo
  0011e	03 ce		 add	 ecx, esi
  00120	89 4d 10	 mov	 DWORD PTR tv719[ebp], ecx
  00123	8b d9		 mov	 ebx, ecx
$LL7@two_way_lo:
  00125	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00128	3a 0c 03	 cmp	 cl, BYTE PTR [ebx+eax]
  0012b	75 05		 jne	 SHORT $LN75@two_way_lo

; 392  : 	    ++i;

  0012d	40		 inc	 eax
  0012e	3b c2		 cmp	 eax, edx
  00130	72 f3		 jb	 SHORT $LL7@two_way_lo
$LN75@two_way_lo:
  00132	8b 5d 14	 mov	 ebx, DWORD PTR _needle_len$[ebp]

; 393  : 	  if (needle_len - 1 <= i)

  00135	3b d0		 cmp	 edx, eax
  00137	77 2d		 ja	 SHORT $LN5@two_way_lo
$LN81@two_way_lo:

; 394  : 	    {
; 395  : 	      /* Scan for matches in left half.  */
; 396  : 	      i = suffix - 1;

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _suffix$1$[ebp]
  0013c	49		 dec	 ecx

; 397  : 	      while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])
; 398  : 				       == CANON_ELEMENT (haystack[i + j])))

  0013d	83 f9 ff	 cmp	 ecx, -1
  00140	74 13		 je	 SHORT $LN45@two_way_lo
  00142	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  00145	03 d6		 add	 edx, esi
$LL4@two_way_lo:
  00147	8a 04 39	 mov	 al, BYTE PTR [ecx+edi]
  0014a	3a 04 0a	 cmp	 al, BYTE PTR [edx+ecx]
  0014d	75 12		 jne	 SHORT $LN3@two_way_lo

; 399  : 		--i;

  0014f	49		 dec	 ecx
  00150	83 f9 ff	 cmp	 ecx, -1
  00153	75 f2		 jne	 SHORT $LL4@two_way_lo
$LN45@two_way_lo:

; 400  : 	      if (i == SIZE_MAX)
; 401  : 		return (RETURN_TYPE) (haystack + j);

  00155	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00158	5f		 pop	 edi
  00159	03 c6		 add	 eax, esi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx

; 409  : }

  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
$LN3@two_way_lo:

; 402  : 	      j += period;

  00161	03 75 f4	 add	 esi, DWORD PTR _period$2$[ebp]

; 403  : 	    }
; 404  : 	  else

  00164	eb 06		 jmp	 SHORT $LN1@two_way_lo
$LN5@two_way_lo:

; 405  : 	    j += i - suffix + 1;

  00166	2b 45 fc	 sub	 eax, DWORD PTR _suffix$1$[ebp]
  00169	46		 inc	 esi
$LN79@two_way_lo:
  0016a	03 f0		 add	 esi, eax
$LN1@two_way_lo:

; 377  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  0016c	8b c6		 mov	 eax, esi
  0016e	2b 45 f8	 sub	 eax, DWORD PTR _haystack_len$4$[ebp]
  00171	03 c3		 add	 eax, ebx
  00173	50		 push	 eax
  00174	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00177	03 45 f8	 add	 eax, DWORD PTR _haystack_len$4$[ebp]
  0017a	6a 00		 push	 0
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _memchr
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	85 c0		 test	 eax, eax
  00187	0f 84 63 ff ff
	ff		 je	 $LL10@two_way_lo
$LN70@two_way_lo:
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi

; 406  : 	}
; 407  :     }
; 408  :   return NULL;

  0018f	33 c0		 xor	 eax, eax
  00191	5b		 pop	 ebx

; 409  : }

  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
$LN71@two_way_lo:

; 318  :     {
; 319  :       /* Entire needle is periodic; a mismatch can only advance by the
; 320  : 	 period, so use memory to avoid rescanning known occurrences
; 321  : 	 of the period.  */
; 322  :       size_t memory = 0;
; 323  :       size_t shift;
; 324  :       j = 0;
; 325  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  00196	8b c3		 mov	 eax, ebx
  00198	33 ff		 xor	 edi, edi
  0019a	2b 45 0c	 sub	 eax, DWORD PTR _haystack_len$[ebp]
  0019d	33 f6		 xor	 esi, esi
  0019f	50		 push	 eax
  001a0	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  001a3	03 45 0c	 add	 eax, DWORD PTR _haystack_len$[ebp]
  001a6	57		 push	 edi
  001a7	50		 push	 eax
  001a8	89 7d f8	 mov	 DWORD PTR _j$1$[ebp], edi
  001ab	e8 00 00 00 00	 call	 _memchr
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b3	85 c0		 test	 eax, eax
  001b5	75 d6		 jne	 SHORT $LN70@two_way_lo
$LL22@two_way_lo:
  001b7	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  001ba	89 45 ec	 mov	 DWORD PTR _haystack_len$2$[ebp], eax
  001bd	85 c0		 test	 eax, eax
  001bf	74 cc		 je	 SHORT $LN70@two_way_lo

; 326  : 	{
; 327  : 	  /* Check the last byte first; if it does not match, then
; 328  : 	     shift to the next possible match location.  */
; 329  : 	  shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];

  001c1	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  001c4	03 c7		 add	 eax, edi
  001c6	0f b6 44 18 ff	 movzx	 eax, BYTE PTR [eax+ebx-1]
  001cb	8b 84 85 ec fb
	ff ff		 mov	 eax, DWORD PTR _shift_table$[ebp+eax*4]

; 330  : 	  if (0 < shift)

  001d2	85 c0		 test	 eax, eax
  001d4	74 18		 je	 SHORT $LN20@two_way_lo

; 331  : 	    {
; 332  : 	      if (memory && shift < period)

  001d6	85 f6		 test	 esi, esi
  001d8	74 0b		 je	 SHORT $LN19@two_way_lo
  001da	8b 4d f4	 mov	 ecx, DWORD PTR _period$[ebp]
  001dd	3b c1		 cmp	 eax, ecx
  001df	73 04		 jae	 SHORT $LN19@two_way_lo

; 333  : 		{
; 334  : 		  /* Since needle is periodic, but the last period has
; 335  : 		     a byte out of place, there can be no match until
; 336  : 		     after the mismatch.  */
; 337  : 		  shift = needle_len - period;

  001e1	8b c3		 mov	 eax, ebx
  001e3	2b c1		 sub	 eax, ecx
$LN19@two_way_lo:

; 338  : 		}
; 339  : 	      memory = 0;

  001e5	33 f6		 xor	 esi, esi

; 340  : 	      j += shift;

  001e7	03 f8		 add	 edi, eax

; 341  : 	      continue;

  001e9	e9 83 00 00 00	 jmp	 $LN82@two_way_lo
$LN20@two_way_lo:

; 342  : 	    }
; 343  : 	  /* Scan for matches in right half.  The last byte has
; 344  : 	     already been matched, by virtue of the shift table.  */
; 345  : 	  i = MAX (suffix, memory);

  001ee	8b 45 fc	 mov	 eax, DWORD PTR _suffix$1$[ebp]

; 346  : 	  while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])
; 347  : 					== CANON_ELEMENT (haystack[i + j])))

  001f1	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  001f4	3b c6		 cmp	 eax, esi
  001f6	8b c8		 mov	 ecx, eax
  001f8	0f 42 ce	 cmovb	 ecx, esi
  001fb	3b d1		 cmp	 edx, ecx
  001fd	76 2b		 jbe	 SHORT $LN84@two_way_lo
  001ff	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00202	8b 5d 10	 mov	 ebx, DWORD PTR _needle$[ebp]
  00205	03 c7		 add	 eax, edi
  00207	89 45 f0	 mov	 DWORD PTR tv721[ebp], eax
  0020a	8b f8		 mov	 edi, eax
  0020c	8d 64 24 00	 npad	 4
$LL18@two_way_lo:
  00210	8a 04 19	 mov	 al, BYTE PTR [ecx+ebx]
  00213	3a 04 0f	 cmp	 al, BYTE PTR [edi+ecx]
  00216	75 05		 jne	 SHORT $LN76@two_way_lo

; 348  : 	    ++i;

  00218	41		 inc	 ecx
  00219	3b ca		 cmp	 ecx, edx
  0021b	72 f3		 jb	 SHORT $LL18@two_way_lo
$LN76@two_way_lo:
  0021d	8b 7d f8	 mov	 edi, DWORD PTR _j$1$[ebp]
  00220	8b 5d 14	 mov	 ebx, DWORD PTR _needle_len$[ebp]
  00223	8b 45 fc	 mov	 eax, DWORD PTR _suffix$1$[ebp]

; 349  : 	  if (needle_len - 1 <= i)

  00226	3b d1		 cmp	 edx, ecx
  00228	77 40		 ja	 SHORT $LN16@two_way_lo
$LN84@two_way_lo:

; 350  : 	    {
; 351  : 	      /* Scan for matches in left half.  */
; 352  : 	      i = suffix - 1;

  0022a	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]

; 353  : 	      while (memory < i + 1 && (CANON_ELEMENT (needle[i])
; 354  : 					== CANON_ELEMENT (haystack[i + j])))

  0022d	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  00230	3b f1		 cmp	 esi, ecx
  00232	73 22		 jae	 SHORT $LN14@two_way_lo
  00234	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00237	8b 5d 10	 mov	 ebx, DWORD PTR _needle$[ebp]
  0023a	03 c7		 add	 eax, edi
  0023c	89 45 f0	 mov	 DWORD PTR tv720[ebp], eax
  0023f	8b f8		 mov	 edi, eax
$LL15@two_way_lo:
  00241	8a 44 0b ff	 mov	 al, BYTE PTR [ebx+ecx-1]
  00245	3a 04 17	 cmp	 al, BYTE PTR [edi+edx]
  00248	75 06		 jne	 SHORT $LN77@two_way_lo

; 355  : 		--i;

  0024a	49		 dec	 ecx
  0024b	4a		 dec	 edx
  0024c	3b f1		 cmp	 esi, ecx
  0024e	72 f1		 jb	 SHORT $LL15@two_way_lo
$LN77@two_way_lo:
  00250	8b 7d f8	 mov	 edi, DWORD PTR _j$1$[ebp]
  00253	8b 5d 14	 mov	 ebx, DWORD PTR _needle_len$[ebp]
$LN14@two_way_lo:

; 356  : 	      if (i + 1 < memory + 1)

  00256	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00259	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0025c	3b c1		 cmp	 eax, ecx
  0025e	72 3e		 jb	 SHORT $LN44@two_way_lo

; 358  : 	      /* No match, so remember how many repetitions of period
; 359  : 		 on the right half were scanned.  */
; 360  : 	      j += period;

  00260	03 7d f4	 add	 edi, DWORD PTR _period$[ebp]

; 361  : 	      memory = needle_len - period;

  00263	8b f3		 mov	 esi, ebx
  00265	2b 75 f4	 sub	 esi, DWORD PTR _period$[ebp]

; 362  : 	    }
; 363  : 	  else

  00268	eb 07		 jmp	 SHORT $LN82@two_way_lo
$LN16@two_way_lo:

; 364  : 	    {
; 365  : 	      j += i - suffix + 1;

  0026a	2b c8		 sub	 ecx, eax
  0026c	47		 inc	 edi
  0026d	03 f9		 add	 edi, ecx

; 366  : 	      memory = 0;

  0026f	33 f6		 xor	 esi, esi
$LN82@two_way_lo:

; 364  : 	    {
; 365  : 	      j += i - suffix + 1;

  00271	8b c7		 mov	 eax, edi
  00273	89 7d f8	 mov	 DWORD PTR _j$1$[ebp], edi
  00276	2b 45 ec	 sub	 eax, DWORD PTR _haystack_len$2$[ebp]
  00279	03 c3		 add	 eax, ebx
  0027b	50		 push	 eax
  0027c	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  0027f	03 45 ec	 add	 eax, DWORD PTR _haystack_len$2$[ebp]
  00282	6a 00		 push	 0
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _memchr
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028d	85 c0		 test	 eax, eax
  0028f	0f 84 22 ff ff
	ff		 je	 $LL22@two_way_lo

; 406  : 	}
; 407  :     }
; 408  :   return NULL;

  00295	5f		 pop	 edi
  00296	5e		 pop	 esi
  00297	33 c0		 xor	 eax, eax
  00299	5b		 pop	 ebx

; 409  : }

  0029a	8b e5		 mov	 esp, ebp
  0029c	5d		 pop	 ebp
  0029d	c3		 ret	 0
$LN44@two_way_lo:

; 357  : 		return (RETURN_TYPE) (haystack + j);

  0029e	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  002a1	03 c7		 add	 eax, edi
  002a3	5f		 pop	 edi
  002a4	5e		 pop	 esi
  002a5	5b		 pop	 ebx

; 409  : }

  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c3		 ret	 0
_two_way_long_needle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\str-two-way.h
;	COMDAT _two_way_short_needle
_TEXT	SEGMENT
_haystack_len$2$ = -20					; size = 4
tv549 = -16						; size = 4
_haystack_len$4$ = -12					; size = 4
_period$ = -12						; size = 4
_j$1$ = -8						; size = 4
_suffix$1$ = -4						; size = 4
_haystack$ = 8						; size = 4
_haystack_len$ = 12					; size = 4
_period$2$ = 16						; size = 4
_needle$ = 16						; size = 4
_needle_len$ = 20					; size = 4
_two_way_short_needle PROC				; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 201  :   size_t i; /* Index into current byte of NEEDLE.  */
; 202  :   size_t j; /* Index into current window of HAYSTACK.  */
; 203  :   size_t period; /* The period of the right half of needle.  */
; 204  :   size_t suffix; /* The index of the right half of needle.  */
; 205  : 
; 206  :   /* Factor the needle into two halves, such that the left half is
; 207  :      smaller than the global period, and the right half is
; 208  :      periodic (with a period as large as NEEDLE_LEN - suffix).  */
; 209  :   suffix = critical_factorization (needle, needle_len, &period);

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _needle$[ebp]
  0000a	8d 45 f4	 lea	 eax, DWORD PTR _period$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 14	 mov	 esi, DWORD PTR _needle_len$[ebp]
  00011	57		 push	 edi
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	53		 push	 ebx
  00015	e8 00 00 00 00	 call	 _critical_factorization

; 210  : 
; 211  :   /* Perform the search.  Each iteration compares the right half
; 212  :      first.  */
; 213  :   if (CMP_FUNC (needle, needle + period, suffix) == 0)

  0001a	8b 55 f4	 mov	 edx, DWORD PTR _period$[ebp]
  0001d	8b f8		 mov	 edi, eax
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	89 45 fc	 mov	 DWORD PTR _suffix$1$[ebp], eax
  00025	03 d3		 add	 edx, ebx
  00027	8b cb		 mov	 ecx, ebx
  00029	83 ef 04	 sub	 edi, 4
  0002c	72 13		 jb	 SHORT $LN55@two_way_sh
  0002e	8b ff		 npad	 2
$LL56@two_way_sh:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 02		 cmp	 eax, DWORD PTR [edx]
  00034	75 14		 jne	 SHORT $LN54@two_way_sh
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c2 04	 add	 edx, 4
  0003c	83 ef 04	 sub	 edi, 4
  0003f	73 ef		 jae	 SHORT $LL56@two_way_sh
$LN55@two_way_sh:
  00041	83 ff fc	 cmp	 edi, -4			; fffffffcH
  00044	0f 84 f6 00 00
	00		 je	 $LN53@two_way_sh
$LN54@two_way_sh:
  0004a	8a 01		 mov	 al, BYTE PTR [ecx]
  0004c	3a 02		 cmp	 al, BYTE PTR [edx]
  0004e	75 37		 jne	 SHORT $LN20@two_way_sh
  00050	83 ff fd	 cmp	 edi, -3			; fffffffdH
  00053	0f 84 e7 00 00
	00		 je	 $LN53@two_way_sh
  00059	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0005c	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  0005f	75 26		 jne	 SHORT $LN20@two_way_sh
  00061	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00064	0f 84 d6 00 00
	00		 je	 $LN53@two_way_sh
  0006a	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0006d	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00070	75 15		 jne	 SHORT $LN20@two_way_sh
  00072	83 ff ff	 cmp	 edi, -1
  00075	0f 84 c5 00 00
	00		 je	 $LN53@two_way_sh
  0007b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0007e	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00081	0f 84 b9 00 00
	00		 je	 $LN53@two_way_sh
$LN20@two_way_sh:

; 245  : 	    }
; 246  : 	}
; 247  :     }
; 248  :   else
; 249  :     {
; 250  :       /* The two halves of needle are distinct; no extra memory is
; 251  : 	 required, and any mismatch results in a maximal shift.  */
; 252  :       period = MAX (suffix, needle_len - suffix) + 1;

  00087	8b 55 fc	 mov	 edx, DWORD PTR _suffix$1$[ebp]
  0008a	8b c6		 mov	 eax, esi
  0008c	2b c2		 sub	 eax, edx
  0008e	8b ca		 mov	 ecx, edx
  00090	3b d0		 cmp	 edx, eax
  00092	0f 42 c8	 cmovb	 ecx, eax

; 253  :       j = 0;

  00095	33 ff		 xor	 edi, edi
  00097	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009a	89 45 10	 mov	 DWORD PTR _period$2$[ebp], eax

; 254  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  0009d	8b c6		 mov	 eax, esi
  0009f	2b 45 0c	 sub	 eax, DWORD PTR _haystack_len$[ebp]
  000a2	50		 push	 eax
  000a3	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  000a6	03 45 0c	 add	 eax, DWORD PTR _haystack_len$[ebp]
  000a9	57		 push	 edi
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _memchr
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	85 c0		 test	 eax, eax
  000b5	0f 85 7c 00 00
	00		 jne	 $LN8@two_way_sh
  000bb	eb 03 8d 49 00	 npad	 5
$LL9@two_way_sh:
  000c0	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  000c3	89 45 f4	 mov	 DWORD PTR _haystack_len$4$[ebp], eax
  000c6	85 c0		 test	 eax, eax
  000c8	74 6d		 je	 SHORT $LN8@two_way_sh

; 255  : 	{
; 256  : 	  /* Scan for matches in right half.  */
; 257  : 	  i = suffix;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _suffix$1$[ebp]

; 258  : 	  while (i < needle_len && (CANON_ELEMENT (needle[i])
; 259  : 				    == CANON_ELEMENT (haystack[i + j])))

  000cd	3b c6		 cmp	 eax, esi
  000cf	73 12		 jae	 SHORT $LN49@two_way_sh
  000d1	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  000d4	03 d7		 add	 edx, edi
$LL7@two_way_sh:
  000d6	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  000d9	3a 0c 02	 cmp	 cl, BYTE PTR [edx+eax]
  000dc	75 2d		 jne	 SHORT $LN6@two_way_sh

; 260  : 	    ++i;

  000de	40		 inc	 eax
  000df	3b c6		 cmp	 eax, esi
  000e1	72 f3		 jb	 SHORT $LL7@two_way_sh
$LN49@two_way_sh:

; 262  : 	    {
; 263  : 	      /* Scan for matches in left half.  */
; 264  : 	      i = suffix - 1;

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _suffix$1$[ebp]
  000e6	49		 dec	 ecx

; 265  : 	      while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])
; 266  : 				       == CANON_ELEMENT (haystack[i + j])))

  000e7	83 f9 ff	 cmp	 ecx, -1
  000ea	74 13		 je	 SHORT $LN32@two_way_sh
  000ec	8b 55 08	 mov	 edx, DWORD PTR _haystack$[ebp]
  000ef	03 d7		 add	 edx, edi
$LL4@two_way_sh:
  000f1	8a 04 19	 mov	 al, BYTE PTR [ecx+ebx]
  000f4	3a 04 0a	 cmp	 al, BYTE PTR [edx+ecx]
  000f7	75 1e		 jne	 SHORT $LN3@two_way_sh

; 267  : 		--i;

  000f9	49		 dec	 ecx
  000fa	83 f9 ff	 cmp	 ecx, -1
  000fd	75 f2		 jne	 SHORT $LL4@two_way_sh
$LN32@two_way_sh:

; 268  : 	      if (i == SIZE_MAX)
; 269  : 		return (RETURN_TYPE) (haystack + j);

  000ff	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00102	03 c7		 add	 eax, edi
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 277  : }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
$LN6@two_way_sh:

; 261  : 	  if (needle_len <= i)

  0010b	3b f0		 cmp	 esi, eax
  0010d	76 d4		 jbe	 SHORT $LN49@two_way_sh

; 271  : 	    }
; 272  : 	  else
; 273  : 	    j += i - suffix + 1;

  0010f	2b 45 fc	 sub	 eax, DWORD PTR _suffix$1$[ebp]
  00112	47		 inc	 edi
  00113	03 f8		 add	 edi, eax
  00115	eb 03		 jmp	 SHORT $LN1@two_way_sh
$LN3@two_way_sh:

; 270  : 	      j += period;

  00117	03 7d 10	 add	 edi, DWORD PTR _period$2$[ebp]
$LN1@two_way_sh:

; 254  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  0011a	8b c7		 mov	 eax, edi
  0011c	2b 45 f4	 sub	 eax, DWORD PTR _haystack_len$4$[ebp]
  0011f	03 c6		 add	 eax, esi
  00121	50		 push	 eax
  00122	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  00125	03 45 f4	 add	 eax, DWORD PTR _haystack_len$4$[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memchr
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	85 c0		 test	 eax, eax
  00135	74 89		 je	 SHORT $LL9@two_way_sh
$LN8@two_way_sh:
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi

; 274  : 	}
; 275  :     }
; 276  :   return NULL;

  00139	33 c0		 xor	 eax, eax
  0013b	5b		 pop	 ebx

; 277  : }

  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
$LN53@two_way_sh:

; 214  :     {
; 215  :       /* Entire needle is periodic; a mismatch can only advance by the
; 216  : 	 period, so use memory to avoid rescanning known occurrences
; 217  : 	 of the period.  */
; 218  :       size_t memory = 0;
; 219  :       j = 0;
; 220  :       while (AVAILABLE (haystack, haystack_len, j, needle_len))

  00140	8b c6		 mov	 eax, esi
  00142	33 ff		 xor	 edi, edi
  00144	2b 45 0c	 sub	 eax, DWORD PTR _haystack_len$[ebp]
  00147	50		 push	 eax
  00148	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  0014b	03 45 0c	 add	 eax, DWORD PTR _haystack_len$[ebp]
  0014e	57		 push	 edi
  0014f	50		 push	 eax
  00150	89 7d f8	 mov	 DWORD PTR _j$1$[ebp], edi
  00153	e8 00 00 00 00	 call	 _memchr
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	85 c0		 test	 eax, eax
  0015d	75 d8		 jne	 SHORT $LN8@two_way_sh
  0015f	90		 npad	 1
$LL19@two_way_sh:
  00160	8b 55 f8	 mov	 edx, DWORD PTR _j$1$[ebp]
  00163	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00166	89 45 ec	 mov	 DWORD PTR _haystack_len$2$[ebp], eax
  00169	85 c0		 test	 eax, eax
  0016b	74 ca		 je	 SHORT $LN8@two_way_sh

; 221  : 	{
; 222  : 	  /* Scan for matches in right half.  */
; 223  : 	  i = MAX (suffix, memory);

  0016d	8b 45 fc	 mov	 eax, DWORD PTR _suffix$1$[ebp]
  00170	3b c7		 cmp	 eax, edi
  00172	8b c8		 mov	 ecx, eax
  00174	0f 42 cf	 cmovb	 ecx, edi

; 224  : 	  while (i < needle_len && (CANON_ELEMENT (needle[i])
; 225  : 				    == CANON_ELEMENT (haystack[i + j])))

  00177	3b ce		 cmp	 ecx, esi
  00179	73 20		 jae	 SHORT $LN50@two_way_sh
  0017b	eb 03 8d 49 00	 npad	 5
$LL17@two_way_sh:
  00180	8a 04 19	 mov	 al, BYTE PTR [ecx+ebx]
  00183	8b 5d 08	 mov	 ebx, DWORD PTR _haystack$[ebp]
  00186	8b 75 14	 mov	 esi, DWORD PTR _needle_len$[ebp]
  00189	03 da		 add	 ebx, edx
  0018b	3a 04 0b	 cmp	 al, BYTE PTR [ebx+ecx]
  0018e	8b 5d 10	 mov	 ebx, DWORD PTR _needle$[ebp]
  00191	75 71		 jne	 SHORT $LN16@two_way_sh

; 226  : 	    ++i;

  00193	41		 inc	 ecx
  00194	3b ce		 cmp	 ecx, esi
  00196	72 e8		 jb	 SHORT $LL17@two_way_sh
$LN58@two_way_sh:
  00198	8b 45 fc	 mov	 eax, DWORD PTR _suffix$1$[ebp]
$LN50@two_way_sh:

; 228  : 	    {
; 229  : 	      /* Scan for matches in left half.  */
; 230  : 	      i = suffix - 1;

  0019b	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]

; 231  : 	      while (memory < i + 1 && (CANON_ELEMENT (needle[i])
; 232  : 					== CANON_ELEMENT (haystack[i + j])))

  0019e	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  001a1	3b f9		 cmp	 edi, ecx
  001a3	73 1d		 jae	 SHORT $LN13@two_way_sh
  001a5	8b 45 f8	 mov	 eax, DWORD PTR _j$1$[ebp]
  001a8	03 45 08	 add	 eax, DWORD PTR _haystack$[ebp]
  001ab	89 45 f0	 mov	 DWORD PTR tv549[ebp], eax
  001ae	8b f0		 mov	 esi, eax
$LL14@two_way_sh:
  001b0	8a 44 0b ff	 mov	 al, BYTE PTR [ebx+ecx-1]
  001b4	3a 04 16	 cmp	 al, BYTE PTR [esi+edx]
  001b7	75 06		 jne	 SHORT $LN57@two_way_sh

; 233  : 		--i;

  001b9	49		 dec	 ecx
  001ba	4a		 dec	 edx
  001bb	3b f9		 cmp	 edi, ecx
  001bd	72 f1		 jb	 SHORT $LL14@two_way_sh
$LN57@two_way_sh:
  001bf	8b 75 14	 mov	 esi, DWORD PTR _needle_len$[ebp]
$LN13@two_way_sh:

; 234  : 	      if (i + 1 < memory + 1)

  001c2	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  001c5	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  001c8	3b c8		 cmp	 ecx, eax
  001ca	72 46		 jb	 SHORT $LN31@two_way_sh

; 236  : 	      /* No match, so remember how many repetitions of period
; 237  : 		 on the right half were scanned.  */
; 238  : 	      j += period;

  001cc	8b 55 f8	 mov	 edx, DWORD PTR _j$1$[ebp]

; 239  : 	      memory = needle_len - period;

  001cf	8b fe		 mov	 edi, esi
  001d1	03 55 f4	 add	 edx, DWORD PTR _period$[ebp]
  001d4	2b 7d f4	 sub	 edi, DWORD PTR _period$[ebp]
$LN59@two_way_sh:

; 236  : 	      /* No match, so remember how many repetitions of period
; 237  : 		 on the right half were scanned.  */
; 238  : 	      j += period;

  001d7	8b c2		 mov	 eax, edx
  001d9	89 55 f8	 mov	 DWORD PTR _j$1$[ebp], edx
  001dc	2b 45 ec	 sub	 eax, DWORD PTR _haystack_len$2$[ebp]
  001df	03 c6		 add	 eax, esi
  001e1	50		 push	 eax
  001e2	8b 45 08	 mov	 eax, DWORD PTR _haystack$[ebp]
  001e5	03 45 ec	 add	 eax, DWORD PTR _haystack_len$2$[ebp]
  001e8	6a 00		 push	 0
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 _memchr
  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f3	85 c0		 test	 eax, eax
  001f5	0f 84 65 ff ff
	ff		 je	 $LL19@two_way_sh

; 274  : 	}
; 275  :     }
; 276  :   return NULL;

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	33 c0		 xor	 eax, eax
  001ff	5b		 pop	 ebx

; 277  : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
$LN16@two_way_sh:

; 227  : 	  if (needle_len <= i)

  00204	3b f1		 cmp	 esi, ecx
  00206	76 90		 jbe	 SHORT $LN58@two_way_sh

; 240  : 	    }
; 241  : 	  else
; 242  : 	    {
; 243  : 	      j += i - suffix + 1;

  00208	2b 4d fc	 sub	 ecx, DWORD PTR _suffix$1$[ebp]
  0020b	42		 inc	 edx
  0020c	03 d1		 add	 edx, ecx

; 244  : 	      memory = 0;

  0020e	33 ff		 xor	 edi, edi
  00210	eb c5		 jmp	 SHORT $LN59@two_way_sh
$LN31@two_way_sh:

; 235  : 		return (RETURN_TYPE) (haystack + j);

  00212	8b 45 f8	 mov	 eax, DWORD PTR _j$1$[ebp]
  00215	03 45 08	 add	 eax, DWORD PTR _haystack$[ebp]
  00218	5f		 pop	 edi
  00219	5e		 pop	 esi
  0021a	5b		 pop	 ebx

; 277  : }

  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c3		 ret	 0
_two_way_short_needle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\str-two-way.h
;	COMDAT _critical_factorization
_TEXT	SEGMENT
tv206 = -12						; size = 4
tv205 = -12						; size = 4
_max_suffix$1$ = -8					; size = 4
_a$2$ = -1						; size = 1
_needle$ = 8						; size = 4
_needle_len$ = 12					; size = 4
_period$ = 16						; size = 4
_critical_factorization PROC				; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 94   :   /* Index of last byte of left half, or SIZE_MAX.  */
; 95   :   size_t max_suffix, max_suffix_rev;
; 96   :   size_t j; /* Index into NEEDLE for current candidate suffix.  */
; 97   :   size_t k; /* Offset into current period.  */
; 98   :   size_t p; /* Intermediate period.  */
; 99   :   unsigned char a, b; /* Current comparison bytes.  */
; 100  : 
; 101  :   /* Invariants:
; 102  :      0 <= j < NEEDLE_LEN - 1
; 103  :      -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)
; 104  :      min(max_suffix, max_suffix_rev) < global period of NEEDLE
; 105  :      1 <= p <= global period of NEEDLE
; 106  :      p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]
; 107  :      1 <= k <= p
; 108  :   */
; 109  : 
; 110  :   /* Perform lexicographic search.  */
; 111  :   max_suffix = SIZE_MAX;
; 112  :   j = 0;
; 113  :   k = p = 1;

  00008	be 01 00 00 00	 mov	 esi, 1
  0000d	83 cb ff	 or	 ebx, -1
  00010	8b d6		 mov	 edx, esi
  00012	89 5d f8	 mov	 DWORD PTR _max_suffix$1$[ebp], ebx
  00015	33 c0		 xor	 eax, eax
  00017	57		 push	 edi

; 114  :   while (j + k < needle_len)

  00018	39 55 0c	 cmp	 DWORD PTR _needle_len$[ebp], edx
  0001b	76 5b		 jbe	 SHORT $LN16@critical_f
  0001d	8d 49 00	 npad	 3
$LL17@critical_f:

; 115  :     {
; 116  :       a = CANON_ELEMENT (needle[j + k]);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _needle$[ebp]
  00023	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00026	89 7d f4	 mov	 DWORD PTR tv206[ebp], edi
  00029	8a 1c 0f	 mov	 bl, BYTE PTR [edi+ecx]

; 117  :       b = CANON_ELEMENT (needle[(size_t)(max_suffix + k)]);

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _max_suffix$1$[ebp]
  0002f	8b 7d 08	 mov	 edi, DWORD PTR _needle$[ebp]
  00032	03 ca		 add	 ecx, edx
  00034	8a 0c 39	 mov	 cl, BYTE PTR [ecx+edi]

; 118  :       if (a < b)

  00037	8b 7d f4	 mov	 edi, DWORD PTR tv206[ebp]
  0003a	3a d9		 cmp	 bl, cl
  0003c	73 10		 jae	 SHORT $LN26@critical_f

; 119  : 	{
; 120  : 	  /* Suffix is smaller, period is entire prefix so far.  */
; 121  : 	  j += k;
; 122  : 	  k = 1;
; 123  : 	  p = j - max_suffix;

  0003e	8b 5d f8	 mov	 ebx, DWORD PTR _max_suffix$1$[ebp]
  00041	8b c7		 mov	 eax, edi
  00043	8b f0		 mov	 esi, eax
  00045	ba 01 00 00 00	 mov	 edx, 1
  0004a	2b f3		 sub	 esi, ebx
  0004c	eb 22		 jmp	 SHORT $LN10@critical_f
$LN26@critical_f:

; 124  : 	}
; 125  :       else if (a == b)

  0004e	75 13		 jne	 SHORT $LN13@critical_f

; 130  : 	  else

  00050	8b 5d f8	 mov	 ebx, DWORD PTR _max_suffix$1$[ebp]
  00053	3b d6		 cmp	 edx, esi
  00055	74 03		 je	 SHORT $LN12@critical_f

; 126  : 	{
; 127  : 	  /* Advance through repetition of the current period.  */
; 128  : 	  if (k != p)
; 129  : 	    ++k;

  00057	42		 inc	 edx

; 130  : 	  else

  00058	eb 16		 jmp	 SHORT $LN10@critical_f
$LN12@critical_f:

; 131  : 	    {
; 132  : 	      j += p;

  0005a	03 c6		 add	 eax, esi

; 133  : 	      k = 1;

  0005c	ba 01 00 00 00	 mov	 edx, 1

; 134  : 	    }
; 135  : 	}
; 136  :       else /* b < a */

  00061	eb 0d		 jmp	 SHORT $LN10@critical_f
$LN13@critical_f:

; 137  : 	{
; 138  : 	  /* Suffix is larger, start over from current location.  */
; 139  : 	  max_suffix = j++;

  00063	8b d8		 mov	 ebx, eax

; 140  : 	  k = p = 1;

  00065	be 01 00 00 00	 mov	 esi, 1
  0006a	89 5d f8	 mov	 DWORD PTR _max_suffix$1$[ebp], ebx
  0006d	40		 inc	 eax
  0006e	8b d6		 mov	 edx, esi
$LN10@critical_f:

; 114  :   while (j + k < needle_len)

  00070	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00073	3b 4d 0c	 cmp	 ecx, DWORD PTR _needle_len$[ebp]
  00076	72 a8		 jb	 SHORT $LL17@critical_f
$LN16@critical_f:

; 141  : 	}
; 142  :     }
; 143  :   *period = p;

  00078	8b 45 10	 mov	 eax, DWORD PTR _period$[ebp]

; 144  : 
; 145  :   /* Perform reverse lexicographic search.  */
; 146  :   max_suffix_rev = SIZE_MAX;

  0007b	83 cf ff	 or	 edi, -1

; 147  :   j = 0;

  0007e	33 c9		 xor	 ecx, ecx
  00080	89 30		 mov	 DWORD PTR [eax], esi

; 148  :   k = p = 1;

  00082	be 01 00 00 00	 mov	 esi, 1
  00087	8b d6		 mov	 edx, esi

; 149  :   while (j + k < needle_len)

  00089	39 55 0c	 cmp	 DWORD PTR _needle_len$[ebp], edx
  0008c	76 51		 jbe	 SHORT $LN8@critical_f
  0008e	8b 5d 08	 mov	 ebx, DWORD PTR _needle$[ebp]
$LL9@critical_f:

; 150  :     {
; 151  :       a = CANON_ELEMENT (needle[j + k]);

  00091	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00094	89 45 f4	 mov	 DWORD PTR tv205[ebp], eax
  00097	8a 04 18	 mov	 al, BYTE PTR [eax+ebx]
  0009a	88 45 ff	 mov	 BYTE PTR _a$2$[ebp], al

; 152  :       b = CANON_ELEMENT (needle[max_suffix_rev + k]);

  0009d	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000a0	8a 24 18	 mov	 ah, BYTE PTR [eax+ebx]

; 153  :       if (b < a)

  000a3	8a 45 ff	 mov	 al, BYTE PTR _a$2$[ebp]
  000a6	3a c4		 cmp	 al, ah
  000a8	76 0e		 jbe	 SHORT $LN27@critical_f

; 154  : 	{
; 155  : 	  /* Suffix is smaller, period is entire prefix so far.  */
; 156  : 	  j += k;

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR tv205[ebp]

; 157  : 	  k = 1;

  000ad	ba 01 00 00 00	 mov	 edx, 1

; 158  : 	  p = j - max_suffix_rev;

  000b2	8b f1		 mov	 esi, ecx
  000b4	2b f7		 sub	 esi, edi
  000b6	eb 1c		 jmp	 SHORT $LN2@critical_f
$LN27@critical_f:

; 159  : 	}
; 160  :       else if (a == b)

  000b8	75 10		 jne	 SHORT $LN5@critical_f

; 161  : 	{
; 162  : 	  /* Advance through repetition of the current period.  */
; 163  : 	  if (k != p)

  000ba	3b d6		 cmp	 edx, esi
  000bc	74 03		 je	 SHORT $LN4@critical_f

; 164  : 	    ++k;

  000be	42		 inc	 edx

; 165  : 	  else

  000bf	eb 13		 jmp	 SHORT $LN2@critical_f
$LN4@critical_f:

; 166  : 	    {
; 167  : 	      j += p;

  000c1	03 ce		 add	 ecx, esi

; 168  : 	      k = 1;

  000c3	ba 01 00 00 00	 mov	 edx, 1

; 169  : 	    }
; 170  : 	}
; 171  :       else /* a < b */

  000c8	eb 0a		 jmp	 SHORT $LN2@critical_f
$LN5@critical_f:

; 172  : 	{
; 173  : 	  /* Suffix is larger, start over from current location.  */
; 174  : 	  max_suffix_rev = j++;
; 175  : 	  k = p = 1;

  000ca	be 01 00 00 00	 mov	 esi, 1
  000cf	8b f9		 mov	 edi, ecx
  000d1	41		 inc	 ecx
  000d2	8b d6		 mov	 edx, esi
$LN2@critical_f:

; 149  :   while (j + k < needle_len)

  000d4	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000d7	3b 45 0c	 cmp	 eax, DWORD PTR _needle_len$[ebp]
  000da	72 b5		 jb	 SHORT $LL9@critical_f
  000dc	8b 5d f8	 mov	 ebx, DWORD PTR _max_suffix$1$[ebp]
$LN8@critical_f:

; 176  : 	}
; 177  :     }
; 178  : 
; 179  :   /* Choose the longer suffix.  Return the first byte of the right
; 180  :      half, rather than the last byte of the left half.  */
; 181  :   if (max_suffix_rev + 1 < max_suffix + 1)

  000df	47		 inc	 edi
  000e0	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000e3	3b f8		 cmp	 edi, eax
  000e5	72 07		 jb	 SHORT $LN18@critical_f

; 182  :     return max_suffix + 1;
; 183  :   *period = p;

  000e7	8b 45 10	 mov	 eax, DWORD PTR _period$[ebp]
  000ea	89 30		 mov	 DWORD PTR [eax], esi

; 184  :   return max_suffix_rev + 1;

  000ec	8b c7		 mov	 eax, edi
$LN18@critical_f:
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx

; 185  : }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
_critical_factorization ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strstr.c
;	COMDAT _strstr
_TEXT	SEGMENT
_searchee$ = 8						; size = 4
_lookfor$ = 12						; size = 4
_strstr	PROC						; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 	/* Larger code size, but guaranteed linear performance.  */
; 49   : 	const char *haystack = searchee;
; 50   : 	const char *needle = lookfor;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lookfor$[ebp]
  00006	53		 push	 ebx

; 51   : 	size_t needle_len; /* Length of NEEDLE.  */
; 52   : 	size_t haystack_len; /* Known minimum length of HAYSTACK.  */
; 53   : 	int ok = 1; /* True if NEEDLE is prefix of HAYSTACK.  */
; 54   : 
; 55   : 	/* Determine length of NEEDLE, and in the process, make sure
; 56   : 		HAYSTACK is at least as long (no point processing all of a long
; 57   : 		NEEDLE if HAYSTACK is too short).  */
; 58   : 	while (*haystack && *needle)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _searchee$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f0		 mov	 esi, eax
  0000e	bf 01 00 00 00	 mov	 edi, 1
  00013	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00016	74 2a		 je	 SHORT $LN6@strstr
  00018	8b d3		 mov	 edx, ebx
  0001a	2b d0		 sub	 edx, eax
  0001c	8d 64 24 00	 npad	 4
$LL7@strstr:
  00020	8a 0e		 mov	 cl, BYTE PTR [esi]
  00022	84 c9		 test	 cl, cl
  00024	74 28		 je	 SHORT $LN18@strstr

; 59   : 		ok &= *haystack++ == *needle++;

  00026	8a 04 32	 mov	 al, BYTE PTR [edx+esi]
  00029	46		 inc	 esi
  0002a	3a c1		 cmp	 al, cl
  0002c	75 07		 jne	 SHORT $LN10@strstr
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	eb 02		 jmp	 SHORT $LN11@strstr
$LN10@strstr:
  00035	33 c0		 xor	 eax, eax
$LN11@strstr:
  00037	23 f8		 and	 edi, eax
  00039	80 3c 32 00	 cmp	 BYTE PTR [edx+esi], 0
  0003d	75 e1		 jne	 SHORT $LL7@strstr
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _lookfor$[ebp]
$LN6@strstr:

; 60   : 	
; 61   : 	if (*needle)

  00042	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00045	74 0a		 je	 SHORT $LN5@strstr

; 62   : 		return NULL;

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	33 c0		 xor	 eax, eax
  0004b	5b		 pop	 ebx

; 83   : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN18@strstr:
  0004e	8b 45 0c	 mov	 eax, DWORD PTR _lookfor$[ebp]
$LN5@strstr:

; 63   : 	
; 64   : 	if (ok)

  00051	85 ff		 test	 edi, edi
  00053	74 07		 je	 SHORT $LN4@strstr

; 65   : 		return (char *) searchee;

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	8b c3		 mov	 eax, ebx
  00059	5b		 pop	 ebx

; 83   : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN4@strstr:

; 66   : 
; 67   : 	/* Reduce the size of haystack using strchr, since it has a smaller
; 68   : 		linear coefficient than the Two-Way algorithm.  */
; 69   : 	needle_len = needle - lookfor;

  0005c	2b f0		 sub	 esi, eax

; 70   : 	haystack = strchr (searchee + 1, *lookfor);

  0005e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00061	50		 push	 eax
  00062	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _strchr
  0006b	8b d0		 mov	 edx, eax
  0006d	83 c4 08	 add	 esp, 8

; 71   : 	if (!haystack || needle_len == 1)

  00070	85 d2		 test	 edx, edx
  00072	74 3e		 je	 SHORT $LN2@strstr
  00074	83 fe 01	 cmp	 esi, 1
  00077	74 39		 je	 SHORT $LN2@strstr

; 73   : 	
; 74   : 	haystack_len = (haystack > searchee + needle_len ? 1
; 75   : 			: needle_len + searchee - haystack);

  00079	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  0007c	3b d1		 cmp	 edx, ecx
  0007e	76 07		 jbe	 SHORT $LN12@strstr
  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	eb 06		 jmp	 SHORT $LN13@strstr
$LN12@strstr:
  00087	8b c6		 mov	 eax, esi
  00089	2b c2		 sub	 eax, edx
  0008b	03 c3		 add	 eax, ebx
$LN13@strstr:

; 76   : 
; 77   : 	/* Perform the search.  */
; 78   : 	if (needle_len < LONG_NEEDLE_THRESHOLD)
; 79   : 		return two_way_short_needle ((const unsigned char *) haystack, haystack_len,
; 80   : 									 (const unsigned char *) lookfor, needle_len);

  0008d	56		 push	 esi
  0008e	ff 75 0c	 push	 DWORD PTR _lookfor$[ebp]
  00091	50		 push	 eax
  00092	52		 push	 edx
  00093	83 fe 20	 cmp	 esi, 32			; 00000020H
  00096	73 0d		 jae	 SHORT $LN1@strstr
  00098	e8 00 00 00 00	 call	 _two_way_short_needle
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 83   : }

  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
$LN1@strstr:

; 81   : 	return two_way_long_needle ((const unsigned char *) haystack, haystack_len,
; 82   : 					(const unsigned char *) lookfor, needle_len);

  000a5	e8 00 00 00 00	 call	 _two_way_long_needle
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx

; 83   : }

  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN2@strstr:
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi

; 72   : 		return (char *) haystack;

  000b4	8b c2		 mov	 eax, edx
  000b6	5b		 pop	 ebx

; 83   : }

  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_strstr	ENDP
_TEXT	ENDS
END
