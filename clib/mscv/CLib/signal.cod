; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\signal\signal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_signal_list DD	02H
	DD	FLAT:$SG1622
	DD	00H
	DD	04H
	DD	FLAT:$SG1623
	DD	00H
	DD	08H
	DD	FLAT:$SG1624
	DD	00H
	DD	0bH
	DD	FLAT:$SG1625
	DD	00H
	DD	0fH
	DD	FLAT:$SG1626
	DD	00H
	DD	015H
	DD	FLAT:$SG1627
	DD	00H
	DD	06H
	DD	FLAT:$SG1628
	DD	00H
$SG1622	DB	'CTRL+C', 00H
	ORG $+1
$SG1623	DB	'Illegal instruction', 00H
$SG1624	DB	'Floating-point exception', 00H
	ORG $+3
$SG1625	DB	'Illegal storage access', 00H
	ORG $+1
$SG1626	DB	'Termination request', 00H
$SG1627	DB	'CTRL+BREAK', 00H
	ORG $+1
$SG1628	DB	'Abnormal termination', 00H
_DATA	ENDS
PUBLIC	__default_handler
PUBLIC	___pxcptinfoptrs
PUBLIC	_signal
PUBLIC	_raise
EXTRN	___errno:PROC
EXTRN	_exit:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\signal\signal.c
;	COMDAT _raise
_TEXT	SEGMENT
_sig$ = 8						; size = 4
_raise	PROC						; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   :    __p_sig_fn_t temp = 0;
; 77   :    unsigned int i;
; 78   : 
; 79   :    switch (sig)

  00003	8b 55 08	 mov	 edx, DWORD PTR _sig$[ebp]
  00006	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00009	83 f8 13	 cmp	 eax, 19			; 00000013H
  0000c	77 5a		 ja	 SHORT $LN8@raise
  0000e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN20@raise[eax]
  00015	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@raise[eax*4]
$LN9@raise:

; 93   :    }
; 94   : 
; 95   : 
; 96   :    //  if(sig <= 0)
; 97   :    //    return -1;
; 98   :    //  if(sig > SIGMAX)
; 99   :    //    return -1;
; 100  : 
; 101  :    for(i=0;i<sizeof(signal_list)/sizeof(signal_list[0]);i++)

  0001c	33 c9		 xor	 ecx, ecx
  0001e	33 c0		 xor	 eax, eax
$LL7@raise:

; 102  :    {
; 103  :       if ( signal_list[i].signal == sig )

  00020	39 90 00 00 00
	00		 cmp	 DWORD PTR _signal_list[eax], edx
  00026	74 16		 je	 SHORT $LN15@raise

; 93   :    }
; 94   : 
; 95   : 
; 96   :    //  if(sig <= 0)
; 97   :    //    return -1;
; 98   :    //  if(sig > SIGMAX)
; 99   :    //    return -1;
; 100  : 
; 101  :    for(i=0;i<sizeof(signal_list)/sizeof(signal_list[0]);i++)

  00028	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002b	41		 inc	 ecx
  0002c	83 f8 54	 cmp	 eax, 84			; 00000054H
  0002f	72 ef		 jb	 SHORT $LL7@raise

; 114  :       _default_handler(sig); /* this does not return */

  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 __default_handler

; 115  :    else
; 116  :       temp(sig);

  00037	83 c4 04	 add	 esp, 4

; 117  : 
; 118  :    return 0;

  0003a	33 c0		 xor	 eax, eax

; 119  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN15@raise:

; 104  :       {
; 105  :          temp = signal_list[i].handler;

  0003e	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00041	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR _signal_list[eax*4+8]

; 106  :          break;
; 107  :       }
; 108  :    }
; 109  : 
; 110  :    if(temp == SIG_IGN)// || (sig == SIGQUIT && temp == (_p_sig_fn_t)SIG_DFL))

  00048	83 f8 01	 cmp	 eax, 1
  0004b	74 17		 je	 SHORT $LN22@raise

; 111  :       return 0;   /* Ignore it */
; 112  : 
; 113  :    if(temp == SIG_DFL)

  0004d	85 c0		 test	 eax, eax
  0004f	75 0d		 jne	 SHORT $LN2@raise

; 114  :       _default_handler(sig); /* this does not return */

  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 __default_handler

; 115  :    else
; 116  :       temp(sig);

  00057	83 c4 04	 add	 esp, 4

; 117  : 
; 118  :    return 0;

  0005a	33 c0		 xor	 eax, eax

; 119  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN2@raise:

; 115  :    else
; 116  :       temp(sig);

  0005e	52		 push	 edx
  0005f	ff d0		 call	 eax
  00061	83 c4 04	 add	 esp, 4
$LN22@raise:

; 117  : 
; 118  :    return 0;

  00064	33 c0		 xor	 eax, eax

; 119  : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN8@raise:

; 80   :    {
; 81   :       case SIGINT:
; 82   :       case SIGILL:
; 83   :       case SIGFPE:
; 84   :       case SIGSEGV:
; 85   :       case SIGTERM:
; 86   :       case SIGBREAK:
; 87   :       case SIGABRT:
; 88   :          break;
; 89   : 
; 90   :       default:
; 91   :          //FIXME: set last err?
; 92   :          return -1;

  00068	83 c8 ff	 or	 eax, -1

; 119  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
  0006d	8d 49 00	 npad	 3
$LN24@raise:
  00070	00 00 00 00	 DD	 $LN9@raise
  00074	00 00 00 00	 DD	 $LN8@raise
$LN20@raise:
  00078	00		 DB	 0
  00079	01		 DB	 1
  0007a	00		 DB	 0
  0007b	01		 DB	 1
  0007c	00		 DB	 0
  0007d	01		 DB	 1
  0007e	00		 DB	 0
  0007f	01		 DB	 1
  00080	01		 DB	 1
  00081	00		 DB	 0
  00082	01		 DB	 1
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	00		 DB	 0
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	00		 DB	 0
_raise	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\signal\signal.c
;	COMDAT _signal
_TEXT	SEGMENT
_sig$ = 8						; size = 4
_func$ = 12						; size = 4
_signal	PROC						; COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   :    __p_sig_fn_t temp;
; 30   :    unsigned int i;
; 31   : 
; 32   :    switch (sig)

  00003	8b 55 08	 mov	 edx, DWORD PTR _sig$[ebp]
  00006	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00009	83 f8 13	 cmp	 eax, 19			; 00000013H
  0000c	77 5d		 ja	 SHORT $LN6@signal
  0000e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN17@signal[eax]
  00015	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN21@signal[eax*4]
$LN7@signal:
  0001c	56		 push	 esi

; 46   :    }
; 47   : 
; 48   :    // check with IsBadCodePtr
; 49   :    if ( (uintptr_t)func < 4096 && func != SIG_DFL && func != SIG_IGN)

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _func$[ebp]
  00020	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00026	73 09		 jae	 SHORT $LN5@signal
  00028	85 f6		 test	 esi, esi
  0002a	74 05		 je	 SHORT $LN5@signal
  0002c	83 fe 01	 cmp	 esi, 1
  0002f	75 15		 jne	 SHORT $LN19@signal
$LN5@signal:

; 50   :    {
; 51   :       _set_errno(EINVAL);
; 52   :       return SIG_ERR;
; 53   :    }
; 54   : 
; 55   :    for(i=0; i < sizeof(signal_list)/sizeof(signal_list[0]); i++)

  00031	33 c9		 xor	 ecx, ecx
  00033	33 c0		 xor	 eax, eax
$LL4@signal:

; 56   :    {
; 57   :       if ( signal_list[i].signal == sig )

  00035	39 90 00 00 00
	00		 cmp	 DWORD PTR _signal_list[eax], edx
  0003b	74 1a		 je	 SHORT $LN13@signal

; 50   :    {
; 51   :       _set_errno(EINVAL);
; 52   :       return SIG_ERR;
; 53   :    }
; 54   : 
; 55   :    for(i=0; i < sizeof(signal_list)/sizeof(signal_list[0]); i++)

  0003d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00040	41		 inc	 ecx
  00041	83 f8 54	 cmp	 eax, 84			; 00000054H
  00044	72 ef		 jb	 SHORT $LL4@signal
$LN19@signal:

; 61   :          return temp;
; 62   :       }
; 63   :    }
; 64   : 
; 65   :    /* should be impossible to get here */
; 66   :    _set_errno(EINVAL);

  00046	e8 00 00 00 00	 call	 ___errno
  0004b	5e		 pop	 esi
  0004c	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 67   :    return SIG_ERR;

  00052	83 c8 ff	 or	 eax, -1

; 68   : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN13@signal:

; 58   :       {
; 59   :          temp = signal_list[i].handler;

  00057	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0005a	8b 04 8d 08 00
	00 00		 mov	 eax, DWORD PTR _signal_list[ecx*4+8]

; 60   :          signal_list[i].handler = func;

  00061	89 34 8d 08 00
	00 00		 mov	 DWORD PTR _signal_list[ecx*4+8], esi
  00068	5e		 pop	 esi

; 68   : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN6@signal:

; 33   :    {
; 34   :       case SIGINT:
; 35   :       case SIGILL:
; 36   :       case SIGFPE:
; 37   :       case SIGSEGV:
; 38   :       case SIGTERM:
; 39   :       case SIGBREAK:
; 40   :       case SIGABRT:
; 41   :          break;
; 42   : 
; 43   :       default:
; 44   :          _set_errno(EINVAL);

  0006b	e8 00 00 00 00	 call	 ___errno
  00070	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 45   :          return SIG_ERR;

  00076	83 c8 ff	 or	 eax, -1

; 68   : }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
  0007b	90		 npad	 1
$LN21@signal:
  0007c	00 00 00 00	 DD	 $LN7@signal
  00080	00 00 00 00	 DD	 $LN6@signal
$LN17@signal:
  00084	00		 DB	 0
  00085	01		 DB	 1
  00086	00		 DB	 0
  00087	01		 DB	 1
  00088	00		 DB	 0
  00089	01		 DB	 1
  0008a	00		 DB	 0
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	00		 DB	 0
  0008e	01		 DB	 1
  0008f	01		 DB	 1
  00090	01		 DB	 1
  00091	00		 DB	 0
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	00		 DB	 0
_signal	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\signal\signal.c
;	COMDAT ___pxcptinfoptrs
_TEXT	SEGMENT
___pxcptinfoptrs PROC					; COMDAT

; 131  : 	return NULL;

  00000	33 c0		 xor	 eax, eax

; 132  : }

  00002	c3		 ret	 0
___pxcptinfoptrs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\signal\signal.c
;	COMDAT __default_handler
_TEXT	SEGMENT
_sig$ = 8						; size = 4
__default_handler PROC					; COMDAT

; 123  :    _exit(3);

  00000	6a 03		 push	 3
  00002	e8 00 00 00 00	 call	 _exit
  00007	59		 pop	 ecx

; 124  : }

  00008	c3		 ret	 0
__default_handler ENDP
_TEXT	ENDS
END
