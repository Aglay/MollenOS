; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strtol.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtol
EXTRN	___errno:PROC
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtol.c
;	COMDAT _strtol
_TEXT	SEGMENT
_cutoff$1$ = -20					; size = 4
_cutlim$1$ = -16					; size = 4
_cutoff$2$ = -12					; size = 4
_neg$1$ = -8						; size = 4
_any$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtol	PROC						; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 9    :   const char *s = nptr;
; 10   :   unsigned long acc;
; 11   :   int c;
; 12   :   unsigned long cutoff;
; 13   :   int neg = 0, any, cutlim;

  00007	33 d2		 xor	 edx, edx
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _nptr$[ebp]
  0000d	89 55 f8	 mov	 DWORD PTR _neg$1$[ebp], edx
$LL25@strtol:

; 14   : 
; 15   :   /*
; 16   :    * Skip white space and pick up leading +/- sign if any.
; 17   :    * If base is 0, allow 0x for hex and 0 for octal, else
; 18   :    * assume decimal; if base is already 16, allow 0x.
; 19   :    */
; 20   :   do {
; 21   :     c = *s++;

  00010	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  00013	47		 inc	 edi

; 22   :   } while (isspace(c));

  00014	0f b6 c1	 movzx	 eax, cl
  00017	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  0001e	75 f0		 jne	 SHORT $LL25@strtol

; 23   :   if (c == '-')

  00020	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00023	75 0a		 jne	 SHORT $LN22@strtol

; 24   :   {
; 25   :     neg = 1;

  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _neg$1$[ebp], edx

; 26   :     c = *s++;

  0002d	eb 05		 jmp	 SHORT $LN38@strtol
$LN22@strtol:

; 27   :   }
; 28   :   else if (c == '+')

  0002f	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00032	75 04		 jne	 SHORT $LN20@strtol
$LN38@strtol:

; 29   :     c = *s++;

  00034	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  00037	47		 inc	 edi
$LN20@strtol:

; 30   :   if ((base == 0 || base == 16) &&
; 31   :       c == '0' && (*s == 'x' || *s == 'X'))

  00038	8b 5d 10	 mov	 ebx, DWORD PTR _base$[ebp]
  0003b	85 db		 test	 ebx, ebx
  0003d	74 05		 je	 SHORT $LN18@strtol
  0003f	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00042	75 1d		 jne	 SHORT $LN19@strtol
$LN18@strtol:
  00044	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00047	75 18		 jne	 SHORT $LN19@strtol
  00049	8a 07		 mov	 al, BYTE PTR [edi]
  0004b	3c 78		 cmp	 al, 120			; 00000078H
  0004d	74 04		 je	 SHORT $LN17@strtol
  0004f	3c 58		 cmp	 al, 88			; 00000058H
  00051	75 0e		 jne	 SHORT $LN19@strtol
$LN17@strtol:

; 32   :   {
; 33   :     c = s[1];

  00053	0f be 4f 01	 movsx	 ecx, BYTE PTR [edi+1]

; 34   :     s += 2;
; 35   :     base = 16;

  00057	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  0005c	83 c7 02	 add	 edi, 2

; 36   :   }
; 37   :   if (base == 0)

  0005f	eb 11		 jmp	 SHORT $LN39@strtol
$LN19@strtol:
  00061	85 db		 test	 ebx, ebx
  00063	75 10		 jne	 SHORT $LN16@strtol

; 38   :     base = c == '0' ? 8 : 10;

  00065	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00068	0f 95 c3	 setne	 bl
  0006b	8d 1c 5d 08 00
	00 00		 lea	 ebx, DWORD PTR [ebx*2+8]
$LN39@strtol:
  00072	89 5d 10	 mov	 DWORD PTR _base$[ebp], ebx
$LN16@strtol:

; 39   : 
; 40   :   /*
; 41   :    * Compute the cutoff value between legal numbers and illegal
; 42   :    * numbers.  That is the largest legal value, divided by the
; 43   :    * base.  An input number that is greater than this value, if
; 44   :    * followed by a legal input character, is too big.  One that
; 45   :    * is equal to this value may be valid or not; the limit
; 46   :    * between valid and invalid numbers is then based on the last
; 47   :    * digit.  For instance, if the range for longs is
; 48   :    * [-2147483648..2147483647] and the input base is 10,
; 49   :    * cutoff will be set to 214748364 and cutlim to either
; 50   :    * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
; 51   :    * a value > 214748364, or equal but the next digit is > 7 (or 8),
; 52   :    * the number is too big, and we will return a range error.
; 53   :    *
; 54   :    * Set any if any `digits' consumed; make it negative to indicate
; 55   :    * overflow.
; 56   :    */
; 57   :   cutoff = neg ? ((unsigned long)LONG_MAX+1) : LONG_MAX;

  00075	33 c0		 xor	 eax, eax
  00077	85 d2		 test	 edx, edx
  00079	56		 push	 esi
  0007a	0f 95 c0	 setne	 al

; 58   :   cutlim = cutoff % (unsigned long)base;

  0007d	33 d2		 xor	 edx, edx
  0007f	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
  00084	89 45 ec	 mov	 DWORD PTR _cutoff$1$[ebp], eax
  00087	f7 f3		 div	 ebx

; 59   :   cutoff /= (unsigned long)base;
; 60   :   for (acc = 0, any = 0;; c = *s++)

  00089	33 db		 xor	 ebx, ebx
  0008b	89 45 f4	 mov	 DWORD PTR _cutoff$2$[ebp], eax
  0008e	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
  00091	89 55 f0	 mov	 DWORD PTR _cutlim$1$[ebp], edx
  00094	89 5d fc	 mov	 DWORD PTR _any$1$[ebp], ebx
  00097	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL15@strtol:

; 61   :   {
; 62   :     if (isdigit(c))

  000a0	0f b6 f1	 movzx	 esi, cl
  000a3	8a 96 00 00 00
	00		 mov	 dl, BYTE PTR __ctype[esi]
  000a9	f6 c2 04	 test	 dl, 4
  000ac	74 05		 je	 SHORT $LN12@strtol

; 63   :       c -= '0';

  000ae	83 e9 30	 sub	 ecx, 48			; 00000030H
  000b1	eb 1a		 jmp	 SHORT $LN9@strtol
$LN12@strtol:

; 64   :     else if (isalpha(c))

  000b3	f6 c2 03	 test	 dl, 3
  000b6	74 4c		 je	 SHORT $LN32@strtol

; 65   :       c -= isupper(c) ? 'A' - 10 : 'a' - 10;

  000b8	80 e2 01	 and	 dl, 1
  000bb	0f b6 c2	 movzx	 eax, dl
  000be	f7 d8		 neg	 eax
  000c0	1b c0		 sbb	 eax, eax
  000c2	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000c5	83 c0 57	 add	 eax, 87			; 00000057H
  000c8	2b c8		 sub	 ecx, eax
  000ca	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
$LN9@strtol:

; 66   :     else
; 67   :       break;
; 68   :     if (c >= base)

  000cd	3b c8		 cmp	 ecx, eax
  000cf	7d 33		 jge	 SHORT $LN32@strtol

; 69   :       break;
; 70   :     if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000d1	83 7d fc 00	 cmp	 DWORD PTR _any$1$[ebp], 0
  000d5	7c 20		 jl	 SHORT $LN6@strtol
  000d7	8b 55 f4	 mov	 edx, DWORD PTR _cutoff$2$[ebp]
  000da	3b da		 cmp	 ebx, edx
  000dc	77 19		 ja	 SHORT $LN6@strtol
  000de	75 05		 jne	 SHORT $LN7@strtol
  000e0	3b 4d f0	 cmp	 ecx, DWORD PTR _cutlim$1$[ebp]
  000e3	7f 12		 jg	 SHORT $LN6@strtol
$LN7@strtol:

; 72   :     else
; 73   :     {
; 74   :       any = 1;
; 75   :       acc *= base;

  000e5	0f af d8	 imul	 ebx, eax
  000e8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _any$1$[ebp], 1

; 76   :       acc += c;

  000ef	03 d9		 add	 ebx, ecx
  000f1	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  000f4	47		 inc	 edi
  000f5	eb a9		 jmp	 SHORT $LL15@strtol
$LN6@strtol:

; 59   :   cutoff /= (unsigned long)base;
; 60   :   for (acc = 0, any = 0;; c = *s++)

  000f7	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  000fa	47		 inc	 edi

; 71   :       any = -1;

  000fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _any$1$[ebp], -1
  00102	eb 9c		 jmp	 SHORT $LL15@strtol
$LN32@strtol:

; 77   :     }
; 78   :   }
; 79   :   if (any < 0)

  00104	8b 45 fc	 mov	 eax, DWORD PTR _any$1$[ebp]
  00107	5e		 pop	 esi
  00108	85 c0		 test	 eax, eax
  0010a	79 13		 jns	 SHORT $LN4@strtol

; 80   :   {
; 81   :     acc = neg ? LONG_MIN : LONG_MAX;

  0010c	8b 5d ec	 mov	 ebx, DWORD PTR _cutoff$1$[ebp]

; 82   :     errno = ERANGE;

  0010f	e8 00 00 00 00	 call	 ___errno
  00114	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  0011a	8b 45 fc	 mov	 eax, DWORD PTR _any$1$[ebp]
  0011d	eb 08		 jmp	 SHORT $LN2@strtol
$LN4@strtol:

; 83   :   }
; 84   :   else if (neg)

  0011f	83 7d f8 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  00123	74 02		 je	 SHORT $LN2@strtol

; 85   :     acc = 0-acc;

  00125	f7 db		 neg	 ebx
$LN2@strtol:

; 86   :   if (endptr != 0)

  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _endptr$[ebp]
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 0c		 je	 SHORT $LN37@strtol

; 87   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  0012e	85 c0		 test	 eax, eax
  00130	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00133	75 03		 jne	 SHORT $LN29@strtol
  00135	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
$LN29@strtol:
  00138	89 01		 mov	 DWORD PTR [ecx], eax
$LN37@strtol:
  0013a	5f		 pop	 edi

; 88   :   return acc;

  0013b	8b c3		 mov	 eax, ebx
  0013d	5b		 pop	 ebx

; 89   : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
_strtol	ENDP
_TEXT	ENDS
END
