; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strtold.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_powten	DQ	04024000000000000r		; 10
	DQ	04059000000000000r		; 100
	DQ	040c3880000000000r		; 10000
	DQ	04197d78400000000r		; 1e+008
	DQ	04341c37937e08000r		; 1e+016
	DQ	04693b8b5b5056e17r		; 1e+032
	DQ	04d384f03e93ff9f5r		; 1e+064
	DQ	05a827748f9301d32r		; 1e+128
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
	DQ	075154fdd7f73bf3cr		; 1e+256
_DATA	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@0000000000000000
PUBLIC	__strtold
EXTRN	__ctype:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff0000000000000
; File c:\users\phail\documents\github\mollenos\clib\src\string\strtold.c
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT __strtold
_TEXT	SEGMENT
_sign$ = -8						; size = 4
_esign$ = -4						; size = 4
tv352 = 8						; size = 4
tv349 = 8						; size = 4
_s$ = 8							; size = 4
_sret$ = 12						; size = 4
__strtold PROC						; COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16   : 	double r;		/* result */
; 17   : 	int e, ne;			/* exponent */
; 18   : 	int sign;			/* +- 1.0 */
; 19   : 	int esign;
; 20   : 	int flags=0;
; 21   : 	int l2powm1;
; 22   : 
; 23   : 	r = 0.0L;

  00006	d9 ee		 fldz

; 24   : 	sign = 1;

  00008	b8 01 00 00 00	 mov	 eax, 1
  0000d	56		 push	 esi
  0000e	d9 c0		 fld	 ST(0)
  00010	89 45 f8	 mov	 DWORD PTR _sign$[ebp], eax

; 25   : 	e = ne = 0;
; 26   : 	esign = 1;

  00013	89 45 fc	 mov	 DWORD PTR _esign$[ebp], eax

; 27   : 
; 28   : 	while(*s && isspace(*s))

  00016	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00019	8a 08		 mov	 cl, BYTE PTR [eax]
  0001b	57		 push	 edi
  0001c	33 f6		 xor	 esi, esi
  0001e	33 ff		 xor	 edi, edi
  00020	33 d2		 xor	 edx, edx
  00022	84 c9		 test	 cl, cl
  00024	74 14		 je	 SHORT $LN44@strtold
$LN30@strtold:
  00026	0f b6 c9	 movzx	 ecx, cl
  00029	f6 81 00 00 00
	00 20		 test	 BYTE PTR __ctype[ecx], 32 ; 00000020H
  00030	74 08		 je	 SHORT $LN44@strtold
  00032	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 29   : 		s++;

  00035	40		 inc	 eax
  00036	84 c9		 test	 cl, cl
  00038	75 ec		 jne	 SHORT $LN30@strtold
$LN44@strtold:

; 30   : 
; 31   : 	if (*s == '+')

  0003a	8a 08		 mov	 cl, BYTE PTR [eax]
  0003c	80 f9 2b	 cmp	 cl, 43			; 0000002bH

; 32   : 		s++;

  0003f	74 0c		 je	 SHORT $LN114@strtold

; 33   : 	else if (*s == '-')

  00041	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00044	75 08		 jne	 SHORT $LN34@strtold

; 34   : 	{
; 35   : 		sign = -1;

  00046	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
$LN114@strtold:

; 36   : 		s++;

  0004d	40		 inc	 eax
$LN34@strtold:

; 37   : 	}
; 38   : 
; 39   : 	while ((*s >= '0') && (*s <= '9'))

  0004e	8a 08		 mov	 cl, BYTE PTR [eax]
  00050	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00056	80 f9 30	 cmp	 cl, 48			; 00000030H
  00059	7c 23		 jl	 SHORT $LN24@strtold
$LN25@strtold:
  0005b	80 f9 39	 cmp	 cl, 57			; 00000039H
  0005e	7f 1e		 jg	 SHORT $LN24@strtold

; 40   : 	{
; 41   : 		flags |= 1;
; 42   : 		r *= 10.0L;
; 43   : 		r += *s - '0';

  00060	0f be c9	 movsx	 ecx, cl
  00063	83 e9 30	 sub	 ecx, 48			; 00000030H
  00066	89 4d 08	 mov	 DWORD PTR tv352[ebp], ecx
  00069	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 44   : 		s++;

  0006c	40		 inc	 eax
  0006d	db 45 08	 fild	 DWORD PTR tv352[ebp]
  00070	83 ce 01	 or	 esi, 1
  00073	d9 ca		 fxch	 ST(2)
  00075	d8 c9		 fmul	 ST(0), ST(1)
  00077	de c2		 faddp	 ST(2), ST(0)
  00079	80 f9 30	 cmp	 cl, 48			; 00000030H
  0007c	7d dd		 jge	 SHORT $LN25@strtold
$LN24@strtold:

; 45   : 	}
; 46   : 
; 47   : 	if (*s == '.')

  0007e	80 38 2e	 cmp	 BYTE PTR [eax], 46	; 0000002eH
  00081	75 2d		 jne	 SHORT $LN66@strtold

; 48   : 	{
; 49   : 		s++;
; 50   : 		while ((*s >= '0') && (*s <= '9'))

  00083	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00086	40		 inc	 eax
  00087	80 f9 30	 cmp	 cl, 48			; 00000030H
  0008a	7c 24		 jl	 SHORT $LN66@strtold
$LN22@strtold:
  0008c	80 f9 39	 cmp	 cl, 57			; 00000039H
  0008f	7f 1f		 jg	 SHORT $LN66@strtold

; 51   : 		{
; 52   : 			flags |= 2;
; 53   : 			r *= 10.0L;
; 54   : 			r += *s - '0';

  00091	0f be c9	 movsx	 ecx, cl
  00094	83 e9 30	 sub	 ecx, 48			; 00000030H
  00097	89 4d 08	 mov	 DWORD PTR tv349[ebp], ecx
  0009a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 55   : 			s++;

  0009d	40		 inc	 eax
  0009e	db 45 08	 fild	 DWORD PTR tv349[ebp]
  000a1	83 ce 02	 or	 esi, 2
  000a4	d9 ca		 fxch	 ST(2)

; 56   : 			ne++;

  000a6	47		 inc	 edi
  000a7	d8 c9		 fmul	 ST(0), ST(1)
  000a9	de c2		 faddp	 ST(2), ST(0)
  000ab	80 f9 30	 cmp	 cl, 48			; 00000030H
  000ae	7d dc		 jge	 SHORT $LN22@strtold
$LN66@strtold:

; 48   : 	{
; 49   : 		s++;
; 50   : 		while ((*s >= '0') && (*s <= '9'))

  000b0	dd d8		 fstp	 ST(0)

; 57   : 		}
; 58   : 	}
; 59   : 	if (flags == 0)

  000b2	85 f6		 test	 esi, esi
  000b4	75 15		 jne	 SHORT $LN20@strtold

; 60   : 	{
; 61   : 		if (sret)

  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _sret$[ebp]
  000b9	dd d8		 fstp	 ST(0)
  000bb	85 c9		 test	 ecx, ecx
  000bd	0f 84 ba 00 00
	00		 je	 $LN31@strtold

; 62   : 			*sret = (char *)s;

  000c3	5f		 pop	 edi
  000c4	89 01		 mov	 DWORD PTR [ecx], eax
  000c6	5e		 pop	 esi

; 122  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
$LN20@strtold:

; 63   : 		return 0.0L;
; 64   : 	}
; 65   : 
; 66   : 	if ((*s == 'e') || (*s == 'E'))

  000cb	8a 08		 mov	 cl, BYTE PTR [eax]
  000cd	80 f9 65	 cmp	 cl, 101			; 00000065H
  000d0	74 05		 je	 SHORT $LN17@strtold
  000d2	80 f9 45	 cmp	 cl, 69			; 00000045H
  000d5	75 42		 jne	 SHORT $LN45@strtold
$LN17@strtold:

; 67   : 	{
; 68   : 		s++;
; 69   : 		if (*s == '+')

  000d7	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000da	40		 inc	 eax
  000db	80 f9 2b	 cmp	 cl, 43			; 0000002bH

; 70   : 			s++;

  000de	74 0c		 je	 SHORT $LN115@strtold

; 71   : 		else if (*s == '-')

  000e0	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000e3	75 08		 jne	 SHORT $LN36@strtold

; 74   : 			esign = -1;

  000e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _esign$[ebp], -1
$LN115@strtold:

; 72   : 		{
; 73   : 			s++;

  000ec	40		 inc	 eax
$LN36@strtold:

; 75   : 		}
; 76   : 		while ((*s >= '0') && (*s <= '9'))

  000ed	8a 08		 mov	 cl, BYTE PTR [eax]
  000ef	80 f9 30	 cmp	 cl, 48			; 00000030H
  000f2	7c 17		 jl	 SHORT $LN12@strtold
$LN13@strtold:
  000f4	80 f9 39	 cmp	 cl, 57			; 00000039H
  000f7	7f 12		 jg	 SHORT $LN12@strtold

; 77   : 		{
; 78   : 			e *= 10;
; 79   : 			e += *s - '0';

  000f9	0f be c9	 movsx	 ecx, cl
  000fc	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]

; 80   : 			s++;

  000ff	40		 inc	 eax
  00100	8d 54 51 d0	 lea	 edx, DWORD PTR [ecx+edx*2-48]
  00104	8a 08		 mov	 cl, BYTE PTR [eax]
  00106	80 f9 30	 cmp	 cl, 48			; 00000030H
  00109	7d e9		 jge	 SHORT $LN13@strtold
$LN12@strtold:

; 81   : 		}
; 82   : 	}
; 83   : 	if (esign < 0)

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _esign$[ebp]
  0010e	85 c9		 test	 ecx, ecx
  00110	79 07		 jns	 SHORT $LN45@strtold

; 84   : 	{
; 85   : 		esign = -esign;

  00112	f7 d9		 neg	 ecx
  00114	89 4d fc	 mov	 DWORD PTR _esign$[ebp], ecx

; 86   : 		e = -e;

  00117	f7 da		 neg	 edx
$LN45@strtold:

; 87   : 	}
; 88   : 	e = e - ne;

  00119	2b d7		 sub	 edx, edi

; 89   : 	if (e < -4096)

  0011b	81 fa 00 f0 ff
	ff		 cmp	 edx, -4096		; fffff000H
  00121	7d 0a		 jge	 SHORT $LN78@strtold

; 90   : 	{
; 91   : 		/* possibly subnormal number, 10^e would overflow */
; 92   : 		r *= 1.0e-2048L;

  00123	de c9		 fmulp	 ST(1), ST(0)

; 93   : 		e += 2048;

  00125	81 c2 00 08 00
	00		 add	 edx, 2048		; 00000800H
  0012b	eb 02		 jmp	 SHORT $LN10@strtold
$LN78@strtold:
  0012d	dd d9		 fstp	 ST(1)
$LN10@strtold:

; 94   : 	}
; 95   : 	if (e < 0)

  0012f	85 d2		 test	 edx, edx
  00131	79 0a		 jns	 SHORT $LN9@strtold

; 96   : 	{
; 97   : 		e = -e;
; 98   : 		esign = -esign;

  00133	8b 4d fc	 mov	 ecx, DWORD PTR _esign$[ebp]
  00136	f7 da		 neg	 edx
  00138	f7 d9		 neg	 ecx
  0013a	89 4d fc	 mov	 DWORD PTR _esign$[ebp], ecx
$LN9@strtold:

; 99   : 	}
; 100  : 	if (e >= 8192)

  0013d	81 fa 00 20 00
	00		 cmp	 edx, 8192		; 00002000H
  00143	7c 07		 jl	 SHORT $LN8@strtold

; 101  : 		e = 8191;

  00145	ba ff 1f 00 00	 mov	 edx, 8191		; 00001fffH

; 102  : 	if (e)

  0014a	eb 04		 jmp	 SHORT $LN43@strtold
$LN8@strtold:
  0014c	85 d2		 test	 edx, edx
  0014e	74 21		 je	 SHORT $LN2@strtold
$LN43@strtold:

; 103  : 	{
; 104  : 		double d = 1.0L;

  00150	d9 e8		 fld1
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET _powten
$LN6@strtold:

; 105  : 		l2powm1 = 0;
; 106  : 		while (e)
; 107  : 		{
; 108  : 			if (e & 1)

  00157	f6 c2 01	 test	 dl, 1
  0015a	74 02		 je	 SHORT $LN4@strtold

; 109  : 				d *= powten[l2powm1];

  0015c	dc 09		 fmul	 QWORD PTR [ecx]
$LN4@strtold:

; 110  : 			e >>= 1;
; 111  : 			l2powm1++;

  0015e	83 c1 08	 add	 ecx, 8
  00161	d1 fa		 sar	 edx, 1
  00163	75 f2		 jne	 SHORT $LN6@strtold

; 112  : 		}
; 113  : 		if (esign > 0)

  00165	83 7d fc 00	 cmp	 DWORD PTR _esign$[ebp], 0
  00169	7e 04		 jle	 SHORT $LN3@strtold

; 114  : 			r *= d;

  0016b	de c9		 fmulp	 ST(1), ST(0)

; 115  : 		else

  0016d	eb 02		 jmp	 SHORT $LN2@strtold
$LN3@strtold:

; 116  : 			r /= d;

  0016f	de f9		 fdivp	 ST(1), ST(0)
$LN2@strtold:

; 117  : 	}
; 118  : 	if (sret)

  00171	8b 4d 0c	 mov	 ecx, DWORD PTR _sret$[ebp]
  00174	85 c9		 test	 ecx, ecx
  00176	74 02		 je	 SHORT $LN1@strtold

; 119  : 		*sret = (char *)s;

  00178	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@strtold:

; 120  : 	
; 121  : 	return r * sign;

  0017a	da 4d f8	 fimul	 DWORD PTR _sign$[ebp]
$LN31@strtold:
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi

; 122  : }

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
__strtold ENDP
_TEXT	ENDS
END
