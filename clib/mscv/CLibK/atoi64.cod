; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\atoi64.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_atoi64
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\atoi64.c
;	COMDAT _atoi64
_TEXT	SEGMENT
_neg$1$ = -4						; size = 4
_acc$1$ = 8						; size = 4
_nptr$ = 8						; size = 4
_atoi64	PROC						; COMDAT

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10   :   char *s = (char *)nptr;

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi

; 11   :   __int64 acc = 0;

  00009	33 f6		 xor	 esi, esi
  0000b	33 db		 xor	 ebx, ebx
  0000d	89 75 08	 mov	 DWORD PTR _acc$1$[ebp], esi

; 12   :   int neg = 0;

  00010	89 5d fc	 mov	 DWORD PTR _neg$1$[ebp], ebx

; 13   : 
; 14   :   if (nptr == NULL)

  00013	85 c9		 test	 ecx, ecx
  00015	75 0a		 jne	 SHORT $LN12@atoi64

; 15   :     return 0;

  00017	5e		 pop	 esi
  00018	33 c0		 xor	 eax, eax
  0001a	33 d2		 xor	 edx, edx
  0001c	5b		 pop	 ebx

; 36   : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN12@atoi64:

; 16   : 
; 17   :   while(isspace((int)*s))

  00021	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00024	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  0002b	74 11		 je	 SHORT $LN7@atoi64
  0002d	8d 49 00	 npad	 3
$LL8@atoi64:
  00030	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]

; 18   :     s++;

  00034	41		 inc	 ecx
  00035	f6 80 00 00 00
	00 20		 test	 BYTE PTR __ctype[eax], 32 ; 00000020H
  0003c	75 f2		 jne	 SHORT $LL8@atoi64
$LN7@atoi64:

; 19   :   if (*s == '-')

  0003e	8a 01		 mov	 al, BYTE PTR [ecx]
  00040	3c 2d		 cmp	 al, 45			; 0000002dH
  00042	75 09		 jne	 SHORT $LN6@atoi64

; 20   :     {
; 21   :       neg = 1;

  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 1

; 22   :       s++;

  0004b	eb 04		 jmp	 SHORT $LN20@atoi64
$LN6@atoi64:

; 23   :     }
; 24   :   else if (*s == '+')

  0004d	3c 2b		 cmp	 al, 43			; 0000002bH
  0004f	75 01		 jne	 SHORT $LN13@atoi64
$LN20@atoi64:

; 25   :     s++;

  00051	41		 inc	 ecx
$LN13@atoi64:

; 26   : 
; 27   :   while (isdigit((int)*s))

  00052	8a 11		 mov	 dl, BYTE PTR [ecx]
  00054	0f b6 c2	 movzx	 eax, dl
  00057	f6 80 00 00 00
	00 04		 test	 BYTE PTR __ctype[eax], 4
  0005e	74 3e		 je	 SHORT $LN2@atoi64
  00060	57		 push	 edi
$LL3@atoi64:

; 28   :     {
; 29   :       acc = 10 * acc + ((int)*s - '0');

  00061	0f be c2	 movsx	 eax, dl

; 30   :       s++;

  00064	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00067	83 e8 30	 sub	 eax, 48			; 00000030H
  0006a	99		 cdq
  0006b	8b fa		 mov	 edi, edx
  0006d	8b d6		 mov	 edx, esi
  0006f	8b f3		 mov	 esi, ebx
  00071	0f a4 d6 02	 shld	 esi, edx, 2
  00075	c1 e2 02	 shl	 edx, 2
  00078	01 55 08	 add	 DWORD PTR _acc$1$[ebp], edx
  0007b	8b 55 08	 mov	 edx, DWORD PTR _acc$1$[ebp]
  0007e	13 de		 adc	 ebx, esi
  00080	0f a4 d3 01	 shld	 ebx, edx, 1
  00084	03 d2		 add	 edx, edx
  00086	03 c2		 add	 eax, edx
  00088	8a 11		 mov	 dl, BYTE PTR [ecx]
  0008a	8b f0		 mov	 esi, eax
  0008c	0f b6 c2	 movzx	 eax, dl
  0008f	13 df		 adc	 ebx, edi
  00091	89 75 08	 mov	 DWORD PTR _acc$1$[ebp], esi
  00094	f6 80 00 00 00
	00 04		 test	 BYTE PTR __ctype[eax], 4
  0009b	75 c4		 jne	 SHORT $LL3@atoi64
  0009d	5f		 pop	 edi
$LN2@atoi64:

; 31   :     }
; 32   : 
; 33   :   if (neg)

  0009e	83 7d fc 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  000a2	74 07		 je	 SHORT $LN1@atoi64

; 34   :     acc *= -1;

  000a4	f7 de		 neg	 esi
  000a6	83 d3 00	 adc	 ebx, 0
  000a9	f7 db		 neg	 ebx
$LN1@atoi64:

; 35   :   return acc;

  000ab	8b c6		 mov	 eax, esi
  000ad	8b d3		 mov	 edx, ebx
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx

; 36   : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
_atoi64	ENDP
_TEXT	ENDS
END
