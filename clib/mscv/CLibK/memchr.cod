; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\memchr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_memchr
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\memchr.c
;	COMDAT _memchr
_TEXT	SEGMENT
_src_void$ = 8						; size = 4
_c$ = 12						; size = 4
_length$ = 16						; size = 4
_memchr	PROC						; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	const unsigned char *src = (const unsigned char *)src_void;

  00003	8b 45 08	 mov	 eax, DWORD PTR _src_void$[ebp]
  00006	53		 push	 ebx

; 74   : 	unsigned char d = (unsigned char)c;
; 75   : 	unsigned long *asrc;
; 76   : 	unsigned long  mask;
; 77   : 	int i;
; 78   : 
; 79   : 	while (_memchrUNALIGNED (src))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 10	 mov	 esi, DWORD PTR _length$[ebp]
  0000e	a8 03		 test	 al, 3
  00010	74 10		 je	 SHORT $LN13@memchr
$LL14@memchr:

; 80   : 	{
; 81   : 		if (!length--)

  00012	8b ce		 mov	 ecx, esi
  00014	4e		 dec	 esi
  00015	85 c9		 test	 ecx, ecx
  00017	74 57		 je	 SHORT $LN28@memchr

; 82   : 			return NULL;
; 83   : 
; 84   : 		if (*src == d)

  00019	38 18		 cmp	 BYTE PTR [eax], bl
  0001b	74 55		 je	 SHORT $LN15@memchr

; 85   : 			return (void *)src;
; 86   : 
; 87   : 		src++;

  0001d	40		 inc	 eax
  0001e	a8 03		 test	 al, 3
  00020	75 f0		 jne	 SHORT $LL14@memchr
$LN13@memchr:

; 88   : 	}
; 89   : 
; 90   : 	if (!TOO_SMALL (length))

  00022	83 fe 04	 cmp	 esi, 4
  00025	72 3b		 jb	 SHORT $LN23@memchr

; 91   : 	{
; 92   : 		/* If we get this far, we know that length is large and src is
; 93   : 			word-aligned. */
; 94   : 		/* The fast code reads the source one word at a time and only
; 95   : 			performs the bytewise search on word-sized segments if they
; 96   : 			contain the search character, which is detected by XORing
; 97   : 			the word-sized segment with a word-sized block of the search
; 98   : 			character and then detecting for the presence of NUL in the
; 99   : 			result.  */
; 100  : 		asrc = (unsigned long *) src;
; 101  : 		mask = d << 8 | d;

  00027	57		 push	 edi
  00028	0f b6 cb	 movzx	 ecx, bl
  0002b	8b f9		 mov	 edi, ecx
  0002d	c1 e7 08	 shl	 edi, 8
  00030	0b f9		 or	 edi, ecx

; 102  : 		mask = mask << 16 | mask;

  00032	8b cf		 mov	 ecx, edi
  00034	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00037	0b f9		 or	 edi, ecx
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL6@memchr:

; 103  : 
; 104  : 		for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
; 105  : 			mask = (mask << i) | mask;
; 106  : 
; 107  : 		while (length >= LBLOCKSIZE)
; 108  : 		{
; 109  : 			if (DETECTCHAR (*asrc, mask))

  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	33 d7		 xor	 edx, edi
  00044	8d 8a ff fe fe
	fe		 lea	 ecx, DWORD PTR [edx-16843009]
  0004a	f7 d2		 not	 edx
  0004c	23 ca		 and	 ecx, edx
  0004e	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00054	75 0b		 jne	 SHORT $LN41@memchr

; 110  : 			break;
; 111  : 			length -= LBLOCKSIZE;

  00056	83 ee 04	 sub	 esi, 4

; 112  : 			asrc++;

  00059	83 c0 04	 add	 eax, 4
  0005c	83 fe 04	 cmp	 esi, 4
  0005f	73 df		 jae	 SHORT $LL6@memchr
$LN41@memchr:
  00061	5f		 pop	 edi
$LN23@memchr:

; 113  : 		}
; 114  : 
; 115  : 		/* If there are fewer than LBLOCKSIZE characters left,
; 116  : 			then we resort to the bytewise loop.  */
; 117  : 
; 118  : 		src = (unsigned char *) asrc;
; 119  : 	}
; 120  : 
; 121  : 	while (length--)

  00062	85 f6		 test	 esi, esi
  00064	74 0a		 je	 SHORT $LN28@memchr
$LL3@memchr:
  00066	4e		 dec	 esi

; 122  : 	{
; 123  : 		if (*src == d)

  00067	38 18		 cmp	 BYTE PTR [eax], bl
  00069	74 07		 je	 SHORT $LN15@memchr

; 124  : 		return (void *) src;
; 125  : 		src++;

  0006b	40		 inc	 eax
  0006c	85 f6		 test	 esi, esi
  0006e	75 f6		 jne	 SHORT $LL3@memchr
$LN28@memchr:

; 126  : 	}
; 127  : 
; 128  : 	return NULL;

  00070	33 c0		 xor	 eax, eax
$LN15@memchr:
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx

; 129  : }

  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_memchr	ENDP
_TEXT	ENDS
END
