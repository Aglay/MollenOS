; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\math\modf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_one	DQ	03ff0000000000000r		; 1
CONST	ENDS
PUBLIC	_modf
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\math\modf.c
;	COMDAT _modf
_TEXT	SEGMENT
_iw_u$1 = -8						; size = 8
_ew_u$2 = -8						; size = 8
tv271 = 8						; size = 8
tv257 = 8						; size = 8
_iw_u$3 = 8						; size = 8
_iw_u$4 = 8						; size = 8
_gh_u$5 = 8						; size = 8
_iw_u$6 = 8						; size = 8
_iw_u$7 = 8						; size = 8
_gh_u$8 = 8						; size = 8
_x$ = 8							; size = 8
_iptr$ = 16						; size = 4
_modf	PROC						; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 89   : 	__int32_t i0,i1,j_0;
; 90   : 	__uint32_t i;
; 91   : 	EXTRACT_WORDS(i0,i1,x);

  00006	f2 0f 10 4d 08	 movsd	 xmm1, QWORD PTR _x$[ebp]
  0000b	f2 0f 11 4d f8	 movsd	 QWORD PTR _ew_u$2[ebp], xmm1

; 92   : 	j_0 = ((i0>>20)&0x7ff)-0x3ff;	/* exponent of x */

  00010	8b 55 fc	 mov	 edx, DWORD PTR _ew_u$2[ebp+4]
  00013	8b ca		 mov	 ecx, edx
  00015	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00018	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  0001e	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH

; 93   : 	if(j_0<20) {			/* integer part in high x */

  00024	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00027	0f 8d 82 00 00
	00		 jge	 $LN37@modf

; 94   : 		if(j_0<0) {			/* |x|<1 */

  0002d	85 c9		 test	 ecx, ecx
  0002f	79 23		 jns	 SHORT $LN36@modf

; 95   : 			INSERT_WORDS(*iptr,i0&0x80000000U,0);	/* *iptr = +-0 */

  00031	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  00034	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H

; 96   : 			return x;

  0003a	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  0003d	89 55 fc	 mov	 DWORD PTR _iw_u$1[ebp+4], edx
  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iw_u$1[ebp], 0
  00047	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR _iw_u$1[ebp]
  0004c	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 127  : 		}
; 128  : 	}
; 129  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN36@modf:
  00054	56		 push	 esi

; 97   : 		} else {
; 98   : 			i = (0x000fffff)>>j_0;

  00055	be ff ff 0f 00	 mov	 esi, 1048575		; 000fffffH
  0005a	d3 fe		 sar	 esi, cl

; 99   : 			if(((i0&i)|i1)==0) {		/* x is integral */

  0005c	8b c6		 mov	 eax, esi
  0005e	23 c2		 and	 eax, edx
  00060	0b 45 f8	 or	 eax, DWORD PTR _ew_u$2[ebp]

; 100  : 				__uint32_t high;
; 101  : 				*iptr = x;

  00063	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  00066	75 1f		 jne	 SHORT $LN23@modf

; 102  : 				GET_HIGH_WORD(high,x);

  00068	f2 0f 11 4d 08	 movsd	 QWORD PTR _gh_u$8[ebp], xmm1

; 103  : 				INSERT_WORDS(x,high&0x80000000U,0);	/* return +-0 */

  0006d	81 65 0c 00 00
	00 80		 and	 DWORD PTR _gh_u$8[ebp+4], -2147483648 ; 80000000H
  00074	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$7[ebp], 0

; 104  : 				return x;

  0007b	dd 45 08	 fld	 QWORD PTR _iw_u$7[ebp]
  0007e	f2 0f 11 08	 movsd	 QWORD PTR [eax], xmm1
  00082	5e		 pop	 esi

; 127  : 		}
; 128  : 	}
; 129  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
$LN23@modf:

; 105  : 			} else {
; 106  : 				INSERT_WORDS(*iptr,i0&(~i),0);

  00087	f7 d6		 not	 esi
  00089	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$6[ebp], 0
  00090	23 f2		 and	 esi, edx
  00092	89 75 0c	 mov	 DWORD PTR _iw_u$6[ebp+4], esi
  00095	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _iw_u$6[ebp]

; 107  : 				return x - *iptr;

  0009a	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0009e	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  000a2	5e		 pop	 esi
  000a3	f2 0f 11 4d 08	 movsd	 QWORD PTR tv271[ebp], xmm1
  000a8	dd 45 08	 fld	 QWORD PTR tv271[ebp]

; 127  : 		}
; 128  : 	}
; 129  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN37@modf:

; 108  : 			}
; 109  : 		}
; 110  : 	} else if (j_0>51) {		/* no fraction part */

  000af	83 f9 33	 cmp	 ecx, 51			; 00000033H
  000b2	7e 21		 jle	 SHORT $LN19@modf
$LN44@modf:

; 111  : 		__uint32_t high;
; 112  : 		*iptr = x*one;

  000b4	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]

; 113  : 		GET_HIGH_WORD(high,x);

  000b7	f2 0f 11 4d 08	 movsd	 QWORD PTR _gh_u$5[ebp], xmm1

; 114  : 		INSERT_WORDS(x,high&0x80000000U,0);	/* return +-0 */

  000bc	81 65 0c 00 00
	00 80		 and	 DWORD PTR _gh_u$5[ebp+4], -2147483648 ; 80000000H
  000c3	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$4[ebp], 0

; 115  : 		return x;

  000ca	dd 45 08	 fld	 QWORD PTR _iw_u$4[ebp]
  000cd	f2 0f 11 08	 movsd	 QWORD PTR [eax], xmm1

; 127  : 		}
; 128  : 	}
; 129  : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
$LN19@modf:

; 116  : 	} else {			/* fraction part in low x */
; 117  : 		i = ((__uint32_t)(0xffffffffU))>>(j_0-20);

  000d5	83 c1 ec	 add	 ecx, -20		; ffffffecH
  000d8	83 c8 ff	 or	 eax, -1
  000db	d3 e8		 shr	 eax, cl

; 118  : 		if((i1&i)==0) { 		/* x is integral */

  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _ew_u$2[ebp]
  000e0	85 c1		 test	 eax, ecx
  000e2	74 d0		 je	 SHORT $LN44@modf

; 119  : 			__uint32_t high;
; 120  : 			*iptr = x;
; 121  : 			GET_HIGH_WORD(high,x);
; 122  : 			INSERT_WORDS(x,high&0x80000000U,0);	/* return +-0 */
; 123  : 			return x;
; 124  : 		} else {
; 125  : 			INSERT_WORDS(*iptr,i0,i1&(~i));

  000e4	f7 d0		 not	 eax
  000e6	89 55 0c	 mov	 DWORD PTR _iw_u$3[ebp+4], edx
  000e9	23 c1		 and	 eax, ecx
  000eb	89 45 08	 mov	 DWORD PTR _iw_u$3[ebp], eax
  000ee	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _iw_u$3[ebp]
  000f3	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]

; 126  : 			return x - *iptr;

  000f6	f2 0f 5c c8	 subsd	 xmm1, xmm0
  000fa	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  000fe	f2 0f 11 4d 08	 movsd	 QWORD PTR tv257[ebp], xmm1
  00103	dd 45 08	 fld	 QWORD PTR tv257[ebp]

; 127  : 		}
; 128  : 	}
; 129  : }

  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
_modf	ENDP
_TEXT	ENDS
END
