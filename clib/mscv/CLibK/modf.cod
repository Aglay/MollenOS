; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\math\modf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_one	DQ	03ff0000000000000r		; 1
CONST	ENDS
PUBLIC	_modf
PUBLIC	__real@0000000000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\math\modf.c
;	COMDAT _modf
_TEXT	SEGMENT
_iw_u$1 = 8						; size = 8
_iw_u$2 = 8						; size = 8
_gh_u$3 = 8						; size = 8
_iw_u$4 = 8						; size = 8
_iw_u$5 = 8						; size = 8
_gh_u$6 = 8						; size = 8
_iw_u$7 = 8						; size = 8
_ew_u$8 = 8						; size = 8
_x$ = 8							; size = 8
_iptr$ = 16						; size = 4
_modf	PROC						; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	int32_t i0, i1, j0;
; 31   : 	uint32_t i;
; 32   : 	EXTRACT_WORDS(i0, i1, x);

  00003	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00006	dd 55 08	 fst	 QWORD PTR _ew_u$8[ebp]

; 33   : 	j0 = ((i0 >> 20) & 0x7ff) - 0x3ff;	/* exponent of x */

  00009	8b 55 0c	 mov	 edx, DWORD PTR _ew_u$8[ebp+4]
  0000c	8b ca		 mov	 ecx, edx
  0000e	c1 f9 14	 sar	 ecx, 20			; 00000014H
  00011	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00017	81 e9 ff 03 00
	00		 sub	 ecx, 1023		; 000003ffH

; 34   : 	if (j0<20) {			/* integer part in high x */

  0001d	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00020	7d 63		 jge	 SHORT $LN38@modf

; 35   : 		if (j0<0) {			/* |x|<1 */

  00022	85 c9		 test	 ecx, ecx
  00024	79 1a		 jns	 SHORT $LN37@modf

; 36   : 			INSERT_WORDS(*iptr, i0 & 0x80000000, 0);	/* *iptr = +-0 */

  00026	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  00029	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  0002f	89 55 0c	 mov	 DWORD PTR _iw_u$7[ebp+4], edx
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$7[ebp], 0
  00039	dd 45 08	 fld	 QWORD PTR _iw_u$7[ebp]
  0003c	dd 18		 fstp	 QWORD PTR [eax]

; 77   : 		}
; 78   : 	}
; 79   : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN37@modf:
  00040	56		 push	 esi

; 37   : 			return x;
; 38   : 		}
; 39   : 		else {
; 40   : 			i = (0x000fffff) >> j0;

  00041	be ff ff 0f 00	 mov	 esi, 1048575		; 000fffffH
  00046	d3 fe		 sar	 esi, cl

; 41   : 			if (((i0&i) | i1) == 0) {		/* x is integral */

  00048	8b c6		 mov	 eax, esi
  0004a	23 c2		 and	 eax, edx
  0004c	0b 45 08	 or	 eax, DWORD PTR _ew_u$8[ebp]

; 42   : 				uint32_t high;
; 43   : 				*iptr = x;

  0004f	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  00052	75 19		 jne	 SHORT $LN24@modf
  00054	dd 10		 fst	 QWORD PTR [eax]

; 44   : 				GET_HIGH_WORD(high, x);

  00056	dd 5d 08	 fstp	 QWORD PTR _gh_u$6[ebp]

; 45   : 				INSERT_WORDS(x, high & 0x80000000, 0);	/* return +-0 */

  00059	81 65 0c 00 00
	00 80		 and	 DWORD PTR _gh_u$6[ebp+4], -2147483648 ; 80000000H
  00060	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$5[ebp], 0

; 46   : 				return x;

  00067	dd 45 08	 fld	 QWORD PTR _iw_u$5[ebp]
  0006a	5e		 pop	 esi

; 77   : 		}
; 78   : 	}
; 79   : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN24@modf:

; 47   : 			}
; 48   : 			else {
; 49   : 				INSERT_WORDS(*iptr, i0&(~i), 0);

  0006d	f7 d6		 not	 esi
  0006f	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$4[ebp], 0
  00076	23 f2		 and	 esi, edx
  00078	89 75 0c	 mov	 DWORD PTR _iw_u$4[ebp+4], esi
  0007b	dd 45 08	 fld	 QWORD PTR _iw_u$4[ebp]
  0007e	dd 10		 fst	 QWORD PTR [eax]

; 50   : 				return x - *iptr;

  00080	de e9		 fsubp	 ST(1), ST(0)
  00082	5e		 pop	 esi

; 77   : 		}
; 78   : 	}
; 79   : }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN38@modf:

; 51   : 			}
; 52   : 		}
; 53   : 	}
; 54   : 	else if (j0>51) {		/* no fraction part */

  00085	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00088	7e 13		 jle	 SHORT $LN20@modf

; 55   : 		uint32_t high;
; 56   : 		if (j0 == 0x400) {		/* inf/NaN */
; 57   : 			*iptr = x;

  0008a	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  0008d	dd 10		 fst	 QWORD PTR [eax]
  0008f	81 f9 00 04 00
	00		 cmp	 ecx, 1024		; 00000400H
  00095	75 1a		 jne	 SHORT $LN19@modf

; 58   : 			return 0.0 / x;

  00097	d9 ee		 fldz
  00099	de f1		 fdivrp	 ST(1), ST(0)

; 77   : 		}
; 78   : 	}
; 79   : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
$LN20@modf:

; 59   : 		}
; 60   : 		*iptr = x*one;
; 61   : 		GET_HIGH_WORD(high, x);
; 62   : 		INSERT_WORDS(x, high & 0x80000000, 0);	/* return +-0 */
; 63   : 		return x;
; 64   : 	}
; 65   : 	else {			/* fraction part in low x */
; 66   : 		i = ((uint32_t)(0xffffffff)) >> (j0 - 20);

  0009d	83 c1 ec	 add	 ecx, -20		; ffffffecH
  000a0	83 c8 ff	 or	 eax, -1
  000a3	d3 e8		 shr	 eax, cl

; 67   : 		if ((i1&i) == 0) { 		/* x is integral */

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _ew_u$8[ebp]
  000a8	85 c1		 test	 eax, ecx
  000aa	75 1b		 jne	 SHORT $LN3@modf

; 68   : 			uint32_t high;
; 69   : 			*iptr = x;

  000ac	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  000af	dd 10		 fst	 QWORD PTR [eax]
$LN19@modf:

; 70   : 			GET_HIGH_WORD(high, x);

  000b1	dd 5d 08	 fstp	 QWORD PTR _gh_u$3[ebp]

; 71   : 			INSERT_WORDS(x, high & 0x80000000, 0);	/* return +-0 */

  000b4	81 65 0c 00 00
	00 80		 and	 DWORD PTR _gh_u$3[ebp+4], -2147483648 ; 80000000H
  000bb	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iw_u$2[ebp], 0

; 72   : 			return x;

  000c2	dd 45 08	 fld	 QWORD PTR _iw_u$2[ebp]

; 77   : 		}
; 78   : 	}
; 79   : }

  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
$LN3@modf:

; 73   : 		}
; 74   : 		else {
; 75   : 			INSERT_WORDS(*iptr, i0, i1&(~i));

  000c7	f7 d0		 not	 eax
  000c9	89 55 0c	 mov	 DWORD PTR _iw_u$1[ebp+4], edx
  000cc	23 c1		 and	 eax, ecx
  000ce	89 45 08	 mov	 DWORD PTR _iw_u$1[ebp], eax
  000d1	8b 45 10	 mov	 eax, DWORD PTR _iptr$[ebp]
  000d4	dd 45 08	 fld	 QWORD PTR _iw_u$1[ebp]
  000d7	dd 10		 fst	 QWORD PTR [eax]

; 76   : 			return x - *iptr;

  000d9	de e9		 fsubp	 ST(1), ST(0)

; 77   : 		}
; 78   : 	}
; 79   : }

  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_modf	ENDP
_TEXT	ENDS
END
