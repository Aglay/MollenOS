; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strcat.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strcat
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strcat.c
;	COMDAT _strcat
_TEXT	SEGMENT
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_strcat	PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	char *s = destination;

  00003	8b 55 08	 mov	 edx, DWORD PTR _destination$[ebp]
  00006	8b c2		 mov	 eax, edx

; 28   : 
; 29   : 	/* Skip over the data in s1 as quickly as possible.  */
; 30   : 	if (ALIGNED (destination))

  00008	f6 c2 03	 test	 dl, 3
  0000b	75 2e		 jne	 SHORT $LN10@strcat

; 31   : 	{
; 32   : 		unsigned long *aligned_s1 = (unsigned long *)destination;
; 33   : 		
; 34   : 		while (!DETECTNULL (*aligned_s1))

  0000d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000f	56		 push	 esi
  00010	8d b1 ff fe fe
	fe		 lea	 esi, DWORD PTR [ecx-16843009]
  00016	f7 d1		 not	 ecx
  00018	23 f1		 and	 esi, ecx
  0001a	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  00020	75 18		 jne	 SHORT $LN3@strcat
$LL4@strcat:
  00022	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 35   : 			aligned_s1++;

  00025	83 c2 04	 add	 edx, 4
  00028	8d b1 ff fe fe
	fe		 lea	 esi, DWORD PTR [ecx-16843009]
  0002e	f7 d1		 not	 ecx
  00030	23 f1		 and	 esi, ecx
  00032	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  00038	74 e8		 je	 SHORT $LL4@strcat
$LN3@strcat:
  0003a	5e		 pop	 esi
$LN10@strcat:

; 36   : 
; 37   : 		destination = (char *)aligned_s1;
; 38   : 	}
; 39   : 
; 40   : 	while (*destination)

  0003b	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0003e	74 06		 je	 SHORT $LN1@strcat
$LL2@strcat:

; 41   : 		destination++;

  00040	42		 inc	 edx
  00041	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00044	75 fa		 jne	 SHORT $LL2@strcat
$LN1@strcat:

; 42   : 
; 43   : 	/* s1 now points to the its trailing null character, we can
; 44   : 		just use strcpy to do the work for us now. */
; 45   : 	strcpy(destination, source);

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  00049	2b d1		 sub	 edx, ecx
  0004b	53		 push	 ebx
  0004c	8d 64 24 00	 npad	 4
$LL8@strcat:
  00050	8a 19		 mov	 bl, BYTE PTR [ecx]
  00052	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl
  00055	41		 inc	 ecx
  00056	84 db		 test	 bl, bl
  00058	75 f6		 jne	 SHORT $LL8@strcat
  0005a	5b		 pop	 ebx

; 46   : 	
; 47   : 	return s;
; 48   : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_strcat	ENDP
_TEXT	ENDS
END
