; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strcmp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strcmp
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strcmp.c
;	COMDAT _strcmp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_strcmp	PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	unsigned long *a1;
; 28   : 	unsigned long *a2;
; 29   : 
; 30   : 	/* If s1 or s2 are unaligned, then compare bytes. */
; 31   : 	if (!UNALIGNED (str1, str2))

  00003	8b 45 08	 mov	 eax, DWORD PTR _str1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _str2$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	0b ca		 or	 ecx, edx
  0000d	56		 push	 esi
  0000e	f6 c1 03	 test	 cl, 3
  00011	75 2c		 jne	 SHORT $LN4@strcmp

; 32   : 	{  
; 33   : 		/* If s1 and s2 are word-aligned, compare them a word at a time. */
; 34   : 		a1 = (unsigned long*)str1;
; 35   : 		a2 = (unsigned long*)str2;
; 36   : 		while (*a1 == *a2)

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00017	75 26		 jne	 SHORT $LN4@strcmp
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL5@strcmp:

; 37   : 		{
; 38   : 			/* To get here, *a1 == *a2, thus if we find a null in *a1,
; 39   : 			then the strings must be equal, so return zero.  */
; 40   : 			if (DETECTNULL (*a1))

  00020	8d b1 ff fe fe
	fe		 lea	 esi, DWORD PTR [ecx-16843009]
  00026	f7 d1		 not	 ecx
  00028	23 f1		 and	 esi, ecx
  0002a	f7 c6 80 80 80
	80		 test	 esi, -2139062144	; 80808080H
  00030	75 2b		 jne	 SHORT $LN11@strcmp

; 42   : 
; 43   : 			a1++;

  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	83 c0 04	 add	 eax, 4

; 44   : 			a2++;

  00038	83 c2 04	 add	 edx, 4
  0003b	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003d	74 e1		 je	 SHORT $LL5@strcmp
$LN4@strcmp:

; 45   : 		}
; 46   : 
; 47   : 		/* A difference was detected in last few bytes of s1, so search bytewise */
; 48   : 		str1 = (char*)a1;
; 49   : 		str2 = (char*)a2;
; 50   : 	}
; 51   : 
; 52   : 	while (*str1 != '\0' && *str1 == *str2)

  0003f	8a 08		 mov	 cl, BYTE PTR [eax]
  00041	84 c9		 test	 cl, cl
  00043	74 0d		 je	 SHORT $LN1@strcmp
$LL2@strcmp:
  00045	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00047	75 09		 jne	 SHORT $LN1@strcmp
  00049	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 53   : 	{
; 54   : 		str1++;

  0004c	40		 inc	 eax

; 55   : 		str2++;

  0004d	42		 inc	 edx
  0004e	84 c9		 test	 cl, cl
  00050	75 f3		 jne	 SHORT $LL2@strcmp
$LN1@strcmp:

; 56   : 	}
; 57   : 	return (*(unsigned char *) str1) - (*(unsigned char *) str2);

  00052	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00055	0f b6 12	 movzx	 edx, BYTE PTR [edx]
  00058	2b c2		 sub	 eax, edx
  0005a	5e		 pop	 esi

; 58   : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN11@strcmp:

; 41   : 				return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	5e		 pop	 esi

; 58   : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_strcmp	ENDP
_TEXT	ENDS
END
