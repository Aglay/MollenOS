; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strcpy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strcpy
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strcpy.c
;	COMDAT _strcpy
_TEXT	SEGMENT
_to$ = 8						; size = 4
_from$ = 12						; size = 4
_strcpy	PROC						; COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 28   : 	char *dst = to;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _to$[ebp]
  00007	8b c3		 mov	 eax, ebx
  00009	56		 push	 esi

; 29   : 	const char *src = from;

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _from$[ebp]

; 30   : 	long *aligned_dst;
; 31   : 	const long *aligned_src;
; 32   : 
; 33   : 	/* If SRC or DEST is unaligned, then copy bytes.  */
; 34   : 	if (!UNALIGNED (src, dst))

  0000d	8b cb		 mov	 ecx, ebx
  0000f	0b ce		 or	 ecx, esi
  00011	f6 c1 03	 test	 cl, 3
  00014	75 39		 jne	 SHORT $LN15@strcpy

; 35   : 	{
; 36   : 		aligned_dst = (long*)dst;
; 37   : 		aligned_src = (long*)src;
; 38   : 
; 39   : 		/* SRC and DEST are both "long int" aligned, try to do "long int"
; 40   : 			sized copies.  */
; 41   : 		while (!DETECTNULL(*aligned_src))

  00016	57		 push	 edi
  00017	8b 3e		 mov	 edi, DWORD PTR [esi]
  00019	8b cf		 mov	 ecx, edi
  0001b	f7 d1		 not	 ecx
  0001d	8d 97 ff fe fe
	fe		 lea	 edx, DWORD PTR [edi-16843009]
  00023	23 d1		 and	 edx, ecx
  00025	f7 c2 80 80 80
	80		 test	 edx, -2139062144	; 80808080H
  0002b	75 21		 jne	 SHORT $LN3@strcpy
  0002d	8d 49 00	 npad	 3
$LL4@strcpy:

; 42   : 		{
; 43   : 			*aligned_dst++ = *aligned_src++;

  00030	83 c6 04	 add	 esi, 4
  00033	89 38		 mov	 DWORD PTR [eax], edi
  00035	83 c0 04	 add	 eax, 4
  00038	8b 3e		 mov	 edi, DWORD PTR [esi]
  0003a	8b cf		 mov	 ecx, edi
  0003c	f7 d1		 not	 ecx
  0003e	8d 97 ff fe fe
	fe		 lea	 edx, DWORD PTR [edi-16843009]
  00044	23 d1		 and	 edx, ecx
  00046	f7 c2 80 80 80
	80		 test	 edx, -2139062144	; 80808080H
  0004c	74 e2		 je	 SHORT $LL4@strcpy
$LN3@strcpy:
  0004e	5f		 pop	 edi
$LN15@strcpy:

; 44   : 		}
; 45   : 
; 46   : 		dst = (char*)aligned_dst;
; 47   : 		src = (char*)aligned_src;
; 48   : 	}
; 49   : 
; 50   : 	while ((*dst++ = *src++))

  0004f	2b f0		 sub	 esi, eax
$LL2@strcpy:
  00051	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  00054	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00057	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  0005a	84 c9		 test	 cl, cl
  0005c	75 f3		 jne	 SHORT $LL2@strcpy

; 51   : 	;
; 52   : 	return to;

  0005e	5e		 pop	 esi
  0005f	8b c3		 mov	 eax, ebx
  00061	5b		 pop	 ebx

; 53   : }

  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_strcpy	ENDP
_TEXT	ENDS
END
