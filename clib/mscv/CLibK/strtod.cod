; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strtod.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	__real@3fb999999999999a
PUBLIC	__real@4024000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_strtod
EXTRN	__fltused:DWORD
;	COMDAT __real@3fb999999999999a
; File c:\users\phail\documents\github\mollenos\clib\src\string\strtod.c
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _strtod
_TEXT	SEGMENT
_sign$ = -4						; size = 4
tv408 = 8						; size = 4
tv404 = 8						; size = 4
_s$ = 8							; size = 4
_sret$ = 12						; size = 4
_strtod	PROC						; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9    :   long double r;		/* result */
; 10   :   int e;			/* exponent */
; 11   :   long double d;		/* scale */
; 12   :   int sign;			/* +- 1.0 */
; 13   :   int esign;
; 14   :   int i;
; 15   :   int flags=0;
; 16   : 
; 17   :   r = 0.0;

  00004	d9 ee		 fldz

; 18   :   sign = 1;
; 19   :   e = 0;
; 20   :   esign = 1;
; 21   : 
; 22   :   if (s == NULL)

  00006	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00009	56		 push	 esi
  0000a	d9 c0		 fld	 ST(0)
  0000c	33 f6		 xor	 esi, esi
  0000e	33 d2		 xor	 edx, edx
  00010	57		 push	 edi
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1
  00018	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  0001b	85 c0		 test	 eax, eax
  0001d	75 08		 jne	 SHORT $LN32@strtod
  0001f	5f		 pop	 edi
  00020	dd d8		 fstp	 ST(0)
  00022	5e		 pop	 esi

; 101  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN32@strtod:

; 23   :      return (double)r;
; 24   : 
; 25   : 
; 26   :   while ((*s == ' ') || (*s == '\t'))

  00027	8a 08		 mov	 cl, BYTE PTR [eax]
  00029	80 f9 20	 cmp	 cl, 32			; 00000020H
  0002c	74 05		 je	 SHORT $LN30@strtod
  0002e	80 f9 09	 cmp	 cl, 9
  00031	75 03		 jne	 SHORT $LN31@strtod
$LN30@strtod:

; 27   :     s++;

  00033	40		 inc	 eax
  00034	eb f1		 jmp	 SHORT $LN32@strtod
$LN31@strtod:

; 28   : 
; 29   :   if (*s == '+')

  00036	8a 08		 mov	 cl, BYTE PTR [eax]
  00038	80 f9 2b	 cmp	 cl, 43			; 0000002bH

; 30   :     s++;

  0003b	74 0c		 je	 SHORT $LN164@strtod

; 31   :   else if (*s == '-')

  0003d	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00040	75 08		 jne	 SHORT $LN38@strtod

; 32   :   {
; 33   :     sign = -1;

  00042	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
$LN164@strtod:

; 34   :     s++;

  00049	40		 inc	 eax
$LN38@strtod:

; 35   :   }
; 36   : 
; 37   :   while ((*s >= '0') && (*s <= '9'))

  0004a	8a 08		 mov	 cl, BYTE PTR [eax]
  0004c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00052	80 f9 30	 cmp	 cl, 48			; 00000030H
  00055	7c 22		 jl	 SHORT $LN25@strtod
$LN26@strtod:
  00057	80 f9 39	 cmp	 cl, 57			; 00000039H
  0005a	7f 1d		 jg	 SHORT $LN25@strtod

; 38   :   {
; 39   :     flags |= 1;
; 40   :     r *= 10.0;
; 41   :     r += *s - '0';

  0005c	0f be c9	 movsx	 ecx, cl
  0005f	83 e9 30	 sub	 ecx, 48			; 00000030H
  00062	89 4d 08	 mov	 DWORD PTR tv408[ebp], ecx
  00065	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 42   :     s++;

  00068	40		 inc	 eax
  00069	db 45 08	 fild	 DWORD PTR tv408[ebp]
  0006c	0b f7		 or	 esi, edi
  0006e	d9 ca		 fxch	 ST(2)
  00070	d8 c9		 fmul	 ST(0), ST(1)
  00072	de c2		 faddp	 ST(2), ST(0)
  00074	80 f9 30	 cmp	 cl, 48			; 00000030H
  00077	7d de		 jge	 SHORT $LN26@strtod
$LN25@strtod:

; 43   :   }
; 44   : 
; 45   :   if (*s == '.')

  00079	80 38 2e	 cmp	 BYTE PTR [eax], 46	; 0000002eH
  0007c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fb999999999999a
  00082	75 30		 jne	 SHORT $LN22@strtod

; 46   :   {
; 47   :     d = 0.1L;
; 48   :     s++;
; 49   :     while ((*s >= '0') && (*s <= '9'))

  00084	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00087	d9 c0		 fld	 ST(0)
  00089	40		 inc	 eax
  0008a	80 f9 30	 cmp	 cl, 48			; 00000030H
  0008d	7c 23		 jl	 SHORT $LN109@strtod
$LN23@strtod:
  0008f	80 f9 39	 cmp	 cl, 57			; 00000039H
  00092	7f 1e		 jg	 SHORT $LN109@strtod

; 50   :     {
; 51   :       flags |= 2;
; 52   :       r += d * (*s - '0');

  00094	0f be c9	 movsx	 ecx, cl
  00097	83 e9 30	 sub	 ecx, 48			; 00000030H
  0009a	89 4d 08	 mov	 DWORD PTR tv404[ebp], ecx
  0009d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 53   :       s++;

  000a0	40		 inc	 eax
  000a1	db 45 08	 fild	 DWORD PTR tv404[ebp]
  000a4	83 ce 02	 or	 esi, 2
  000a7	d8 c9		 fmul	 ST(0), ST(1)
  000a9	de c4		 faddp	 ST(4), ST(0)

; 54   :       d *= 0.1L;

  000ab	d8 c9		 fmul	 ST(0), ST(1)
  000ad	80 f9 30	 cmp	 cl, 48			; 00000030H
  000b0	7d dd		 jge	 SHORT $LN23@strtod
$LN109@strtod:

; 46   :   {
; 47   :     d = 0.1L;
; 48   :     s++;
; 49   :     while ((*s >= '0') && (*s <= '9'))

  000b2	dd d8		 fstp	 ST(0)
$LN22@strtod:

; 55   :     }
; 56   :   }
; 57   : 
; 58   :   if (flags == 0)

  000b4	85 f6		 test	 esi, esi
  000b6	75 0b		 jne	 SHORT $LN111@strtod
  000b8	dd da		 fstp	 ST(2)
  000ba	dd d9		 fstp	 ST(1)
  000bc	dd d8		 fstp	 ST(0)

; 59   :   {
; 60   :     if (sret)
; 61   :       *sret = (char *)s;
; 62   :     return 0;

  000be	e9 da 00 00 00	 jmp	 $LN13@strtod
$LN111@strtod:

; 63   :   }
; 64   : 
; 65   :   if ((*s == 'e') || (*s == 'E'))

  000c3	8a 08		 mov	 cl, BYTE PTR [eax]
  000c5	dd db		 fstp	 ST(3)
  000c7	80 f9 65	 cmp	 cl, 101			; 00000065H
  000ca	74 05		 je	 SHORT $LN18@strtod
  000cc	80 f9 45	 cmp	 cl, 69			; 00000045H
  000cf	75 7d		 jne	 SHORT $LN145@strtod
$LN18@strtod:

; 66   :   {
; 67   :     s++;
; 68   :     if (*s == '+')

  000d1	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000d4	40		 inc	 eax
  000d5	80 f9 2b	 cmp	 cl, 43			; 0000002bH
  000d8	75 03		 jne	 SHORT $LN17@strtod

; 69   :       s++;

  000da	40		 inc	 eax
  000db	eb 09		 jmp	 SHORT $LN15@strtod
$LN17@strtod:

; 70   :     else if (*s == '-')

  000dd	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000e0	75 04		 jne	 SHORT $LN15@strtod

; 71   :     {
; 72   :       s++;

  000e2	40		 inc	 eax

; 73   :       esign = -1;

  000e3	83 cf ff	 or	 edi, -1
$LN15@strtod:

; 74   :     }
; 75   :     if ((*s < '0') || (*s > '9'))

  000e6	8a 08		 mov	 cl, BYTE PTR [eax]
  000e8	80 f9 30	 cmp	 cl, 48			; 00000030H
  000eb	0f 8c a8 00 00
	00		 jl	 $LN139@strtod
  000f1	80 f9 39	 cmp	 cl, 57			; 00000039H
  000f4	0f 8f 9f 00 00
	00		 jg	 $LN139@strtod
$LN11@strtod:

; 79   : 
; 80   : 		return (double)r;
; 81   :     }
; 82   : 
; 83   :     while ((*s >= '0') && (*s <= '9'))

  000fa	80 f9 39	 cmp	 cl, 57			; 00000039H
  000fd	7f 12		 jg	 SHORT $LN10@strtod

; 84   :     {
; 85   :       e *= 10;
; 86   :       e += *s - '0';

  000ff	0f be c9	 movsx	 ecx, cl
  00102	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]

; 87   :       s++;

  00105	40		 inc	 eax
  00106	8d 54 51 d0	 lea	 edx, DWORD PTR [ecx+edx*2-48]
  0010a	8a 08		 mov	 cl, BYTE PTR [eax]
  0010c	80 f9 30	 cmp	 cl, 48			; 00000030H
  0010f	7d e9		 jge	 SHORT $LN11@strtod
$LN10@strtod:

; 88   :     }
; 89   :   }
; 90   : 
; 91   :   if (esign < 0)

  00111	85 ff		 test	 edi, edi
  00113	79 39		 jns	 SHORT $LN145@strtod
  00115	dd d8		 fstp	 ST(0)

; 92   :     for (i = 1; i <= e; i++)

  00117	be 01 00 00 00	 mov	 esi, 1
  0011c	83 fa 08	 cmp	 edx, 8
  0011f	7c 1f		 jl	 SHORT $LC49@strtod
  00121	8b ca		 mov	 ecx, edx
  00123	c1 e9 03	 shr	 ecx, 3
  00126	8d 34 cd 01 00
	00 00		 lea	 esi, DWORD PTR [ecx*8+1]
$LN82@strtod:
  0012d	49		 dec	 ecx

; 93   :       r *= 0.1L;

  0012e	d8 c9		 fmul	 ST(0), ST(1)
  00130	d8 c9		 fmul	 ST(0), ST(1)
  00132	d8 c9		 fmul	 ST(0), ST(1)
  00134	d8 c9		 fmul	 ST(0), ST(1)
  00136	d8 c9		 fmul	 ST(0), ST(1)
  00138	d8 c9		 fmul	 ST(0), ST(1)
  0013a	d8 c9		 fmul	 ST(0), ST(1)
  0013c	d8 c9		 fmul	 ST(0), ST(1)
  0013e	75 ed		 jne	 SHORT $LN82@strtod
$LC49@strtod:

; 92   :     for (i = 1; i <= e; i++)

  00140	3b f2		 cmp	 esi, edx
  00142	7f 41		 jg	 SHORT $LN152@strtod
  00144	2b d6		 sub	 edx, esi
  00146	42		 inc	 edx
$LC83@strtod:
  00147	4a		 dec	 edx

; 93   :       r *= 0.1L;

  00148	d8 c9		 fmul	 ST(0), ST(1)
  0014a	75 fb		 jne	 SHORT $LC83@strtod

; 94   :   else

  0014c	eb 37		 jmp	 SHORT $LN152@strtod
$LN145@strtod:

; 88   :     }
; 89   :   }
; 90   : 
; 91   :   if (esign < 0)

  0014e	dd da		 fstp	 ST(2)

; 95   :     for (i = 1; i <= e; i++)

  00150	be 01 00 00 00	 mov	 esi, 1
  00155	83 fa 08	 cmp	 edx, 8
  00158	7c 1f		 jl	 SHORT $LC52@strtod
  0015a	8b ca		 mov	 ecx, edx
  0015c	c1 e9 03	 shr	 ecx, 3
  0015f	8d 34 cd 01 00
	00 00		 lea	 esi, DWORD PTR [ecx*8+1]
$LN84@strtod:
  00166	49		 dec	 ecx

; 96   :       r *= 10.0;

  00167	d8 c9		 fmul	 ST(0), ST(1)
  00169	d8 c9		 fmul	 ST(0), ST(1)
  0016b	d8 c9		 fmul	 ST(0), ST(1)
  0016d	d8 c9		 fmul	 ST(0), ST(1)
  0016f	d8 c9		 fmul	 ST(0), ST(1)
  00171	d8 c9		 fmul	 ST(0), ST(1)
  00173	d8 c9		 fmul	 ST(0), ST(1)
  00175	d8 c9		 fmul	 ST(0), ST(1)
  00177	75 ed		 jne	 SHORT $LN84@strtod
$LC52@strtod:

; 95   :     for (i = 1; i <= e; i++)

  00179	3b f2		 cmp	 esi, edx
  0017b	7f 08		 jg	 SHORT $LN152@strtod
  0017d	2b d6		 sub	 edx, esi
  0017f	42		 inc	 edx
$LC85@strtod:
  00180	4a		 dec	 edx

; 96   :       r *= 10.0;

  00181	d8 c9		 fmul	 ST(0), ST(1)
  00183	75 fb		 jne	 SHORT $LC85@strtod
$LN152@strtod:

; 97   : 
; 98   :   if (sret)

  00185	8b 4d 0c	 mov	 ecx, DWORD PTR _sret$[ebp]
  00188	dd d9		 fstp	 ST(1)
  0018a	85 c9		 test	 ecx, ecx
  0018c	74 02		 je	 SHORT $LN1@strtod

; 99   :     *sret = (char *)s;

  0018e	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@strtod:

; 100  :   return (double)(r * sign);

  00190	da 4d fc	 fimul	 DWORD PTR _sign$[ebp]
  00193	5f		 pop	 edi
  00194	5e		 pop	 esi

; 101  : }

  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
$LN139@strtod:

; 74   :     }
; 75   :     if ((*s < '0') || (*s > '9'))

  00199	dd da		 fstp	 ST(2)
  0019b	dd d9		 fstp	 ST(1)
$LN13@strtod:

; 76   :     {
; 77   : 		if (sret)

  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _sret$[ebp]
  001a0	85 c9		 test	 ecx, ecx
  001a2	74 02		 je	 SHORT $LN34@strtod

; 78   : 			*sret = (char *)s;

  001a4	89 01		 mov	 DWORD PTR [ecx], eax
$LN34@strtod:
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 101  : }

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
_strtod	ENDP
_TEXT	ENDS
END
