; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdlib\strtod.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_tinytens DQ	03c9cd2b297d889bcr		; 1e-016
	DQ	03949f623d5a8a733r		; 1e-032
	DQ	032a50ffd44f4a73dr		; 1e-064
	DQ	0255bba08cf8c979dr		; 1e-128
	DQ	01168062864ac6f43r		; 8.11296e-225
?fpi@?5??_strtod_l@@9@9 DD 035H				; `_strtod_l'::`6'::fpi
	DD	0fffffbceH
	DD	03cbH
	DD	01H
	DD	00H
?fpinan@?BK@??_strtod_l@@9@9 DD 034H			; `_strtod_l'::`26'::fpinan
	DD	0fffffbceH
	DD	03cbH
	DD	01H
	DD	00H
CONST	ENDS
PUBLIC	_strtof
PUBLIC	_strtod
PUBLIC	___get_global_locale
PUBLIC	___get_locale_r
PUBLIC	___get_current_locale
PUBLIC	__strtod_l
PUBLIC	??_C@_02HBFAAMOG@nf?$AA@			; `string'
PUBLIC	??_C@_05KMOPHDFI@inity?$AA@			; `string'
PUBLIC	??_C@_02LCNFMBND@an?$AA@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fcfffff94a03595
PUBLIC	__real@3fdfffff94a03595
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe0000035afe535
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@41f0000000000000
PUBLIC	__real@bff0000000000000
EXTRN	___errno:PROC
EXTRN	_strncmp:PROC
EXTRN	___isnan:PROC
EXTRN	_nanf:PROC
EXTRN	___localeconv_l:PROC
EXTRN	___ulp:PROC
EXTRN	__Balloc:PROC
EXTRN	__Bfree:PROC
EXTRN	___s2b:PROC
EXTRN	___i2b:PROC
EXTRN	___multiply:PROC
EXTRN	___pow5mult:PROC
EXTRN	___d2b:PROC
EXTRN	___lshift:PROC
EXTRN	___match:PROC
EXTRN	___mdiff:PROC
EXTRN	___mcmp:PROC
EXTRN	___gethex:PROC
EXTRN	___ratio:PROC
EXTRN	___copybits:PROC
EXTRN	___hexnan:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memcpy:PROC
EXTRN	___global_locale:BYTE
EXTRN	___mprec_bigtens:BYTE
EXTRN	___mprec_tens:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000035afe535
CONST	SEGMENT
__real@3fe0000035afe535 DQ 03fe0000035afe535r	; 0.5
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fdfffff94a03595
CONST	SEGMENT
__real@3fdfffff94a03595 DQ 03fdfffff94a03595r	; 0.5
CONST	ENDS
;	COMDAT __real@3fcfffff94a03595
CONST	SEGMENT
__real@3fcfffff94a03595 DQ 03fcfffff94a03595r	; 0.25
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_02LCNFMBND@an?$AA@
CONST	SEGMENT
??_C@_02LCNFMBND@an?$AA@ DB 'an', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KMOPHDFI@inity?$AA@
CONST	SEGMENT
??_C@_05KMOPHDFI@inity?$AA@ DB 'inity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HBFAAMOG@nf?$AA@
CONST	SEGMENT
??_C@_02HBFAAMOG@nf?$AA@ DB 'nf', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtod.c
;	COMDAT _ULtod
_TEXT	SEGMENT
_L$ = 8							; size = 4
_bits$ = 12						; size = 4
_exp$ = 16						; size = 4
_k$ = 20						; size = 4
_ULtod	PROC						; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	switch (k & STRTOG_Retmask) {

  00003	8b 45 14	 mov	 eax, DWORD PTR _k$[ebp]
  00006	83 e0 07	 and	 eax, 7
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _L$[ebp]
  0000d	83 f8 06	 cmp	 eax, 6
  00010	77 63		 ja	 SHORT $LN7@ULtod
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@ULtod[eax*4]
$LN6@ULtod:

; 87   : 	case STRTOG_NoNumber:
; 88   : 	case STRTOG_Zero:
; 89   : 		L[0] = L[1] = 0;

  00019	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 90   : 		break;

  00026	eb 4d		 jmp	 SHORT $LN7@ULtod
$LN5@ULtod:

; 91   : 
; 92   : 	case STRTOG_Denormal:
; 93   : 		L[_1] = bits[0];

  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	89 06		 mov	 DWORD PTR [esi], eax

; 94   : 		L[_0] = bits[1];

  0002f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00032	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 95   : 		break;

  00035	eb 3e		 jmp	 SHORT $LN7@ULtod
$LN4@ULtod:

; 96   : 
; 97   : 	case STRTOG_Normal:
; 98   : 	case STRTOG_NaNbits:
; 99   : 		L[_1] = bits[0];

  00037	8b 55 0c	 mov	 edx, DWORD PTR _bits$[ebp]

; 100  : 		L[_0] = (bits[1] & ~0x100000) | ((exp + 0x3ff + 52) << 20);

  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _exp$[ebp]
  0003d	8b 02		 mov	 eax, DWORD PTR [edx]
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	8d 89 33 04 00
	00		 lea	 ecx, DWORD PTR [ecx+1075]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	c1 e1 14	 shl	 ecx, 20			; 00000014H
  0004d	25 ff ff ef ff	 and	 eax, -1048577		; ffefffffH
  00052	0b c8		 or	 ecx, eax
  00054	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 101  : 		break;

  00057	eb 1c		 jmp	 SHORT $LN7@ULtod
$LN3@ULtod:

; 102  : 
; 103  : 	case STRTOG_Infinite:
; 104  : 		L[_0] = 0x7ff00000;

  00059	c7 46 04 00 00
	f0 7f		 mov	 DWORD PTR [esi+4], 2146435072 ; 7ff00000H

; 105  : 		L[_1] = 0;

  00060	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 106  : 		break;

  00066	eb 0d		 jmp	 SHORT $LN7@ULtod
$LN2@ULtod:

; 107  : 
; 108  : 	case STRTOG_NaN:
; 109  : 		L[_0] = 0x7fffffff;

  00068	c7 46 04 ff ff
	ff 7f		 mov	 DWORD PTR [esi+4], 2147483647 ; 7fffffffH

; 110  : 		L[_1] = (unsigned long)-1;

  0006f	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN7@ULtod:

; 111  : 	}
; 112  : 	if (k & STRTOG_Neg)

  00075	f6 45 14 08	 test	 BYTE PTR _k$[ebp], 8
  00079	74 07		 je	 SHORT $LN1@ULtod

; 113  : 		L[_0] |= 0x80000000L;

  0007b	81 4e 04 00 00
	00 80		 or	 DWORD PTR [esi+4], -2147483648 ; 80000000H
$LN1@ULtod:
  00082	5e		 pop	 esi

; 114  : }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
  00085	8d 49 00	 npad	 3
$LN12@ULtod:
  00088	00 00 00 00	 DD	 $LN6@ULtod
  0008c	00 00 00 00	 DD	 $LN4@ULtod
  00090	00 00 00 00	 DD	 $LN5@ULtod
  00094	00 00 00 00	 DD	 $LN3@ULtod
  00098	00 00 00 00	 DD	 $LN2@ULtod
  0009c	00 00 00 00	 DD	 $LN4@ULtod
  000a0	00 00 00 00	 DD	 $LN6@ULtod
_ULtod	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtod.c
;	COMDAT _sulp
_TEXT	SEGMENT
_u$ = -8						; size = 8
_x$ = 8							; size = 8
_scale$ = 16						; size = 4
_sulp	PROC						; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	U u;
; 69   : 	double rv;
; 70   : 	int i;
; 71   : 
; 72   : 	rv = ulp(dval(x));

  00003	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	83 ec 08	 sub	 esp, 8
  0000c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0000f	e8 00 00 00 00	 call	 ___ulp
  00014	83 c4 08	 add	 esp, 8

; 73   : 	if (!scale || (i = 2 * P + 1 - ((dword0(x) & Exp_mask) >> Exp_shift)) <= 0)

  00017	83 7d 10 00	 cmp	 DWORD PTR _scale$[ebp], 0
  0001b	74 2c		 je	 SHORT $LN3@sulp
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp+4]
  00020	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00025	c1 e8 14	 shr	 eax, 20			; 00000014H
  00028	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002d	2b c8		 sub	 ecx, eax
  0002f	85 c9		 test	 ecx, ecx
  00031	7e 16		 jle	 SHORT $LN3@sulp

; 74   : 		return rv; /* Is there an example where i <= 0 ? */
; 75   : 	dword0(u) = Exp_1 + ((__int32_t)i << Exp_shift);

  00033	8d 81 ff 03 00
	00		 lea	 eax, DWORD PTR [ecx+1023]

; 76   : #ifndef _DOUBLE_IS_32BITS
; 77   : 	dword1(u) = 0;

  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _u$[ebp], 0
  00040	c1 e0 14	 shl	 eax, 20			; 00000014H
  00043	89 45 fc	 mov	 DWORD PTR _u$[ebp+4], eax

; 78   : #endif
; 79   : 	return rv * u.d;

  00046	dc 4d f8	 fmul	 QWORD PTR _u$[ebp]
$LN3@sulp:

; 80   : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_sulp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtod.c
;	COMDAT __strtod_l
_TEXT	SEGMENT
_bits$1 = -128						; size = 8
_bits$2 = -120						; size = 8
_rv0$ = -112						; size = 8
tv1504 = -104						; size = 8
tv1379 = -104						; size = 8
_rv$2$ = -104						; size = 8
tv1399 = -96						; size = 8
_rv$ = -96						; size = 8
_bbbits$ = -88						; size = 4
_bbe$ = -84						; size = 4
_aadj1$ = -80						; size = 8
_bb1$1$ = -76						; size = 4
_s1$1$ = -76						; size = 4
tv1508 = -76						; size = 4
tv1505 = -76						; size = 4
tv1401 = -76						; size = 4
_i$5$ = -76						; size = 4
_dec_len$1$ = -76					; size = 4
_aadj1$1$ = -72						; size = 8
_bb5$1$ = -68						; size = 4
_s0$1$ = -68						; size = 4
_aadj$3$ = -64						; size = 8
_bd5$1$ = -60						; size = 4
_decpt$1$ = -60						; size = 4
_Lsb1$1$ = -56						; size = 4
_esign$1$ = -56						; size = 4
_z$1$ = -56						; size = 4
_bs2$1$ = -52						; size = 4
_nd0$2$ = -52						; size = 4
_Lsb$1$ = -48						; size = 4
_nz0$1$ = -48						; size = 4
_nf$1$ = -44						; size = 4
_exp$3 = -44						; size = 4
_dsign$1$ = -40						; size = 4
_c$1$ = -40						; size = 4
_delta$1$ = -36						; size = 4
_e$1$ = -32						; size = 4
_s$1$ = -32						; size = 4
_lconv$1$ = -32						; size = 4
_bd$1$ = -28						; size = 4
_bs$1$ = -24						; size = 4
_scale$1$ = -20						; size = 4
_nz$1$ = -20						; size = 4
_bb$ = -16						; size = 4
_sign$1$ = -12						; size = 4
_bd0$1$ = -8						; size = 4
_y$1$ = -8						; size = 4
_s$ = -4						; size = 4
_bd2$1$ = 8						; size = 4
_j$3$ = 8						; size = 4
_k$1$ = 8						; size = 4
tv1393 = 8						; size = 4
tv1380 = 8						; size = 4
_s00$ = 8						; size = 4
tv1404 = 10						; size = 2
_se$ = 12						; size = 4
_loc$ = 16						; size = 4
__strtod_l PROC						; COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 119  : #ifdef Avoid_Underflow
; 120  : 	int scale;
; 121  : #endif
; 122  : 	int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, decpt, dsign,
; 123  : 		e, e1, esign, i, j, k, nd, nd0, nf, nz, nz0, sign;
; 124  : 	const char *s, *s0, *s1;
; 125  : 	double aadj, adj;
; 126  : 	U aadj1, rv, rv0;
; 127  : 	Long L;
; 128  : 	unsigned long y, z;
; 129  : 	_Bigint *bb = NULL, *bb1, *bd = NULL, *bd0, *bs = NULL, *delta = NULL;
; 130  : #ifdef Avoid_Underflow
; 131  : 	unsigned long Lsb, Lsb1;
; 132  : #endif
; 133  : #ifdef SET_INEXACT
; 134  : 	int inexact, oldinexact;
; 135  : #endif
; 136  : #ifdef Honor_FLT_ROUNDS
; 137  : 	int rounding;
; 138  : #endif
; 139  : 	struct lconv *lconv = __localeconv_l(loc);

  0000c	8b 7d 10	 mov	 edi, DWORD PTR _loc$[ebp]
  0000f	57		 push	 edi
  00010	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bb$[ebp], 0
  00017	e8 00 00 00 00	 call	 ___localeconv_l
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 e0	 mov	 DWORD PTR _lconv$1$[ebp], eax

; 140  : 	int dec_len = strlen(lconv->decimal_point);

  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL262@strtod_l:
  00027	8a 02		 mov	 al, BYTE PTR [edx]
  00029	42		 inc	 edx
  0002a	84 c0		 test	 al, al
  0002c	75 f9		 jne	 SHORT $LL262@strtod_l

; 141  : 
; 142  : 	delta = bs = bd = NULL;
; 143  : 	sign = nz0 = nz = decpt = 0;
; 144  : 	dval(rv) = 0.;
; 145  : 	for (s = s00;; s++) switch (*s) {

  0002e	8b 45 08	 mov	 eax, DWORD PTR _s00$[ebp]
  00031	2b d1		 sub	 edx, ecx
  00033	d9 ee		 fldz
  00035	8b f0		 mov	 esi, eax
  00037	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  0003a	33 db		 xor	 ebx, ebx
  0003c	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  0003f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00042	89 55 b4	 mov	 DWORD PTR _dec_len$1$[ebp], edx
  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bd$1$[ebp], 0
  0004c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bs$1$[ebp], 0
  00053	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _delta$1$[ebp], 0
  0005a	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _decpt$1$[ebp], 0
  00061	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nz$1$[ebp], 0
  00068	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _nz0$1$[ebp], 0
  0006f	89 5d f4	 mov	 DWORD PTR _sign$1$[ebp], ebx
  00072	dd 5d a0	 fstp	 QWORD PTR _rv$[ebp]
  00075	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00078	77 37		 ja	 SHORT $break2$461
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL195@strtod_l:
  00080	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN263@strtod_l[eax]
  00087	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN459@strtod_l[eax*4]
$LN194@strtod_l:
  0008e	46		 inc	 esi
  0008f	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  00092	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00095	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00098	76 e6		 jbe	 SHORT $LL195@strtod_l

; 1073 : 						if (aadj < .4999999 || aadj > .5000001)

  0009a	eb 15		 jmp	 SHORT $break2$461
$LN190@strtod_l:

; 146  : 	case '-':
; 147  : 		sign = 1;

  0009c	bb 01 00 00 00	 mov	 ebx, 1
  000a1	89 5d f4	 mov	 DWORD PTR _sign$1$[ebp], ebx
$LN189@strtod_l:

; 148  : 		/* no break */
; 149  : 	case '+':
; 150  : 		if (*++s)

  000a4	46		 inc	 esi
  000a5	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  000a8	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000ab	0f 84 bb 03 00
	00		 je	 $ret0$462
$break2$461:

; 151  : 			goto break2;
; 152  : 		/* no break */
; 153  : 	case 0:
; 154  : 		goto ret0;
; 155  : 	case '\t':
; 156  : 	case '\n':
; 157  : 	case '\v':
; 158  : 	case '\f':
; 159  : 	case '\r':
; 160  : 	case ' ':
; 161  : 		continue;
; 162  : 	default:
; 163  : 		goto break2;
; 164  : 	}
; 165  : break2:
; 166  : 	if (*s == '0') {

  000b1	8a 0e		 mov	 cl, BYTE PTR [esi]
  000b3	80 f9 30	 cmp	 cl, 48			; 00000030H
  000b6	75 2b		 jne	 SHORT $LN172@strtod_l

; 167  : #ifndef NO_HEX_FP
; 168  : 		{
; 169  : 			static const FPI fpi = { 53, 1 - 1023 - 53 + 1, 2046 - 1023 - 53 + 1, 1, SI };
; 170  : 			Long exp;
; 171  : 			unsigned long bits[2];
; 172  : 			switch (s[1]) {

  000b8	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  000bb	80 f9 58	 cmp	 cl, 88			; 00000058H
  000be	74 60		 je	 SHORT $LN181@strtod_l
  000c0	80 f9 78	 cmp	 cl, 120			; 00000078H
  000c3	74 5b		 je	 SHORT $LN181@strtod_l

; 202  : 					}}
; 203  : 				goto ret;
; 204  : 			}
; 205  : 		}
; 206  : #endif
; 207  : 		nz0 = 1;

  000c5	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _nz0$1$[ebp], 1
  000cc	8d 64 24 00	 npad	 4
$LL174@strtod_l:

; 208  : 		while (*++s == '0');

  000d0	46		 inc	 esi
  000d1	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  000d4	80 3e 30	 cmp	 BYTE PTR [esi], 48	; 00000030H
  000d7	74 f7		 je	 SHORT $LL174@strtod_l

; 209  : 		if (!*s)

  000d9	8a 0e		 mov	 cl, BYTE PTR [esi]
  000db	84 c9		 test	 cl, cl
  000dd	0f 84 df 0c 00
	00		 je	 $LN289@strtod_l
$LN172@strtod_l:

; 210  : 			goto ret;
; 211  : 	}
; 212  : 	s0 = s;
; 213  : 	y = z = 0;

  000e3	33 c0		 xor	 eax, eax

; 214  : 	for (nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)

  000e5	0f be c9	 movsx	 ecx, cl
  000e8	33 db		 xor	 ebx, ebx
  000ea	89 75 bc	 mov	 DWORD PTR _s0$1$[ebp], esi
  000ed	33 ff		 xor	 edi, edi
  000ef	89 5d c8	 mov	 DWORD PTR _z$1$[ebp], ebx
  000f2	89 45 f8	 mov	 DWORD PTR _y$1$[ebp], eax
  000f5	89 45 d4	 mov	 DWORD PTR _nf$1$[ebp], eax
  000f8	89 4d d8	 mov	 DWORD PTR _c$1$[ebp], ecx
  000fb	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000fe	0f 8c ae 00 00
	00		 jl	 $LN169@strtod_l
$LL171@strtod_l:
  00104	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00107	0f 8f 9f 00 00
	00		 jg	 $LN277@strtod_l

; 215  : 		if (nd < 9)

  0010d	83 ff 09	 cmp	 edi, 9
  00110	7d 7d		 jge	 SHORT $LN168@strtod_l

; 216  : 			y = 10 * y + c - '0';

  00112	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00115	8d 40 e8	 lea	 eax, DWORD PTR [eax-24]
  00118	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0011b	89 45 f8	 mov	 DWORD PTR _y$1$[ebp], eax

; 217  : 		else

  0011e	eb 7b		 jmp	 SHORT $LN170@strtod_l
$LN181@strtod_l:

; 173  : 			case 'x':
; 174  : 			case 'X':
; 175  : 				/* If the number is not hex, then the parse of
; 176  : 				0 is still valid.  */
; 177  : 				s00 = s + 1;
; 178  : 				{
; 179  : #if defined(FE_DOWNWARD) && defined(FE_TONEAREST) && defined(FE_TOWARDZERO) && defined(FE_UPWARD)
; 180  : 					FPI fpi1 = fpi;
; 181  : 					switch (fegetround()) {
; 182  : 					case FE_TOWARDZERO:	fpi1.rounding = 0; break;
; 183  : 					case FE_UPWARD:	fpi1.rounding = 2; break;
; 184  : 					case FE_DOWNWARD:	fpi1.rounding = 3;
; 185  : 					}
; 186  : #else
; 187  : #define fpi1 fpi
; 188  : #endif
; 189  : 					switch ((i = gethex(&s, &fpi1, &exp, &bb, sign, loc)) & STRTOG_Retmask) {

  00120	57		 push	 edi
  00121	53		 push	 ebx
  00122	8d 45 f0	 lea	 eax, DWORD PTR _bb$[ebp]
  00125	46		 inc	 esi
  00126	50		 push	 eax
  00127	8d 45 d4	 lea	 eax, DWORD PTR _exp$3[ebp]
  0012a	50		 push	 eax
  0012b	8d 45 fc	 lea	 eax, DWORD PTR _s$[ebp]
  0012e	68 00 00 00 00	 push	 OFFSET ?fpi@?5??_strtod_l@@9@9
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ___gethex
  00139	8b f8		 mov	 edi, eax
  0013b	83 c4 18	 add	 esp, 24			; 00000018H
  0013e	8b cf		 mov	 ecx, edi
  00140	83 e1 07	 and	 ecx, 7
  00143	0f 84 76 0c 00
	00		 je	 $LN275@strtod_l
  00149	83 f9 06	 cmp	 ecx, 6
  0014c	0f 84 1d 03 00
	00		 je	 $LN178@strtod_l

; 190  : 					case STRTOG_NoNumber:
; 191  : 						s = s00;
; 192  : 						sign = 0;
; 193  : 						/* FALLTHROUGH */
; 194  : 					case STRTOG_Zero:
; 195  : 						break;
; 196  : 					default:
; 197  : 						if (bb) {

  00152	8b 4d f0	 mov	 ecx, DWORD PTR _bb$[ebp]
  00155	85 c9		 test	 ecx, ecx
  00157	74 17		 je	 SHORT $LN175@strtod_l

; 198  : 							copybits(bits, fpi.nbits, bb);

  00159	51		 push	 ecx
  0015a	8d 45 80	 lea	 eax, DWORD PTR _bits$1[ebp]
  0015d	6a 35		 push	 53			; 00000035H
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 ___copybits

; 199  : 							Bfree(bb);

  00165	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  00168	e8 00 00 00 00	 call	 __Bfree
  0016d	83 c4 10	 add	 esp, 16			; 00000010H
$LN175@strtod_l:

; 200  : 						}
; 201  : 						ULtod(rv.i, bits, exp, i);

  00170	57		 push	 edi
  00171	ff 75 d4	 push	 DWORD PTR _exp$3[ebp]
  00174	8d 45 80	 lea	 eax, DWORD PTR _bits$1[ebp]
  00177	50		 push	 eax
  00178	8d 45 a0	 lea	 eax, DWORD PTR _rv$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _ULtod
  00181	83 c4 10	 add	 esp, 16			; 00000010H
$LN276@strtod_l:
  00184	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00187	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
  0018a	e9 36 0c 00 00	 jmp	 $LN325@strtod_l
$LN168@strtod_l:

; 218  : 			z = 10 * z + c - '0';

  0018f	8d 43 fa	 lea	 eax, DWORD PTR [ebx-6]
  00192	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00195	8d 1c 41	 lea	 ebx, DWORD PTR [ecx+eax*2]
  00198	8b 45 f8	 mov	 eax, DWORD PTR _y$1$[ebp]
$LN170@strtod_l:

; 214  : 	for (nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)

  0019b	46		 inc	 esi
  0019c	47		 inc	 edi
  0019d	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  001a0	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  001a3	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001a6	0f 8d 58 ff ff
	ff		 jge	 $LL171@strtod_l
$LN277@strtod_l:
  001ac	89 4d d8	 mov	 DWORD PTR _c$1$[ebp], ecx
  001af	89 5d c8	 mov	 DWORD PTR _z$1$[ebp], ebx
$LN169@strtod_l:

; 219  : 	nd0 = nd;
; 220  : 	if (strncmp(s, lconv->decimal_point, dec_len) == 0)

  001b2	8b 45 e0	 mov	 eax, DWORD PTR _lconv$1$[ebp]
  001b5	52		 push	 edx
  001b6	89 7d cc	 mov	 DWORD PTR _nd0$2$[ebp], edi
  001b9	ff 30		 push	 DWORD PTR [eax]
  001bb	56		 push	 esi
  001bc	e8 00 00 00 00	 call	 _strncmp

; 221  : 	{
; 222  : 		decpt = 1;
; 223  : 		c = *(s += dec_len);

  001c1	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c7	85 c0		 test	 eax, eax
  001c9	0f 85 d7 00 00
	00		 jne	 $LN265@strtod_l
  001cf	03 75 b4	 add	 esi, DWORD PTR _dec_len$1$[ebp]
  001d2	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  001d5	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _decpt$1$[ebp], 1
  001dc	89 75 e0	 mov	 DWORD PTR _s$1$[ebp], esi
  001df	0f be 0e	 movsx	 ecx, BYTE PTR [esi]

; 224  : 		if (!nd) {

  001e2	85 ff		 test	 edi, edi
  001e4	75 3f		 jne	 SHORT $LN294@strtod_l

; 225  : 			for (; c == '0'; c = *++s)

  001e6	33 d2		 xor	 edx, edx
  001e8	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001eb	75 1f		 jne	 SHORT $LN162@strtod_l
  001ed	8d 49 00	 npad	 3
$LL164@strtod_l:
  001f0	46		 inc	 esi

; 226  : 				nz++;

  001f1	42		 inc	 edx
  001f2	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  001f5	0f be 1e	 movsx	 ebx, BYTE PTR [esi]
  001f8	89 5d d8	 mov	 DWORD PTR _c$1$[ebp], ebx
  001fb	83 fb 30	 cmp	 ebx, 48			; 00000030H
  001fe	74 f0		 je	 SHORT $LL164@strtod_l
  00200	8b 5d c8	 mov	 ebx, DWORD PTR _z$1$[ebp]
  00203	8b 4d d8	 mov	 ecx, DWORD PTR _c$1$[ebp]
  00206	89 55 ec	 mov	 DWORD PTR _nz$1$[ebp], edx
  00209	89 75 e0	 mov	 DWORD PTR _s$1$[ebp], esi
$LN162@strtod_l:

; 227  : 			if (c > '0' && c <= '9') {

  0020c	8d 41 cf	 lea	 eax, DWORD PTR [ecx-49]
  0020f	83 f8 08	 cmp	 eax, 8
  00212	0f 87 91 00 00
	00		 ja	 $LN293@strtod_l

; 228  : 				s0 = s;
; 229  : 				nf += nz;

  00218	89 55 d4	 mov	 DWORD PTR _nf$1$[ebp], edx

; 230  : 				nz = 0;

  0021b	33 c0		 xor	 eax, eax

; 231  : 				goto have_dig;

  0021d	8b 55 f8	 mov	 edx, DWORD PTR _y$1$[ebp]
  00220	89 75 bc	 mov	 DWORD PTR _s0$1$[ebp], esi
  00223	eb 0e		 jmp	 SHORT $have_dig$463
$LN294@strtod_l:
  00225	8b 55 f8	 mov	 edx, DWORD PTR _y$1$[ebp]
$LN165@strtod_l:

; 232  : 			}
; 233  : 			goto dig_done;
; 234  : 		}
; 235  : 		for (; c >= '0' && c <= '9'; c = *++s) {

  00228	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  0022b	83 f8 09	 cmp	 eax, 9
  0022e	77 7c		 ja	 SHORT $dig_done$464
  00230	8b 45 ec	 mov	 eax, DWORD PTR _nz$1$[ebp]
$have_dig$463:

; 236  : 		have_dig:
; 237  : 			nz++;

  00233	40		 inc	 eax
  00234	89 45 ec	 mov	 DWORD PTR _nz$1$[ebp], eax

; 238  : 			if (c -= '0') {

  00237	83 e9 30	 sub	 ecx, 48			; 00000030H
  0023a	74 5e		 je	 SHORT $LN159@strtod_l

; 239  : 				nf += nz;

  0023c	01 45 d4	 add	 DWORD PTR _nf$1$[ebp], eax

; 240  : 				for (i = 1; i < nz; i++)

  0023f	83 f8 01	 cmp	 eax, 1
  00242	7e 31		 jle	 SHORT $LN154@strtod_l

; 239  : 				nf += nz;

  00244	8b 75 f8	 mov	 esi, DWORD PTR _y$1$[ebp]
  00247	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0024a	8d 9b 00 00 00
	00		 npad	 6
$LL156@strtod_l:

; 241  : 					if (nd++ < 9)

  00250	8b c7		 mov	 eax, edi
  00252	47		 inc	 edi
  00253	83 f8 09	 cmp	 eax, 9
  00256	7d 07		 jge	 SHORT $LN153@strtod_l

; 242  : 						y *= 10;

  00258	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  0025b	03 f6		 add	 esi, esi
  0025d	eb 0a		 jmp	 SHORT $LN155@strtod_l
$LN153@strtod_l:

; 243  : 					else if (nd <= DBL_DIG + 1)

  0025f	83 ff 10	 cmp	 edi, 16			; 00000010H
  00262	7f 05		 jg	 SHORT $LN155@strtod_l

; 244  : 						z *= 10;

  00264	8d 1c 9b	 lea	 ebx, DWORD PTR [ebx+ebx*4]
  00267	03 db		 add	 ebx, ebx
$LN155@strtod_l:

; 240  : 				for (i = 1; i < nz; i++)

  00269	4a		 dec	 edx
  0026a	75 e4		 jne	 SHORT $LL156@strtod_l
  0026c	89 75 f8	 mov	 DWORD PTR _y$1$[ebp], esi
  0026f	8b 75 e0	 mov	 esi, DWORD PTR _s$1$[ebp]
  00272	8b 55 f8	 mov	 edx, DWORD PTR _y$1$[ebp]
$LN154@strtod_l:

; 245  : 				if (nd++ < 9)

  00275	8b c7		 mov	 eax, edi
  00277	47		 inc	 edi
  00278	83 f8 09	 cmp	 eax, 9
  0027b	7d 0b		 jge	 SHORT $LN150@strtod_l

; 246  : 					y = 10 * y + c;

  0027d	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00280	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00283	89 55 f8	 mov	 DWORD PTR _y$1$[ebp], edx
  00286	eb 0b		 jmp	 SHORT $LN148@strtod_l
$LN150@strtod_l:

; 247  : 				else if (nd <= DBL_DIG + 1)

  00288	83 ff 10	 cmp	 edi, 16			; 00000010H
  0028b	7f 06		 jg	 SHORT $LN148@strtod_l

; 248  : 					z = 10 * z + c;

  0028d	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  00290	8d 1c 41	 lea	 ebx, DWORD PTR [ecx+eax*2]
$LN148@strtod_l:

; 249  : 				nz = 0;

  00293	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _nz$1$[ebp], 0
$LN159@strtod_l:

; 232  : 			}
; 233  : 			goto dig_done;
; 234  : 		}
; 235  : 		for (; c >= '0' && c <= '9'; c = *++s) {

  0029a	46		 inc	 esi
  0029b	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  0029e	89 75 e0	 mov	 DWORD PTR _s$1$[ebp], esi
  002a1	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  002a4	eb 82		 jmp	 SHORT $LN165@strtod_l
$LN265@strtod_l:
  002a6	8b 4d d8	 mov	 ecx, DWORD PTR _c$1$[ebp]
$LN293@strtod_l:
  002a9	8b 55 f8	 mov	 edx, DWORD PTR _y$1$[ebp]
$dig_done$464:

; 250  : 			}
; 251  : 		}
; 252  : 	}
; 253  : dig_done:
; 254  : 	e = 0;

  002ac	33 c0		 xor	 eax, eax

; 255  : 	if (c == 'e' || c == 'E') {

  002ae	83 f9 65	 cmp	 ecx, 101		; 00000065H
  002b1	74 09		 je	 SHORT $LN146@strtod_l
  002b3	83 f9 45	 cmp	 ecx, 69			; 00000045H
  002b6	0f 85 bf 00 00
	00		 jne	 $LN129@strtod_l
$LN146@strtod_l:

; 256  : 		if (!nd && !nz && !nz0) {

  002bc	85 ff		 test	 edi, edi
  002be	75 0e		 jne	 SHORT $LN145@strtod_l
  002c0	39 45 ec	 cmp	 DWORD PTR _nz$1$[ebp], eax
  002c3	75 09		 jne	 SHORT $LN145@strtod_l
  002c5	39 45 d0	 cmp	 DWORD PTR _nz0$1$[ebp], eax
  002c8	0f 84 9e 01 00
	00		 je	 $ret0$462
$LN145@strtod_l:

; 257  : 			goto ret0;
; 258  : 		}
; 259  : 		s00 = s;

  002ce	89 75 08	 mov	 DWORD PTR _s00$[ebp], esi

; 260  : 		esign = 0;
; 261  : 		switch (c = *++s) {

  002d1	46		 inc	 esi
  002d2	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  002d5	89 45 c8	 mov	 DWORD PTR _esign$1$[ebp], eax
  002d8	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  002db	8b c1		 mov	 eax, ecx
  002dd	83 e8 2b	 sub	 eax, 43			; 0000002bH
  002e0	74 0c		 je	 SHORT $LN141@strtod_l
  002e2	83 e8 02	 sub	 eax, 2
  002e5	75 0e		 jne	 SHORT $LN143@strtod_l

; 262  : 		case '-':
; 263  : 			esign = 1;

  002e7	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _esign$1$[ebp], 1
$LN141@strtod_l:

; 264  : 		case '+':
; 265  : 			c = *++s;

  002ee	46		 inc	 esi
  002ef	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  002f2	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
$LN143@strtod_l:

; 266  : 		}
; 267  : 		if (c >= '0' && c <= '9') {

  002f5	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  002f8	83 f8 09	 cmp	 eax, 9
  002fb	77 76		 ja	 SHORT $LN140@strtod_l

; 268  : 			while (c == '0')

  002fd	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00300	75 0c		 jne	 SHORT $LN138@strtod_l
$LL139@strtod_l:

; 269  : 				c = *++s;

  00302	46		 inc	 esi
  00303	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  00306	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00309	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0030c	74 f4		 je	 SHORT $LL139@strtod_l
$LN138@strtod_l:

; 270  : 			if (c > '0' && c <= '9') {

  0030e	8d 41 cf	 lea	 eax, DWORD PTR [ecx-49]
  00311	83 f8 08	 cmp	 eax, 8
  00314	77 63		 ja	 SHORT $LN137@strtod_l

; 271  : 				L = c - '0';
; 272  : 				s1 = s;

  00316	89 75 b4	 mov	 DWORD PTR _s1$1$[ebp], esi
  00319	83 c1 d0	 add	 ecx, -48		; ffffffd0H

; 273  : 				while ((c = *++s) >= '0' && c <= '9')

  0031c	46		 inc	 esi
  0031d	89 4d e0	 mov	 DWORD PTR _e$1$[ebp], ecx
  00320	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  00323	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00326	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00329	7c 25		 jl	 SHORT $LN135@strtod_l
  0032b	8b 55 e0	 mov	 edx, DWORD PTR _e$1$[ebp]
  0032e	8b ff		 npad	 2
$LL136@strtod_l:
  00330	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00333	7f 15		 jg	 SHORT $LN278@strtod_l
  00335	46		 inc	 esi

; 274  : 					L = 10 * L + c - '0';

  00336	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00339	8d 52 e8	 lea	 edx, DWORD PTR [edx-24]
  0033c	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  0033f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00342	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00345	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00348	7d e6		 jge	 SHORT $LL136@strtod_l
$LN278@strtod_l:
  0034a	89 55 e0	 mov	 DWORD PTR _e$1$[ebp], edx
  0034d	8b 55 f8	 mov	 edx, DWORD PTR _y$1$[ebp]
$LN135@strtod_l:

; 275  : 				if (s - s1 > 8 || L > 19999)

  00350	8b c6		 mov	 eax, esi
  00352	2b 45 b4	 sub	 eax, DWORD PTR _s1$1$[ebp]
  00355	83 f8 08	 cmp	 eax, 8
  00358	7f 0a		 jg	 SHORT $LN133@strtod_l
  0035a	8b 45 e0	 mov	 eax, DWORD PTR _e$1$[ebp]
  0035d	3d 1f 4e 00 00	 cmp	 eax, 19999		; 00004e1fH
  00362	7e 05		 jle	 SHORT $LN132@strtod_l
$LN133@strtod_l:

; 276  : 					/* Avoid confusion from exponents
; 277  : 					* so large that e might overflow.
; 278  : 					*/
; 279  : 					e = 19999; /* safe for 16 bit ints */

  00364	b8 1f 4e 00 00	 mov	 eax, 19999		; 00004e1fH
$LN132@strtod_l:

; 280  : 				else
; 281  : 					e = (int)L;
; 282  : 				if (esign)

  00369	83 7d c8 00	 cmp	 DWORD PTR _esign$1$[ebp], 0
  0036d	74 0c		 je	 SHORT $LN129@strtod_l

; 283  : 					e = -e;

  0036f	f7 d8		 neg	 eax

; 284  : 			}
; 285  : 			else

  00371	eb 08		 jmp	 SHORT $LN129@strtod_l
$LN140@strtod_l:

; 286  : 				e = 0;
; 287  : 		}
; 288  : 		else
; 289  : 			s = s00;

  00373	8b 75 08	 mov	 esi, DWORD PTR _s00$[ebp]
  00376	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
$LN137@strtod_l:
  00379	33 c0		 xor	 eax, eax
$LN129@strtod_l:

; 290  : 	}
; 291  : 	if (!nd) {

  0037b	85 ff		 test	 edi, edi
  0037d	0f 85 f6 00 00
	00		 jne	 $LN128@strtod_l

; 292  : 		if (!nz && !nz0) {

  00383	39 7d ec	 cmp	 DWORD PTR _nz$1$[ebp], edi
  00386	0f 85 36 0a 00
	00		 jne	 $LN289@strtod_l
  0038c	39 7d d0	 cmp	 DWORD PTR _nz0$1$[ebp], edi
  0038f	0f 85 2d 0a 00
	00		 jne	 $LN289@strtod_l

; 293  : #ifdef INFNAN_CHECK
; 294  : 			/* Check for Nan and Infinity */
; 295  : 			unsigned long bits[2];
; 296  : 			static const FPI fpinan =	/* only 52 explicit bits */
; 297  : 			{ 52, 1 - 1023 - 53 + 1, 2046 - 1023 - 53 + 1, 1, SI };
; 298  : 			if (!decpt)

  00395	39 7d c4	 cmp	 DWORD PTR _decpt$1$[ebp], edi
  00398	0f 85 ce 00 00
	00		 jne	 $ret0$462

; 299  : 				switch (c) {

  0039e	83 c1 b7	 add	 ecx, -73		; ffffffb7H
  003a1	83 f9 25	 cmp	 ecx, 37			; 00000025H
  003a4	0f 87 c2 00 00
	00		 ja	 $ret0$462
  003aa	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR $LN264@strtod_l[ecx]
  003b1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN460@strtod_l[eax*4]
$LN123@strtod_l:

; 300  : 				case 'i':
; 301  : 				case 'I':
; 302  : 					if (match(&s, "nf")) {

  003b8	8d 45 fc	 lea	 eax, DWORD PTR _s$[ebp]
  003bb	68 00 00 00 00	 push	 OFFSET ??_C@_02HBFAAMOG@nf?$AA@
  003c0	50		 push	 eax
  003c1	e8 00 00 00 00	 call	 ___match
  003c6	83 c4 08	 add	 esp, 8
  003c9	85 c0		 test	 eax, eax
  003cb	0f 84 9b 00 00
	00		 je	 $ret0$462

; 303  : 						--s;

  003d1	ff 4d fc	 dec	 DWORD PTR _s$[ebp]

; 304  : 						if (!match(&s, "inity"))

  003d4	8d 45 fc	 lea	 eax, DWORD PTR _s$[ebp]
  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_05KMOPHDFI@inity?$AA@
  003dc	50		 push	 eax
  003dd	e8 00 00 00 00	 call	 ___match

; 305  : 							++s;

  003e2	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
  003e5	83 c4 08	 add	 esp, 8
  003e8	85 c0		 test	 eax, eax
  003ea	75 01		 jne	 SHORT $LN121@strtod_l
  003ec	46		 inc	 esi
$LN121@strtod_l:

; 306  : 						dword0(rv) = 0x7ff00000;

  003ed	c7 45 a4 00 00
	f0 7f		 mov	 DWORD PTR _rv$[ebp+4], 2146435072 ; 7ff00000H

; 307  : #ifndef _DOUBLE_IS_32BITS
; 308  : 						dword1(rv) = 0;

  003f4	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _rv$[ebp], 0

; 309  : #endif /*!_DOUBLE_IS_32BITS*/
; 310  : 						goto ret;

  003fb	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  003fe	e9 c2 09 00 00	 jmp	 $LN325@strtod_l
$LN120@strtod_l:

; 311  : 					}
; 312  : 					break;
; 313  : 				case 'n':
; 314  : 				case 'N':
; 315  : 					if (match(&s, "an")) {

  00403	8d 45 fc	 lea	 eax, DWORD PTR _s$[ebp]
  00406	68 00 00 00 00	 push	 OFFSET ??_C@_02LCNFMBND@an?$AA@
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 ___match
  00411	83 c4 08	 add	 esp, 8
  00414	85 c0		 test	 eax, eax
  00416	74 54		 je	 SHORT $ret0$462

; 316  : #ifndef No_Hex_NaN
; 317  : 						if (*s == '(' /*)*/
; 318  : 							&& hexnan(&s, &fpinan, bits)
; 319  : 							== STRTOG_NaNbits) {

  00418	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
  0041b	80 3e 28	 cmp	 BYTE PTR [esi], 40	; 00000028H
  0041e	75 36		 jne	 SHORT $LN118@strtod_l
  00420	8d 45 88	 lea	 eax, DWORD PTR _bits$2[ebp]
  00423	50		 push	 eax
  00424	8d 45 fc	 lea	 eax, DWORD PTR _s$[ebp]
  00427	68 00 00 00 00	 push	 OFFSET ?fpinan@?BK@??_strtod_l@@9@9
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 ___hexnan

; 323  : #endif /*!_DOUBLE_IS_32BITS*/
; 324  : 						}
; 325  : 						else {

  00432	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
  00435	83 c4 0c	 add	 esp, 12			; 0000000cH
  00438	83 f8 05	 cmp	 eax, 5
  0043b	75 19		 jne	 SHORT $LN118@strtod_l

; 320  : 							dword0(rv) = 0x7ff00000 | bits[1];

  0043d	8b 45 8c	 mov	 eax, DWORD PTR _bits$2[ebp+4]
  00440	0d 00 00 f0 7f	 or	 eax, 2146435072		; 7ff00000H
  00445	89 45 a4	 mov	 DWORD PTR _rv$[ebp+4], eax

; 321  : #ifndef _DOUBLE_IS_32BITS
; 322  : 							dword1(rv) = bits[0];

  00448	8b 45 88	 mov	 eax, DWORD PTR _bits$2[ebp]
  0044b	89 45 a0	 mov	 DWORD PTR _rv$[ebp], eax

; 323  : #endif /*!_DOUBLE_IS_32BITS*/
; 324  : 						}
; 325  : 						else {

  0044e	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00451	e9 6f 09 00 00	 jmp	 $LN325@strtod_l
$LN118@strtod_l:

; 326  : #endif
; 327  : 							dword0(rv) = NAN_WORD0;

  00456	c7 45 a4 00 00
	f8 ff		 mov	 DWORD PTR _rv$[ebp+4], -524288 ; fff80000H

; 328  : #ifndef _DOUBLE_IS_32BITS
; 329  : 							dword1(rv) = NAN_WORD1;

  0045d	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _rv$[ebp], 0

; 330  : #endif /*!_DOUBLE_IS_32BITS*/
; 331  : #ifndef No_Hex_NaN
; 332  : 						}
; 333  : #endif
; 334  : 						goto ret;

  00464	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00467	e9 59 09 00 00	 jmp	 $LN325@strtod_l
$ret0$462:

; 335  : 					}
; 336  : 			}
; 337  : #endif /* INFNAN_CHECK */
; 338  : 		ret0:
; 339  : 			s = s00;

  0046c	8b 75 08	 mov	 esi, DWORD PTR _s00$[ebp]
$LN178@strtod_l:

; 340  : 			sign = 0;
; 341  : 		}
; 342  : 		goto ret;

  0046f	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
  00472	33 c9		 xor	 ecx, ecx
  00474	e9 4f 09 00 00	 jmp	 $ret$465
$LN128@strtod_l:

; 343  : 	}
; 344  : 	e1 = e -= nf;

  00479	2b 45 d4	 sub	 eax, DWORD PTR _nf$1$[ebp]
  0047c	89 45 e0	 mov	 DWORD PTR _e$1$[ebp], eax

; 345  : 
; 346  : 	/* Now we have nd0 digits, starting at s0, followed by a
; 347  : 	* decimal point, followed by nd-nd0 digits.  The number we're
; 348  : 	* after is the integer represented by those digits times
; 349  : 	* 10**e */
; 350  : 
; 351  : 	if (!nd0)

  0047f	8b 45 cc	 mov	 eax, DWORD PTR _nd0$2$[ebp]
  00482	85 c0		 test	 eax, eax

; 352  : 		nd0 = nd;
; 353  : 	k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
; 354  : 	dval(rv) = y;

  00484	89 55 b4	 mov	 DWORD PTR tv1508[ebp], edx
  00487	db 45 b4	 fild	 DWORD PTR tv1508[ebp]
  0048a	0f 44 c7	 cmove	 eax, edi
  0048d	89 45 cc	 mov	 DWORD PTR _nd0$2$[ebp], eax
  00490	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00495	3b f8		 cmp	 edi, eax
  00497	0f 4c c7	 cmovl	 eax, edi
  0049a	89 45 08	 mov	 DWORD PTR _k$1$[ebp], eax
  0049d	85 d2		 test	 edx, edx
  0049f	79 06		 jns	 SHORT $LN446@strtod_l
  004a1	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN446@strtod_l:
  004a7	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  004aa	dd 55 a0	 fst	 QWORD PTR _rv$[ebp]

; 355  : 	if (k > 9) {

  004ad	83 f8 09	 cmp	 eax, 9
  004b0	7e 26		 jle	 SHORT $LN115@strtod_l

; 356  : #ifdef SET_INEXACT
; 357  : 		if (k > DBL_DIG)
; 358  : 			oldinexact = get_inexact();
; 359  : #endif
; 360  : 		dval(rv) = tens[k - 9] * dval(rv) + z;

  004b2	dc 0c c5 b8 ff
	ff ff		 fmul	 QWORD PTR ___mprec_tens[eax*8-72]
  004b9	89 5d b4	 mov	 DWORD PTR tv1505[ebp], ebx
  004bc	db 45 b4	 fild	 DWORD PTR tv1505[ebp]
  004bf	85 db		 test	 ebx, ebx
  004c1	79 06		 jns	 SHORT $LN447@strtod_l
  004c3	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN447@strtod_l:
  004c9	dd 5d 98	 fstp	 QWORD PTR tv1504[ebp]
  004cc	dc 45 98	 fadd	 QWORD PTR tv1504[ebp]
  004cf	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
  004d2	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  004d5	dd 55 a0	 fst	 QWORD PTR _rv$[ebp]
$LN115@strtod_l:

; 361  : 	}
; 362  : 	bd0 = 0;
; 363  : 	if (nd <= DBL_DIG
; 364  : #ifndef RND_PRODQUOT
; 365  : #ifndef Honor_FLT_ROUNDS
; 366  : 		&& Flt_Rounds == 1
; 367  : #endif
; 368  : #endif
; 369  : 		) {
; 370  : 		if (!e)

  004d8	8b 5d e0	 mov	 ebx, DWORD PTR _e$1$[ebp]
  004db	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bd0$1$[ebp], 0
  004e2	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  004e5	7f 58		 jg	 SHORT $LN108@strtod_l
  004e7	85 db		 test	 ebx, ebx
  004e9	0f 84 d6 08 00
	00		 je	 $LN325@strtod_l

; 371  : 			goto ret;
; 372  : 		if (e > 0) {

  004ef	7e 34		 jle	 SHORT $LN112@strtod_l

; 373  : 			if (e <= Ten_pmax) {

  004f1	83 fb 16	 cmp	 ebx, 22			; 00000016H
  004f4	7f 0c		 jg	 SHORT $LN111@strtod_l

; 374  : #ifdef VAX
; 375  : 				goto vax_ovfl_check;
; 376  : #else
; 377  : #ifdef Honor_FLT_ROUNDS
; 378  : 				/* round correctly FLT_ROUNDS = 2 or 3 */
; 379  : 				if (sign) {
; 380  : 					dval(rv) = -dval(rv);
; 381  : 					sign = 0;
; 382  : 				}
; 383  : #endif
; 384  : 				/* rv = */ rounded_product(dval(rv), tens[e]);

  004f6	dc 0c dd 00 00
	00 00		 fmul	 QWORD PTR ___mprec_tens[ebx*8]

; 385  : 				goto ret;

  004fd	e9 c3 08 00 00	 jmp	 $LN325@strtod_l
$LN111@strtod_l:

; 386  : #endif
; 387  : 			}
; 388  : 			i = DBL_DIG - nd;

  00502	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00507	2b cf		 sub	 ecx, edi

; 389  : 			if (e <= Ten_pmax + i) {

  00509	8d 41 16	 lea	 eax, DWORD PTR [ecx+22]
  0050c	3b d8		 cmp	 ebx, eax
  0050e	7f 2f		 jg	 SHORT $LN108@strtod_l

; 390  : 				/* A fancier test would sometimes let us do
; 391  : 				* this for larger i values.
; 392  : 				*/
; 393  : #ifdef Honor_FLT_ROUNDS
; 394  : 				/* round correctly FLT_ROUNDS = 2 or 3 */
; 395  : 				if (sign) {
; 396  : 					dval(rv) = -dval(rv);
; 397  : 					sign = 0;
; 398  : 				}
; 399  : #endif
; 400  : 				e -= i;
; 401  : 				dval(rv) *= tens[i];

  00510	dc 0c cd 00 00
	00 00		 fmul	 QWORD PTR ___mprec_tens[ecx*8]

; 402  : #ifdef VAX
; 403  : 				/* VAX exponent range is so narrow we must
; 404  : 				* worry about overflow here...
; 405  : 				*/
; 406  : 			vax_ovfl_check :
; 407  : 				dword0(rv) -= P*Exp_msk1;
; 408  : 				/* rv = */ rounded_product(dval(rv), tens[e]);
; 409  : 				if ((dword0(rv) & Exp_mask)
; 410  : 				 > Exp_msk1*(DBL_MAX_EXP + Bias - 1 - P))
; 411  : 				 goto ovfl;
; 412  : 				dword0(rv) += P*Exp_msk1;
; 413  : #else
; 414  : 				/* rv = */ rounded_product(dval(rv), tens[e]);

  00517	2b d9		 sub	 ebx, ecx
  00519	dc 0c dd 00 00
	00 00		 fmul	 QWORD PTR ___mprec_tens[ebx*8]

; 415  : #endif
; 416  : 				goto ret;

  00520	e9 a0 08 00 00	 jmp	 $LN325@strtod_l
$LN112@strtod_l:

; 417  : 			}
; 418  : 		}
; 419  : #ifndef Inaccurate_Divide
; 420  : 		else if (e >= -Ten_pmax) {

  00525	83 fb ea	 cmp	 ebx, -22		; ffffffeaH
  00528	7c 15		 jl	 SHORT $LN108@strtod_l

; 421  : #ifdef Honor_FLT_ROUNDS
; 422  : 			/* round correctly FLT_ROUNDS = 2 or 3 */
; 423  : 			if (sign) {
; 424  : 				dval(rv) = -dval(rv);
; 425  : 				sign = 0;
; 426  : 			}
; 427  : #endif
; 428  : 			/* rv = */ rounded_quotient(dval(rv), tens[-e]);

  0052a	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
  00531	b9 00 00 00 00	 mov	 ecx, OFFSET ___mprec_tens
  00536	2b c8		 sub	 ecx, eax
  00538	dc 31		 fdiv	 QWORD PTR [ecx]

; 429  : 			goto ret;

  0053a	e9 86 08 00 00	 jmp	 $LN325@strtod_l
$LN108@strtod_l:

; 430  : 		}
; 431  : #endif
; 432  : 	}
; 433  : 	e1 += nd - k;

  0053f	8b c3		 mov	 eax, ebx

; 434  : 
; 435  : #ifdef IEEE_Arith
; 436  : #ifdef SET_INEXACT
; 437  : 	inexact = 1;
; 438  : 	if (k <= DBL_DIG)
; 439  : 		oldinexact = get_inexact();
; 440  : #endif
; 441  : #ifdef Avoid_Underflow
; 442  : 	scale = 0;

  00541	33 db		 xor	 ebx, ebx
  00543	2b 45 08	 sub	 eax, DWORD PTR _k$1$[ebp]
  00546	03 c7		 add	 eax, edi
  00548	89 5d ec	 mov	 DWORD PTR _scale$1$[ebp], ebx

; 443  : #endif
; 444  : #ifdef Honor_FLT_ROUNDS
; 445  : 	if ((rounding = Flt_Rounds) >= 2) {
; 446  : 		if (sign)
; 447  : 			rounding = rounding == 2 ? 0 : 2;
; 448  : 		else
; 449  : 			if (rounding != 2)
; 450  : 				rounding = 0;
; 451  : 	}
; 452  : #endif
; 453  : #endif /*IEEE_Arith*/
; 454  : 
; 455  : 	/* Get starting approximation = rv * 10**e1 */
; 456  : 
; 457  : 	if (e1 > 0) {

  0054b	85 c0		 test	 eax, eax
  0054d	0f 8e a7 00 00
	00		 jle	 $LN449@strtod_l

; 458  : 		if ((i = e1 & 15) != 0)

  00553	8b c8		 mov	 ecx, eax
  00555	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00558	74 0d		 je	 SHORT $LN106@strtod_l

; 459  : 			dval(rv) *= tens[i];

  0055a	dc 0c cd 00 00
	00 00		 fmul	 QWORD PTR ___mprec_tens[ecx*8]
  00561	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00564	dd 55 a0	 fst	 QWORD PTR _rv$[ebp]
$LN106@strtod_l:

; 460  : 		if (e1 &= ~15) {

  00567	83 e0 f0	 and	 eax, -16		; fffffff0H
  0056a	0f 84 68 01 00
	00		 je	 $LN376@strtod_l

; 461  : 			if (e1 > DBL_MAX_10_EXP) {

  00570	3d 34 01 00 00	 cmp	 eax, 308		; 00000134H
  00575	0f 8f dc 07 00
	00		 jg	 $LN361@strtod_l

; 501  : 					goto retfree;
; 502  : 				goto ret;
; 503  : 			}
; 504  : 			e1 >>= 4;

  0057b	c1 f8 04	 sar	 eax, 4

; 505  : 			for (j = 0; e1 > 1; j++, e1 >>= 1)

  0057e	33 c9		 xor	 ecx, ecx
  00580	83 f8 01	 cmp	 eax, 1
  00583	7e 16		 jle	 SHORT $LN368@strtod_l
$LN102@strtod_l:

; 506  : 				if (e1 & 1)

  00585	a8 01		 test	 al, 1
  00587	74 0a		 je	 SHORT $LN101@strtod_l

; 507  : 					dval(rv) *= bigtens[j];

  00589	dc 0c cd 00 00
	00 00		 fmul	 QWORD PTR ___mprec_bigtens[ecx*8]
  00590	dd 55 a0	 fst	 QWORD PTR _rv$[ebp]
$LN101@strtod_l:

; 505  : 			for (j = 0; e1 > 1; j++, e1 >>= 1)

  00593	d1 f8		 sar	 eax, 1
  00595	41		 inc	 ecx
  00596	83 f8 01	 cmp	 eax, 1
  00599	7f ea		 jg	 SHORT $LN102@strtod_l
$LN368@strtod_l:

; 508  : 			/* The last multiplication could overflow. */
; 509  : 			dword0(rv) -= P*Exp_msk1;

  0059b	81 6d a4 00 00
	50 03		 sub	 DWORD PTR _rv$[ebp+4], 55574528 ; 03500000H
  005a2	dd d8		 fstp	 ST(0)

; 510  : 			dval(rv) *= bigtens[j];

  005a4	dd 04 cd 00 00
	00 00		 fld	 QWORD PTR ___mprec_bigtens[ecx*8]
  005ab	dc 4d a0	 fmul	 QWORD PTR _rv$[ebp]
  005ae	dd 5d a0	 fstp	 QWORD PTR _rv$[ebp]

; 511  : 			if ((z = dword0(rv) & Exp_mask)
; 512  : 			 > Exp_msk1*(DBL_MAX_EXP + Bias - P))

  005b1	8b 75 a4	 mov	 esi, DWORD PTR _rv$[ebp+4]
  005b4	8b c6		 mov	 eax, esi
  005b6	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  005bb	3d 00 00 a0 7c	 cmp	 eax, 2090860544		; 7ca00000H
  005c0	0f 87 93 07 00
	00		 ja	 $LN321@strtod_l

; 513  : 			 goto ovfl;
; 514  : 			if (z > Exp_msk1*(DBL_MAX_EXP + Bias - 1 - P)) {

  005c6	3d 00 00 90 7c	 cmp	 eax, 2089811968		; 7c900000H
  005cb	76 19		 jbe	 SHORT $LN97@strtod_l

; 515  : 				/* set to largest number */
; 516  : 				/* (Can't trust DBL_MAX) */
; 517  : 				dword0(rv) = Big0;

  005cd	be ff ff ef 7f	 mov	 esi, 2146435071		; 7fefffffH

; 518  : #ifndef _DOUBLE_IS_32BITS
; 519  : 				dword1(rv) = Big1;

  005d2	83 cb ff	 or	 ebx, -1
  005d5	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi
  005d8	89 5d a0	 mov	 DWORD PTR _rv$[ebp], ebx

; 520  : #endif /*!_DOUBLE_IS_32BITS*/
; 521  : 			}
; 522  : 			else

  005db	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  005de	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  005e1	e9 fa 00 00 00	 jmp	 $LN80@strtod_l
$LN97@strtod_l:

; 523  : 				dword0(rv) += P*Exp_msk1;

  005e6	81 c6 00 00 50
	03		 add	 esi, 55574528		; 03500000H
  005ec	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi

; 524  : 		}

  005ef	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  005f2	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  005f5	e9 e3 00 00 00	 jmp	 $LN450@strtod_l
$LN449@strtod_l:

; 525  : 	}
; 526  : 	else if (e1 < 0) {

  005fa	0f 89 d8 00 00
	00		 jns	 $LN376@strtod_l

; 527  : 		e1 = -e1;

  00600	f7 d8		 neg	 eax

; 528  : 		if ((i = e1 & 15) != 0)

  00602	8b c8		 mov	 ecx, eax
  00604	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00607	74 0d		 je	 SHORT $LN93@strtod_l

; 529  : 			dval(rv) /= tens[i];

  00609	dc 34 cd 00 00
	00 00		 fdiv	 QWORD PTR ___mprec_tens[ecx*8]
  00610	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00613	dd 55 a0	 fst	 QWORD PTR _rv$[ebp]
$LN93@strtod_l:

; 530  : 		if (e1 >>= 4) {

  00616	c1 f8 04	 sar	 eax, 4
  00619	85 c0		 test	 eax, eax
  0061b	0f 84 b7 00 00
	00		 je	 $LN376@strtod_l

; 531  : 			if (e1 >= 1 << n_bigtens)

  00621	83 f8 20	 cmp	 eax, 32			; 00000020H
  00624	0f 8d b4 06 00
	00		 jge	 $LN379@strtod_l

; 532  : 				goto undfl;
; 533  : #ifdef Avoid_Underflow
; 534  : 			if (e1 & Scale_Bit)

  0062a	a8 10		 test	 al, 16			; 00000010H
  0062c	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00631	0f 45 d9	 cmovne	 ebx, ecx
  00634	89 5d ec	 mov	 DWORD PTR _scale$1$[ebp], ebx

; 535  : 				scale = 2 * P;
; 536  : 			for (j = 0; e1 > 0; j++, e1 >>= 1)

  00637	85 c0		 test	 eax, eax
  00639	7e 1c		 jle	 SHORT $LN382@strtod_l
  0063b	b9 00 00 00 00	 mov	 ecx, OFFSET _tinytens
$LN89@strtod_l:

; 537  : 				if (e1 & 1)

  00640	a8 01		 test	 al, 1
  00642	74 05		 je	 SHORT $LN88@strtod_l

; 538  : 					dval(rv) *= tinytens[j];

  00644	dc 09		 fmul	 QWORD PTR [ecx]
  00646	dd 55 a0	 fst	 QWORD PTR _rv$[ebp]
$LN88@strtod_l:

; 535  : 				scale = 2 * P;
; 536  : 			for (j = 0; e1 > 0; j++, e1 >>= 1)

  00649	d1 f8		 sar	 eax, 1
  0064b	83 c1 08	 add	 ecx, 8
  0064e	85 c0		 test	 eax, eax
  00650	7f ee		 jg	 SHORT $LN89@strtod_l
  00652	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  00655	eb 02		 jmp	 SHORT $LN87@strtod_l
$LN382@strtod_l:
  00657	dd d8		 fstp	 ST(0)
$LN87@strtod_l:

; 539  : 			if (scale && (j = 2 * P + 1 - ((dword0(rv) & Exp_mask)
; 540  : 				>> Exp_shift)) > 0) {

  00659	8b 75 a4	 mov	 esi, DWORD PTR _rv$[ebp+4]
  0065c	85 db		 test	 ebx, ebx
  0065e	74 5e		 je	 SHORT $LN268@strtod_l
  00660	8b c6		 mov	 eax, esi
  00662	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00667	c1 e8 14	 shr	 eax, 20			; 00000014H
  0066a	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0066f	2b c8		 sub	 ecx, eax
  00671	85 c9		 test	 ecx, ecx
  00673	7e 49		 jle	 SHORT $LN268@strtod_l

; 541  : 				/* scaled rv is denormal; zap j low bits */
; 542  : 				if (j >= 32) {

  00675	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00678	7c 2f		 jl	 SHORT $LN84@strtod_l

; 543  : #ifndef _DOUBLE_IS_32BITS
; 544  : 					dword1(rv) = 0;

  0067a	33 db		 xor	 ebx, ebx
  0067c	89 5d a0	 mov	 DWORD PTR _rv$[ebp], ebx

; 545  : #endif /*!_DOUBLE_IS_32BITS*/
; 546  : 					if (j >= 53)

  0067f	83 f9 35	 cmp	 ecx, 53			; 00000035H
  00682	7c 10		 jl	 SHORT $LN83@strtod_l

; 547  : 						dword0(rv) = (P + 2)*Exp_msk1;

  00684	be 00 00 70 03	 mov	 esi, 57671680		; 03700000H
  00689	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi

; 548  : 					else

  0068c	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  0068f	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00692	eb 30		 jmp	 SHORT $LN81@strtod_l
$LN83@strtod_l:

; 549  : 						dword0(rv) &= 0xffffffff << (j - 32);

  00694	83 c1 e0	 add	 ecx, -32		; ffffffe0H
  00697	83 c8 ff	 or	 eax, -1
  0069a	d3 e0		 shl	 eax, cl
  0069c	23 f0		 and	 esi, eax
  0069e	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi

; 550  : 				}
; 551  : #ifndef _DOUBLE_IS_32BITS
; 552  : 				else

  006a1	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  006a4	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  006a7	eb 1b		 jmp	 SHORT $LN81@strtod_l
$LN84@strtod_l:

; 553  : 					dword1(rv) &= 0xffffffff << j;

  006a9	8b 5d a0	 mov	 ebx, DWORD PTR _rv$[ebp]
  006ac	83 c8 ff	 or	 eax, -1
  006af	d3 e0		 shl	 eax, cl
  006b1	23 d8		 and	 ebx, eax
  006b3	89 5d a0	 mov	 DWORD PTR _rv$[ebp], ebx
  006b6	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  006b9	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  006bc	eb 06		 jmp	 SHORT $LN81@strtod_l
$LN268@strtod_l:
  006be	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
  006c1	8b 5d a0	 mov	 ebx, DWORD PTR _rv$[ebp]
$LN81@strtod_l:

; 554  : #endif /*!_DOUBLE_IS_32BITS*/
; 555  : 			}
; 556  : #else
; 557  : 			for (j = 0; e1 > 1; j++, e1 >>= 1)
; 558  : 				if (e1 & 1)
; 559  : 					dval(rv) *= tinytens[j];
; 560  : 			/* The last multiplication could underflow. */
; 561  : 			dval(rv0) = dval(rv);
; 562  : 			dval(rv) *= tinytens[j];
; 563  : 			if (!dval(rv)) {
; 564  : 				dval(rv) = 2.*dval(rv0);
; 565  : 				dval(rv) *= tinytens[j];
; 566  : #endif
; 567  : 				if (!dval(rv)) {

  006c4	d9 ee		 fldz
  006c6	d9 c9		 fxch	 ST(1)
  006c8	df e9		 fucomip ST(1)
  006ca	dd d8		 fstp	 ST(0)
  006cc	9f		 lahf
  006cd	f6 c4 44	 test	 ah, 68			; 00000044H
  006d0	0f 8b 0a 06 00
	00		 jnp	 $LN454@strtod_l
  006d6	eb 08		 jmp	 SHORT $LN80@strtod_l
$LN376@strtod_l:
  006d8	8b 75 a4	 mov	 esi, DWORD PTR _rv$[ebp+4]
  006db	dd d8		 fstp	 ST(0)
$LN450@strtod_l:
  006dd	8b 5d a0	 mov	 ebx, DWORD PTR _rv$[ebp]
$LN80@strtod_l:

; 576  : 				}
; 577  : #ifndef Avoid_Underflow
; 578  : #ifndef _DOUBLE_IS_32BITS
; 579  : 				dword0(rv) = Tiny0;
; 580  : 				dword1(rv) = Tiny1;
; 581  : #else
; 582  : 				dword0(rv) = Tiny1;
; 583  : #endif /*_DOUBLE_IS_32BITS*/
; 584  : 				/* The refinement below will clean
; 585  : 				* this approximation up.
; 586  : 				*/
; 587  : 			}
; 588  : #endif
; 589  : 		}
; 590  : 	}
; 591  : 
; 592  : 	/* Now the hard part -- adjusting rv to the correct value.*/
; 593  : 
; 594  : 	/* Put digits into bd: true value = bd * 10^e */
; 595  : 
; 596  : 	bd0 = s2b(s0, nd0, nd, y);

  006e0	8b 45 cc	 mov	 eax, DWORD PTR _nd0$2$[ebp]
  006e3	52		 push	 edx
  006e4	57		 push	 edi
  006e5	50		 push	 eax
  006e6	ff 75 bc	 push	 DWORD PTR _s0$1$[ebp]
  006e9	e8 00 00 00 00	 call	 ___s2b
  006ee	83 c4 10	 add	 esp, 16			; 00000010H
  006f1	89 45 f8	 mov	 DWORD PTR _bd0$1$[ebp], eax

; 597  : 	if (bd0 == NULL)

  006f4	85 c0		 test	 eax, eax
  006f6	0f 84 9e 01 00
	00		 je	 $LN308@strtod_l

; 598  : 		goto ovfl;
; 599  : 
; 600  : 	for (;;) {
; 601  : 		bd = Balloc(bd0->_k);

  006fc	ff 70 04	 push	 DWORD PTR [eax+4]
  006ff	e8 00 00 00 00	 call	 __Balloc
  00704	8b d0		 mov	 edx, eax
  00706	83 c4 04	 add	 esp, 4
  00709	89 55 e4	 mov	 DWORD PTR _bd$1$[ebp], edx

; 602  : 		if (bd == NULL)

  0070c	85 d2		 test	 edx, edx
  0070e	0f 84 86 01 00
	00		 je	 $LN308@strtod_l
  00714	8b 45 f8	 mov	 eax, DWORD PTR _bd0$1$[ebp]
  00717	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0071a	eb 07		 jmp	 SHORT $LN77@strtod_l
  0071c	8d 64 24 00	 npad	 4
$LL323@strtod_l:
  00720	8b 45 f8	 mov	 eax, DWORD PTR _bd0$1$[ebp]
$LN77@strtod_l:

; 604  : 		Bcopy(bd, bd0);

  00723	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00726	8d 04 85 08 00
	00 00		 lea	 eax, DWORD PTR [eax*4+8]
  0072d	50		 push	 eax
  0072e	51		 push	 ecx
  0072f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00732	50		 push	 eax
  00733	e8 00 00 00 00	 call	 _memcpy

; 605  : 		bb = d2b(dval(rv), &bbe, &bbbits);	/* rv = bb * 2^bbe */

  00738	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
  0073b	8d 45 a8	 lea	 eax, DWORD PTR _bbbits$[ebp]
  0073e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00741	50		 push	 eax
  00742	8d 45 ac	 lea	 eax, DWORD PTR _bbe$[ebp]
  00745	50		 push	 eax
  00746	83 ec 08	 sub	 esp, 8
  00749	dd 1c 24	 fstp	 QWORD PTR [esp]
  0074c	e8 00 00 00 00	 call	 ___d2b
  00751	83 c4 10	 add	 esp, 16			; 00000010H
  00754	89 45 f0	 mov	 DWORD PTR _bb$[ebp], eax

; 606  : 		if (bb == NULL)

  00757	85 c0		 test	 eax, eax
  00759	0f 84 3b 01 00
	00		 je	 $LN308@strtod_l

; 607  : 			goto ovfl;
; 608  : 		bs = i2b(1);

  0075f	6a 01		 push	 1
  00761	e8 00 00 00 00	 call	 ___i2b
  00766	83 c4 04	 add	 esp, 4
  00769	89 45 e8	 mov	 DWORD PTR _bs$1$[ebp], eax

; 609  : 		if (bs == NULL)

  0076c	85 c0		 test	 eax, eax
  0076e	0f 84 26 01 00
	00		 je	 $LN308@strtod_l

; 610  : 			goto ovfl;
; 611  : 
; 612  : 		if (e >= 0) {

  00774	8b 45 e0	 mov	 eax, DWORD PTR _e$1$[ebp]
  00777	85 c0		 test	 eax, eax
  00779	78 10		 js	 SHORT $LN72@strtod_l

; 613  : 			bb2 = bb5 = 0;

  0077b	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _bb5$1$[ebp], 0
  00782	33 ff		 xor	 edi, edi

; 614  : 			bd2 = bd5 = e;

  00784	89 45 c4	 mov	 DWORD PTR _bd5$1$[ebp], eax
  00787	8b d0		 mov	 edx, eax

; 615  : 		}
; 616  : 		else {

  00789	eb 10		 jmp	 SHORT $LN71@strtod_l
$LN72@strtod_l:

; 617  : 			bb2 = bb5 = -e;

  0078b	f7 d8		 neg	 eax

; 618  : 			bd2 = bd5 = 0;

  0078d	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _bd5$1$[ebp], 0
  00794	89 45 bc	 mov	 DWORD PTR _bb5$1$[ebp], eax
  00797	8b f8		 mov	 edi, eax
  00799	33 d2		 xor	 edx, edx
$LN71@strtod_l:

; 619  : 		}
; 620  : 		if (bbe >= 0)

  0079b	8b 4d ac	 mov	 ecx, DWORD PTR _bbe$[ebp]
  0079e	85 c9		 test	 ecx, ecx
  007a0	78 04		 js	 SHORT $LN70@strtod_l

; 621  : 			bb2 += bbe;

  007a2	03 f9		 add	 edi, ecx

; 622  : 		else

  007a4	eb 02		 jmp	 SHORT $LN69@strtod_l
$LN70@strtod_l:

; 623  : 			bd2 -= bbe;

  007a6	2b d1		 sub	 edx, ecx
$LN69@strtod_l:

; 624  : 		bs2 = bb2;
; 625  : #ifdef Honor_FLT_ROUNDS
; 626  : 		if (rounding != 1)
; 627  : 			bs2++;
; 628  : #endif
; 629  : #ifdef Avoid_Underflow
; 630  : 		Lsb = LSB;
; 631  : 		Lsb1 = 0;
; 632  : 		j = bbe - scale;
; 633  : 		i = j + bbbits - 1;	/* logb(rv) */

  007a8	2b 4d ec	 sub	 ecx, DWORD PTR _scale$1$[ebp]
  007ab	49		 dec	 ecx
  007ac	89 7d cc	 mov	 DWORD PTR _bs2$1$[ebp], edi
  007af	03 4d a8	 add	 ecx, DWORD PTR _bbbits$[ebp]
  007b2	89 4d b4	 mov	 DWORD PTR _i$5$[ebp], ecx

; 634  : 		j = P + 1 - bbbits;

  007b5	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  007ba	2b 4d a8	 sub	 ecx, DWORD PTR _bbbits$[ebp]

; 635  : 		if (i < Emin) {	/* denormal */

  007bd	8b 45 b4	 mov	 eax, DWORD PTR _i$5$[ebp]
  007c0	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _Lsb$1$[ebp], 1
  007c7	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _Lsb1$1$[ebp], 0
  007ce	89 4d 08	 mov	 DWORD PTR _j$3$[ebp], ecx
  007d1	3d 02 fc ff ff	 cmp	 eax, -1022		; fffffc02H
  007d6	7d 26		 jge	 SHORT $LN66@strtod_l

; 636  : 			i = Emin - i;

  007d8	b9 02 fc ff ff	 mov	 ecx, -1022		; fffffc02H
  007dd	2b c8		 sub	 ecx, eax

; 637  : 			j -= i;
; 638  : 			if (i < 32)
; 639  : 				Lsb <<= i;

  007df	b8 01 00 00 00	 mov	 eax, 1
  007e4	29 4d 08	 sub	 DWORD PTR _j$3$[ebp], ecx
  007e7	83 f9 20	 cmp	 ecx, 32			; 00000020H
  007ea	7d 07		 jge	 SHORT $LN67@strtod_l
  007ec	d3 e0		 shl	 eax, cl
  007ee	89 45 d0	 mov	 DWORD PTR _Lsb$1$[ebp], eax

; 640  : 			else

  007f1	eb 08		 jmp	 SHORT $LN451@strtod_l
$LN67@strtod_l:

; 641  : 				Lsb1 = Lsb << (i - 32);

  007f3	83 c1 e0	 add	 ecx, -32		; ffffffe0H
  007f6	d3 e0		 shl	 eax, cl
  007f8	89 45 c8	 mov	 DWORD PTR _Lsb1$1$[ebp], eax
$LN451@strtod_l:
  007fb	8b 4d 08	 mov	 ecx, DWORD PTR _j$3$[ebp]
$LN66@strtod_l:

; 642  : 		}
; 643  : #else /*Avoid_Underflow*/
; 644  : #ifdef Sudden_Underflow
; 645  : #ifdef IBM
; 646  : 		j = 1 + 4 * P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
; 647  : #else
; 648  : 		j = P + 1 - bbbits;
; 649  : #endif
; 650  : #else /*Sudden_Underflow*/
; 651  : 		j = bbe;
; 652  : 		i = j + bbbits - 1;	/* logb(rv) */
; 653  : 		if (i < Emin)	/* denormal */
; 654  : 			j += P - Emin;
; 655  : 		else
; 656  : 			j = P + 1 - bbbits;
; 657  : #endif /*Sudden_Underflow*/
; 658  : #endif /*Avoid_Underflow*/
; 659  : 		bb2 += j;
; 660  : 		bd2 += j;
; 661  : #ifdef Avoid_Underflow
; 662  : 		bd2 += scale;

  007fe	8b 45 ec	 mov	 eax, DWORD PTR _scale$1$[ebp]
  00801	03 f9		 add	 edi, ecx
  00803	03 c1		 add	 eax, ecx

; 663  : #endif
; 664  : 		i = bb2 < bd2 ? bb2 : bd2;
; 665  : 		if (i > bs2)

  00805	8b 4d cc	 mov	 ecx, DWORD PTR _bs2$1$[ebp]
  00808	03 d0		 add	 edx, eax
  0080a	3b fa		 cmp	 edi, edx
  0080c	89 55 08	 mov	 DWORD PTR _bd2$1$[ebp], edx
  0080f	8b c2		 mov	 eax, edx
  00811	0f 4c c7	 cmovl	 eax, edi
  00814	3b c1		 cmp	 eax, ecx
  00816	0f 4f c1	 cmovg	 eax, ecx

; 666  : 			i = bs2;
; 667  : 		if (i > 0) {

  00819	85 c0		 test	 eax, eax
  0081b	7e 0c		 jle	 SHORT $LN64@strtod_l

; 668  : 			bb2 -= i;
; 669  : 			bd2 -= i;

  0081d	2b d0		 sub	 edx, eax
  0081f	2b f8		 sub	 edi, eax

; 670  : 			bs2 -= i;

  00821	2b c8		 sub	 ecx, eax
  00823	89 55 08	 mov	 DWORD PTR _bd2$1$[ebp], edx
  00826	89 4d cc	 mov	 DWORD PTR _bs2$1$[ebp], ecx
$LN64@strtod_l:

; 671  : 		}
; 672  : 		if (bb5 > 0) {

  00829	8b 45 bc	 mov	 eax, DWORD PTR _bb5$1$[ebp]
  0082c	85 c0		 test	 eax, eax
  0082e	7e 37		 jle	 SHORT $LN271@strtod_l

; 673  : 			bs = pow5mult(bs, bb5);

  00830	50		 push	 eax
  00831	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  00834	e8 00 00 00 00	 call	 ___pow5mult
  00839	83 c4 08	 add	 esp, 8
  0083c	89 45 e8	 mov	 DWORD PTR _bs$1$[ebp], eax

; 674  : 			if (bs == NULL)

  0083f	85 c0		 test	 eax, eax
  00841	74 57		 je	 SHORT $LN308@strtod_l

; 675  : 				goto ovfl;
; 676  : 			bb1 = mult(bs, bb);

  00843	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  00846	50		 push	 eax
  00847	e8 00 00 00 00	 call	 ___multiply
  0084c	83 c4 08	 add	 esp, 8
  0084f	89 45 b4	 mov	 DWORD PTR _bb1$1$[ebp], eax

; 677  : 			if (bb1 == NULL)

  00852	85 c0		 test	 eax, eax
  00854	74 44		 je	 SHORT $LN308@strtod_l

; 678  : 				goto ovfl;
; 679  : 			Bfree(bb);

  00856	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  00859	e8 00 00 00 00	 call	 __Bfree

; 680  : 			bb = bb1;

  0085e	8b 45 b4	 mov	 eax, DWORD PTR _bb1$1$[ebp]
  00861	83 c4 04	 add	 esp, 4
  00864	89 45 f0	 mov	 DWORD PTR _bb$[ebp], eax
$LN271@strtod_l:

; 681  : 		}
; 682  : 		if (bb2 > 0) {

  00867	85 ff		 test	 edi, edi
  00869	7e 13		 jle	 SHORT $LN59@strtod_l

; 683  : 			bb = lshift(bb, bb2);

  0086b	57		 push	 edi
  0086c	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  0086f	e8 00 00 00 00	 call	 ___lshift
  00874	83 c4 08	 add	 esp, 8
  00877	89 45 f0	 mov	 DWORD PTR _bb$[ebp], eax

; 684  : 			if (bb == NULL)

  0087a	85 c0		 test	 eax, eax
  0087c	74 1c		 je	 SHORT $LN308@strtod_l
$LN59@strtod_l:

; 685  : 				goto ovfl;
; 686  : 		}
; 687  : 		if (bd5 > 0) {

  0087e	8b 45 c4	 mov	 eax, DWORD PTR _bd5$1$[ebp]
  00881	85 c0		 test	 eax, eax
  00883	7e 1d		 jle	 SHORT $LN324@strtod_l

; 688  : 			bd = pow5mult(bd, bd5);

  00885	50		 push	 eax
  00886	ff 75 e4	 push	 DWORD PTR _bd$1$[ebp]
  00889	e8 00 00 00 00	 call	 ___pow5mult
  0088e	8b f8		 mov	 edi, eax
  00890	83 c4 08	 add	 esp, 8
  00893	89 7d e4	 mov	 DWORD PTR _bd$1$[ebp], edi

; 689  : 			if (bd == NULL)

  00896	85 ff		 test	 edi, edi
  00898	75 0b		 jne	 SHORT $LN57@strtod_l
$LN308@strtod_l:
  0089a	8b 7d f8	 mov	 edi, DWORD PTR _bd0$1$[ebp]
  0089d	e9 b9 04 00 00	 jmp	 $ovfl$466
$LN324@strtod_l:
  008a2	8b 7d e4	 mov	 edi, DWORD PTR _bd$1$[ebp]
$LN57@strtod_l:

; 690  : 				goto ovfl;
; 691  : 		}
; 692  : 		if (bd2 > 0) {

  008a5	8b 45 08	 mov	 eax, DWORD PTR _bd2$1$[ebp]
  008a8	85 c0		 test	 eax, eax
  008aa	7e 13		 jle	 SHORT $LN55@strtod_l

; 693  : 			bd = lshift(bd, bd2);

  008ac	50		 push	 eax
  008ad	57		 push	 edi
  008ae	e8 00 00 00 00	 call	 ___lshift
  008b3	8b f8		 mov	 edi, eax
  008b5	83 c4 08	 add	 esp, 8
  008b8	89 7d e4	 mov	 DWORD PTR _bd$1$[ebp], edi

; 694  : 			if (bd == NULL)

  008bb	85 ff		 test	 edi, edi
  008bd	74 db		 je	 SHORT $LN308@strtod_l
$LN55@strtod_l:

; 695  : 				goto ovfl;
; 696  : 		}
; 697  : 		if (bs2 > 0) {

  008bf	8b 45 cc	 mov	 eax, DWORD PTR _bs2$1$[ebp]
  008c2	85 c0		 test	 eax, eax
  008c4	7e 13		 jle	 SHORT $LN53@strtod_l

; 698  : 			bs = lshift(bs, bs2);

  008c6	50		 push	 eax
  008c7	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  008ca	e8 00 00 00 00	 call	 ___lshift
  008cf	83 c4 08	 add	 esp, 8
  008d2	89 45 e8	 mov	 DWORD PTR _bs$1$[ebp], eax

; 699  : 			if (bs == NULL)

  008d5	85 c0		 test	 eax, eax
  008d7	74 c1		 je	 SHORT $LN308@strtod_l
$LN53@strtod_l:

; 700  : 				goto ovfl;
; 701  : 		}
; 702  : 		delta = diff(bb, bd);

  008d9	57		 push	 edi
  008da	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  008dd	e8 00 00 00 00	 call	 ___mdiff
  008e2	83 c4 08	 add	 esp, 8
  008e5	89 45 dc	 mov	 DWORD PTR _delta$1$[ebp], eax

; 703  : 		if (delta == NULL)

  008e8	85 c0		 test	 eax, eax
  008ea	74 ae		 je	 SHORT $LN308@strtod_l

; 704  : 			goto ovfl;
; 705  : 		dsign = delta->_sign;
; 706  : 		delta->_sign = 0;
; 707  : 		i = cmp(delta, bs);

  008ec	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  008ef	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  008f2	50		 push	 eax
  008f3	89 7d d8	 mov	 DWORD PTR _dsign$1$[ebp], edi
  008f6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  008fd	e8 00 00 00 00	 call	 ___mcmp
  00902	83 c4 08	 add	 esp, 8

; 708  : #ifdef Honor_FLT_ROUNDS
; 709  : 		if (rounding != 1) {
; 710  : 			if (i < 0) {
; 711  : 				/* Error is less than an ulp */
; 712  : 				if (!delta->_x[0] && delta->_wds <= 1) {
; 713  : 					/* exact */
; 714  : #ifdef SET_INEXACT
; 715  : 					inexact = 0;
; 716  : #endif
; 717  : 					break;
; 718  : 				}
; 719  : 				if (rounding) {
; 720  : 					if (dsign) {
; 721  : 						adj = 1.;
; 722  : 						goto apply_adj;
; 723  : 					}
; 724  : 				}
; 725  : 				else if (!dsign) {
; 726  : 					adj = -1.;
; 727  : 					if (!dword1(rv)
; 728  : 						&& !(dword0(rv) & Frac_mask)) {
; 729  : 						y = dword0(rv) & Exp_mask;
; 730  : #ifdef Avoid_Underflow
; 731  : 						if (!scale || y > 2 * P*Exp_msk1)
; 732  : #else
; 733  : 						if (y)
; 734  : #endif
; 735  : 						{
; 736  : 							delta = lshift(ptr, delta, Log2P);
; 737  : 							if (cmp(delta, bs) <= 0)
; 738  : 								adj = -0.5;
; 739  : 						}
; 740  : 					}
; 741  : 				apply_adj:
; 742  : #ifdef Avoid_Underflow
; 743  : 					if (scale && (y = dword0(rv) & Exp_mask)
; 744  : 						<= 2 * P*Exp_msk1)
; 745  : 						dword0(adj) += (2 * P + 1)*Exp_msk1 - y;
; 746  : #else
; 747  : #ifdef Sudden_Underflow
; 748  : 					if ((dword0(rv) & Exp_mask) <=
; 749  : 						P*Exp_msk1) {
; 750  : 						dword0(rv) += P*Exp_msk1;
; 751  : 						dval(rv) += adj*ulp(dval(rv));
; 752  : 						dword0(rv) -= P*Exp_msk1;
; 753  : 					}
; 754  : 					else
; 755  : #endif /*Sudden_Underflow*/
; 756  : #endif /*Avoid_Underflow*/
; 757  : 						dval(rv) += adj*ulp(dval(rv));
; 758  : 				}
; 759  : 				break;
; 760  : 			}
; 761  : 			adj = ratio(delta, bs);
; 762  : 			if (adj < 1.)
; 763  : 				adj = 1.;
; 764  : 			if (adj <= 0x7ffffffe) {
; 765  : 				/* adj = rounding ? ceil(adj) : floor(adj); */
; 766  : 				y = adj;
; 767  : 				if (y != adj) {
; 768  : 					if (!((rounding >> 1) ^ dsign))
; 769  : 						y++;
; 770  : 					adj = y;
; 771  : 				}
; 772  : 			}
; 773  : #ifdef Avoid_Underflow
; 774  : 			if (scale && (y = dword0(rv) & Exp_mask) <= 2 * P*Exp_msk1)
; 775  : 				dword0(adj) += (2 * P + 1)*Exp_msk1 - y;
; 776  : #else
; 777  : #ifdef Sudden_Underflow
; 778  : 			if ((dword0(rv) & Exp_mask) <= P*Exp_msk1) {
; 779  : 				dword0(rv) += P*Exp_msk1;
; 780  : 				adj *= ulp(dval(rv));
; 781  : 				if (dsign)
; 782  : 					dval(rv) += adj;
; 783  : 				else
; 784  : 					dval(rv) -= adj;
; 785  : 				dword0(rv) -= P*Exp_msk1;
; 786  : 				goto cont;
; 787  : 			}
; 788  : #endif /*Sudden_Underflow*/
; 789  : #endif /*Avoid_Underflow*/
; 790  : 			adj *= ulp(dval(rv));
; 791  : 			if (dsign) {
; 792  : 				if (dword0(rv) == Big0 && dword1(rv) == Big1)
; 793  : 					goto ovfl;
; 794  : 				dval(rv) += adj;
; 795  : 				else
; 796  : 					dval(rv) -= adj;
; 797  : 				goto cont;
; 798  : 			}
; 799  : #endif /*Honor_FLT_ROUNDS*/
; 800  : 
; 801  : 			if (i < 0) {

  00905	85 c0		 test	 eax, eax
  00907	0f 88 68 03 00
	00		 js	 $LN227@strtod_l

; 829  : 					goto drop_down;
; 830  : 				break;
; 831  : 			}
; 832  : 			if (i == 0) {

  0090d	0f 84 96 02 00
	00		 je	 $LN228@strtod_l

; 930  : 						goto undfl;
; 931  : #endif
; 932  : 				}
; 933  : #ifdef Avoid_Underflow
; 934  : 				dsign = 1 - dsign;
; 935  : #endif
; 936  : #endif
; 937  : 				break;
; 938  : 			}
; 939  : 			if ((aadj = ratio(delta, bs)) <= 2.) {

  00913	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  00916	ff 75 dc	 push	 DWORD PTR _delta$1$[ebp]
  00919	e8 00 00 00 00	 call	 ___ratio
  0091e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  00924	83 c4 08	 add	 esp, 8
  00927	df f1		 fcomip	 ST(1)
  00929	0f 82 f9 00 00
	00		 jb	 $LN30@strtod_l

; 940  : 				if (dsign)

  0092f	85 ff		 test	 edi, edi
  00931	74 11		 je	 SHORT $LN29@strtod_l

; 941  : 					aadj = dval(aadj1) = 1.;

  00933	dd d8		 fstp	 ST(0)
  00935	d9 e8		 fld1
  00937	d9 c0		 fld	 ST(0)
  00939	dd 55 b8	 fst	 QWORD PTR _aadj1$1$[ebp]
  0093c	dd 5d b0	 fstp	 QWORD PTR _aadj1$[ebp]
  0093f	dd 55 c0	 fst	 QWORD PTR _aadj$3$[ebp]
  00942	eb 37		 jmp	 SHORT $LN201@strtod_l
$LN29@strtod_l:

; 942  : 				else if (dword1(rv) || dword0(rv) & Bndry_mask) {

  00944	85 db		 test	 ebx, ebx
  00946	0f 85 ab 00 00
	00		 jne	 $LN400@strtod_l
  0094c	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  00952	0f 85 be 00 00
	00		 jne	 $LN403@strtod_l

; 949  : 				}
; 950  : 				else {
; 951  : 					/* special case -- power of FLT_RADIX to be */
; 952  : 					/* rounded down... */
; 953  : 
; 954  : 					if (aadj < 2. / FLT_RADIX)

  00958	d9 e8		 fld1
  0095a	df f1		 fcomip	 ST(1)
  0095c	76 0a		 jbe	 SHORT $LN23@strtod_l

; 955  : 						aadj = 1. / FLT_RADIX;

  0095e	dd d8		 fstp	 ST(0)
  00960	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000000000000

; 956  : 					else

  00966	eb 06		 jmp	 SHORT $LN452@strtod_l
$LN23@strtod_l:

; 957  : 						aadj *= 0.5;

  00968	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
$LN452@strtod_l:
  0096e	dd 55 c0	 fst	 QWORD PTR _aadj$3$[ebp]
$LN200@strtod_l:

; 963  : 				dval(aadj1) = dsign ? aadj : -aadj;

  00971	d9 c0		 fld	 ST(0)
  00973	d9 e0		 fchs
$LN453@strtod_l:
  00975	dd 55 b8	 fst	 QWORD PTR _aadj1$1$[ebp]
  00978	dd 5d b0	 fstp	 QWORD PTR _aadj1$[ebp]
$LN201@strtod_l:

; 964  : #ifdef Check_FLT_ROUNDS
; 965  : 				switch (Rounding) {
; 966  : 				case 2: /* towards +infinity */
; 967  : 					dval(aadj1) -= 0.5;
; 968  : 					break;
; 969  : 				case 0: /* towards 0 */
; 970  : 				case 3: /* towards -infinity */
; 971  : 					dval(aadj1) += 0.5;
; 972  : 				}
; 973  : #else
; 974  : 				if (Flt_Rounds == 0)
; 975  : 					dval(aadj1) += 0.5;
; 976  : #endif /*Check_FLT_ROUNDS*/
; 977  : 			}
; 978  : 			y = dword0(rv) & Exp_mask;

  0097b	8b fe		 mov	 edi, esi
  0097d	81 e7 00 00 f0
	7f		 and	 edi, 2146435072		; 7ff00000H

; 979  : 
; 980  : 			/* Check for overflow */
; 981  : 
; 982  : 			if (y == Exp_msk1*(DBL_MAX_EXP + Bias - 1)) {

  00983	81 ff 00 00 e0
	7f		 cmp	 edi, 2145386496		; 7fe00000H
  00989	0f 85 c8 00 00
	00		 jne	 $LN19@strtod_l

; 983  : 				dval(rv0) = dval(rv);
; 984  : 				dword0(rv) -= P*Exp_msk1;
; 985  : 				adj = dval(aadj1) * ulp(dval(rv));

  0098f	dd d8		 fstp	 ST(0)
  00991	83 ec 08	 sub	 esp, 8
  00994	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
  00997	81 ee 00 00 50
	03		 sub	 esi, 55574528		; 03500000H
  0099d	dd 5d 90	 fstp	 QWORD PTR _rv0$[ebp]
  009a0	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi
  009a3	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  009a6	dd 1c 24	 fstp	 QWORD PTR [esp]
  009a9	e8 00 00 00 00	 call	 ___ulp
  009ae	dc 4d b8	 fmul	 QWORD PTR _aadj1$1$[ebp]
  009b1	83 c4 08	 add	 esp, 8

; 986  : 				dval(rv) += adj;

  009b4	dc 45 a0	 fadd	 QWORD PTR _rv$[ebp]
  009b7	dd 5d a0	 fstp	 QWORD PTR _rv$[ebp]

; 987  : 				if ((dword0(rv) & Exp_mask) >=
; 988  : 					Exp_msk1*(DBL_MAX_EXP + Bias - P)) {

  009ba	8b 75 a4	 mov	 esi, DWORD PTR _rv$[ebp+4]
  009bd	8b c6		 mov	 eax, esi
  009bf	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  009c4	3d 00 00 a0 7c	 cmp	 eax, 2090860544		; 7ca00000H
  009c9	72 75		 jb	 SHORT $LN18@strtod_l

; 989  : 					if (dword0(rv0) == Big0 && dword1(rv0) == Big1)

  009cb	81 7d 94 ff ff
	ef 7f		 cmp	 DWORD PTR _rv0$[ebp+4], 2146435071 ; 7fefffffH
  009d2	75 0a		 jne	 SHORT $LN17@strtod_l
  009d4	83 7d 90 ff	 cmp	 DWORD PTR _rv0$[ebp], -1
  009d8	0f 84 bc fe ff
	ff		 je	 $LN308@strtod_l
$LN17@strtod_l:

; 990  : 						goto ovfl;
; 991  : 					dword0(rv) = Big0;

  009de	be ff ff ef 7f	 mov	 esi, 2146435071		; 7fefffffH

; 992  : #ifndef _DOUBLE_IS_32BITS
; 993  : 					dword1(rv) = Big1;

  009e3	83 cb ff	 or	 ebx, -1
  009e6	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi
  009e9	89 5d a0	 mov	 DWORD PTR _rv$[ebp], ebx

; 994  : #endif /*!_DOUBLE_IS_32BITS*/
; 995  : 					goto cont;

  009ec	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  009ef	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  009f2	e9 6f 01 00 00	 jmp	 $cont$467
$LN400@strtod_l:
  009f7	dd d8		 fstp	 ST(0)

; 943  : #ifndef Sudden_Underflow
; 944  : 					if (dword1(rv) == Tiny1 && !dword0(rv))

  009f9	83 fb 01	 cmp	 ebx, 1
  009fc	75 1a		 jne	 SHORT $LN25@strtod_l
  009fe	85 f6		 test	 esi, esi
  00a00	0f 84 da 02 00
	00		 je	 $LN454@strtod_l

; 945  : 						goto undfl;
; 946  : #endif
; 947  : 					aadj = 1.;

  00a06	d9 e8		 fld1
  00a08	dd 55 c0	 fst	 QWORD PTR _aadj$3$[ebp]

; 948  : 					dval(aadj1) = -1.;

  00a0b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@bff0000000000000

; 958  : 					dval(aadj1) = -aadj;
; 959  : 				}
; 960  : 			}
; 961  : 			else {

  00a11	e9 5f ff ff ff	 jmp	 $LN453@strtod_l
$LN403@strtod_l:

; 943  : #ifndef Sudden_Underflow
; 944  : 					if (dword1(rv) == Tiny1 && !dword0(rv))

  00a16	dd d8		 fstp	 ST(0)
$LN25@strtod_l:

; 945  : 						goto undfl;
; 946  : #endif
; 947  : 					aadj = 1.;

  00a18	d9 e8		 fld1
  00a1a	dd 55 c0	 fst	 QWORD PTR _aadj$3$[ebp]

; 948  : 					dval(aadj1) = -1.;

  00a1d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@bff0000000000000

; 958  : 					dval(aadj1) = -aadj;
; 959  : 				}
; 960  : 			}
; 961  : 			else {

  00a23	e9 4d ff ff ff	 jmp	 $LN453@strtod_l
$LN30@strtod_l:

; 962  : 				aadj *= 0.5;

  00a28	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00a2e	dd 55 c0	 fst	 QWORD PTR _aadj$3$[ebp]

; 963  : 				dval(aadj1) = dsign ? aadj : -aadj;

  00a31	85 ff		 test	 edi, edi
  00a33	0f 84 38 ff ff
	ff		 je	 $LN200@strtod_l
  00a39	d9 c0		 fld	 ST(0)
  00a3b	e9 35 ff ff ff	 jmp	 $LN453@strtod_l
$LN18@strtod_l:

; 996  : 				}
; 997  : 				else
; 998  : 					dword0(rv) += P*Exp_msk1;
; 999  : 			}
; 1000 : 			else {

  00a40	8b 5d d8	 mov	 ebx, DWORD PTR _dsign$1$[ebp]
  00a43	81 c6 00 00 50
	03		 add	 esi, 55574528		; 03500000H
  00a49	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi
  00a4c	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00a4f	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  00a52	e9 9f 00 00 00	 jmp	 $LN15@strtod_l
$LN19@strtod_l:

; 1001 : #ifdef Avoid_Underflow
; 1002 : 				if (scale && y <= 2 * P*Exp_msk1) {

  00a57	83 7d ec 00	 cmp	 DWORD PTR _scale$1$[ebp], 0
  00a5b	74 74		 je	 SHORT $LN414@strtod_l
  00a5d	81 ff 00 00 a0
	06		 cmp	 edi, 111149056		; 06a00000H
  00a63	77 6c		 ja	 SHORT $LN414@strtod_l

; 1003 : 					if (aadj <= 0x7fffffff) {

  00a65	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@41dfffffffc00000
  00a6b	df f1		 fcomip	 ST(1)
  00a6d	72 4b		 jb	 SHORT $LN420@strtod_l

; 1004 : 						if ((z = (unsigned long)aadj) == 0)

  00a6f	d9 7d 0a	 fnstcw	 WORD PTR tv1404[ebp]
  00a72	0f b7 45 0a	 movzx	 eax, WORD PTR tv1404[ebp]
  00a76	b9 01 00 00 00	 mov	 ecx, 1
  00a7b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a80	89 45 b4	 mov	 DWORD PTR tv1401[ebp], eax
  00a83	d9 6d b4	 fldcw	 WORD PTR tv1401[ebp]
  00a86	df 7d a0	 fistp	 QWORD PTR tv1399[ebp]
  00a89	8b 45 a0	 mov	 eax, DWORD PTR tv1399[ebp]
  00a8c	85 c0		 test	 eax, eax
  00a8e	0f 44 c1	 cmove	 eax, ecx
  00a91	d9 6d 0a	 fldcw	 WORD PTR tv1404[ebp]

; 1005 : 							z = 1;
; 1006 : 						aadj = z;

  00a94	89 45 08	 mov	 DWORD PTR tv1393[ebp], eax
  00a97	db 45 08	 fild	 DWORD PTR tv1393[ebp]
  00a9a	85 c0		 test	 eax, eax
  00a9c	79 06		 jns	 SHORT $LN448@strtod_l
  00a9e	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN448@strtod_l:

; 1007 : 						dval(aadj1) = dsign ? aadj : -aadj;

  00aa4	8b 5d d8	 mov	 ebx, DWORD PTR _dsign$1$[ebp]
  00aa7	dd 55 c0	 fst	 QWORD PTR _aadj$3$[ebp]
  00aaa	85 db		 test	 ebx, ebx
  00aac	74 05		 je	 SHORT $LN202@strtod_l
  00aae	dd 5d b0	 fstp	 QWORD PTR _aadj1$[ebp]
  00ab1	eb 0c		 jmp	 SHORT $LN203@strtod_l
$LN202@strtod_l:
  00ab3	d9 e0		 fchs
  00ab5	dd 5d b0	 fstp	 QWORD PTR _aadj1$[ebp]
  00ab8	eb 05		 jmp	 SHORT $LN203@strtod_l
$LN420@strtod_l:
  00aba	8b 5d d8	 mov	 ebx, DWORD PTR _dsign$1$[ebp]
  00abd	dd d8		 fstp	 ST(0)
$LN203@strtod_l:

; 1008 : 					}
; 1009 : 					dword0(aadj1) += (2 * P + 1)*Exp_msk1 - y;

  00abf	b8 00 00 b0 06	 mov	 eax, 112197632		; 06b00000H
  00ac4	2b c7		 sub	 eax, edi
  00ac6	01 45 b4	 add	 DWORD PTR _aadj1$[ebp+4], eax
  00ac9	dd 45 b0	 fld	 QWORD PTR _aadj1$[ebp]
  00acc	dd 5d b8	 fstp	 QWORD PTR _aadj1$1$[ebp]
  00acf	eb 05		 jmp	 SHORT $LN14@strtod_l
$LN414@strtod_l:
  00ad1	8b 5d d8	 mov	 ebx, DWORD PTR _dsign$1$[ebp]
  00ad4	dd d8		 fstp	 ST(0)
$LN14@strtod_l:

; 1010 : 				}
; 1011 : 				adj = dval(aadj1) * ulp(dval(rv));

  00ad6	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
  00ad9	83 ec 08	 sub	 esp, 8
  00adc	dd 1c 24	 fstp	 QWORD PTR [esp]
  00adf	e8 00 00 00 00	 call	 ___ulp
  00ae4	dc 4d b8	 fmul	 QWORD PTR _aadj1$1$[ebp]
  00ae7	83 c4 08	 add	 esp, 8

; 1012 : 				dval(rv) += adj;

  00aea	dc 45 98	 fadd	 QWORD PTR _rv$2$[ebp]
  00aed	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00af0	dd 5d a0	 fstp	 QWORD PTR _rv$[ebp]
  00af3	8b 75 a4	 mov	 esi, DWORD PTR _rv$[ebp+4]
$LN15@strtod_l:

; 1063 : #ifndef SET_INEXACT
; 1064 : #ifdef Avoid_Underflow
; 1065 : 			if (!scale)

  00af6	83 7d ec 00	 cmp	 DWORD PTR _scale$1$[ebp], 0
  00afa	75 67		 jne	 SHORT $LN272@strtod_l

; 1013 : #else
; 1014 : #ifdef Sudden_Underflow
; 1015 : 				if ((dword0(rv) & Exp_mask) <= P*Exp_msk1) {
; 1016 : 					dval(rv0) = dval(rv);
; 1017 : 					dword0(rv) += P*Exp_msk1;
; 1018 : 					adj = dval(aadj1) * ulp(dval(rv));
; 1019 : 					dval(rv) += adj;
; 1020 : #ifdef IBM
; 1021 : 					if ((dword0(rv) & Exp_mask) <  P*Exp_msk1)
; 1022 : #else
; 1023 : 					if ((dword0(rv) & Exp_mask) <= P*Exp_msk1)
; 1024 : #endif
; 1025 : 					{
; 1026 : 						if (dword0(rv0) == Tiny0
; 1027 : 							&& dword1(rv0) == Tiny1)
; 1028 : 							goto undfl;
; 1029 : #ifndef _DOUBLE_IS_32BITS
; 1030 : 						dword0(rv) = Tiny0;
; 1031 : 						dword1(rv) = Tiny1;
; 1032 : #else
; 1033 : 						dword0(rv) = Tiny1;
; 1034 : #endif /*_DOUBLE_IS_32BITS*/
; 1035 : 						goto cont;
; 1036 : 					}
; 1037 : 					else
; 1038 : 						dword0(rv) -= P*Exp_msk1;
; 1039 : 				}
; 1040 : 				else {
; 1041 : 					adj = dval(aadj1) * ulp(dval(rv));
; 1042 : 					dval(rv) += adj;
; 1043 : 				}
; 1044 : #else /*Sudden_Underflow*/
; 1045 : 				/* Compute adj so that the IEEE rounding rules will
; 1046 : 				* correctly round rv + adj in some half-way cases.
; 1047 : 				* If rv * ulp(rv) is denormalized (i.e.,
; 1048 : 				* y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
; 1049 : 				* trouble from bits lost to denormalization;
; 1050 : 				* example: 1.2e-307 .
; 1051 : 				*/
; 1052 : 				if (y <= (P - 1)*Exp_msk1 && aadj > 1.) {
; 1053 : 					dval(aadj1) = (double)(int)(aadj + 0.5);
; 1054 : 					if (!dsign)
; 1055 : 						dval(aadj1) = -dval(aadj1);
; 1056 : 				}
; 1057 : 				adj = dval(aadj1) * ulp(dval(rv));
; 1058 : 				dval(rv) += adj;
; 1059 : #endif /*Sudden_Underflow*/
; 1060 : #endif /*Avoid_Underflow*/
; 1061 : 			}
; 1062 : 			z = dword0(rv) & Exp_mask;

  00afc	8b c6		 mov	 eax, esi
  00afe	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H

; 1066 : #endif
; 1067 : 				if (y == z) {

  00b03	3b f8		 cmp	 edi, eax
  00b05	75 5c		 jne	 SHORT $LN272@strtod_l

; 1068 : 					/* Can we stop now? */
; 1069 : 					L = (Long)aadj;

  00b07	dd 45 c0	 fld	 QWORD PTR _aadj$3$[ebp]
  00b0a	d9 c0		 fld	 ST(0)
  00b0c	e8 00 00 00 00	 call	 __ftol2_sse

; 1070 : 					aadj -= L;

  00b11	89 45 08	 mov	 DWORD PTR tv1380[ebp], eax

; 1071 : 					/* The tolerances below are conservative. */
; 1072 : 					if (dsign || dword1(rv) || dword0(rv) & Bndry_mask) {

  00b14	85 db		 test	 ebx, ebx
  00b16	db 45 08	 fild	 DWORD PTR tv1380[ebp]
  00b19	dd 5d 98	 fstp	 QWORD PTR tv1379[ebp]
  00b1c	dc 65 98	 fsub	 QWORD PTR tv1379[ebp]
  00b1f	8b 75 a4	 mov	 esi, DWORD PTR _rv$[ebp+4]
  00b22	8b 5d a0	 mov	 ebx, DWORD PTR _rv$[ebp]
  00b25	75 24		 jne	 SHORT $LN8@strtod_l
  00b27	85 db		 test	 ebx, ebx
  00b29	75 20		 jne	 SHORT $LN8@strtod_l
  00b2b	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  00b31	75 18		 jne	 SHORT $LN8@strtod_l

; 1074 : 							break;
; 1075 : 					}
; 1076 : 					else if (aadj < .4999999 / FLT_RADIX)

  00b33	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fcfffff94a03595
$LN456@strtod_l:
  00b39	df f1		 fcomip	 ST(1)
  00b3b	dd d8		 fstp	 ST(0)
  00b3d	0f 87 43 02 00
	00		 ja	 $LN307@strtod_l
  00b43	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00b46	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  00b49	eb 1b		 jmp	 SHORT $cont$467
$LN8@strtod_l:

; 1073 : 						if (aadj < .4999999 || aadj > .5000001)

  00b4b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fdfffff94a03595
  00b51	df f1		 fcomip	 ST(1)
  00b53	0f 87 2b 02 00
	00		 ja	 $LN436@strtod_l
  00b59	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe0000035afe535
  00b5f	d9 c9		 fxch	 ST(1)
  00b61	eb d6		 jmp	 SHORT $LN456@strtod_l
$LN272@strtod_l:
  00b63	8b 5d a0	 mov	 ebx, DWORD PTR _rv$[ebp]
$cont$467:

; 1077 : 						break;
; 1078 : 				}
; 1079 : #endif
; 1080 : 		cont:
; 1081 : 			Bfree(bb);

  00b66	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  00b69	e8 00 00 00 00	 call	 __Bfree

; 1082 : 			Bfree(bd);

  00b6e	ff 75 e4	 push	 DWORD PTR _bd$1$[ebp]
  00b71	e8 00 00 00 00	 call	 __Bfree

; 1083 : 			Bfree(bs);

  00b76	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  00b79	e8 00 00 00 00	 call	 __Bfree

; 1084 : 			Bfree(delta);

  00b7e	ff 75 dc	 push	 DWORD PTR _delta$1$[ebp]
  00b81	e8 00 00 00 00	 call	 __Bfree
  00b86	8b 7d f8	 mov	 edi, DWORD PTR _bd0$1$[ebp]
  00b89	ff 77 04	 push	 DWORD PTR [edi+4]
  00b8c	e8 00 00 00 00	 call	 __Balloc
  00b91	8b d0		 mov	 edx, eax
  00b93	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  00b96	83 c4 14	 add	 esp, 20			; 00000014H
  00b99	89 55 e4	 mov	 DWORD PTR _bd$1$[ebp], edx
  00b9c	85 d2		 test	 edx, edx
  00b9e	0f 85 7c fb ff
	ff		 jne	 $LL323@strtod_l

; 603  : 			goto ovfl;

  00ba4	e9 b2 01 00 00	 jmp	 $ovfl$466
$LN228@strtod_l:

; 833  : 				/* exactly half-way between */
; 834  : 				if (dsign) {

  00ba9	85 ff		 test	 edi, edi
  00bab	74 6d		 je	 SHORT $LN45@strtod_l

; 835  : 					if ((dword0(rv) & Bndry_mask1) == Bndry_mask1
; 836  : 						&&  dword1(rv) == (
; 837  : #ifdef Avoid_Underflow
; 838  : 						(scale && (y = dword0(rv) & Exp_mask) <= 2 * P*Exp_msk1)
; 839  : 						? (0xffffffff & (0xffffffff << (2 * P + 1 - (y >> Exp_shift)))) :
; 840  : #endif
; 841  : 						0xffffffff)) {

  00bad	8b 55 ec	 mov	 edx, DWORD PTR _scale$1$[ebp]
  00bb0	8b c6		 mov	 eax, esi
  00bb2	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  00bb7	3d ff ff 0f 00	 cmp	 eax, 1048575		; 000fffffH
  00bbc	75 6f		 jne	 SHORT $LN41@strtod_l
  00bbe	85 d2		 test	 edx, edx
  00bc0	74 1f		 je	 SHORT $LN198@strtod_l
  00bc2	8b c6		 mov	 eax, esi
  00bc4	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00bc9	3d 00 00 a0 06	 cmp	 eax, 111149056		; 06a00000H
  00bce	77 11		 ja	 SHORT $LN198@strtod_l
  00bd0	c1 e8 14	 shr	 eax, 20			; 00000014H
  00bd3	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00bd8	2b c8		 sub	 ecx, eax
  00bda	83 c8 ff	 or	 eax, -1
  00bdd	d3 e0		 shl	 eax, cl
  00bdf	eb 03		 jmp	 SHORT $LN199@strtod_l
$LN198@strtod_l:
  00be1	83 c8 ff	 or	 eax, -1
$LN199@strtod_l:
  00be4	3b d8		 cmp	 ebx, eax
  00be6	75 45		 jne	 SHORT $LN41@strtod_l

; 842  : 						/*boundary case -- increment exponent*/
; 843  : 						if (dword0(rv) == Big0 && dword1(rv) == Big1)

  00be8	81 fe ff ff ef
	7f		 cmp	 esi, 2146435071		; 7fefffffH
  00bee	75 09		 jne	 SHORT $LN43@strtod_l
  00bf0	83 fb ff	 cmp	 ebx, -1
  00bf3	0f 84 a1 fc ff
	ff		 je	 $LN308@strtod_l
$LN43@strtod_l:

; 844  : 							goto ovfl;
; 845  : 						dword0(rv) = (dword0(rv) & Exp_mask)
; 846  : 							+ Exp_msk1
; 847  : #ifdef IBM
; 848  : 							| Exp_msk1 >> 4
; 849  : #endif
; 850  : 							;

  00bf9	81 e6 00 00 f0
	7f		 and	 esi, 2146435072		; 7ff00000H

; 851  : #ifndef _DOUBLE_IS_32BITS
; 852  : 						dword1(rv) = 0;

  00bff	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _rv$[ebp], 0
  00c06	81 c6 00 00 10
	00		 add	 esi, 1048576		; 00100000H
  00c0c	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi

; 853  : #endif /*!_DOUBLE_IS_32BITS*/
; 854  : #ifdef Avoid_Underflow
; 855  : 						dsign = 0;
; 856  : #endif
; 857  : 						break;

  00c0f	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00c12	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00c15	e9 07 01 00 00	 jmp	 $LN231@strtod_l
$LN45@strtod_l:

; 858  : 					}
; 859  : 				}
; 860  : 				else if (!(dword0(rv) & Bndry_mask) && !dword1(rv)) {

  00c1a	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  00c20	75 08		 jne	 SHORT $LN301@strtod_l
  00c22	85 db		 test	 ebx, ebx
  00c24	0f 84 94 00 00
	00		 je	 $drop_down$468
$LN301@strtod_l:
  00c2a	8b 55 ec	 mov	 edx, DWORD PTR _scale$1$[ebp]
$LN41@strtod_l:

; 895  : #endif /*!_DOUBLE_IS_32BITS*/
; 896  : #ifdef IBM
; 897  : 					goto cont;
; 898  : #else
; 899  : 					break;
; 900  : #endif
; 901  : 				}
; 902  : #ifndef ROUND_BIASED
; 903  : #ifdef Avoid_Underflow
; 904  : 				if (Lsb1) {

  00c2d	8b 45 c8	 mov	 eax, DWORD PTR _Lsb1$1$[ebp]
  00c30	85 c0		 test	 eax, eax
  00c32	74 04		 je	 SHORT $LN37@strtod_l

; 905  : 					if (!(dword0(rv) & Lsb1))

  00c34	85 f0		 test	 esi, eax

; 906  : 						break;
; 907  : 				}
; 908  : 				else if (!(dword1(rv) & Lsb))

  00c36	eb 03		 jmp	 SHORT $LN457@strtod_l
$LN37@strtod_l:
  00c38	85 5d d0	 test	 ebx, DWORD PTR _Lsb$1$[ebp]
$LN457@strtod_l:
  00c3b	0f 84 98 00 00
	00		 je	 $LN279@strtod_l

; 909  : 					break;
; 910  : #else
; 911  : 				if (!(dword1(rv) & LSB))
; 912  : 					break;
; 913  : #endif
; 914  : #endif
; 915  : 				if (dsign)
; 916  : #ifdef Avoid_Underflow
; 917  : 					dval(rv) += sulp(rv, scale);

  00c41	52		 push	 edx
  00c42	56		 push	 esi
  00c43	53		 push	 ebx
  00c44	e8 00 00 00 00	 call	 _sulp
  00c49	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c4c	85 ff		 test	 edi, edi
  00c4e	74 0b		 je	 SHORT $LN33@strtod_l
  00c50	dc 45 98	 fadd	 QWORD PTR _rv$2$[ebp]
  00c53	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]

; 918  : #else
; 919  : 					dval(rv) += ulp(dval(rv));
; 920  : #endif
; 921  : #ifndef ROUND_BIASED
; 922  : 				else {

  00c56	e9 c6 00 00 00	 jmp	 $LN231@strtod_l
$LN33@strtod_l:

; 923  : #ifdef Avoid_Underflow
; 924  : 					dval(rv) -= sulp(rv, scale);

  00c5b	dc 6d 98	 fsubr	 QWORD PTR _rv$2$[ebp]
  00c5e	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]

; 925  : #else
; 926  : 					dval(rv) -= ulp(dval(rv));
; 927  : #endif
; 928  : #ifndef Sudden_Underflow
; 929  : 					if (!dval(rv))

  00c61	d9 ee		 fldz
  00c63	d9 c9		 fxch	 ST(1)
  00c65	db e9		 fucomi	 ST(1)
  00c67	9f		 lahf
  00c68	f6 c4 44	 test	 ah, 68			; 00000044H
  00c6b	0f 8a ae 00 00
	00		 jp	 $LN443@strtod_l
  00c71	dd d8		 fstp	 ST(0)
  00c73	eb 6d		 jmp	 SHORT $undfl$469
$LN227@strtod_l:

; 802  : 				/* Error is less than half an ulp -- check for
; 803  : 				* special case of mantissa a power of two.
; 804  : 				*/
; 805  : 				if (dsign || dword1(rv) || dword0(rv) & Bndry_mask
; 806  : #ifdef IEEE_Arith
; 807  : #ifdef Avoid_Underflow
; 808  : 					|| (dword0(rv) & Exp_mask) <= (2 * P + 1)*Exp_msk1
; 809  : #else
; 810  : 					|| (dword0(rv) & Exp_mask) <= Exp_msk1
; 811  : #endif
; 812  : #endif
; 813  : 					) {

  00c75	85 ff		 test	 edi, edi
  00c77	75 60		 jne	 SHORT $LN279@strtod_l
  00c79	85 db		 test	 ebx, ebx
  00c7b	75 5c		 jne	 SHORT $LN279@strtod_l
  00c7d	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  00c83	75 54		 jne	 SHORT $LN279@strtod_l
  00c85	8b c6		 mov	 eax, esi
  00c87	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00c8c	3d 00 00 b0 06	 cmp	 eax, 112197632		; 06b00000H
  00c91	76 46		 jbe	 SHORT $LN279@strtod_l

; 814  : #ifdef SET_INEXACT
; 815  : 					if (!delta->x[0] && delta->wds <= 1)
; 816  : 						inexact = 0;
; 817  : #endif
; 818  : 					break;
; 819  : 				}
; 820  : 				if (!delta->_x[0] && delta->_wds <= 1) {

  00c93	8b 5d dc	 mov	 ebx, DWORD PTR _delta$1$[ebp]
  00c96	39 7b 14	 cmp	 DWORD PTR [ebx+20], edi
  00c99	75 06		 jne	 SHORT $LN48@strtod_l
  00c9b	83 7b 10 01	 cmp	 DWORD PTR [ebx+16], 1
  00c9f	7e 38		 jle	 SHORT $LN279@strtod_l
$LN48@strtod_l:

; 821  : 					/* exact result */
; 822  : #ifdef SET_INEXACT
; 823  : 					inexact = 0;
; 824  : #endif
; 825  : 					break;
; 826  : 				}
; 827  : 				delta = lshift(delta, Log2P);

  00ca1	6a 01		 push	 1
  00ca3	53		 push	 ebx
  00ca4	e8 00 00 00 00	 call	 ___lshift

; 828  : 				if (cmp(delta, bs) > 0)

  00ca9	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  00cac	8b d8		 mov	 ebx, eax
  00cae	53		 push	 ebx
  00caf	89 5d dc	 mov	 DWORD PTR _delta$1$[ebp], ebx
  00cb2	e8 00 00 00 00	 call	 ___mcmp
  00cb7	83 c4 10	 add	 esp, 16			; 00000010H
  00cba	85 c0		 test	 eax, eax
  00cbc	7e 1b		 jle	 SHORT $LN279@strtod_l
$drop_down$468:

; 861  : 				drop_down:
; 862  : 					/* boundary case -- decrement exponent */
; 863  : #ifdef Sudden_Underflow /*{{*/
; 864  : 					L = dword0(rv) & Exp_mask;
; 865  : #ifdef IBM
; 866  : 					if (L <  Exp_msk1)
; 867  : #else
; 868  : #ifdef Avoid_Underflow
; 869  : 					if (L <= (scale ? (2 * P + 1)*Exp_msk1 : Exp_msk1))
; 870  : #else
; 871  : 					if (L <= Exp_msk1)
; 872  : #endif /*Avoid_Underflow*/
; 873  : #endif /*IBM*/
; 874  : 						goto undfl;
; 875  : 					L -= Exp_msk1;
; 876  : #else /*Sudden_Underflow}{*/
; 877  : #ifdef Avoid_Underflow
; 878  : 					if (scale) {

  00cbe	83 7d ec 00	 cmp	 DWORD PTR _scale$1$[ebp], 0
  00cc2	74 3c		 je	 SHORT $LN39@strtod_l

; 879  : 						L = dword0(rv) & Exp_mask;

  00cc4	8b c6		 mov	 eax, esi
  00cc6	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H

; 880  : 						if (L <= (2 * P + 1)*Exp_msk1) {

  00ccb	3d 00 00 b0 06	 cmp	 eax, 112197632		; 06b00000H
  00cd0	77 2e		 ja	 SHORT $LN39@strtod_l

; 881  : 							if (L > (P + 2)*Exp_msk1)

  00cd2	3d 00 00 70 03	 cmp	 eax, 57671680		; 03700000H
  00cd7	76 07		 jbe	 SHORT $LN454@strtod_l
$LN279@strtod_l:
  00cd9	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
  00cdc	eb 43		 jmp	 SHORT $LN231@strtod_l
$LN379@strtod_l:
  00cde	dd d8		 fstp	 ST(0)
$LN454@strtod_l:
  00ce0	d9 ee		 fldz
$undfl$469:

; 568  : 				undfl:
; 569  : 					dval(rv) = 0.;

  00ce2	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]

; 570  : #ifndef NO_ERRNO
; 571  : 					_set_errno(ERANGE);

  00ce5	e8 00 00 00 00	 call	 ___errno

; 572  : #endif
; 573  : 					if (bd0)

  00cea	8b 7d f8	 mov	 edi, DWORD PTR _bd0$1$[ebp]
  00ced	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00cf3	85 ff		 test	 edi, edi
  00cf5	0f 85 9b 00 00
	00		 jne	 $retfree$470

; 574  : 						goto retfree;
; 575  : 					goto ret;

  00cfb	e9 bf 00 00 00	 jmp	 $LN275@strtod_l
$LN39@strtod_l:

; 882  : 								/* round even ==> */
; 883  : 								/* accept rv */
; 884  : 								break;
; 885  : 							/* rv = smallest denormal */
; 886  : 							goto undfl;
; 887  : 						}
; 888  : 					}
; 889  : #endif /*Avoid_Underflow*/
; 890  : 					L = (dword0(rv) & Exp_mask) - Exp_msk1;

  00d00	81 e6 00 00 f0
	7f		 and	 esi, 2146435072		; 7ff00000H

; 891  : #endif /*Sudden_Underflow}*/
; 892  : 					dword0(rv) = L | Bndry_mask1;
; 893  : #ifndef _DOUBLE_IS_32BITS
; 894  : 					dword1(rv) = 0xffffffff;

  00d06	c7 45 a0 ff ff
	ff ff		 mov	 DWORD PTR _rv$[ebp], -1
  00d0d	4e		 dec	 esi
  00d0e	81 ce ff ff 0f
	00		 or	 esi, 1048575		; 000fffffH
  00d14	89 75 a4	 mov	 DWORD PTR _rv$[ebp+4], esi
  00d17	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00d1a	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00d1d	eb 02		 jmp	 SHORT $LN231@strtod_l
$LN443@strtod_l:
  00d1f	dd d9		 fstp	 ST(1)
$LN231@strtod_l:

; 1085 : 		}
; 1086 : #ifdef SET_INEXACT
; 1087 : 		if (inexact) {
; 1088 : 			if (!oldinexact) {
; 1089 : 				dword0(rv0) = Exp_1 + (70 << Exp_shift);
; 1090 : #ifndef _DOUBLE_IS_32BITS
; 1091 : 				dword1(rv0) = 0;
; 1092 : #endif /*!_DOUBLE_IS_32BITS*/
; 1093 : 				dval(rv0) += 1.;
; 1094 : 			}
; 1095 : 		}
; 1096 : 		else if (!oldinexact)
; 1097 : 			clear_inexact();
; 1098 : #endif
; 1099 : #ifdef Avoid_Underflow
; 1100 : 		if (scale) {

  00d21	83 7d ec 00	 cmp	 DWORD PTR _scale$1$[ebp], 0
  00d25	74 6a		 je	 SHORT $LN440@strtod_l

; 1101 : 			dword0(rv0) = Exp_1 - 2 * P*Exp_msk1;

  00d27	c7 45 94 00 00
	50 39		 mov	 DWORD PTR _rv0$[ebp+4], 961544192 ; 39500000H

; 1102 : #ifndef _DOUBLE_IS_32BITS
; 1103 : 			dword1(rv0) = 0;

  00d2e	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _rv0$[ebp], 0

; 1104 : #endif /*!_DOUBLE_IS_32BITS*/
; 1105 : 			dval(rv) *= dval(rv0);

  00d35	dc 4d 90	 fmul	 QWORD PTR _rv0$[ebp]
  00d38	dd 55 98	 fst	 QWORD PTR _rv$2$[ebp]
  00d3b	dd 5d a0	 fstp	 QWORD PTR _rv$[ebp]

; 1106 : #ifndef NO_ERRNO
; 1107 : 			/* try to avoid the bug of testing an 8087 register value */
; 1108 : 			if (dword0(rv) == 0 && dword1(rv) == 0)

  00d3e	83 7d a4 00	 cmp	 DWORD PTR _rv$[ebp+4], 0
  00d42	75 4f		 jne	 SHORT $LN304@strtod_l
  00d44	83 7d a0 00	 cmp	 DWORD PTR _rv$[ebp], 0
  00d48	75 49		 jne	 SHORT $LN304@strtod_l

; 1109 : 				_set_errno(ERANGE);

  00d4a	e8 00 00 00 00	 call	 ___errno
  00d4f	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00d55	eb 3c		 jmp	 SHORT $LN304@strtod_l
$LN361@strtod_l:
  00d57	dd d8		 fstp	 ST(0)
$LN321@strtod_l:
  00d59	33 ff		 xor	 edi, edi
$ovfl$466:

; 462  : 			ovfl:
; 463  : #ifndef NO_ERRNO
; 464  : 				_set_errno(ERANGE);

  00d5b	e8 00 00 00 00	 call	 ___errno

; 465  : #endif
; 466  : 				/* Can't trust HUGE_VAL */
; 467  : #ifdef IEEE_Arith
; 468  : #ifdef Honor_FLT_ROUNDS
; 469  : 				switch (rounding) {
; 470  : 				case 0: /* toward 0 */
; 471  : 				case 3: /* toward -infinity */
; 472  : 					dword0(rv) = Big0;
; 473  : #ifndef _DOUBLE_IS_32BITS
; 474  : 					dword1(rv) = Big1;
; 475  : #endif /*!_DOUBLE_IS_32BITS*/
; 476  : 					break;
; 477  : 				default:
; 478  : 					dword0(rv) = Exp_mask;
; 479  : #ifndef _DOUBLE_IS_32BITS
; 480  : 					dword1(rv) = 0;
; 481  : #endif /*!_DOUBLE_IS_32BITS*/
; 482  : 				}
; 483  : #else /*Honor_FLT_ROUNDS*/
; 484  : 				dword0(rv) = Exp_mask;

  00d60	c7 45 a4 00 00
	f0 7f		 mov	 DWORD PTR _rv$[ebp+4], 2146435072 ; 7ff00000H

; 485  : #ifndef _DOUBLE_IS_32BITS
; 486  : 				dword1(rv) = 0;

  00d67	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _rv$[ebp], 0
  00d6e	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H

; 487  : #endif /*!_DOUBLE_IS_32BITS*/
; 488  : #endif /*Honor_FLT_ROUNDS*/
; 489  : #ifdef SET_INEXACT
; 490  : 				/* set overflow bit */
; 491  : 				dval(rv0) = 1e300;
; 492  : 				dval(rv0) *= dval(rv0);
; 493  : #endif
; 494  : #else /*IEEE_Arith*/
; 495  : 				dword0(rv) = Big0;
; 496  : #ifndef _DOUBLE_IS_32BITS
; 497  : 				dword1(rv) = Big1;
; 498  : #endif /*!_DOUBLE_IS_32BITS*/
; 499  : #endif /*IEEE_Arith*/
; 500  : 				if (bd0)

  00d74	85 ff		 test	 edi, edi
  00d76	0f 84 08 f4 ff
	ff		 je	 $LN276@strtod_l
  00d7c	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00d7f	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  00d82	eb 12		 jmp	 SHORT $retfree$470
$LN436@strtod_l:
  00d84	dd d8		 fstp	 ST(0)
$LN307@strtod_l:
  00d86	dd 45 a0	 fld	 QWORD PTR _rv$[ebp]
  00d89	8b 7d f8	 mov	 edi, DWORD PTR _bd0$1$[ebp]
  00d8c	dd 5d 98	 fstp	 QWORD PTR _rv$2$[ebp]
  00d8f	eb 05		 jmp	 SHORT $retfree$470
$LN440@strtod_l:
  00d91	dd d8		 fstp	 ST(0)
$LN304@strtod_l:
  00d93	8b 7d f8	 mov	 edi, DWORD PTR _bd0$1$[ebp]
$retfree$470:

; 1110 : #endif
; 1111 : 		}
; 1112 : #endif /* Avoid_Underflow */
; 1113 : #ifdef SET_INEXACT
; 1114 : 		if (inexact && !(dword0(rv) & Exp_mask)) {
; 1115 : 			/* set underflow bit */
; 1116 : 			dval(rv0) = 1e-300;
; 1117 : 			dval(rv0) *= dval(rv0);
; 1118 : 		}
; 1119 : #endif
; 1120 : 	retfree:
; 1121 : 		Bfree(bb);

  00d96	ff 75 f0	 push	 DWORD PTR _bb$[ebp]
  00d99	e8 00 00 00 00	 call	 __Bfree

; 1122 : 		Bfree(bd);

  00d9e	ff 75 e4	 push	 DWORD PTR _bd$1$[ebp]
  00da1	e8 00 00 00 00	 call	 __Bfree

; 1123 : 		Bfree(bs);

  00da6	ff 75 e8	 push	 DWORD PTR _bs$1$[ebp]
  00da9	e8 00 00 00 00	 call	 __Bfree

; 1124 : 		Bfree(bd0);

  00dae	57		 push	 edi
  00daf	e8 00 00 00 00	 call	 __Bfree

; 1125 : 		Bfree(delta);

  00db4	ff 75 dc	 push	 DWORD PTR _delta$1$[ebp]
  00db7	e8 00 00 00 00	 call	 __Bfree
  00dbc	83 c4 14	 add	 esp, 20			; 00000014H
$LN275@strtod_l:
  00dbf	8b 75 fc	 mov	 esi, DWORD PTR _s$[ebp]
$LN289@strtod_l:
  00dc2	dd 45 98	 fld	 QWORD PTR _rv$2$[ebp]
$LN325@strtod_l:
  00dc5	8b 4d f4	 mov	 ecx, DWORD PTR _sign$1$[ebp]
$ret$465:

; 1126 : 	ret:
; 1127 : 		if (se)

  00dc8	8b 45 0c	 mov	 eax, DWORD PTR _se$[ebp]
  00dcb	85 c0		 test	 eax, eax
  00dcd	74 02		 je	 SHORT $LN1@strtod_l

; 1128 : 			*se = (char *)s;

  00dcf	89 30		 mov	 DWORD PTR [eax], esi
$LN1@strtod_l:
  00dd1	5f		 pop	 edi
  00dd2	5e		 pop	 esi
  00dd3	5b		 pop	 ebx

; 1129 : 		return sign ? -dval(rv) : dval(rv);

  00dd4	85 c9		 test	 ecx, ecx
  00dd6	74 02		 je	 SHORT $LN205@strtod_l
  00dd8	d9 e0		 fchs
$LN205@strtod_l:

; 1130 : 	}

  00dda	8b e5		 mov	 esp, ebp
  00ddc	5d		 pop	 ebp
  00ddd	c3		 ret	 0
  00dde	8b ff		 npad	 2
$LN459@strtod_l:
  00de0	00 00 00 00	 DD	 $ret0$462
  00de4	00 00 00 00	 DD	 $LN194@strtod_l
  00de8	00 00 00 00	 DD	 $LN189@strtod_l
  00dec	00 00 00 00	 DD	 $LN190@strtod_l
  00df0	00 00 00 00	 DD	 $break2$461
$LN263@strtod_l:
  00df4	00		 DB	 0
  00df5	04		 DB	 4
  00df6	04		 DB	 4
  00df7	04		 DB	 4
  00df8	04		 DB	 4
  00df9	04		 DB	 4
  00dfa	04		 DB	 4
  00dfb	04		 DB	 4
  00dfc	04		 DB	 4
  00dfd	01		 DB	 1
  00dfe	01		 DB	 1
  00dff	01		 DB	 1
  00e00	01		 DB	 1
  00e01	01		 DB	 1
  00e02	04		 DB	 4
  00e03	04		 DB	 4
  00e04	04		 DB	 4
  00e05	04		 DB	 4
  00e06	04		 DB	 4
  00e07	04		 DB	 4
  00e08	04		 DB	 4
  00e09	04		 DB	 4
  00e0a	04		 DB	 4
  00e0b	04		 DB	 4
  00e0c	04		 DB	 4
  00e0d	04		 DB	 4
  00e0e	04		 DB	 4
  00e0f	04		 DB	 4
  00e10	04		 DB	 4
  00e11	04		 DB	 4
  00e12	04		 DB	 4
  00e13	04		 DB	 4
  00e14	01		 DB	 1
  00e15	04		 DB	 4
  00e16	04		 DB	 4
  00e17	04		 DB	 4
  00e18	04		 DB	 4
  00e19	04		 DB	 4
  00e1a	04		 DB	 4
  00e1b	04		 DB	 4
  00e1c	04		 DB	 4
  00e1d	04		 DB	 4
  00e1e	04		 DB	 4
  00e1f	02		 DB	 2
  00e20	04		 DB	 4
  00e21	03		 DB	 3
  00e22	8b ff		 npad	 2
$LN460@strtod_l:
  00e24	00 00 00 00	 DD	 $LN123@strtod_l
  00e28	00 00 00 00	 DD	 $LN120@strtod_l
  00e2c	00 00 00 00	 DD	 $ret0$462
$LN264@strtod_l:
  00e30	00		 DB	 0
  00e31	02		 DB	 2
  00e32	02		 DB	 2
  00e33	02		 DB	 2
  00e34	02		 DB	 2
  00e35	01		 DB	 1
  00e36	02		 DB	 2
  00e37	02		 DB	 2
  00e38	02		 DB	 2
  00e39	02		 DB	 2
  00e3a	02		 DB	 2
  00e3b	02		 DB	 2
  00e3c	02		 DB	 2
  00e3d	02		 DB	 2
  00e3e	02		 DB	 2
  00e3f	02		 DB	 2
  00e40	02		 DB	 2
  00e41	02		 DB	 2
  00e42	02		 DB	 2
  00e43	02		 DB	 2
  00e44	02		 DB	 2
  00e45	02		 DB	 2
  00e46	02		 DB	 2
  00e47	02		 DB	 2
  00e48	02		 DB	 2
  00e49	02		 DB	 2
  00e4a	02		 DB	 2
  00e4b	02		 DB	 2
  00e4c	02		 DB	 2
  00e4d	02		 DB	 2
  00e4e	02		 DB	 2
  00e4f	02		 DB	 2
  00e50	00		 DB	 0
  00e51	02		 DB	 2
  00e52	02		 DB	 2
  00e53	02		 DB	 2
  00e54	02		 DB	 2
  00e55	01		 DB	 1
__strtod_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\locale\setlocale.h
;	COMDAT ___get_current_locale
_TEXT	SEGMENT
___get_current_locale PROC				; COMDAT

; 229  : 	return __get_locale_r() ? 
; 230  : 		__get_locale_r() : __get_global_locale();

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ___global_locale

; 231  : }

  00005	c3		 ret	 0
___get_current_locale ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\locale\setlocale.h
;	COMDAT ___get_locale_r
_TEXT	SEGMENT
___get_locale_r PROC					; COMDAT

; 218  : 	/* Access the per thread storage locale */
; 219  : 	return NULL;

  00000	33 c0		 xor	 eax, eax

; 220  :   //return r->_locale;
; 221  : }

  00002	c3		 ret	 0
___get_locale_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\locale\setlocale.h
;	COMDAT ___get_global_locale
_TEXT	SEGMENT
___get_global_locale PROC				; COMDAT

; 211  :   extern struct __locale_t __global_locale;
; 212  :   return &__global_locale;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ___global_locale

; 213  : }

  00005	c3		 ret	 0
___get_global_locale ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtod.c
;	COMDAT _strtod
_TEXT	SEGMENT
_s00$ = 8						; size = 4
_se$ = 12						; size = 4
_strtod	PROC						; COMDAT

; 1134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1135 : 	return _strtod_l(s00, se, __get_current_locale());

  00003	68 00 00 00 00	 push	 OFFSET ___global_locale
  00008	ff 75 0c	 push	 DWORD PTR _se$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR _s00$[ebp]
  0000e	e8 00 00 00 00	 call	 __strtod_l
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1136 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_strtod	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtod.c
;	COMDAT _strtof
_TEXT	SEGMENT
_retval$1$ = -8						; size = 8
tv65 = -4						; size = 4
_s00$ = 8						; size = 4
_se$ = 12						; size = 4
_strtof	PROC						; COMDAT

; 1140 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1141 : 	double retval = _strtod_l(s00, se, __get_current_locale());

  00006	68 00 00 00 00	 push	 OFFSET ___global_locale
  0000b	ff 75 0c	 push	 DWORD PTR _se$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _s00$[ebp]
  00011	e8 00 00 00 00	 call	 __strtod_l

; 1142 : 	if (isnan(retval))

  00016	83 c4 04	 add	 esp, 4
  00019	dd 55 f8	 fst	 QWORD PTR _retval$1$[ebp]
  0001c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0001f	e8 00 00 00 00	 call	 ___isnan
  00024	83 c4 08	 add	 esp, 8
  00027	85 c0		 test	 eax, eax
  00029	74 0e		 je	 SHORT $LN1@strtof

; 1143 : 		return nanf(NULL);

  0002b	6a 00		 push	 0
  0002d	e8 00 00 00 00	 call	 _nanf
  00032	83 c4 04	 add	 esp, 4

; 1145 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN1@strtof:

; 1144 : 	return (float)retval;

  00039	dd 45 f8	 fld	 QWORD PTR _retval$1$[ebp]
  0003c	d9 5d fc	 fstp	 DWORD PTR tv65[ebp]
  0003f	d9 45 fc	 fld	 DWORD PTR tv65[ebp]

; 1145 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_strtof	ENDP
_TEXT	ENDS
END
