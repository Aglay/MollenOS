; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdlib\strtol.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtol
EXTRN	___locale_ctype_ptr:PROC
EXTRN	___errno:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtol.c
;	COMDAT _strtol
_TEXT	SEGMENT
_cutoff$1$ = -16					; size = 4
_cutlim$1$ = -12					; size = 4
_cutoff$2$ = -8						; size = 4
_neg$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_any$1$ = 16						; size = 4
_base$ = 16						; size = 4
_strtol	PROC						; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 49   : 	register const unsigned char *s = (const unsigned char *)nptr;

  00008	8b 7d 08	 mov	 edi, DWORD PTR _nptr$[ebp]

; 50   : 	register unsigned long acc;
; 51   : 	register int c;
; 52   : 	register unsigned long cutoff;
; 53   : 	register int neg = 0, any, cutlim;

  0000b	33 db		 xor	 ebx, ebx
  0000d	89 5d fc	 mov	 DWORD PTR _neg$1$[ebp], ebx
  00010	56		 push	 esi
$LL27@strtol:

; 54   : 
; 55   : 	/*
; 56   : 	* Skip white space and pick up leading +/- sign if any.
; 57   : 	* If base is 0, allow 0x for hex and 0 for octal, else
; 58   : 	* assume decimal; if base is already 16, allow 0x.
; 59   : 	*/
; 60   : 	do {
; 61   : 		c = *s++;

  00011	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00014	47		 inc	 edi

; 62   : 	} while (isspace(c));

  00015	e8 00 00 00 00	 call	 ___locale_ctype_ptr
  0001a	f6 44 30 01 08	 test	 BYTE PTR [eax+esi+1], 8
  0001f	75 f0		 jne	 SHORT $LL27@strtol

; 63   : 	if (c == '-') {

  00021	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  00024	75 0a		 jne	 SHORT $LN24@strtol

; 64   : 		neg = 1;

  00026	bb 01 00 00 00	 mov	 ebx, 1
  0002b	89 5d fc	 mov	 DWORD PTR _neg$1$[ebp], ebx

; 65   : 		c = *s++;

  0002e	eb 05		 jmp	 SHORT $LN40@strtol
$LN24@strtol:

; 66   : 	}
; 67   : 	else if (c == '+')

  00030	83 fe 2b	 cmp	 esi, 43			; 0000002bH
  00033	75 04		 jne	 SHORT $LN22@strtol
$LN40@strtol:

; 68   : 		c = *s++;

  00035	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00038	47		 inc	 edi
$LN22@strtol:

; 69   : 	if ((base == 0 || base == 16) &&
; 70   : 		c == '0' && (*s == 'x' || *s == 'X')) {

  00039	8b 4d 10	 mov	 ecx, DWORD PTR _base$[ebp]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 05		 je	 SHORT $LN20@strtol
  00040	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00043	75 1d		 jne	 SHORT $LN21@strtol
$LN20@strtol:
  00045	83 fe 30	 cmp	 esi, 48			; 00000030H
  00048	75 18		 jne	 SHORT $LN21@strtol
  0004a	8a 07		 mov	 al, BYTE PTR [edi]
  0004c	3c 78		 cmp	 al, 120			; 00000078H
  0004e	74 04		 je	 SHORT $LN19@strtol
  00050	3c 58		 cmp	 al, 88			; 00000058H
  00052	75 0e		 jne	 SHORT $LN21@strtol
$LN19@strtol:

; 71   : 		c = s[1];

  00054	0f b6 77 01	 movzx	 esi, BYTE PTR [edi+1]

; 72   : 		s += 2;
; 73   : 		base = 16;

  00058	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0005d	83 c7 02	 add	 edi, 2

; 74   : 	}
; 75   : 	if (base == 0)

  00060	eb 11		 jmp	 SHORT $LN18@strtol
$LN21@strtol:
  00062	85 c9		 test	 ecx, ecx
  00064	75 0d		 jne	 SHORT $LN18@strtol

; 76   : 		base = c == '0' ? 8 : 10;

  00066	83 fe 30	 cmp	 esi, 48			; 00000030H
  00069	0f 95 c1	 setne	 cl
  0006c	8d 0c 4d 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+8]
$LN18@strtol:

; 77   : 
; 78   : 	/*
; 79   : 	* Compute the cutoff value between legal numbers and illegal
; 80   : 	* numbers.  That is the largest legal value, divided by the
; 81   : 	* base.  An input number that is greater than this value, if
; 82   : 	* followed by a legal input character, is too big.  One that
; 83   : 	* is equal to this value may be valid or not; the limit
; 84   : 	* between valid and invalid numbers is then based on the last
; 85   : 	* digit.  For instance, if the range for longs is
; 86   : 	* [-2147483648..2147483647] and the input base is 10,
; 87   : 	* cutoff will be set to 214748364 and cutlim to either
; 88   : 	* 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
; 89   : 	* a value > 214748364, or equal but the next digit is > 7 (or 8),
; 90   : 	* the number is too big, and we will return a range error.
; 91   : 	*
; 92   : 	* Set any if any `digits' consumed; make it negative to indicate
; 93   : 	* overflow.
; 94   : 	*/
; 95   : 	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;

  00073	33 c0		 xor	 eax, eax
  00075	85 db		 test	 ebx, ebx
  00077	0f 95 c0	 setne	 al

; 96   : 	cutlim = cutoff % (unsigned long)base;

  0007a	33 d2		 xor	 edx, edx
  0007c	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH

; 97   : 	cutoff /= (unsigned long)base;
; 98   : 	for (acc = 0, any = 0;; c = *s++) {

  00081	33 db		 xor	 ebx, ebx
  00083	89 45 f0	 mov	 DWORD PTR _cutoff$1$[ebp], eax
  00086	f7 f1		 div	 ecx
  00088	89 55 f4	 mov	 DWORD PTR _cutlim$1$[ebp], edx
  0008b	33 d2		 xor	 edx, edx
  0008d	89 45 f8	 mov	 DWORD PTR _cutoff$2$[ebp], eax
$LL17@strtol:

; 99   : 		if (c >= '0' && c <= '9')

  00090	8d 46 d0	 lea	 eax, DWORD PTR [esi-48]
  00093	83 f8 09	 cmp	 eax, 9
  00096	77 04		 ja	 SHORT $LN14@strtol

; 100  : 			c -= '0';

  00098	8b f0		 mov	 esi, eax
  0009a	eb 18		 jmp	 SHORT $LN9@strtol
$LN14@strtol:

; 101  : 		else if (c >= 'A' && c <= 'Z')

  0009c	8d 46 bf	 lea	 eax, DWORD PTR [esi-65]
  0009f	83 f8 19	 cmp	 eax, 25			; 00000019H
  000a2	77 05		 ja	 SHORT $LN12@strtol

; 102  : 			c -= 'A' - 10;

  000a4	83 ee 37	 sub	 esi, 55			; 00000037H
  000a7	eb 0b		 jmp	 SHORT $LN9@strtol
$LN12@strtol:

; 103  : 		else if (c >= 'a' && c <= 'z')

  000a9	8d 46 9f	 lea	 eax, DWORD PTR [esi-97]
  000ac	83 f8 19	 cmp	 eax, 25			; 00000019H
  000af	77 32		 ja	 SHORT $LN34@strtol

; 104  : 			c -= 'a' - 10;

  000b1	83 ee 57	 sub	 esi, 87			; 00000057H
$LN9@strtol:

; 105  : 		else
; 106  : 			break;
; 107  : 		if (c >= base)

  000b4	3b f1		 cmp	 esi, ecx
  000b6	7d 2b		 jge	 SHORT $LN34@strtol

; 108  : 			break;
; 109  : 		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000b8	85 d2		 test	 edx, edx
  000ba	78 1e		 js	 SHORT $LN6@strtol
  000bc	8b 45 f8	 mov	 eax, DWORD PTR _cutoff$2$[ebp]
  000bf	3b d8		 cmp	 ebx, eax
  000c1	77 17		 ja	 SHORT $LN6@strtol
  000c3	75 05		 jne	 SHORT $LN7@strtol
  000c5	3b 75 f4	 cmp	 esi, DWORD PTR _cutlim$1$[ebp]
  000c8	7f 10		 jg	 SHORT $LN6@strtol
$LN7@strtol:

; 111  : 		else {
; 112  : 			any = 1;
; 113  : 			acc *= base;

  000ca	0f af d9	 imul	 ebx, ecx
  000cd	ba 01 00 00 00	 mov	 edx, 1

; 114  : 			acc += c;

  000d2	03 de		 add	 ebx, esi
  000d4	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  000d7	47		 inc	 edi
  000d8	eb b6		 jmp	 SHORT $LL17@strtol
$LN6@strtol:

; 97   : 	cutoff /= (unsigned long)base;
; 98   : 	for (acc = 0, any = 0;; c = *s++) {

  000da	0f b6 37	 movzx	 esi, BYTE PTR [edi]

; 110  : 			any = -1;

  000dd	83 ca ff	 or	 edx, -1
  000e0	47		 inc	 edi
  000e1	eb ad		 jmp	 SHORT $LL17@strtol
$LN34@strtol:
  000e3	89 55 10	 mov	 DWORD PTR _any$1$[ebp], edx
  000e6	5e		 pop	 esi

; 115  : 		}
; 116  : 	}
; 117  : 	if (any < 0) {

  000e7	85 d2		 test	 edx, edx
  000e9	79 13		 jns	 SHORT $LN4@strtol

; 118  : 		acc = neg ? LONG_MIN : LONG_MAX;

  000eb	8b 5d f0	 mov	 ebx, DWORD PTR _cutoff$1$[ebp]

; 119  : 		_set_errno(ERANGE);

  000ee	e8 00 00 00 00	 call	 ___errno
  000f3	8b 55 10	 mov	 edx, DWORD PTR _any$1$[ebp]
  000f6	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  000fc	eb 08		 jmp	 SHORT $LN2@strtol
$LN4@strtol:

; 120  : 	}
; 121  : 	else if (neg)

  000fe	83 7d fc 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  00102	74 02		 je	 SHORT $LN2@strtol

; 122  : 		acc = -acc;

  00104	f7 db		 neg	 ebx
$LN2@strtol:

; 123  : 	if (endptr != 0)

  00106	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  00109	85 c0		 test	 eax, eax
  0010b	74 0c		 je	 SHORT $LN39@strtol

; 124  : 		*endptr = (char *)(any ? (char *)s - 1 : nptr);

  0010d	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  00110	85 d2		 test	 edx, edx
  00112	75 03		 jne	 SHORT $LN31@strtol
  00114	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
$LN31@strtol:
  00117	89 08		 mov	 DWORD PTR [eax], ecx
$LN39@strtol:
  00119	5f		 pop	 edi

; 125  : 	return (acc);

  0011a	8b c3		 mov	 eax, ebx
  0011c	5b		 pop	 ebx

; 126  : }

  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
_strtol	ENDP
_TEXT	ENDS
END
