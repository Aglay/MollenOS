; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\math\scalbn.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_two54	DQ	04350000000000000r		; 1.80144e+016
_twom54	DQ	03c90000000000000r		; 5.55112e-017
_huge	DQ	07e37e43c8800759cr		; 1e+300
_tiny	DQ	001a56e1fc2f8f359r		; 1e-300
CONST	ENDS
PUBLIC	___fpclassifyl
PUBLIC	___fpclassifyf
PUBLIC	___fpclassify
PUBLIC	___isnan
PUBLIC	___isnanf
PUBLIC	___isnanl
PUBLIC	___signbit
PUBLIC	___signbitf
PUBLIC	___signbitl
PUBLIC	_scalbn
PUBLIC	__real@01a56e1fc2f8f359
PUBLIC	__real@3c90000000000000
PUBLIC	__real@4350000000000000
PUBLIC	__real@7e37e43c8800759c
EXTRN	_copysign:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@4350000000000000
CONST	SEGMENT
__real@4350000000000000 DQ 04350000000000000r	; 1.80144e+016
CONST	ENDS
;	COMDAT __real@3c90000000000000
CONST	SEGMENT
__real@3c90000000000000 DQ 03c90000000000000r	; 5.55112e-017
CONST	ENDS
;	COMDAT __real@01a56e1fc2f8f359
CONST	SEGMENT
__real@01a56e1fc2f8f359 DQ 001a56e1fc2f8f359r	; 1e-300
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\math\scalbn.c
;	COMDAT _scalbn
_TEXT	SEGMENT
_x$ = 8							; size = 8
_n$ = 16						; size = 4
_scalbn	PROC						; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	int  k,hx,lx;
; 32   : 	hx = __HI(x);
; 33   : 	lx = __LO(x);
; 34   : 	k = (hx&0x7ff00000)>>20;		/* extract exponent */

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp+4]
  00006	8b c1		 mov	 eax, ecx

; 35   : 	if (k==0) {				/* 0 or subnormal x */

  00008	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]

; 36   : 		if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */

  0000b	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  0000e	c1 f8 14	 sar	 eax, 20			; 00000014H
  00011	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00016	75 30		 jne	 SHORT $LN7@scalbn
  00018	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  0001e	0b 4d 08	 or	 ecx, DWORD PTR _x$[ebp]
  00021	0f 84 b7 00 00
	00		 je	 $LN10@scalbn

; 37   : 		x *= two54; 

  00027	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4350000000000000
  0002d	dd 55 08	 fst	 QWORD PTR _x$[ebp]

; 38   : 		hx = __HI(x);
; 39   : 		k = ((hx&0x7ff00000)>>20) - 54; 

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp+4]
  00033	8b c1		 mov	 eax, ecx
  00035	c1 f8 14	 sar	 eax, 20			; 00000014H
  00038	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0003d	83 e8 36	 sub	 eax, 54			; 00000036H

; 40   : 		if (n< -50000) return tiny*x; 	/*underflow*/

  00040	81 fa b0 3c ff
	ff		 cmp	 edx, -50000		; ffff3cb0H
  00046	7c 72		 jl	 SHORT $LN31@scalbn
$LN7@scalbn:

; 41   : 	}
; 42   : 	if (k==0x7ff) return x+x;		/* NaN or Inf */

  00048	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  0004d	75 04		 jne	 SHORT $LN6@scalbn
  0004f	dc c0		 fadd	 ST(0), ST(0)

; 54   : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN6@scalbn:

; 43   : 	k = k+n; 

  00053	03 c2		 add	 eax, edx

; 44   : 	if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */

  00055	3d fe 07 00 00	 cmp	 eax, 2046		; 000007feH
  0005a	7e 20		 jle	 SHORT $LN5@scalbn
  0005c	83 ec 10	 sub	 esp, 16			; 00000010H
  0005f	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
$LN32@scalbn:
  00063	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@7e37e43c8800759c
  00069	dd 1c 24	 fstp	 QWORD PTR [esp]
  0006c	e8 00 00 00 00	 call	 _copysign
  00071	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@7e37e43c8800759c
  00077	83 c4 10	 add	 esp, 16			; 00000010H

; 54   : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN5@scalbn:

; 45   : 	if (k > 0) 				/* normal result */

  0007c	85 c0		 test	 eax, eax
  0007e	7e 15		 jle	 SHORT $LN4@scalbn

; 46   : 	{__HI(x) = (hx&0x800fffff)|(k<<20); return x;}

  00080	c1 e0 14	 shl	 eax, 20			; 00000014H
  00083	81 e1 ff ff 0f
	80		 and	 ecx, -2146435073	; 800fffffH
  00089	0b c1		 or	 eax, ecx
  0008b	dd d8		 fstp	 ST(0)
  0008d	89 45 0c	 mov	 DWORD PTR _x$[ebp+4], eax
  00090	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 54   : }

  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN4@scalbn:

; 47   : 	if (k <= -54)

  00095	83 f8 ca	 cmp	 eax, -54		; ffffffcaH
  00098	7f 28		 jg	 SHORT $LN26@scalbn

; 48   : 		if (n > 50000) 	/* in case integer overflow in n+k */
; 49   : 			return huge*copysign(huge,x);	/*overflow*/

  0009a	83 ec 10	 sub	 esp, 16			; 00000010H
  0009d	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  000a1	81 fa 50 c3 00
	00		 cmp	 edx, 50000		; 0000c350H
  000a7	7f ba		 jg	 SHORT $LN32@scalbn

; 50   : 		else return tiny*copysign(tiny,x); 	/*underflow*/

  000a9	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@01a56e1fc2f8f359
  000af	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b2	e8 00 00 00 00	 call	 _copysign
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN31@scalbn:
  000ba	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@01a56e1fc2f8f359

; 54   : }

  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
$LN26@scalbn:

; 51   : 		k += 54;				/* subnormal result */
; 52   : 		__HI(x) = (hx&0x800fffff)|(k<<20);

  000c2	83 c0 36	 add	 eax, 54			; 00000036H
  000c5	81 e1 ff ff 0f
	80		 and	 ecx, -2146435073	; 800fffffH
  000cb	c1 e0 14	 shl	 eax, 20			; 00000014H
  000ce	dd d8		 fstp	 ST(0)
  000d0	0b c1		 or	 eax, ecx
  000d2	89 45 0c	 mov	 DWORD PTR _x$[ebp+4], eax

; 53   : 		return x*twom54;

  000d5	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000d8	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3c90000000000000
$LN10@scalbn:

; 54   : }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_scalbn	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___signbitl
_TEXT	SEGMENT
_stw$ = -4						; size = 2
_x$ = 8							; size = 8
___signbitl PROC					; COMDAT

; 271  : __CRT_INLINE int __cdecl __signbitl(long double x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 272  : 	unsigned short stw;
; 273  : #if defined(_MSC_VER)
; 274  : 	_asm {
; 275  : 		fld [x];

  00004	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 276  : 		fxam;

  00007	d9 e5		 fxam

; 277  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 278  : 		mov word ptr[stw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _stw$[ebp], ax

; 279  : 	}
; 280  : #else
; 281  : 	__asm__ __volatile__("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
; 282  : #endif
; 283  : 	return stw & 0x0200;

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _stw$[ebp]
  00014	25 00 02 00 00	 and	 eax, 512		; 00000200H

; 284  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
___signbitl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___signbitf
_TEXT	SEGMENT
_stw$ = -4						; size = 2
_x$ = 8							; size = 4
___signbitf PROC					; COMDAT

; 256  : __CRT_INLINE int __cdecl __signbitf(float x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 257  : 	unsigned short stw;
; 258  : #if defined(_MSC_VER)
; 259  : 	_asm {
; 260  : 		fld [x];

  00004	d9 45 08	 fld	 DWORD PTR _x$[ebp]

; 261  : 		fxam;

  00007	d9 e5		 fxam

; 262  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 263  : 		mov word ptr[stw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _stw$[ebp], ax

; 264  : 	}
; 265  : #else
; 266  : 	__asm__ __volatile__("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
; 267  : #endif
; 268  : 	return stw & 0x0200;

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _stw$[ebp]
  00014	25 00 02 00 00	 and	 eax, 512		; 00000200H

; 269  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
___signbitf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___signbit
_TEXT	SEGMENT
_stw$ = -4						; size = 2
_x$ = 8							; size = 8
___signbit PROC						; COMDAT

; 241  : __CRT_INLINE int __cdecl __signbit(double x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  : 	unsigned short stw;
; 243  : #if defined(_MSC_VER)
; 244  : 	_asm {
; 245  : 		fld [x];

  00004	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 246  : 		fxam;

  00007	d9 e5		 fxam

; 247  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 248  : 		mov word ptr[stw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _stw$[ebp], ax

; 249  : 	}
; 250  : #else
; 251  : 	__asm__ __volatile__("fxam; fstsw %%ax;": "=a" (stw) : "t" (x));
; 252  : #endif
; 253  : 	return stw & 0x0200;

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _stw$[ebp]
  00014	25 00 02 00 00	 and	 eax, 512		; 00000200H

; 254  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
___signbit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___isnanl
_TEXT	SEGMENT
_sw$ = -4						; size = 2
__x$ = 8						; size = 8
___isnanl PROC						; COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 212  : 	unsigned short sw;
; 213  : #if defined(_MSC_VER)
; 214  : 	_asm {
; 215  : 		fld [_x];

  00004	dd 45 08	 fld	 QWORD PTR __x$[ebp]

; 216  : 		fxam;

  00007	d9 e5		 fxam

; 217  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 218  : 		mov word ptr[sw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _sw$[ebp], ax

; 219  : 	}
; 220  : #else
; 221  : 	__asm__ __volatile__("fxam;"
; 222  : 		"fstsw %%ax": "=a" (sw) : "t" (_x));
; 223  : #endif
; 224  : 	return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
; 225  : 		== FP_NAN;

  00010	0f b7 4d fc	 movzx	 ecx, WORD PTR _sw$[ebp]
  00014	33 c0		 xor	 eax, eax
  00016	81 e1 00 45 00
	00		 and	 ecx, 17664		; 00004500H
  0001c	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00022	0f 94 c0	 sete	 al

; 226  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
___isnanl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___isnanf
_TEXT	SEGMENT
_sw$ = -4						; size = 2
__x$ = 8						; size = 4
___isnanf PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 194  : 	unsigned short sw;
; 195  : #if defined(_MSC_VER)
; 196  : 	_asm {
; 197  : 		fld [_x];

  00004	d9 45 08	 fld	 DWORD PTR __x$[ebp]

; 198  : 		fxam;

  00007	d9 e5		 fxam

; 199  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 200  : 		mov word ptr[sw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _sw$[ebp], ax

; 201  : 	}
; 202  : #else
; 203  : 	__asm__ __volatile__("fxam;"
; 204  : 		"fstsw %%ax": "=a" (sw) : "t" (_x));
; 205  : #endif
; 206  : 	return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
; 207  : 		== FP_NAN;

  00010	0f b7 4d fc	 movzx	 ecx, WORD PTR _sw$[ebp]
  00014	33 c0		 xor	 eax, eax
  00016	81 e1 00 45 00
	00		 and	 ecx, 17664		; 00004500H
  0001c	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00022	0f 94 c0	 sete	 al

; 208  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
___isnanf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___isnan
_TEXT	SEGMENT
_sw$ = -4						; size = 2
__x$ = 8						; size = 8
___isnan PROC						; COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 176  : 	unsigned short sw;
; 177  : #if defined(_MSC_VER)
; 178  : 	_asm {
; 179  : 		fld [_x];

  00004	dd 45 08	 fld	 QWORD PTR __x$[ebp]

; 180  : 		fxam;

  00007	d9 e5		 fxam

; 181  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 182  : 		mov word ptr[sw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _sw$[ebp], ax

; 183  : 	}
; 184  : #else
; 185  : 	__asm__ __volatile__("fxam;"
; 186  : 		"fstsw %%ax": "=a" (sw) : "t" (_x));
; 187  : #endif
; 188  : 	return (sw & (FP_NAN | FP_NORMAL | FP_INFINITE | FP_ZERO | FP_SUBNORMAL))
; 189  : 		== FP_NAN;

  00010	0f b7 4d fc	 movzx	 ecx, WORD PTR _sw$[ebp]
  00014	33 c0		 xor	 eax, eax
  00016	81 e1 00 45 00
	00		 and	 ecx, 17664		; 00004500H
  0001c	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00022	0f 94 c0	 sete	 al

; 190  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
___isnan ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___fpclassify
_TEXT	SEGMENT
_sw$ = -4						; size = 2
_x$ = 8							; size = 8
___fpclassify PROC					; COMDAT

; 125  : __CRT_INLINE int __cdecl __fpclassify(double x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 126  : 	unsigned short sw;
; 127  : #if defined(_MSC_VER)
; 128  : 	_asm {
; 129  : 		fld [x];

  00004	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 130  : 		fxam;

  00007	d9 e5		 fxam

; 131  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 132  : 		mov word ptr[sw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _sw$[ebp], ax

; 133  : 	}
; 134  : #else
; 135  : 	__asm__ __volatile__("fxam; fstsw %%ax;" : "=a" (sw) : "t" (x));
; 136  : #endif
; 137  : 	return sw & (FP_NAN | FP_NORMAL | FP_ZERO);

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _sw$[ebp]
  00014	25 00 45 00 00	 and	 eax, 17664		; 00004500H

; 138  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
___fpclassify ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___fpclassifyf
_TEXT	SEGMENT
_sw$ = -4						; size = 2
_x$ = 8							; size = 4
___fpclassifyf PROC					; COMDAT

; 139  : __CRT_INLINE int __cdecl __fpclassifyf(float x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 140  : 	unsigned short sw;
; 141  : #if defined(_MSC_VER)
; 142  : 	_asm {
; 143  : 		fld [x];

  00004	d9 45 08	 fld	 DWORD PTR _x$[ebp]

; 144  : 		fxam;

  00007	d9 e5		 fxam

; 145  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 146  : 		mov word ptr[sw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _sw$[ebp], ax

; 147  : 	}
; 148  : #else
; 149  : 	__asm__ __volatile__("fxam; fstsw %%ax;" : "=a" (sw) : "t" (x));
; 150  : #endif
; 151  : 	return sw & (FP_NAN | FP_NORMAL | FP_ZERO);

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _sw$[ebp]
  00014	25 00 45 00 00	 and	 eax, 17664		; 00004500H

; 152  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
___fpclassifyf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\include\math.h
;	COMDAT ___fpclassifyl
_TEXT	SEGMENT
_sw$ = -4						; size = 2
_x$ = 8							; size = 8
___fpclassifyl PROC					; COMDAT

; 111  : __CRT_INLINE int __cdecl __fpclassifyl(long double x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 112  : 	unsigned short sw;
; 113  : #if defined(_MSC_VER)
; 114  : 	_asm {
; 115  : 		fld [x];

  00004	dd 45 08	 fld	 QWORD PTR _x$[ebp]

; 116  : 		fxam;

  00007	d9 e5		 fxam

; 117  : 		fstsw ax;

  00009	9b df e0	 fstsw	 ax

; 118  : 		mov word ptr [sw], ax;

  0000c	66 89 45 fc	 mov	 WORD PTR _sw$[ebp], ax

; 119  : 	}
; 120  : #else
; 121  : 	__asm__ __volatile__("fxam; fstsw %%ax;" : "=a" (sw) : "t" (x));
; 122  : #endif
; 123  : 	return sw & (FP_NAN | FP_NORMAL | FP_ZERO);

  00010	0f b7 45 fc	 movzx	 eax, WORD PTR _sw$[ebp]
  00014	25 00 45 00 00	 and	 eax, 17664		; 00004500H

; 124  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
___fpclassifyl ENDP
_TEXT	ENDS
END
