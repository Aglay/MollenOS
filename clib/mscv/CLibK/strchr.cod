; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strchr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strchr
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strchr.c
;	COMDAT _strchr
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_i$ = 12						; size = 4
_strchr	PROC						; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	const unsigned char *s = (const unsigned char *)s1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00006	53		 push	 ebx

; 64   : 	unsigned char c = (unsigned char)i;
; 65   : 	unsigned long mask,j;
; 66   : 	unsigned long *aligned_addr;
; 67   : 
; 68   : 	/* Special case for finding 0.  */
; 69   : 	if (!c)

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _i$[ebp]
  0000a	84 db		 test	 bl, bl
  0000c	75 50		 jne	 SHORT $LN26@strchr

; 70   : 	{
; 71   : 		while (_strchrUNALIGNED (s))

  0000e	a8 03		 test	 al, 3
  00010	74 0e		 je	 SHORT $LN18@strchr
$LL19@strchr:

; 72   : 		{
; 73   : 			if (!*s)

  00012	80 38 00	 cmp	 BYTE PTR [eax], 0
  00015	0f 84 d7 00 00
	00		 je	 $LN21@strchr

; 74   : 				return (char *) s;
; 75   : 			s++;

  0001b	40		 inc	 eax
  0001c	a8 03		 test	 al, 3
  0001e	75 f2		 jne	 SHORT $LL19@strchr
$LN18@strchr:

; 76   : 		}
; 77   : 		/* Operate a word at a time.  */
; 78   : 		aligned_addr = (unsigned long *) s;
; 79   : 		while (!DETECTNULL (*aligned_addr))

  00020	8b 10		 mov	 edx, DWORD PTR [eax]
  00022	8d 8a ff fe fe
	fe		 lea	 ecx, DWORD PTR [edx-16843009]
  00028	f7 d2		 not	 edx
  0002a	23 ca		 and	 ecx, edx
  0002c	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00032	75 18		 jne	 SHORT $LN15@strchr
$LL16@strchr:
  00034	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 80   : 			aligned_addr++;

  00037	83 c0 04	 add	 eax, 4
  0003a	8d 8a ff fe fe
	fe		 lea	 ecx, DWORD PTR [edx-16843009]
  00040	f7 d2		 not	 edx
  00042	23 ca		 and	 ecx, edx
  00044	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  0004a	74 e8		 je	 SHORT $LL16@strchr
$LN15@strchr:

; 81   : 		/* Found the end of string.  */
; 82   : 		s = (const unsigned char *) aligned_addr;
; 83   : 		while (*s) s++;

  0004c	80 38 00	 cmp	 BYTE PTR [eax], 0
  0004f	0f 84 9d 00 00
	00		 je	 $LN21@strchr
$LL14@strchr:
  00055	40		 inc	 eax
  00056	80 38 00	 cmp	 BYTE PTR [eax], 0
  00059	75 fa		 jne	 SHORT $LL14@strchr
  0005b	5b		 pop	 ebx

; 116  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN26@strchr:

; 84   : 		return (char *) s;
; 85   : 	}
; 86   : 
; 87   : 	/* All other bytes.  Align the pointer, then search a long at a time.  */
; 88   : 	while (_strchrUNALIGNED (s))

  0005e	a8 03		 test	 al, 3
  00060	74 17		 je	 SHORT $LN11@strchr
$LL12@strchr:

; 89   : 	{
; 90   : 		if (!*s)

  00062	8a 08		 mov	 cl, BYTE PTR [eax]
  00064	84 c9		 test	 cl, cl
  00066	0f 84 84 00 00
	00		 je	 $LN1@strchr

; 91   : 			return NULL;
; 92   : 		if (*s == c)

  0006c	3a cb		 cmp	 cl, bl
  0006e	0f 84 7e 00 00
	00		 je	 $LN21@strchr

; 93   : 			return (char *) s;
; 94   : 		s++;

  00074	40		 inc	 eax
  00075	a8 03		 test	 al, 3
  00077	75 e9		 jne	 SHORT $LL12@strchr
$LN11@strchr:
  00079	56		 push	 esi
  0007a	57		 push	 edi

; 95   : 	}
; 96   : 
; 97   : 	mask = c;

  0007b	0f b6 fb	 movzx	 edi, bl

; 98   : 	for (j = 8; j < LBLOCKSIZE * 8; j <<= 1)

  0007e	b9 08 00 00 00	 mov	 ecx, 8
$LL8@strchr:

; 99   : 		mask = (mask << j) | mask;

  00083	8b d7		 mov	 edx, edi
  00085	d3 e2		 shl	 edx, cl
  00087	03 c9		 add	 ecx, ecx
  00089	0b fa		 or	 edi, edx
  0008b	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0008e	72 f3		 jb	 SHORT $LL8@strchr

; 100  : 
; 101  : 	aligned_addr = (unsigned long *) s;
; 102  : 	while (!DETECTNULL (*aligned_addr) && !DETECTCHAR (*aligned_addr, mask))

  00090	8b 30		 mov	 esi, DWORD PTR [eax]
  00092	8b ce		 mov	 ecx, esi
  00094	f7 d1		 not	 ecx
  00096	8d 96 ff fe fe
	fe		 lea	 edx, DWORD PTR [esi-16843009]
  0009c	23 d1		 and	 edx, ecx
  0009e	f7 c2 80 80 80
	80		 test	 edx, -2139062144	; 80808080H
  000a4	75 2e		 jne	 SHORT $LN55@strchr
$LL5@strchr:
  000a6	33 f7		 xor	 esi, edi
  000a8	8d 8e ff fe fe
	fe		 lea	 ecx, DWORD PTR [esi-16843009]
  000ae	f7 d6		 not	 esi
  000b0	23 ce		 and	 ecx, esi
  000b2	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  000b8	75 1a		 jne	 SHORT $LN55@strchr
  000ba	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 103  : 		aligned_addr++;

  000bd	83 c0 04	 add	 eax, 4
  000c0	8b ce		 mov	 ecx, esi
  000c2	f7 d1		 not	 ecx
  000c4	8d 96 ff fe fe
	fe		 lea	 edx, DWORD PTR [esi-16843009]
  000ca	23 d1		 and	 edx, ecx
  000cc	f7 c2 80 80 80
	80		 test	 edx, -2139062144	; 80808080H
  000d2	74 d2		 je	 SHORT $LL5@strchr
$LN55@strchr:

; 104  : 
; 105  : 	/* The block of bytes currently pointed to by aligned_addr
; 106  : 		contains either a null or the target char, or both.  We
; 107  : 		catch it using the bytewise search.  */
; 108  : 
; 109  : 	s = (unsigned char *) aligned_addr;
; 110  : 
; 111  : 	while (*s && *s != c)

  000d4	8a 08		 mov	 cl, BYTE PTR [eax]
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	84 c9		 test	 cl, cl
  000da	74 10		 je	 SHORT $LN2@strchr
  000dc	8d 64 24 00	 npad	 4
$LL3@strchr:
  000e0	3a cb		 cmp	 cl, bl
  000e2	74 0e		 je	 SHORT $LN21@strchr
  000e4	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 112  : 		s++;

  000e7	40		 inc	 eax
  000e8	84 c9		 test	 cl, cl
  000ea	75 f4		 jne	 SHORT $LL3@strchr
$LN2@strchr:

; 113  : 	if (*s == c)

  000ec	38 18		 cmp	 BYTE PTR [eax], bl
  000ee	74 02		 je	 SHORT $LN21@strchr
$LN1@strchr:

; 114  : 		return (char *)s;
; 115  : 	return NULL;

  000f0	33 c0		 xor	 eax, eax
$LN21@strchr:
  000f2	5b		 pop	 ebx

; 116  : }

  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
_strchr	ENDP
_TEXT	ENDS
END
