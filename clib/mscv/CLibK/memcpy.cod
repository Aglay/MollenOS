; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\mem\memcpy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	___GlbMemCpyInstance
_BSS	SEGMENT
___GlbMemCpyInstance DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_memcpy
PUBLIC	_MemCpyBase
PUBLIC	_MemCpySSE
PUBLIC	_MemCpyMMX
PUBLIC	_MemCpySelect
EXTRN	_asm_memcpy_mmx:PROC
EXTRN	_asm_memcpy_sse:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\mem\memcpy.c
;	COMDAT _MemCpySelect
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Source$ = 12						; size = 4
_Count$ = 16						; size = 4
_MemCpySelect PROC					; COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 143  : 	/* Variables */
; 144  : 	uint32_t CpuFeatEcx = 0;
; 145  : 	uint32_t CpuFeatEdx = 0;
; 146  : 
; 147  : 	/* Now extract the cpu information 
; 148  : 	 * so we can select a memcpy */
; 149  : #ifdef _MSC_VER
; 150  : 	int CpuInfo[4] = { 0 };
; 151  : 	__cpuid(CpuInfo, 1);
; 152  : 	CpuFeatEcx = CpuInfo[2];
; 153  : #else
; 154  : 	int unused = 0;
; 155  : 	__cpuid(1, unused, unused, CpuFeatEcx, CpuFeatEdx);
; 156  : #endif
; 157  : 
; 158  : 	/* Now do the select */
; 159  : 	if (CpuFeatEdx & CPUID_FEAT_EDX_SSE) {
; 160  : 		__GlbMemCpyInstance = MemCpySSE;
; 161  : 		return MemCpySSE(Destination, Source, Count);
; 162  : 	}
; 163  : 	else if (CpuFeatEdx & CPUID_FEAT_EDX_MMX) {
; 164  : 		__GlbMemCpyInstance = MemCpyMMX;
; 165  : 		return MemCpyMMX(Destination, Source, Count);
; 166  : 	}
; 167  : 	else {
; 168  : 		__GlbMemCpyInstance = MemCpyBase;

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ___GlbMemCpyInstance, OFFSET _MemCpyBase
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 169  : 		return MemCpyBase(Destination, Source, Count);

  00012	ff 75 10	 push	 DWORD PTR _Count$[ebp]
  00015	ff 75 0c	 push	 DWORD PTR _Source$[ebp]
  00018	ff 75 08	 push	 DWORD PTR _Destination$[ebp]
  0001b	e8 00 00 00 00	 call	 _MemCpyBase
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx

; 170  : 	}
; 171  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_MemCpySelect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\mem\memcpy.c
;	COMDAT _MemCpyMMX
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Source$ = 12						; size = 4
_Count$ = 16						; size = 4
_MemCpyMMX PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : 	/* Loop Count */
; 78   : 	uint32_t MmxLoops = Count / 8;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _Count$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	c1 e8 03	 shr	 eax, 3

; 80   : 
; 81   : 	/* Sanity, we don't want to go through the
; 82   : 	* overhead if it's less than a certain threshold */
; 83   : 	if (MmxLoops < MEMCPY_ACCEL_THRESHOLD) {

  0000b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0000e	73 09		 jae	 SHORT $LN1@MemCpyMMX

; 84   : 		return MemCpyBase(Destination, Source, Count);

  00010	89 4d 10	 mov	 DWORD PTR _Count$[ebp], ecx

; 92   : }

  00013	5d		 pop	 ebp

; 84   : 		return MemCpyBase(Destination, Source, Count);

  00014	e9 00 00 00 00	 jmp	 _MemCpyBase
$LN1@MemCpyMMX:

; 79   : 	uint32_t mBytes = Count % 8;

  00019	83 e1 07	 and	 ecx, 7

; 85   : 	}
; 86   : 
; 87   : 	/* Call asm */
; 88   : 	asm_memcpy_mmx(Destination, Source, MmxLoops, mBytes);

  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	ff 75 0c	 push	 DWORD PTR _Source$[ebp]
  00021	ff 75 08	 push	 DWORD PTR _Destination$[ebp]
  00024	e8 00 00 00 00	 call	 _asm_memcpy_mmx

; 89   : 
; 90   : 	/* Done */
; 91   : 	return Destination;

  00029	8b 45 08	 mov	 eax, DWORD PTR _Destination$[ebp]
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 92   : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_MemCpyMMX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\mem\memcpy.c
;	COMDAT _MemCpySSE
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Source$ = 12						; size = 4
_Count$ = 16						; size = 4
_MemCpySSE PROC						; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	/* Loop Count */
; 56   : 	uint32_t SseLoops = Count / 16;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _Count$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	c1 e8 04	 shr	 eax, 4

; 58   : 
; 59   : 	/* Sanity, we don't want to go through the
; 60   : 	 * overhead if it's less than a certain threshold */
; 61   : 	if (SseLoops < MEMCPY_ACCEL_THRESHOLD) {

  0000b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0000e	73 09		 jae	 SHORT $LN1@MemCpySSE

; 62   : 		return MemCpyBase(Destination, Source, Count);

  00010	89 4d 10	 mov	 DWORD PTR _Count$[ebp], ecx

; 70   : }

  00013	5d		 pop	 ebp

; 62   : 		return MemCpyBase(Destination, Source, Count);

  00014	e9 00 00 00 00	 jmp	 _MemCpyBase
$LN1@MemCpySSE:

; 57   : 	uint32_t mBytes = Count % 16;

  00019	83 e1 0f	 and	 ecx, 15			; 0000000fH

; 63   : 	}
; 64   : 
; 65   : 	/* Call asm */
; 66   : 	asm_memcpy_sse(Destination, Source, SseLoops, mBytes);

  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	ff 75 0c	 push	 DWORD PTR _Source$[ebp]
  00021	ff 75 08	 push	 DWORD PTR _Destination$[ebp]
  00024	e8 00 00 00 00	 call	 _asm_memcpy_sse

; 67   : 	
; 68   : 	/* Done */
; 69   : 	return Destination;

  00029	8b 45 08	 mov	 eax, DWORD PTR _Destination$[ebp]
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 70   : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_MemCpySSE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\mem\memcpy.c
;	COMDAT _MemCpyBase
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Source$ = 12						; size = 4
_Count$ = 16						; size = 4
_MemCpyBase PROC					; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 98   : 	char *dst = (char*)Destination;
; 99   : 	const char *src = (const char*)Source;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _Source$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _Destination$[ebp]
  0000a	8b c3		 mov	 eax, ebx
  0000c	56		 push	 esi

; 100  : 	long *aligned_dst;
; 101  : 	const long *aligned_src;
; 102  : 
; 103  : 	/* If the size is small, or either SRC or DST is unaligned,
; 104  : 	then punt into the byte copy loop.  This should be rare.  */
; 105  : 	if (!TOO_SMALL(Count) && !UNALIGNED(src, dst))

  0000d	8b 75 10	 mov	 esi, DWORD PTR _Count$[ebp]
  00010	83 fe 10	 cmp	 esi, 16			; 00000010H
  00013	72 4c		 jb	 SHORT $LN3@MemCpyBase
  00015	8b cb		 mov	 ecx, ebx
  00017	0b ca		 or	 ecx, edx
  00019	f6 c1 03	 test	 cl, 3
  0001c	75 43		 jne	 SHORT $LN3@MemCpyBase

; 106  : 	{
; 107  : 		aligned_dst = (long*)dst;

  0001e	57		 push	 edi
  0001f	8b fe		 mov	 edi, esi
  00021	c1 ef 04	 shr	 edi, 4
$LL6@MemCpyBase:

; 108  : 		aligned_src = (long*)src;
; 109  : 
; 110  : 		/* Copy 4X long words at a time if possible.  */
; 111  : 		while (Count >= BIGBLOCKSIZE)
; 112  : 		{
; 113  : 			*aligned_dst++ = *aligned_src++;

  00024	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 114  : 			*aligned_dst++ = *aligned_src++;
; 115  : 			*aligned_dst++ = *aligned_src++;
; 116  : 			*aligned_dst++ = *aligned_src++;
; 117  : 			Count -= BIGBLOCKSIZE;

  00026	83 ee 10	 sub	 esi, 16			; 00000010H
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0002e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00031	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00034	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00037	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0003a	83 c2 10	 add	 edx, 16			; 00000010H
  0003d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00040	83 c0 10	 add	 eax, 16			; 00000010H
  00043	4f		 dec	 edi
  00044	75 de		 jne	 SHORT $LL6@MemCpyBase

; 118  : 		}
; 119  : 
; 120  : 		/* Copy one long word at a time if possible.  */
; 121  : 		while (Count >= LITTLEBLOCKSIZE)

  00046	83 fe 04	 cmp	 esi, 4
  00049	72 15		 jb	 SHORT $LN24@MemCpyBase
  0004b	8b fe		 mov	 edi, esi
  0004d	c1 ef 02	 shr	 edi, 2
$LL4@MemCpyBase:

; 122  : 		{
; 123  : 			*aligned_dst++ = *aligned_src++;

  00050	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 124  : 			Count -= LITTLEBLOCKSIZE;

  00052	83 ee 04	 sub	 esi, 4
  00055	89 08		 mov	 DWORD PTR [eax], ecx
  00057	83 c2 04	 add	 edx, 4
  0005a	83 c0 04	 add	 eax, 4
  0005d	4f		 dec	 edi
  0005e	75 f0		 jne	 SHORT $LL4@MemCpyBase
$LN24@MemCpyBase:
  00060	5f		 pop	 edi
$LN3@MemCpyBase:

; 125  : 		}
; 126  : 
; 127  : 		/* Pick up any residual with a byte copier.  */
; 128  : 		dst = (char*)aligned_dst;
; 129  : 		src = (char*)aligned_src;
; 130  : 	}
; 131  : 
; 132  : 	while (Count--)

  00061	85 f6		 test	 esi, esi
  00063	74 0e		 je	 SHORT $LN23@MemCpyBase
  00065	2b d0		 sub	 edx, eax
$LL2@MemCpyBase:

; 133  : 		*dst++ = *src++;

  00067	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  0006a	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0006d	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  00070	4e		 dec	 esi
  00071	75 f4		 jne	 SHORT $LL2@MemCpyBase
$LN23@MemCpyBase:
  00073	5e		 pop	 esi

; 134  : 
; 135  : 	return Destination;

  00074	8b c3		 mov	 eax, ebx
  00076	5b		 pop	 ebx

; 136  : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_MemCpyBase ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\mem\memcpy.c
;	COMDAT _memcpy
_TEXT	SEGMENT
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_count$ = 16						; size = 4
_memcpy	PROC						; COMDAT

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  : 	/* Sanity, just in case */
; 182  : 	if (__GlbMemCpyInstance == NULL) {

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___GlbMemCpyInstance
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET _MemCpySelect
  0000d	85 c0		 test	 eax, eax
  0000f	0f 44 c1	 cmove	 eax, ecx
  00012	a3 00 00 00 00	 mov	 DWORD PTR ___GlbMemCpyInstance, eax

; 188  : }

  00017	5d		 pop	 ebp

; 183  : 		__GlbMemCpyInstance = MemCpySelect;
; 184  : 	}
; 185  : 
; 186  : 	/* Just return the selected template */
; 187  : 	return __GlbMemCpyInstance(destination, source, count);

  00018	ff e0		 jmp	 eax
_memcpy	ENDP
_TEXT	ENDS
END
