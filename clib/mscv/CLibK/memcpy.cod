; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\memcpy.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_CpuFeatEcx
PUBLIC	_CpuFeatEdx
_BSS	SEGMENT
_CpuFeatEcx DD	01H DUP (?)
_CpuFeatEdx DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_memcpy
PUBLIC	_memcpy_sse
PUBLIC	_memcpy_mmx
EXTRN	_asm_memcpy_mmx:PROC
EXTRN	_asm_memcpy_sse:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\memcpy.c
;	COMDAT _memcpy_mmx
_TEXT	SEGMENT
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_count$ = 16						; size = 4
_memcpy_mmx PROC					; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 	/* Loop Count */
; 45   : 	uint32_t MmxLoops = count / 8;
; 46   : 	uint32_t mBytes = count % 8;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	83 e0 07	 and	 eax, 7
  0000b	c1 e9 03	 shr	 ecx, 3

; 47   : 
; 48   : 	/* Call asm */
; 49   : 	asm_memcpy_mmx(destination, source, MmxLoops, mBytes);

  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	ff 75 0c	 push	 DWORD PTR _source$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _destination$[ebp]
  00016	e8 00 00 00 00	 call	 _asm_memcpy_mmx

; 50   : 
; 51   : 	/* Done */
; 52   : 	return destination;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _destination$[ebp]
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 53   : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_memcpy_mmx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\memcpy.c
;	COMDAT _memcpy_sse
_TEXT	SEGMENT
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_count$ = 16						; size = 4
_memcpy_sse PROC					; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	/* Loop Count */
; 32   : 	uint32_t SseLoops = count / 16;
; 33   : 	uint32_t mBytes = count % 16;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	83 e0 0f	 and	 eax, 15			; 0000000fH
  0000b	c1 e9 04	 shr	 ecx, 4

; 34   : 
; 35   : 	/* Call asm */
; 36   : 	asm_memcpy_sse(destination, source, SseLoops, mBytes);

  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	ff 75 0c	 push	 DWORD PTR _source$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _destination$[ebp]
  00016	e8 00 00 00 00	 call	 _asm_memcpy_sse

; 37   : 	
; 38   : 	/* Done */
; 39   : 	return destination;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _destination$[ebp]
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 40   : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_memcpy_sse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\memcpy.c
;	COMDAT _memcpy
_TEXT	SEGMENT
_cpuinfo$1 = -16					; size = 16
_destination$ = 8					; size = 4
_source$ = 12						; size = 4
_count$ = 16						; size = 4
_memcpy	PROC						; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 58   : 	/* Sanity */
; 59   : 	if(CpuFeatEcx == 0 && CpuFeatEdx == 0)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CpuFeatEcx, 0
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _CpuFeatEdx
  00015	57		 push	 edi
  00016	75 2e		 jne	 SHORT $LN12@memcpy
  00018	85 f6		 test	 esi, esi
  0001a	75 2a		 jne	 SHORT $LN12@memcpy

; 60   : 	{
; 61   : #ifdef _MSC_VER
; 62   : 		int cpuinfo[4] = { 0 };

  0001c	33 c0		 xor	 eax, eax

; 63   : 		__cpuid(cpuinfo, 1);

  0001e	8d 7d f0	 lea	 edi, DWORD PTR _cpuinfo$1[ebp]
  00021	89 45 f4	 mov	 DWORD PTR _cpuinfo$1[ebp+4], eax
  00024	33 c9		 xor	 ecx, ecx
  00026	89 45 f8	 mov	 DWORD PTR _cpuinfo$1[ebp+8], eax
  00029	89 45 fc	 mov	 DWORD PTR _cpuinfo$1[ebp+12], eax
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	0f a2		 cpuid
  00033	89 07		 mov	 DWORD PTR [edi], eax
  00035	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00038	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0003b	89 57 0c	 mov	 DWORD PTR [edi+12], edx

; 64   : 		CpuFeatEcx = cpuinfo[2];

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _cpuinfo$1[ebp+8]
  00041	a3 00 00 00 00	 mov	 DWORD PTR _CpuFeatEcx, eax
$LN12@memcpy:

; 65   : #else
; 66   : 		int unused = 0;
; 67   : 		__cpuid(1, unused, unused, CpuFeatEcx, CpuFeatEdx);
; 68   : #endif
; 69   : 	}
; 70   : 
; 71   : 	//Can we use SSE?
; 72   : 	if(CpuFeatEdx & CPUID_FEAT_EDX_SSE)

  00046	f7 c6 00 00 00
	02		 test	 esi, 33554432		; 02000000H
  0004c	74 18		 je	 SHORT $LN11@memcpy

; 73   : 		return memcpy_sse(destination, source, count);

  0004e	ff 75 10	 push	 DWORD PTR _count$[ebp]
  00051	ff 75 0c	 push	 DWORD PTR _source$[ebp]
  00054	ff 75 08	 push	 DWORD PTR _destination$[ebp]
  00057	e8 00 00 00 00	 call	 _memcpy_sse
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 116  : 	}
; 117  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN11@memcpy:

; 74   : 	else if(CpuFeatEdx & CPUID_FEAT_EDX_MMX)

  00066	f7 c6 00 00 80
	00		 test	 esi, 8388608		; 00800000H
  0006c	74 18		 je	 SHORT $LN9@memcpy

; 75   : 		return memcpy_mmx(destination, source, count);

  0006e	ff 75 10	 push	 DWORD PTR _count$[ebp]
  00071	ff 75 0c	 push	 DWORD PTR _source$[ebp]
  00074	ff 75 08	 push	 DWORD PTR _destination$[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy_mmx
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx

; 116  : 	}
; 117  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN9@memcpy:

; 76   : 	else
; 77   : 	{
; 78   : 		char *dst = (char*)destination;
; 79   : 		const char *src = (const char*)source;
; 80   : 		long *aligned_dst;
; 81   : 		const long *aligned_src;
; 82   : 
; 83   : 		/* If the size is small, or either SRC or DST is unaligned,
; 84   : 			then punt into the byte copy loop.  This should be rare.  */
; 85   : 		if (!TOO_SMALL(count) && !UNALIGNED (src, dst))

  00086	8b 75 10	 mov	 esi, DWORD PTR _count$[ebp]
  00089	8b 5d 08	 mov	 ebx, DWORD PTR _destination$[ebp]
  0008c	8b c3		 mov	 eax, ebx
  0008e	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00091	83 fe 10	 cmp	 esi, 16			; 00000010H
  00094	72 4a		 jb	 SHORT $LN3@memcpy
  00096	8b cb		 mov	 ecx, ebx
  00098	0b ca		 or	 ecx, edx
  0009a	f6 c1 03	 test	 cl, 3
  0009d	75 41		 jne	 SHORT $LN3@memcpy

; 86   : 		{
; 87   : 			aligned_dst = (long*)dst;

  0009f	8b fe		 mov	 edi, esi
  000a1	c1 ef 04	 shr	 edi, 4
$LL6@memcpy:

; 88   : 			aligned_src = (long*)src;
; 89   : 
; 90   : 			/* Copy 4X long words at a time if possible.  */
; 91   : 			while (count >= BIGBLOCKSIZE)
; 92   : 			{
; 93   : 				*aligned_dst++ = *aligned_src++;

  000a4	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 94   : 				*aligned_dst++ = *aligned_src++;
; 95   : 				*aligned_dst++ = *aligned_src++;
; 96   : 				*aligned_dst++ = *aligned_src++;
; 97   : 				count -= BIGBLOCKSIZE;

  000a6	83 ee 10	 sub	 esi, 16			; 00000010H
  000a9	89 08		 mov	 DWORD PTR [eax], ecx
  000ab	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ae	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000b1	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000b4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000b7	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000ba	83 c2 10	 add	 edx, 16			; 00000010H
  000bd	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000c0	83 c0 10	 add	 eax, 16			; 00000010H
  000c3	4f		 dec	 edi
  000c4	75 de		 jne	 SHORT $LL6@memcpy

; 98   : 			}
; 99   : 
; 100  : 			/* Copy one long word at a time if possible.  */
; 101  : 			while (count >= LITTLEBLOCKSIZE)

  000c6	83 fe 04	 cmp	 esi, 4
  000c9	72 15		 jb	 SHORT $LN3@memcpy
  000cb	8b fe		 mov	 edi, esi
  000cd	c1 ef 02	 shr	 edi, 2
$LL4@memcpy:

; 102  : 			{
; 103  : 				*aligned_dst++ = *aligned_src++;

  000d0	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 104  : 				count -= LITTLEBLOCKSIZE;

  000d2	83 ee 04	 sub	 esi, 4
  000d5	89 08		 mov	 DWORD PTR [eax], ecx
  000d7	83 c2 04	 add	 edx, 4
  000da	83 c0 04	 add	 eax, 4
  000dd	4f		 dec	 edi
  000de	75 f0		 jne	 SHORT $LL4@memcpy
$LN3@memcpy:

; 105  : 			}
; 106  : 
; 107  : 			/* Pick up any residual with a byte copier.  */
; 108  : 			dst = (char*)aligned_dst;
; 109  : 			src = (char*)aligned_src;
; 110  : 		}
; 111  : 
; 112  : 		while (count--)

  000e0	85 f6		 test	 esi, esi
  000e2	74 0e		 je	 SHORT $LN20@memcpy
  000e4	2b d0		 sub	 edx, eax
$LL2@memcpy:

; 113  : 		*dst++ = *src++;

  000e6	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  000e9	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000ec	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  000ef	4e		 dec	 esi
  000f0	75 f4		 jne	 SHORT $LL2@memcpy
$LN20@memcpy:
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi

; 114  : 
; 115  : 		return destination;

  000f4	8b c3		 mov	 eax, ebx
  000f6	5b		 pop	 ebx

; 116  : 	}
; 117  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_memcpy	ENDP
_TEXT	ENDS
END
