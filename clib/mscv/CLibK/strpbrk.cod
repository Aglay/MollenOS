; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strpbrk.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strpbrk
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strpbrk.c
;	COMDAT _strpbrk
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_strpbrk PROC						; COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 36   : 	const char *c = s2;
; 37   : 	if (!*s1)

  00005	8b 75 08	 mov	 esi, DWORD PTR _s1$[ebp]
  00008	8a 1e		 mov	 bl, BYTE PTR [esi]
  0000a	84 db		 test	 bl, bl
  0000c	75 06		 jne	 SHORT $LN20@strpbrk

; 38   : 		return (char *) NULL;

  0000e	5e		 pop	 esi
  0000f	33 c0		 xor	 eax, eax
  00011	5b		 pop	 ebx

; 58   : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN20@strpbrk:
  00014	57		 push	 edi

; 38   : 		return (char *) NULL;

  00015	8b 7d 0c	 mov	 edi, DWORD PTR _s2$[ebp]
  00018	8a 07		 mov	 al, BYTE PTR [edi]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL8@strpbrk:

; 41   : 	{
; 42   : 		for (c = s2; *c; c++)

  00020	8b d7		 mov	 edx, edi
  00022	84 c0		 test	 al, al
  00024	74 10		 je	 SHORT $LN14@strpbrk
  00026	8a c8		 mov	 cl, al
$LL6@strpbrk:

; 43   : 		{
; 44   : 			if (*s1 == *c)

  00028	3a d9		 cmp	 bl, cl
  0002a	74 0a		 je	 SHORT $LN14@strpbrk

; 41   : 	{
; 42   : 		for (c = s2; *c; c++)

  0002c	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  0002f	42		 inc	 edx
  00030	84 c9		 test	 cl, cl
  00032	75 f4		 jne	 SHORT $LL6@strpbrk

; 45   : 			break;
; 46   : 		}
; 47   : 
; 48   : 		if (*c)

  00034	eb 05		 jmp	 SHORT $LN19@strpbrk
$LN14@strpbrk:
  00036	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00039	75 0e		 jne	 SHORT $LN1@strpbrk
$LN19@strpbrk:

; 39   : 
; 40   : 	while (*s1)

  0003b	8a 5e 01	 mov	 bl, BYTE PTR [esi+1]

; 49   : 			break;
; 50   : 
; 51   : 		s1++;

  0003e	46		 inc	 esi
  0003f	84 db		 test	 bl, bl
  00041	75 dd		 jne	 SHORT $LL8@strpbrk

; 52   : 	}
; 53   : 
; 54   : 	if (*c == '\0')

  00043	38 1a		 cmp	 BYTE PTR [edx], bl
  00045	75 02		 jne	 SHORT $LN1@strpbrk

; 55   : 		s1 = NULL;

  00047	33 f6		 xor	 esi, esi
$LN1@strpbrk:
  00049	5f		 pop	 edi

; 56   : 
; 57   : 	return (char *) s1;

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 58   : }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_strpbrk ENDP
_TEXT	ENDS
END
