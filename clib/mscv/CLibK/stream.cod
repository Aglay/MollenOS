; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdio\stream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@		; `string'
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ DB '(null)', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?_nullstring@?1??streamout@@9@9 DD FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ ; `streamout'::`2'::_nullstring
_DATA	ENDS
CONST	SEGMENT
?digits_l@?1??format_float@@9@9 DB '0123456789abcdef0x', 00H ; `format_float'::`2'::digits_l
	ORG $+1
?digits_u@?1??format_float@@9@9 DB '0123456789ABCDEF0X', 00H ; `format_float'::`2'::digits_u
	ORG $+1
?_nan@?1??format_float@@9@9 DB '#QNAN', 00H		; `format_float'::`2'::_nan
	ORG $+2
?_infinity@?1??format_float@@9@9 DB '#INF', 00H		; `format_float'::`2'::_infinity
	ORG $+3
?digits_l@?1??streamout@@9@9 DB '0123456789abcdef0x', 00H ; `streamout'::`2'::digits_l
	ORG $+1
?digits_u@?1??streamout@@9@9 DB '0123456789ABCDEF0X', 00H ; `streamout'::`2'::digits_u
CONST	ENDS
PUBLIC	_StreamCharacterToUtf8
PUBLIC	_format_float
PUBLIC	_streamout
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@43e0000000000000
EXTRN	__finite:PROC
EXTRN	__isnan:PROC
EXTRN	_VideoPutChar:PROC
EXTRN	__CIlog10:PROC
EXTRN	__CIpow:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__aullrem:PROC
EXTRN	__ftol2:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+018
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL?$AA@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout
_TEXT	SEGMENT
_buffer$ = -104						; size = 50
_flags$1$ = -52						; size = 4
tv726 = -52						; size = 4
_prefixlen$1$ = -48					; size = 4
tv659 = -48						; size = 4
_prefix$ = -48						; size = 4
_digits$1$ = -44					; size = 4
_uLen$1 = -44						; size = 4
tv594 = -40						; size = 8
_base$1$ = -36						; size = 4
_val64$2$ = -32						; size = 4
_string$ = -32						; size = 4
_val64$1$ = -28						; size = 4
_written$4$ = -28					; size = 4
_cnt$ = -24						; size = 4
_prefix$1$ = -20					; size = 4
_chr$ = -16						; size = 1
_padding$2$ = -12					; size = 4
_string$1$ = -8						; size = 4
_written_all$1$ = -4					; size = 4
_out$ = 8						; size = 4
_precision$2$ = 12					; size = 4
tv724 = 12						; size = 4
tv658 = 12						; size = 4
_size$ = 12						; size = 4
_format$ = 16						; size = 4
_argptr$ = 20						; size = 4
_streamout PROC						; COMDAT

; 362  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H

; 363  : 	static const char digits_l[] = "0123456789abcdef0x";
; 364  : 	static const char digits_u[] = "0123456789ABCDEF0X";
; 365  : 	static const char *_nullstring = "(null)";
; 366  : 	char buffer[BUFFER_SIZE + 1];
; 367  : 	uint32_t cnt = size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]

; 368  : 	char chr, *string;
; 369  : 	STRING *nt_string;
; 370  : 	const char *digits, *prefix;
; 371  : 	int base, fieldwidth, precision, padding;
; 372  : 	size_t prefixlen, len;
; 373  : 	int written = 1, written_all = 0;

  00009	ba 01 00 00 00	 mov	 edx, 1
  0000e	53		 push	 ebx
  0000f	56		 push	 esi

; 374  : 	unsigned int flags;
; 375  : 	unsigned __int64 val64;
; 376  : 
; 377  : 	buffer[BUFFER_SIZE] = '\0';

  00010	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  00013	57		 push	 edi
  00014	33 ff		 xor	 edi, edi
  00016	89 45 e8	 mov	 DWORD PTR _cnt$[ebp], eax
  00019	89 55 e4	 mov	 DWORD PTR _written$4$[ebp], edx
  0001c	89 7d fc	 mov	 DWORD PTR _written_all$1$[ebp], edi
  0001f	c6 45 c9 00	 mov	 BYTE PTR _buffer$[ebp+49], 0
$LN269@streamout:

; 381  : 	{
; 382  : 		/* Get character and advance */
; 383  : 		chr = *format++;

  00023	8a 06		 mov	 al, BYTE PTR [esi]
  00025	46		 inc	 esi
  00026	8b 5d 08	 mov	 ebx, DWORD PTR _out$[ebp]

; 384  : 
; 385  : 		/* Check for end of format string */
; 386  : 		if (chr == '\0') 

  00029	84 c0		 test	 al, al
  0002b	0f 84 9d 06 00
	00		 je	 $LN117@streamout

; 387  : 			break;
; 388  : 
; 389  : 		/* Check for 'normal' character or double % */
; 390  : 		if ((chr != ('%')) ||
; 391  : 			(chr = *format++) == ('%'))

  00031	3c 25		 cmp	 al, 37			; 00000025H
  00033	0f 85 ff 05 00
	00		 jne	 $LN114@streamout
  00039	8a 06		 mov	 al, BYTE PTR [esi]
  0003b	46		 inc	 esi
  0003c	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0003f	3c 25		 cmp	 al, 37			; 00000025H
  00041	0f 84 f1 05 00
	00		 je	 $LN114@streamout

; 438  : 			continue;
; 439  : 		}
; 440  : 
; 441  : 		/* Handle flags-characters */
; 442  : 		flags = 0;

  00047	33 db		 xor	 ebx, ebx
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL102@streamout:

; 443  : 		while (1)
; 444  : 		{
; 445  : 			if (chr == ('-')) flags |= FLAG_ALIGN_LEFT;

  00050	3c 2d		 cmp	 al, 45			; 0000002dH
  00052	75 0b		 jne	 SHORT $LN100@streamout

; 450  : 			else break;
; 451  : 			chr = *format++;

  00054	8a 06		 mov	 al, BYTE PTR [esi]
  00056	83 cb 01	 or	 ebx, 1
  00059	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0005c	46		 inc	 esi

; 452  : 		}

  0005d	eb f1		 jmp	 SHORT $LL102@streamout
$LN100@streamout:

; 446  : 			else if (chr == ('+')) flags |= FLAG_FORCE_SIGN;

  0005f	3c 2b		 cmp	 al, 43			; 0000002bH
  00061	75 0b		 jne	 SHORT $LN98@streamout

; 450  : 			else break;
; 451  : 			chr = *format++;

  00063	8a 06		 mov	 al, BYTE PTR [esi]
  00065	83 cb 02	 or	 ebx, 2
  00068	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0006b	46		 inc	 esi

; 452  : 		}

  0006c	eb e2		 jmp	 SHORT $LL102@streamout
$LN98@streamout:

; 447  : 			else if (chr == (' ')) flags |= FLAG_FORCE_SIGNSP;

  0006e	3c 20		 cmp	 al, 32			; 00000020H
  00070	75 0b		 jne	 SHORT $LN96@streamout

; 450  : 			else break;
; 451  : 			chr = *format++;

  00072	8a 06		 mov	 al, BYTE PTR [esi]
  00074	83 cb 04	 or	 ebx, 4
  00077	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0007a	46		 inc	 esi

; 452  : 		}

  0007b	eb d3		 jmp	 SHORT $LL102@streamout
$LN96@streamout:

; 448  : 			else if (chr == ('0')) flags |= FLAG_PAD_ZERO;

  0007d	3c 30		 cmp	 al, 48			; 00000030H
  0007f	75 0b		 jne	 SHORT $LN94@streamout

; 450  : 			else break;
; 451  : 			chr = *format++;

  00081	8a 06		 mov	 al, BYTE PTR [esi]
  00083	83 cb 08	 or	 ebx, 8
  00086	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00089	46		 inc	 esi

; 452  : 		}

  0008a	eb c4		 jmp	 SHORT $LL102@streamout
$LN94@streamout:

; 449  : 			else if (chr == ('#')) flags |= FLAG_SPECIAL;

  0008c	3c 23		 cmp	 al, 35			; 00000023H
  0008e	75 0b		 jne	 SHORT $LN92@streamout

; 450  : 			else break;
; 451  : 			chr = *format++;

  00090	8a 06		 mov	 al, BYTE PTR [esi]
  00092	83 cb 10	 or	 ebx, 16			; 00000010H
  00095	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00098	46		 inc	 esi

; 452  : 		}

  00099	eb b5		 jmp	 SHORT $LL102@streamout
$LN92@streamout:

; 453  : 
; 454  : 		/* Handle field width modifier */
; 455  : 		if (chr == ('*'))

  0009b	3c 2a		 cmp	 al, 42			; 0000002aH
  0009d	75 23		 jne	 SHORT $LN90@streamout

; 456  : 		{
; 457  : 			fieldwidth = va_arg(argptr, int);

  0009f	8b 7d 14	 mov	 edi, DWORD PTR _argptr$[ebp]
  000a2	83 c7 04	 add	 edi, 4
  000a5	89 7d 14	 mov	 DWORD PTR _argptr$[ebp], edi
  000a8	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  000ab	89 4d f4	 mov	 DWORD PTR _padding$2$[ebp], ecx

; 458  : 			if (fieldwidth < 0)

  000ae	85 c9		 test	 ecx, ecx
  000b0	79 08		 jns	 SHORT $LN89@streamout

; 459  : 			{
; 460  : 				flags |= FLAG_ALIGN_LEFT;

  000b2	83 cb 01	 or	 ebx, 1

; 461  : 				fieldwidth = -fieldwidth;

  000b5	f7 d9		 neg	 ecx
  000b7	89 4d f4	 mov	 DWORD PTR _padding$2$[ebp], ecx
$LN89@streamout:

; 462  : 			}
; 463  : 			chr = *format++;

  000ba	8a 06		 mov	 al, BYTE PTR [esi]
  000bc	46		 inc	 esi
  000bd	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 464  : 		}
; 465  : 		else

  000c0	eb 2e		 jmp	 SHORT $LN86@streamout
$LN90@streamout:

; 466  : 		{
; 467  : 			fieldwidth = 0;

  000c2	33 c9		 xor	 ecx, ecx
  000c4	89 4d f4	 mov	 DWORD PTR _padding$2$[ebp], ecx

; 468  : 			while (chr >= ('0') && chr <= ('9'))

  000c7	3c 30		 cmp	 al, 48			; 00000030H
  000c9	7c 22		 jl	 SHORT $LN250@streamout
  000cb	eb 03 8d 49 00	 npad	 5
$LL87@streamout:
  000d0	3c 39		 cmp	 al, 57			; 00000039H
  000d2	7f 16		 jg	 SHORT $LN246@streamout

; 469  : 			{
; 470  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000d4	0f be c0	 movsx	 eax, al
  000d7	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000da	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  000dd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 471  : 				chr = *format++;

  000e0	8a 06		 mov	 al, BYTE PTR [esi]
  000e2	46		 inc	 esi
  000e3	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  000e6	3c 30		 cmp	 al, 48			; 00000030H
  000e8	7d e6		 jge	 SHORT $LL87@streamout
$LN246@streamout:
  000ea	89 4d f4	 mov	 DWORD PTR _padding$2$[ebp], ecx
$LN250@streamout:
  000ed	8b 7d 14	 mov	 edi, DWORD PTR _argptr$[ebp]
$LN86@streamout:

; 472  : 			}
; 473  : 		}
; 474  : 
; 475  : 		/* Handle precision modifier */
; 476  : 		if (chr == '.')

  000f0	3c 2e		 cmp	 al, 46			; 0000002eH
  000f2	75 43		 jne	 SHORT $LN85@streamout

; 477  : 		{
; 478  : 			chr = *format++;

  000f4	8a 06		 mov	 al, BYTE PTR [esi]
  000f6	46		 inc	 esi
  000f7	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 479  : 
; 480  : 			if (chr == ('*'))

  000fa	3c 2a		 cmp	 al, 42			; 0000002aH
  000fc	75 11		 jne	 SHORT $LN84@streamout

; 481  : 			{
; 482  : 				precision = va_arg(argptr, int);
; 483  : 				chr = *format++;

  000fe	8a 06		 mov	 al, BYTE PTR [esi]
  00100	83 c7 04	 add	 edi, 4
  00103	89 7d 14	 mov	 DWORD PTR _argptr$[ebp], edi
  00106	46		 inc	 esi
  00107	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0010a	8b 7f fc	 mov	 edi, DWORD PTR [edi-4]

; 484  : 			}
; 485  : 			else

  0010d	eb 2b		 jmp	 SHORT $LN262@streamout
$LN84@streamout:

; 486  : 			{
; 487  : 				precision = 0;

  0010f	33 ff		 xor	 edi, edi
  00111	89 7d 0c	 mov	 DWORD PTR _precision$2$[ebp], edi

; 488  : 				while (chr >= ('0') && chr <= ('9'))

  00114	3c 30		 cmp	 al, 48			; 00000030H
  00116	7c 28		 jl	 SHORT $LL79@streamout
$LL82@streamout:
  00118	3c 39		 cmp	 al, 57			; 00000039H
  0011a	7f 24		 jg	 SHORT $LL79@streamout

; 489  : 				{
; 490  : 					precision = precision * 10 + (chr - ('0'));

  0011c	0f be c0	 movsx	 eax, al
  0011f	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00122	8d 79 e8	 lea	 edi, DWORD PTR [ecx-24]
  00125	8d 3c 78	 lea	 edi, DWORD PTR [eax+edi*2]

; 491  : 					chr = *format++;

  00128	8a 06		 mov	 al, BYTE PTR [esi]
  0012a	46		 inc	 esi
  0012b	89 7d 0c	 mov	 DWORD PTR _precision$2$[ebp], edi
  0012e	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00131	3c 30		 cmp	 al, 48			; 00000030H
  00133	7d e3		 jge	 SHORT $LL82@streamout

; 492  : 				}
; 493  : 			}

  00135	eb 09		 jmp	 SHORT $LL79@streamout
$LN85@streamout:

; 494  : 		}
; 495  : 		else precision = -1;

  00137	83 cf ff	 or	 edi, -1
$LN262@streamout:
  0013a	89 7d 0c	 mov	 DWORD PTR _precision$2$[ebp], edi
  0013d	8d 49 00	 npad	 3
$LL79@streamout:

; 496  : 
; 497  : 		/* Handle argument size prefix */
; 498  : 		do
; 499  : 		{
; 500  : 			if (chr == ('h')) flags |= FLAG_SHORT;

  00140	3c 68		 cmp	 al, 104			; 00000068H
  00142	75 0e		 jne	 SHORT $LN76@streamout

; 524  : 				{
; 525  : 					flags |= FLAG_INTPTR;
; 526  : 				}
; 527  : 				else break;
; 528  : 			}
; 529  : 			else break;
; 530  : 			chr = *format++;

  00144	8a 06		 mov	 al, BYTE PTR [esi]
  00146	81 cb 00 01 00
	00		 or	 ebx, 256		; 00000100H
  0014c	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0014f	46		 inc	 esi

; 531  : 		}
; 532  : 		while (USE_MULTISIZE);

  00150	eb ee		 jmp	 SHORT $LL79@streamout
$LN76@streamout:

; 501  : 			else if (chr == ('w')) flags |= FLAG_WIDECHAR;

  00152	3c 77		 cmp	 al, 119			; 00000077H
  00154	75 0e		 jne	 SHORT $LN74@streamout
$LN67@streamout:

; 524  : 				{
; 525  : 					flags |= FLAG_INTPTR;
; 526  : 				}
; 527  : 				else break;
; 528  : 			}
; 529  : 			else break;
; 530  : 			chr = *format++;

  00156	8a 06		 mov	 al, BYTE PTR [esi]
  00158	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  0015e	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00161	46		 inc	 esi

; 531  : 		}
; 532  : 		while (USE_MULTISIZE);

  00162	eb dc		 jmp	 SHORT $LL79@streamout
$LN74@streamout:

; 502  : 			else if (chr == ('L')) flags |= 0; // FIXME: long double

  00164	3c 4c		 cmp	 al, 76			; 0000004cH
  00166	74 73		 je	 SHORT $LN58@streamout

; 503  : 			else if (chr == ('F')) flags |= 0; // FIXME: what is that?

  00168	3c 46		 cmp	 al, 70			; 00000046H
  0016a	74 6f		 je	 SHORT $LN58@streamout

; 504  : 			else if (chr == ('l'))

  0016c	3c 6c		 cmp	 al, 108			; 0000006cH
  0016e	75 13		 jne	 SHORT $LN68@streamout

; 505  : 			{
; 506  : 				/* Check if this is the 2nd 'l' in a row */
; 507  : 				if (format[-2] == 'l') flags |= FLAG_INT64;

  00170	38 46 fe	 cmp	 BYTE PTR [esi-2], al
  00173	75 e1		 jne	 SHORT $LN67@streamout

; 524  : 				{
; 525  : 					flags |= FLAG_INTPTR;
; 526  : 				}
; 527  : 				else break;
; 528  : 			}
; 529  : 			else break;
; 530  : 			chr = *format++;

  00175	8a 06		 mov	 al, BYTE PTR [esi]
  00177	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  0017d	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00180	46		 inc	 esi

; 531  : 		}
; 532  : 		while (USE_MULTISIZE);

  00181	eb bd		 jmp	 SHORT $LL79@streamout
$LN68@streamout:

; 508  : 				else flags |= FLAG_LONG;
; 509  : 			}
; 510  : 			else if (chr == ('I'))

  00183	3c 49		 cmp	 al, 73			; 00000049H
  00185	75 5f		 jne	 SHORT $LN77@streamout

; 511  : 			{
; 512  : 				if (format[0] == ('3') && format[1] == ('2'))

  00187	8a 0e		 mov	 cl, BYTE PTR [esi]
  00189	80 f9 33	 cmp	 cl, 51			; 00000033H
  0018c	75 12		 jne	 SHORT $LN63@streamout
  0018e	80 7e 01 32	 cmp	 BYTE PTR [esi+1], 50	; 00000032H
  00192	75 0c		 jne	 SHORT $LN63@streamout

; 524  : 				{
; 525  : 					flags |= FLAG_INTPTR;
; 526  : 				}
; 527  : 				else break;
; 528  : 			}
; 529  : 			else break;
; 530  : 			chr = *format++;

  00194	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  00197	83 c6 02	 add	 esi, 2
  0019a	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  0019d	46		 inc	 esi

; 531  : 		}
; 532  : 		while (USE_MULTISIZE);

  0019e	eb a0		 jmp	 SHORT $LL79@streamout
$LN63@streamout:

; 513  : 				{
; 514  : 					format += 2;
; 515  : 				}
; 516  : 				else if (format[0] == ('6') && format[1] == ('4'))

  001a0	80 f9 36	 cmp	 cl, 54			; 00000036H
  001a3	75 18		 jne	 SHORT $LN61@streamout
  001a5	80 7e 01 34	 cmp	 BYTE PTR [esi+1], 52	; 00000034H
  001a9	75 12		 jne	 SHORT $LN61@streamout

; 524  : 				{
; 525  : 					flags |= FLAG_INTPTR;
; 526  : 				}
; 527  : 				else break;
; 528  : 			}
; 529  : 			else break;
; 530  : 			chr = *format++;

  001ab	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001ae	83 c6 02	 add	 esi, 2
  001b1	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  001b7	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  001ba	46		 inc	 esi

; 531  : 		}
; 532  : 		while (USE_MULTISIZE);

  001bb	eb 83		 jmp	 SHORT $LL79@streamout
$LN61@streamout:

; 517  : 				{
; 518  : 					format += 2;
; 519  : 					flags |= FLAG_INT64;
; 520  : 				}
; 521  : 				else if (format[0] == ('x') || format[0] == ('X') ||
; 522  : 					format[0] == ('d') || format[0] == ('i') ||
; 523  : 					format[0] == ('u') || format[0] == ('o'))

  001bd	80 f9 78	 cmp	 cl, 120			; 00000078H
  001c0	74 19		 je	 SHORT $LN58@streamout
  001c2	80 f9 58	 cmp	 cl, 88			; 00000058H
  001c5	74 14		 je	 SHORT $LN58@streamout
  001c7	80 f9 64	 cmp	 cl, 100			; 00000064H
  001ca	74 0f		 je	 SHORT $LN58@streamout
  001cc	80 f9 69	 cmp	 cl, 105			; 00000069H
  001cf	74 0a		 je	 SHORT $LN58@streamout
  001d1	80 f9 75	 cmp	 cl, 117			; 00000075H
  001d4	74 05		 je	 SHORT $LN58@streamout
  001d6	80 f9 6f	 cmp	 cl, 111			; 0000006fH
  001d9	75 0b		 jne	 SHORT $LN77@streamout
$LN58@streamout:

; 524  : 				{
; 525  : 					flags |= FLAG_INTPTR;
; 526  : 				}
; 527  : 				else break;
; 528  : 			}
; 529  : 			else break;
; 530  : 			chr = *format++;

  001db	8a 06		 mov	 al, BYTE PTR [esi]
  001dd	46		 inc	 esi
  001de	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 531  : 		}
; 532  : 		while (USE_MULTISIZE);

  001e1	e9 5a ff ff ff	 jmp	 $LL79@streamout
$LN77@streamout:

; 533  : 
; 534  : 		/* Handle the format specifier */
; 535  : 		digits = digits_l;
; 536  : 		string = &buffer[BUFFER_SIZE];

  001e6	8d 4d c9	 lea	 ecx, DWORD PTR _buffer$[ebp+49]

; 537  : 		base = 10;
; 538  : 		prefix = 0;
; 539  : 		switch (chr)

  001e9	0f be c0	 movsx	 eax, al
  001ec	89 4d f8	 mov	 DWORD PTR _string$1$[ebp], ecx
  001ef	83 c0 bf	 add	 eax, -65		; ffffffbfH
  001f2	89 4d e0	 mov	 DWORD PTR _string$[ebp], ecx
  001f5	33 c9		 xor	 ecx, ecx
  001f7	89 75 10	 mov	 DWORD PTR _format$[ebp], esi
  001fa	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??streamout@@9@9
  00201	c7 45 dc 0a 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 10 ; 0000000aH
  00208	89 4d ec	 mov	 DWORD PTR _prefix$1$[ebp], ecx
  0020b	89 4d d0	 mov	 DWORD PTR _prefix$[ebp], ecx
  0020e	83 f8 37	 cmp	 eax, 55			; 00000037H
  00211	0f 87 18 04 00
	00		 ja	 $LN22@streamout
  00217	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN220@streamout[eax]
  0021e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN274@streamout[eax*4]
$LN53@streamout:

; 540  : 		{
; 541  : 		case ('n'):
; 542  : 			if (flags & FLAG_INT64)
; 543  : 				*va_arg(argptr, __int64*) = written_all;

  00225	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00228	8b 7d fc	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  0022b	83 c1 04	 add	 ecx, 4
  0022e	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00231	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00237	74 13		 je	 SHORT $LN52@streamout
  00239	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0023c	8b c7		 mov	 eax, edi
  0023e	99		 cdq
  0023f	89 01		 mov	 DWORD PTR [ecx], eax
  00241	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00244	8b 55 e4	 mov	 edx, DWORD PTR _written$4$[ebp]
  00247	e9 7a 04 00 00	 jmp	 $LN161@streamout
$LN52@streamout:

; 544  : 			else if (flags & FLAG_SHORT)
; 545  : 				*va_arg(argptr, short*) = (short)written_all;

  0024c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0024f	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00255	74 08		 je	 SHORT $LN50@streamout
  00257	66 89 38	 mov	 WORD PTR [eax], di

; 546  : 			else

  0025a	e9 67 04 00 00	 jmp	 $LN161@streamout
$LN50@streamout:

; 547  : 				*va_arg(argptr, int*) = written_all;

  0025f	89 38		 mov	 DWORD PTR [eax], edi

; 548  : 			continue;

  00261	e9 60 04 00 00	 jmp	 $LN161@streamout
$LN48@streamout:

; 549  : 
; 550  : 		case ('C'):
; 551  : 		case ('c'):
; 552  : 			string = buffer;
; 553  : 			len = 1;
; 554  : 
; 555  : 			/* Get character */
; 556  : 			uint32_t uChar = (uint32_t)va_arg(argptr, int);

  00266	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00269	8d 45 98	 lea	 eax, DWORD PTR _buffer$[ebp]
  0026c	89 45 f8	 mov	 DWORD PTR _string$1$[ebp], eax
  0026f	83 c1 04	 add	 ecx, 4

; 557  : 			uint32_t uLen = 0;
; 558  : 
; 559  : 			/* Stream it out */
; 560  : 			StreamCharacterToUtf8(uChar, string, &uLen);

  00272	8d 45 d4	 lea	 eax, DWORD PTR _uLen$1[ebp]
  00275	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00278	50		 push	 eax
  00279	8d 45 98	 lea	 eax, DWORD PTR _buffer$[ebp]
  0027c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _uLen$1[ebp], 0
  00283	50		 push	 eax
  00284	ff 71 fc	 push	 DWORD PTR [ecx-4]
  00287	e8 00 00 00 00	 call	 _StreamCharacterToUtf8

; 561  : 
; 562  : 			/* Null terminate */
; 563  : 			((char*)string)[uLen] = (char)('\0');

  0028c	8b 7d d4	 mov	 edi, DWORD PTR _uLen$1[ebp]
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00292	c6 44 3d 98 00	 mov	 BYTE PTR _buffer$[ebp+edi], 0
$LN248@streamout:
  00297	8b 4d 0c	 mov	 ecx, DWORD PTR _precision$2$[ebp]
$LN129@streamout:

; 685  : 		}
; 686  : 
; 687  : 		/* Calculate padding */
; 688  : 		prefixlen = prefix ? strlen(prefix) : 0;

  0029a	33 d2		 xor	 edx, edx
$LN266@streamout:

; 689  : 		if (precision < 0) precision = 0;

  0029c	33 c0		 xor	 eax, eax
  0029e	89 55 d0	 mov	 DWORD PTR _prefixlen$1$[ebp], edx
  002a1	85 c9		 test	 ecx, ecx
  002a3	0f 48 c8	 cmovs	 ecx, eax

; 690  : 		padding = (int)(fieldwidth - len - prefixlen - precision);

  002a6	8b 45 f4	 mov	 eax, DWORD PTR _padding$2$[ebp]
  002a9	2b c2		 sub	 eax, edx
  002ab	89 4d 0c	 mov	 DWORD PTR _precision$2$[ebp], ecx
  002ae	2b c7		 sub	 eax, edi
  002b0	2b c1		 sub	 eax, ecx

; 691  : 		if (padding < 0) padding = 0;

  002b2	b9 00 00 00 00	 mov	 ecx, 0
  002b7	0f 48 c1	 cmovs	 eax, ecx
  002ba	89 45 f4	 mov	 DWORD PTR _padding$2$[ebp], eax

; 692  : 
; 693  : 		/* Optional left space padding */
; 694  : 		if ((flags & (FLAG_ALIGN_LEFT | FLAG_PAD_ZERO)) == 0)

  002bd	f6 c3 09	 test	 bl, 9
  002c0	75 2e		 jne	 SHORT $LN16@streamout

; 695  : 		{
; 696  : 			for (; padding > 0; padding--)

  002c2	85 c0		 test	 eax, eax
  002c4	7e 2a		 jle	 SHORT $LN16@streamout
$LL18@streamout:

; 697  : 			{
; 698  : 				if ((written = StreamOutCharacter(out, &cnt, (' '))) == 0) return -1;

  002c6	6a 20		 push	 32			; 00000020H
  002c8	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  002cb	50		 push	 eax
  002cc	ff 75 08	 push	 DWORD PTR _out$[ebp]
  002cf	e8 00 00 00 00	 call	 _StreamOutCharacter
  002d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d7	85 c0		 test	 eax, eax
  002d9	0f 84 00 04 00
	00		 je	 $LN150@streamout

; 699  : 				written_all += written;

  002df	01 45 fc	 add	 DWORD PTR _written_all$1$[ebp], eax
  002e2	8b 45 f4	 mov	 eax, DWORD PTR _padding$2$[ebp]
  002e5	48		 dec	 eax
  002e6	89 45 f4	 mov	 DWORD PTR _padding$2$[ebp], eax
  002e9	85 c0		 test	 eax, eax
  002eb	7f d9		 jg	 SHORT $LL18@streamout
  002ed	8b 55 d0	 mov	 edx, DWORD PTR _prefixlen$1$[ebp]
$LN16@streamout:

; 700  : 			}
; 701  : 		}
; 702  : 
; 703  : 		/* Optional prefix */
; 704  : 		if (prefix)

  002f0	8b 4d ec	 mov	 ecx, DWORD PTR _prefix$1$[ebp]
  002f3	85 c9		 test	 ecx, ecx
  002f5	74 1d		 je	 SHORT $LN14@streamout

; 705  : 		{
; 706  : 			written = streamout_string(out, &cnt, prefix, prefixlen);

  002f7	52		 push	 edx
  002f8	51		 push	 ecx
  002f9	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  002fc	50		 push	 eax
  002fd	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00300	e8 00 00 00 00	 call	 _streamout_astring
  00305	83 c4 10	 add	 esp, 16			; 00000010H

; 707  : 			if (written == -1) return -1;

  00308	83 f8 ff	 cmp	 eax, -1
  0030b	0f 84 ce 03 00
	00		 je	 $LN150@streamout

; 708  : 			written_all += written;

  00311	01 45 fc	 add	 DWORD PTR _written_all$1$[ebp], eax
$LN14@streamout:

; 709  : 		}
; 710  : 
; 711  : 		/* Optional left '0' padding */
; 712  : 		if ((flags & FLAG_ALIGN_LEFT) == 0) precision += padding;

  00314	8b c3		 mov	 eax, ebx
  00316	83 e0 01	 and	 eax, 1
  00319	89 45 cc	 mov	 DWORD PTR tv726[ebp], eax
  0031c	8b 45 0c	 mov	 eax, DWORD PTR _precision$2$[ebp]
  0031f	75 03		 jne	 SHORT $LN141@streamout
  00321	03 45 f4	 add	 eax, DWORD PTR _padding$2$[ebp]
$LN141@streamout:

; 713  : 		while (precision-- > 0)

  00324	85 c0		 test	 eax, eax
  00326	7e 27		 jle	 SHORT $LN156@streamout
$LL11@streamout:
  00328	48		 dec	 eax
  00329	89 45 0c	 mov	 DWORD PTR _precision$2$[ebp], eax

; 714  : 		{
; 715  : 			if ((written = StreamOutCharacter(out, &cnt, ('0'))) == 0) return -1;

  0032c	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  0032f	6a 30		 push	 48			; 00000030H
  00331	50		 push	 eax
  00332	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00335	e8 00 00 00 00	 call	 _StreamOutCharacter
  0033a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033d	85 c0		 test	 eax, eax
  0033f	0f 84 9a 03 00
	00		 je	 $LN150@streamout

; 716  : 			written_all += written;

  00345	01 45 fc	 add	 DWORD PTR _written_all$1$[ebp], eax
  00348	8b 45 0c	 mov	 eax, DWORD PTR _precision$2$[ebp]
  0034b	85 c0		 test	 eax, eax
  0034d	7f d9		 jg	 SHORT $LL11@streamout
$LN156@streamout:

; 717  : 		}
; 718  : 
; 719  : 		/* Output the string */
; 720  : 		if (flags & FLAG_WIDECHAR)
; 721  : 			written = streamout_wstring(out, &cnt, (wchar_t*)string, len);

  0034f	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00352	57		 push	 edi
  00353	ff 75 f8	 push	 DWORD PTR _string$1$[ebp]
  00356	50		 push	 eax
  00357	ff 75 08	 push	 DWORD PTR _out$[ebp]
  0035a	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00360	0f 84 69 02 00
	00		 je	 $LN8@streamout
  00366	e8 00 00 00 00	 call	 _streamout_wstring
  0036b	8b d0		 mov	 edx, eax
  0036d	89 55 e4	 mov	 DWORD PTR _written$4$[ebp], edx

; 722  : 		else

  00370	e9 64 02 00 00	 jmp	 $LN267@streamout
$LN47@streamout:

; 564  : 			len = (size_t)uLen;
; 565  : 			
; 566  : 			/* Done */
; 567  : 			break;
; 568  : 
; 569  : 		case ('Z'):
; 570  : 			nt_string = va_arg(argptr, void*);

  00375	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00378	83 c1 04	 add	 ecx, 4
  0037b	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  0037e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]

; 571  : 			if (nt_string && (string = nt_string->Buffer))

  00381	85 c9		 test	 ecx, ecx
  00383	74 52		 je	 SHORT $LN206@streamout
  00385	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00388	89 45 f8	 mov	 DWORD PTR _string$1$[ebp], eax
  0038b	85 c0		 test	 eax, eax
  0038d	74 48		 je	 SHORT $LN206@streamout

; 572  : 			{
; 573  : 				len = nt_string->Length;

  0038f	0f b7 39	 movzx	 edi, WORD PTR [ecx]

; 574  : 				if (flags & FLAG_WIDECHAR) len /= sizeof(wchar_t);

  00392	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00398	0f 84 f9 fe ff
	ff		 je	 $LN248@streamout
  0039e	d1 ef		 shr	 edi, 1

; 575  : 				break;

  003a0	e9 f2 fe ff ff	 jmp	 $LN248@streamout
$LN44@streamout:

; 576  : 			}
; 577  : 			string = 0;
; 578  : 			goto case_string;
; 579  : 
; 580  : 		case ('S'):
; 581  : 			string = va_arg(argptr, void*);

  003a5	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  003a8	83 c1 04	 add	 ecx, 4
  003ab	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  003ae	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  003b1	89 45 f8	 mov	 DWORD PTR _string$1$[ebp], eax

; 582  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  003b4	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  003ba	75 17		 jne	 SHORT $case_string$275
  003bc	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H

; 583  : 			goto case_string;

  003c2	eb 0f		 jmp	 SHORT $case_string$275
$LN42@streamout:

; 584  : 
; 585  : 		case ('s'):
; 586  : 			string = va_arg(argptr, void*);

  003c4	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  003c7	83 c1 04	 add	 ecx, 4
  003ca	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  003cd	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  003d0	89 45 f8	 mov	 DWORD PTR _string$1$[ebp], eax
$case_string$275:

; 587  : 
; 588  : case_string:
; 589  : 			if (!string)

  003d3	85 c0		 test	 eax, eax
  003d5	75 0e		 jne	 SHORT $LN41@streamout
$LN206@streamout:

; 590  : 			{
; 591  : 				string = (char*)_nullstring;

  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_nullstring@?1??streamout@@9@9

; 592  : 				flags &= ~FLAG_WIDECHAR;

  003dc	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  003e2	89 45 f8	 mov	 DWORD PTR _string$1$[ebp], eax
$LN41@streamout:

; 593  : 			}
; 594  : 
; 595  : // 			if (flags & FLAG_WIDECHAR)
; 596  : // 				len = wcsnlen((wchar_t*)string, (unsigned)precision);
; 597  : // 			else
; 598  : 				len = strlen((char*)string);

  003e5	8b f8		 mov	 edi, eax
  003e7	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  003ea	8d 9b 00 00 00
	00		 npad	 6
$LL221@streamout:
  003f0	8a 07		 mov	 al, BYTE PTR [edi]
  003f2	47		 inc	 edi
  003f3	84 c0		 test	 al, al
  003f5	75 f9		 jne	 SHORT $LL221@streamout
  003f7	2b f9		 sub	 edi, ecx

; 599  : 			precision = 0;

  003f9	33 c9		 xor	 ecx, ecx

; 600  : 			break;

  003fb	e9 9a fe ff ff	 jmp	 $LN129@streamout
$LN40@streamout:

; 601  : 
; 602  : 		case ('G'):
; 603  : 		case ('E'):
; 604  : 		case ('A'):
; 605  : 		case ('g'):
; 606  : 		case ('e'):
; 607  : 		case ('a'):
; 608  : 		case ('f'):
; 609  : #ifdef _UNICODE
; 610  : 			flags |= FLAG_WIDECHAR;
; 611  : #else
; 612  : 			flags &= ~FLAG_WIDECHAR;
; 613  : #endif
; 614  : 			/* Use external function, one for kernel one for user mode */
; 615  : 			format_float(chr, flags, precision, &string, &prefix, &argptr);

  00400	8d 45 14	 lea	 eax, DWORD PTR _argptr$[ebp]
  00403	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  00409	50		 push	 eax
  0040a	8d 45 d0	 lea	 eax, DWORD PTR _prefix$[ebp]
  0040d	50		 push	 eax
  0040e	8d 45 e0	 lea	 eax, DWORD PTR _string$[ebp]
  00411	50		 push	 eax
  00412	57		 push	 edi
  00413	53		 push	 ebx
  00414	ff 75 f0	 push	 DWORD PTR _chr$[ebp]
  00417	e8 00 00 00 00	 call	 _format_float

; 616  : 			len = strlen(string);

  0041c	8b 45 e0	 mov	 eax, DWORD PTR _string$[ebp]
  0041f	83 c4 18	 add	 esp, 24			; 00000018H
  00422	8b f8		 mov	 edi, eax
  00424	89 45 f8	 mov	 DWORD PTR _string$1$[ebp], eax
  00427	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0042a	8d 9b 00 00 00
	00		 npad	 6
$LL222@streamout:
  00430	8a 07		 mov	 al, BYTE PTR [edi]
  00432	47		 inc	 edi
  00433	84 c0		 test	 al, al
  00435	75 f9		 jne	 SHORT $LL222@streamout

; 617  : 			precision = 0;
; 618  : 			break;

  00437	8b 45 d0	 mov	 eax, DWORD PTR _prefix$[ebp]
  0043a	2b f9		 sub	 edi, ecx
  0043c	33 c9		 xor	 ecx, ecx
  0043e	89 45 ec	 mov	 DWORD PTR _prefix$1$[ebp], eax
  00441	e9 69 01 00 00	 jmp	 $LN54@streamout
$LN39@streamout:

; 619  : 
; 620  : 		case ('d'):
; 621  : 		case ('i'):
; 622  : 			val64 = (__int64)va_arg_f(argptr, flags);

  00446	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00449	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  0044f	74 0d		 je	 SHORT $LN123@streamout
  00451	8b 01		 mov	 eax, DWORD PTR [ecx]
  00453	83 c1 08	 add	 ecx, 8
  00456	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00459	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0045c	eb 18		 jmp	 SHORT $LN263@streamout
$LN123@streamout:
  0045e	83 c1 04	 add	 ecx, 4
  00461	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00464	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0046a	74 06		 je	 SHORT $LN121@streamout
  0046c	0f bf 41 fc	 movsx	 eax, WORD PTR [ecx-4]
  00470	eb 03		 jmp	 SHORT $LN122@streamout
$LN121@streamout:
  00472	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
$LN122@streamout:
  00475	99		 cdq
$LN263@streamout:
  00476	89 55 e0	 mov	 DWORD PTR _val64$2$[ebp], edx
  00479	89 45 e4	 mov	 DWORD PTR _val64$1$[ebp], eax

; 623  : 
; 624  : 			if ((__int64)val64 < 0)

  0047c	85 d2		 test	 edx, edx
  0047e	7f 19		 jg	 SHORT $LN38@streamout
  00480	7c 04		 jl	 SHORT $LN223@streamout
  00482	85 c0		 test	 eax, eax
  00484	73 13		 jae	 SHORT $LN38@streamout
$LN223@streamout:

; 625  : 			{
; 626  : 				val64 = -(__int64)val64;

  00486	f7 d8		 neg	 eax

; 627  : 				prefix = ("-");

  00488	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  0048f	83 d2 00	 adc	 edx, 0
  00492	f7 da		 neg	 edx
  00494	e9 97 00 00 00	 jmp	 $LN270@streamout
$LN38@streamout:

; 628  : 			}
; 629  : 			else if (flags & FLAG_FORCE_SIGN)

  00499	f6 c3 02	 test	 bl, 2
  0049c	74 0d		 je	 SHORT $LN36@streamout

; 630  : 				prefix = ("+");

  0049e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01MIFGBAGJ@?$CL?$AA@
  004a3	89 4d ec	 mov	 DWORD PTR _prefix$1$[ebp], ecx
  004a6	e9 8b 00 00 00	 jmp	 $case_number$276
$LN36@streamout:

; 631  : 			else if (flags & FLAG_FORCE_SIGNSP)

  004ab	f6 c3 04	 test	 bl, 4
  004ae	0f 84 82 00 00
	00		 je	 $case_number$276

; 632  : 				prefix = (" ");

  004b4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  004b9	89 4d ec	 mov	 DWORD PTR _prefix$1$[ebp], ecx

; 633  : 
; 634  : 			goto case_number;

  004bc	eb 78		 jmp	 SHORT $case_number$276
$LN33@streamout:

; 635  : 
; 636  : 		case ('o'):
; 637  : 			base = 8;

  004be	c7 45 dc 08 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 8

; 638  : 			if (flags & FLAG_SPECIAL)

  004c5	f6 c3 10	 test	 bl, 16			; 00000010H
  004c8	74 35		 je	 SHORT $case_unsigned$277

; 639  : 			{
; 640  : 				prefix = ("0");

  004ca	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET ??_C@_01GBGANLPD@0?$AA@

; 641  : 				if (precision > 0) precision--;

  004d1	85 ff		 test	 edi, edi
  004d3	7e 2a		 jle	 SHORT $case_unsigned$277
  004d5	4f		 dec	 edi

; 642  : 			}
; 643  : 			goto case_unsigned;

  004d6	eb 27		 jmp	 SHORT $case_unsigned$277
$LN30@streamout:

; 644  : 
; 645  : 		case ('p'):
; 646  : 			precision = 2 * sizeof(void*);

  004d8	bf 08 00 00 00	 mov	 edi, 8

; 647  : 			flags &= ~FLAG_PAD_ZERO;

  004dd	83 e3 f7	 and	 ebx, -9			; fffffff7H
$LN29@streamout:

; 648  : 			flags |= FLAG_INTPTR;
; 649  : 			/* Fall through */
; 650  : 
; 651  : 		case ('X'):
; 652  : 			digits = digits_u;

  004e0	b8 00 00 00 00	 mov	 eax, OFFSET ?digits_u@?1??streamout@@9@9
  004e5	89 45 d4	 mov	 DWORD PTR _digits$1$[ebp], eax
  004e8	eb 03		 jmp	 SHORT $LN28@streamout
$LN251@streamout:
  004ea	8b 45 d4	 mov	 eax, DWORD PTR _digits$1$[ebp]
$LN28@streamout:

; 653  : 			/* Fall through */
; 654  : 
; 655  : 		case ('x'):
; 656  : 			base = 16;

  004ed	c7 45 dc 10 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 16 ; 00000010H

; 657  : 			if (flags & FLAG_SPECIAL)

  004f4	f6 c3 10	 test	 bl, 16			; 00000010H
  004f7	74 06		 je	 SHORT $case_unsigned$277

; 658  : 			{
; 659  : 				prefix = &digits[16];

  004f9	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  004fc	89 4d ec	 mov	 DWORD PTR _prefix$1$[ebp], ecx
$case_unsigned$277:

; 660  : 			}
; 661  : 
; 662  : 		case ('u'):
; 663  : case_unsigned:
; 664  : 			val64 = va_arg_fu(argptr, flags);

  004ff	8b 4d 14	 mov	 ecx, DWORD PTR _argptr$[ebp]
  00502	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00508	74 0d		 je	 SHORT $LN127@streamout
  0050a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0050c	83 c1 08	 add	 ecx, 8
  0050f	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  00512	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00515	eb 19		 jmp	 SHORT $LN270@streamout
$LN127@streamout:
  00517	83 c1 04	 add	 ecx, 4
  0051a	89 4d 14	 mov	 DWORD PTR _argptr$[ebp], ecx
  0051d	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00523	74 06		 je	 SHORT $LN125@streamout
  00525	0f b7 41 fc	 movzx	 eax, WORD PTR [ecx-4]
  00529	eb 03		 jmp	 SHORT $LN265@streamout
$LN125@streamout:
  0052b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
$LN265@streamout:
  0052e	33 d2		 xor	 edx, edx
$LN270@streamout:
  00530	89 45 e4	 mov	 DWORD PTR _val64$1$[ebp], eax
  00533	89 55 e0	 mov	 DWORD PTR _val64$2$[ebp], edx
$case_number$276:

; 665  : 
; 666  : case_number:
; 667  : 			flags &= ~FLAG_WIDECHAR;

  00536	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH

; 668  : 			if (precision < 0) precision = 1;

  0053c	b9 01 00 00 00	 mov	 ecx, 1
  00541	85 ff		 test	 edi, edi
  00543	89 5d cc	 mov	 DWORD PTR _flags$1$[ebp], ebx
  00546	0f 48 f9	 cmovs	 edi, ecx

; 669  : 
; 670  : 			/* Gather digits in reverse order */
; 671  : 			while (val64)

  00549	0b c2		 or	 eax, edx
  0054b	89 7d 0c	 mov	 DWORD PTR _precision$2$[ebp], edi
  0054e	74 47		 je	 SHORT $LN23@streamout
  00550	8b 45 dc	 mov	 eax, DWORD PTR _base$1$[ebp]
  00553	8b 75 f8	 mov	 esi, DWORD PTR _string$1$[ebp]
  00556	8b 5d e4	 mov	 ebx, DWORD PTR _val64$1$[ebp]
  00559	99		 cdq
  0055a	8b c8		 mov	 ecx, eax
  0055c	8b c2		 mov	 eax, edx
  0055e	8b 55 e0	 mov	 edx, DWORD PTR _val64$2$[ebp]
  00561	89 4d d0	 mov	 DWORD PTR tv659[ebp], ecx
  00564	89 45 0c	 mov	 DWORD PTR tv658[ebp], eax
$LL24@streamout:

; 672  : 			{
; 673  : 				*--string = digits[val64 % base];

  00567	50		 push	 eax
  00568	51		 push	 ecx
  00569	52		 push	 edx
  0056a	53		 push	 ebx
  0056b	4e		 dec	 esi
  0056c	e8 00 00 00 00	 call	 __aulldvrm
  00571	89 5d dc	 mov	 DWORD PTR tv594[ebp+4], ebx

; 674  : 				val64 /= base;
; 675  : 				precision--;

  00574	4f		 dec	 edi
  00575	8b d8		 mov	 ebx, eax
  00577	8b 45 d4	 mov	 eax, DWORD PTR _digits$1$[ebp]
  0057a	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  0057d	8b 4d d0	 mov	 ecx, DWORD PTR tv659[ebp]
  00580	88 06		 mov	 BYTE PTR [esi], al
  00582	8b c3		 mov	 eax, ebx
  00584	0b c2		 or	 eax, edx
  00586	8b 45 0c	 mov	 eax, DWORD PTR tv658[ebp]
  00589	75 dc		 jne	 SHORT $LL24@streamout
  0058b	8b 5d cc	 mov	 ebx, DWORD PTR _flags$1$[ebp]
  0058e	89 75 f8	 mov	 DWORD PTR _string$1$[ebp], esi
  00591	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  00594	89 7d 0c	 mov	 DWORD PTR _precision$2$[ebp], edi
$LN23@streamout:

; 676  : 			}
; 677  : 
; 678  : 			len = strlen(string);

  00597	8b 7d f8	 mov	 edi, DWORD PTR _string$1$[ebp]
  0059a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0059d	8d 49 00	 npad	 3
$LL224@streamout:
  005a0	8a 07		 mov	 al, BYTE PTR [edi]
  005a2	47		 inc	 edi
  005a3	84 c0		 test	 al, al
  005a5	75 f9		 jne	 SHORT $LL224@streamout
  005a7	8b 45 ec	 mov	 eax, DWORD PTR _prefix$1$[ebp]
  005aa	2b f9		 sub	 edi, ecx
  005ac	8b 4d 0c	 mov	 ecx, DWORD PTR _precision$2$[ebp]
$LN54@streamout:

; 685  : 		}
; 686  : 
; 687  : 		/* Calculate padding */
; 688  : 		prefixlen = prefix ? strlen(prefix) : 0;

  005af	85 c0		 test	 eax, eax
  005b1	0f 84 e3 fc ff
	ff		 je	 $LN129@streamout
  005b7	8b d0		 mov	 edx, eax
  005b9	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  005bc	89 45 0c	 mov	 DWORD PTR tv724[ebp], eax
  005bf	90		 npad	 1
$LL225@streamout:
  005c0	8a 02		 mov	 al, BYTE PTR [edx]
  005c2	42		 inc	 edx
  005c3	84 c0		 test	 al, al
  005c5	75 f9		 jne	 SHORT $LL225@streamout
  005c7	2b 55 0c	 sub	 edx, DWORD PTR tv724[ebp]
  005ca	e9 cd fc ff ff	 jmp	 $LN266@streamout
$LN8@streamout:

; 723  : 			written = streamout_astring(out, &cnt, (char*)string, len);

  005cf	e8 00 00 00 00	 call	 _streamout_astring
  005d4	8b d0		 mov	 edx, eax
  005d6	89 45 e4	 mov	 DWORD PTR _written$4$[ebp], eax
$LN267@streamout:
  005d9	83 c4 10	 add	 esp, 16			; 00000010H

; 724  : 		if (written == -1) return -1;

  005dc	83 fa ff	 cmp	 edx, -1
  005df	0f 84 fa 00 00
	00		 je	 $LN150@streamout

; 725  : 		written_all += written;

  005e5	8b 7d fc	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  005e8	03 fa		 add	 edi, edx

; 726  : 
; 727  : #if 0 && SUPPORT_FLOAT
; 728  : 		/* Optional right '0' padding */
; 729  : 		while (precision-- > 0)
; 730  : 		{
; 731  : 			if ((written = StreamOutCharacter(out, &cnt, ('0'))) == 0) return -1;
; 732  : 			written_all += written;
; 733  : 			len++;
; 734  : 		}
; 735  : #endif
; 736  : 
; 737  : 		/* Optional right padding */
; 738  : 		if (flags & FLAG_ALIGN_LEFT)

  005ea	83 7d cc 00	 cmp	 DWORD PTR tv726[ebp], 0
  005ee	89 7d fc	 mov	 DWORD PTR _written_all$1$[ebp], edi
  005f1	0f 84 cf 00 00
	00		 je	 $LN161@streamout

; 739  : 		{
; 740  : 			while (padding-- > 0)

  005f7	8b 5d f4	 mov	 ebx, DWORD PTR _padding$2$[ebp]
  005fa	85 db		 test	 ebx, ebx
  005fc	0f 8e c4 00 00
	00		 jle	 $LN161@streamout
$LL4@streamout:

; 741  : 			{
; 742  : 				if ((written = StreamOutCharacter(out, &cnt, (' '))) == 0) return -1;

  00602	6a 20		 push	 32			; 00000020H
  00604	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00607	4b		 dec	 ebx
  00608	50		 push	 eax
  00609	ff 75 08	 push	 DWORD PTR _out$[ebp]
  0060c	e8 00 00 00 00	 call	 _StreamOutCharacter
  00611	8b d0		 mov	 edx, eax
  00613	83 c4 0c	 add	 esp, 12			; 0000000cH
  00616	89 55 e4	 mov	 DWORD PTR _written$4$[ebp], edx
  00619	85 d2		 test	 edx, edx
  0061b	0f 84 be 00 00
	00		 je	 $LN150@streamout

; 743  : 				written_all += written;

  00621	03 fa		 add	 edi, edx
  00623	89 7d fc	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00626	85 db		 test	 ebx, ebx
  00628	7f d8		 jg	 SHORT $LL4@streamout

; 744  : 			}
; 745  : 		}
; 746  : 
; 747  : 	}

  0062a	e9 97 00 00 00	 jmp	 $LN161@streamout
$LN22@streamout:

; 679  : 			break;
; 680  : 
; 681  : 		default:
; 682  : 			/* Treat anything else as a new character */
; 683  : 			format--;
; 684  : 			continue;

  0062f	8b 7d fc	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  00632	4e		 dec	 esi
  00633	e9 8e 00 00 00	 jmp	 $LN161@streamout
$LN114@streamout:

; 392  : 		{
; 393  : 			/* Sanity */
; 394  : 			if (IsUTF8(chr))

  00638	8a c8		 mov	 cl, al
  0063a	80 e1 c0	 and	 cl, 192			; 000000c0H
  0063d	80 f9 80	 cmp	 cl, 128			; 00000080H
  00640	75 65		 jne	 SHORT $LN113@streamout

; 395  : 			{
; 396  : 				/* Build UTF-8 */
; 397  : 				uint32_t uChar = (uint32_t)chr;
; 398  : 				uint32_t Size = 0;
; 399  : 
; 400  : 				/* Iterate */
; 401  : 				while (*format && IsUTF8(*format))

  00642	8a 16		 mov	 dl, BYTE PTR [esi]
  00644	33 db		 xor	 ebx, ebx
  00646	0f be c8	 movsx	 ecx, al
  00649	84 d2		 test	 dl, dl
  0064b	74 1b		 je	 SHORT $LN247@streamout
  0064d	8d 49 00	 npad	 3
$LL112@streamout:
  00650	8a c2		 mov	 al, dl
  00652	24 c0		 and	 al, 192			; 000000c0H
  00654	3c 80		 cmp	 al, 128			; 00000080H
  00656	75 10		 jne	 SHORT $LN247@streamout

; 402  : 				{
; 403  : 					/* Move */
; 404  : 					uChar <<= 6;
; 405  : 
; 406  : 					/* Add */
; 407  : 					uChar += (unsigned char)*format;
; 408  : 
; 409  : 					/* Inc */
; 410  : 					Size++;
; 411  : 					format++;

  00658	46		 inc	 esi
  00659	c1 e1 06	 shl	 ecx, 6
  0065c	0f b6 c2	 movzx	 eax, dl
  0065f	43		 inc	 ebx
  00660	03 c8		 add	 ecx, eax
  00662	8a 16		 mov	 dl, BYTE PTR [esi]
  00664	84 d2		 test	 dl, dl
  00666	75 e8		 jne	 SHORT $LL112@streamout
$LN247@streamout:

; 412  : 				}
; 413  : 
; 414  : 				/* Move */
; 415  : 				uChar <<= 6;

  00668	c1 e1 06	 shl	 ecx, 6

; 416  : 
; 417  : 				/* Add the last byte */
; 418  : 				if (Size == 1)

  0066b	83 fb 01	 cmp	 ebx, 1
  0066e	75 08		 jne	 SHORT $LN110@streamout

; 419  : 					uChar |= (((unsigned char)*format) & 0x1F);

  00670	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00673	83 e0 1f	 and	 eax, 31			; 0000001fH
  00676	eb 18		 jmp	 SHORT $LN268@streamout
$LN110@streamout:

; 420  : 				else if (Size == 2)

  00678	83 fb 02	 cmp	 ebx, 2
  0067b	75 08		 jne	 SHORT $LN108@streamout

; 421  : 					uChar |= (((unsigned char)*format) & 0xF);

  0067d	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00680	83 e0 0f	 and	 eax, 15			; 0000000fH
  00683	eb 0b		 jmp	 SHORT $LN268@streamout
$LN108@streamout:

; 422  : 				else if (Size == 3)

  00685	83 fb 03	 cmp	 ebx, 3
  00688	75 08		 jne	 SHORT $LN106@streamout

; 423  : 					uChar |= (((unsigned char)*format) & 0x7);

  0068a	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0068d	83 e0 07	 and	 eax, 7
$LN268@streamout:
  00690	0b c8		 or	 ecx, eax
$LN106@streamout:

; 424  : 
; 425  : 				/* Write the character to the stream */
; 426  : 				if ((written = StreamOutCharacter(out, &cnt, uChar)) == 0)

  00692	8b 5d 08	 mov	 ebx, DWORD PTR _out$[ebp]
  00695	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  00698	51		 push	 ecx
  00699	50		 push	 eax
  0069a	53		 push	 ebx
  0069b	e8 00 00 00 00	 call	 _StreamOutCharacter
  006a0	8b d0		 mov	 edx, eax
  006a2	89 55 e4	 mov	 DWORD PTR _written$4$[ebp], edx

; 428  : 			}
; 429  : 			else

  006a5	eb 13		 jmp	 SHORT $LN272@streamout
$LN113@streamout:

; 430  : 			{
; 431  : 				/* Write the character to the stream */
; 432  : 				if ((written = StreamOutCharacter(out, &cnt, chr)) == 0)

  006a7	0f be c0	 movsx	 eax, al
  006aa	50		 push	 eax
  006ab	8d 45 e8	 lea	 eax, DWORD PTR _cnt$[ebp]
  006ae	50		 push	 eax
  006af	53		 push	 ebx
  006b0	e8 00 00 00 00	 call	 _StreamOutCharacter
  006b5	8b d0		 mov	 edx, eax
  006b7	89 45 e4	 mov	 DWORD PTR _written$4$[ebp], eax
$LN272@streamout:
  006ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  006bd	85 d2		 test	 edx, edx
  006bf	74 1e		 je	 SHORT $LN150@streamout

; 433  : 					return -1;
; 434  : 			}
; 435  : 
; 436  : 			/* Done */
; 437  : 			written_all += written;

  006c1	03 fa		 add	 edi, edx
  006c3	89 7d fc	 mov	 DWORD PTR _written_all$1$[ebp], edi
$LN161@streamout:

; 378  : 
; 379  : 	/* Iterate String */
; 380  : 	while (written >= 0)

  006c6	85 d2		 test	 edx, edx
  006c8	0f 89 55 f9 ff
	ff		 jns	 $LN269@streamout
$LN117@streamout:

; 748  : 
; 749  : 	if (written == -1) return -1;

  006ce	83 c8 ff	 or	 eax, -1
  006d1	3b d0		 cmp	 edx, eax
  006d3	0f 44 f8	 cmove	 edi, eax
  006d6	8b c7		 mov	 eax, edi
  006d8	5f		 pop	 edi
  006d9	5e		 pop	 esi
  006da	5b		 pop	 ebx

; 750  : 
; 751  : 	return written_all;
; 752  : }

  006db	8b e5		 mov	 esp, ebp
  006dd	5d		 pop	 ebp
  006de	c3		 ret	 0
$LN150@streamout:
  006df	5f		 pop	 edi
  006e0	5e		 pop	 esi

; 427  : 					return -1;

  006e1	83 c8 ff	 or	 eax, -1
  006e4	5b		 pop	 ebx

; 750  : 
; 751  : 	return written_all;
; 752  : }

  006e5	8b e5		 mov	 esp, ebp
  006e7	5d		 pop	 ebp
  006e8	c3		 ret	 0
  006e9	8d 49 00	 npad	 3
$LN274@streamout:
  006ec	00 00 00 00	 DD	 $LN40@streamout
  006f0	00 00 00 00	 DD	 $LN48@streamout
  006f4	00 00 00 00	 DD	 $LN44@streamout
  006f8	00 00 00 00	 DD	 $LN29@streamout
  006fc	00 00 00 00	 DD	 $LN47@streamout
  00700	00 00 00 00	 DD	 $LN39@streamout
  00704	00 00 00 00	 DD	 $LN53@streamout
  00708	00 00 00 00	 DD	 $LN33@streamout
  0070c	00 00 00 00	 DD	 $LN30@streamout
  00710	00 00 00 00	 DD	 $LN42@streamout
  00714	00 00 00 00	 DD	 $case_unsigned$277
  00718	00 00 00 00	 DD	 $LN251@streamout
  0071c	00 00 00 00	 DD	 $LN22@streamout
$LN220@streamout:
  00720	00		 DB	 0
  00721	0c		 DB	 12			; 0000000cH
  00722	01		 DB	 1
  00723	0c		 DB	 12			; 0000000cH
  00724	00		 DB	 0
  00725	0c		 DB	 12			; 0000000cH
  00726	00		 DB	 0
  00727	0c		 DB	 12			; 0000000cH
  00728	0c		 DB	 12			; 0000000cH
  00729	0c		 DB	 12			; 0000000cH
  0072a	0c		 DB	 12			; 0000000cH
  0072b	0c		 DB	 12			; 0000000cH
  0072c	0c		 DB	 12			; 0000000cH
  0072d	0c		 DB	 12			; 0000000cH
  0072e	0c		 DB	 12			; 0000000cH
  0072f	0c		 DB	 12			; 0000000cH
  00730	0c		 DB	 12			; 0000000cH
  00731	0c		 DB	 12			; 0000000cH
  00732	02		 DB	 2
  00733	0c		 DB	 12			; 0000000cH
  00734	0c		 DB	 12			; 0000000cH
  00735	0c		 DB	 12			; 0000000cH
  00736	0c		 DB	 12			; 0000000cH
  00737	03		 DB	 3
  00738	0c		 DB	 12			; 0000000cH
  00739	04		 DB	 4
  0073a	0c		 DB	 12			; 0000000cH
  0073b	0c		 DB	 12			; 0000000cH
  0073c	0c		 DB	 12			; 0000000cH
  0073d	0c		 DB	 12			; 0000000cH
  0073e	0c		 DB	 12			; 0000000cH
  0073f	0c		 DB	 12			; 0000000cH
  00740	00		 DB	 0
  00741	0c		 DB	 12			; 0000000cH
  00742	01		 DB	 1
  00743	05		 DB	 5
  00744	00		 DB	 0
  00745	00		 DB	 0
  00746	00		 DB	 0
  00747	0c		 DB	 12			; 0000000cH
  00748	05		 DB	 5
  00749	0c		 DB	 12			; 0000000cH
  0074a	0c		 DB	 12			; 0000000cH
  0074b	0c		 DB	 12			; 0000000cH
  0074c	0c		 DB	 12			; 0000000cH
  0074d	06		 DB	 6
  0074e	07		 DB	 7
  0074f	08		 DB	 8
  00750	0c		 DB	 12			; 0000000cH
  00751	0c		 DB	 12			; 0000000cH
  00752	09		 DB	 9
  00753	0c		 DB	 12			; 0000000cH
  00754	0a		 DB	 10			; 0000000aH
  00755	0c		 DB	 12			; 0000000cH
  00756	0c		 DB	 12			; 0000000cH
  00757	0b		 DB	 11			; 0000000bH
_streamout ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _format_float
_TEXT	SEGMENT
tv680 = -48						; size = 8
tv564 = -48						; size = 8
tv557 = -48						; size = 8
tv489 = -48						; size = 8
tv351 = -48						; size = 8
tv344 = -48						; size = 8
tv482 = -40						; size = 8
tv467 = -40						; size = 8
tv418 = -40						; size = 8
tv394 = -40						; size = 8
tv387 = -40						; size = 8
tv378 = -40						; size = 8
_fpval$1$ = -32						; size = 8
_padding$1$ = -24					; size = 4
_exponent$1$ = -20					; size = 4
_fpval2$1$ = -16					; size = 8
_sign$ = -12						; size = 4
_digits$1$ = -8						; size = 4
_precision$1$ = -4					; size = 4
tv769 = 8						; size = 4
tv681 = 8						; size = 4
_chr$ = 8						; size = 1
_flags$ = 12						; size = 4
tv781 = 16						; size = 4
tv685 = 16						; size = 4
tv483 = 16						; size = 4
tv468 = 16						; size = 4
tv379 = 16						; size = 4
tv322 = 16						; size = 4
_num_digits$2$ = 16					; size = 4
_num_digits$1$ = 16					; size = 4
_precision$ = 16					; size = 4
_string$ = 20						; size = 4
_prefix$ = 24						; size = 4
_argptr$ = 28						; size = 4
_format_float PROC					; COMDAT

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	53		 push	 ebx

; 222  : 	static const char digits_l[] = ("0123456789abcdef0x");
; 223  : 	static const char digits_u[] = ("0123456789ABCDEF0X");
; 224  : 	static const char _nan[] = ("#QNAN");
; 225  : 	static const char _infinity[] = ("#INF");
; 226  : 	const char *digits = digits_l;
; 227  : 	int exponent = 0, sign;
; 228  : 	long double fpval, fpval2;
; 229  : 	int padding = 0, num_digits, val32, base = 10;

  00007	33 db		 xor	 ebx, ebx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??format_float@@9@9
  00010	89 5d e8	 mov	 DWORD PTR _padding$1$[ebp], ebx

; 230  : 
; 231  : 	/* Normalize the precision */
; 232  : 	if (precision < 0) precision = 6;

  00013	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
  00016	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	85 db		 test	 ebx, ebx
  0001d	79 07		 jns	 SHORT $LN37@format_flo
  0001f	bb 06 00 00 00	 mov	 ebx, 6
  00024	eb 10		 jmp	 SHORT $LN174@format_flo
$LN37@format_flo:

; 233  : 	else if (precision > 17)

  00026	83 fb 11	 cmp	 ebx, 17			; 00000011H
  00029	7e 11		 jle	 SHORT $LN35@format_flo

; 234  : 	{
; 235  : 		padding = precision - 17;

  0002b	83 c3 ef	 add	 ebx, -17		; ffffffefH
  0002e	89 5d e8	 mov	 DWORD PTR _padding$1$[ebp], ebx

; 236  : 		precision = 17;

  00031	bb 11 00 00 00	 mov	 ebx, 17			; 00000011H
$LN174@format_flo:
  00036	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
  00039	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
$LN35@format_flo:

; 237  : 	}
; 238  : 
; 239  : 	/* Get the float value and calculate the exponent */
; 240  : 	fpval = va_arg_ffp(*argptr, flags);

  0003c	8b 45 1c	 mov	 eax, DWORD PTR _argptr$[ebp]
  0003f	83 00 08	 add	 DWORD PTR [eax], 8
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00047	dd 55 e0	 fst	 QWORD PTR _fpval$1$[ebp]

; 241  : 	exponent = get_exp((double)fpval);

  0004a	d9 ee		 fldz
  0004c	d9 c9		 fxch	 ST(1)
  0004e	db e9		 fucomi	 ST(1)
  00050	9f		 lahf
  00051	f6 c4 44	 test	 ah, 68			; 00000044H
  00054	7a 04		 jp	 SHORT $LN44@format_flo
  00056	dd d8		 fstp	 ST(0)
  00058	eb 0d		 jmp	 SHORT $LN43@format_flo
$LN44@format_flo:
  0005a	db f1		 fcomi	 ST(1)
  0005c	dd d9		 fstp	 ST(1)
  0005e	73 02		 jae	 SHORT $LN175@format_flo
  00060	d9 e0		 fchs
$LN175@format_flo:
  00062	e8 00 00 00 00	 call	 __CIlog10
$LN43@format_flo:
  00067	83 ec 08	 sub	 esp, 8
  0006a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0006d	e8 00 00 00 00	 call	 _floor
  00072	83 c4 08	 add	 esp, 8
  00075	e8 00 00 00 00	 call	 __ftol2_sse

; 242  : 	sign = fpval < 0 ? -1 : 1;

  0007a	dd 45 e0	 fld	 QWORD PTR _fpval$1$[ebp]
  0007d	8b f0		 mov	 esi, eax
  0007f	d9 ee		 fldz
  00081	df f1		 fcomip	 ST(1)
  00083	89 75 ec	 mov	 DWORD PTR _exponent$1$[ebp], esi
  00086	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
  0008d	77 07		 ja	 SHORT $LN47@format_flo
  0008f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1
$LN47@format_flo:

; 243  : 
; 244  : 	switch (chr)

  00096	8b 45 08	 mov	 eax, DWORD PTR _chr$[ebp]
  00099	8b 7d 14	 mov	 edi, DWORD PTR _string$[ebp]
  0009c	0f be c0	 movsx	 eax, al
  0009f	83 c0 bf	 add	 eax, -65		; ffffffbfH
  000a2	83 f8 26	 cmp	 eax, 38			; 00000026H
  000a5	0f 87 4e 02 00
	00		 ja	 $LN102@format_flo
  000ab	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN84@format_flo[eax]
  000b2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN179@format_flo[eax*4]
$LN32@format_flo:

; 245  : 	{
; 246  : 	case ('G'):
; 247  : 		digits = digits_u;

  000b9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN31@format_flo:

; 248  : 	case ('g'):
; 249  : 		if (precision > 0) precision--;

  000c0	85 db		 test	 ebx, ebx
  000c2	7e 07		 jle	 SHORT $LN30@format_flo
  000c4	4b		 dec	 ebx
  000c5	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
  000c8	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
$LN30@format_flo:

; 250  : 		if (exponent < -4 || exponent >= precision) goto case_e;

  000cb	83 fe fc	 cmp	 esi, -4			; fffffffcH
  000ce	0f 8c b5 00 00
	00		 jl	 $case_e$180
  000d4	3b f3		 cmp	 esi, ebx
  000d6	0f 8d ad 00 00
	00		 jge	 $case_e$180

; 251  : 
; 252  : 		/* Shift the decimal point and round */
; 253  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  000dc	dd d8		 fstp	 ST(0)
  000de	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  000e1	dd 5d d0	 fstp	 QWORD PTR tv564[ebp]
  000e4	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  000ea	dd 45 d0	 fld	 QWORD PTR tv564[ebp]
  000ed	e8 00 00 00 00	 call	 __CIpow
  000f2	db 45 f4	 fild	 DWORD PTR _sign$[ebp]
  000f5	83 ec 08	 sub	 esp, 8
  000f8	dd 5d d0	 fstp	 QWORD PTR tv557[ebp]
  000fb	dd 45 d0	 fld	 QWORD PTR tv557[ebp]
  000fe	dc 4d e0	 fmul	 QWORD PTR _fpval$1$[ebp]
  00101	de c9		 fmulp	 ST(1), ST(0)
  00103	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00109	dd 1c 24	 fstp	 QWORD PTR [esp]
  0010c	e8 00 00 00 00	 call	 _floor
  00111	83 c4 08	 add	 esp, 8
  00114	dd 55 f0	 fst	 QWORD PTR _fpval2$1$[ebp]

; 254  : 
; 255  : 		/* Skip trailing zeroes */
; 256  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  00117	85 db		 test	 ebx, ebx
  00119	0f 84 19 02 00
	00		 je	 $LN176@format_flo
  0011f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  00125	eb 02		 jmp	 SHORT $LN27@format_flo
$LN139@format_flo:
  00127	d9 c9		 fxch	 ST(1)
$LN27@format_flo:
  00129	33 c9		 xor	 ecx, ecx
  0012b	d9 c1		 fld	 ST(1)
  0012d	33 f6		 xor	 esi, esi
  0012f	89 4d 10	 mov	 DWORD PTR tv781[ebp], ecx
  00132	db f1		 fcomi	 ST(1)
  00134	72 15		 jb	 SHORT $LN85@format_flo
  00136	d8 e1		 fsub	 ST(0), ST(1)
  00138	d9 c9		 fxch	 ST(1)
  0013a	db f1		 fcomi	 ST(1)
  0013c	76 0b		 jbe	 SHORT $LN133@format_flo
  0013e	03 f1		 add	 esi, ecx
  00140	81 d1 00 00 00
	80		 adc	 ecx, -2147483648	; 80000000H
  00146	89 4d 10	 mov	 DWORD PTR tv781[ebp], ecx
$LN133@format_flo:
  00149	d9 c9		 fxch	 ST(1)
$LN85@format_flo:
  0014b	e8 00 00 00 00	 call	 __ftol2
  00150	03 c6		 add	 eax, esi
  00152	6a 00		 push	 0
  00154	13 55 10	 adc	 edx, DWORD PTR tv781[ebp]
  00157	6a 0a		 push	 10			; 0000000aH
  00159	52		 push	 edx
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 __aullrem
  00160	0b c2		 or	 eax, edx
  00162	0f 85 ce 01 00
	00		 jne	 $LN135@format_flo

; 257  : 		{
; 258  : 			precision--;
; 259  : 			fpval2 /= 10;

  00168	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0016e	4b		 dec	 ebx
  0016f	de fa		 fdivp	 ST(2), ST(0)
  00171	d9 c9		 fxch	 ST(1)
  00173	89 5d fc	 mov	 DWORD PTR _precision$1$[ebp], ebx
  00176	dd 55 f0	 fst	 QWORD PTR _fpval2$1$[ebp]
  00179	75 ac		 jne	 SHORT $LN139@format_flo
  0017b	dd d8		 fstp	 ST(0)

; 260  : 		}
; 261  : 		break;

  0017d	e9 b6 01 00 00	 jmp	 $LN176@format_flo
$LN25@format_flo:

; 262  : 
; 263  : 	case ('E'):
; 264  : 		digits = digits_u;

  00182	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$case_e$180:

; 265  : 	case ('e'):
; 266  : case_e:
; 267  : 		/* Shift the decimal point and round */
; 268  : 		fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  00189	db 45 f4	 fild	 DWORD PTR _sign$[ebp]
  0018c	8b c3		 mov	 eax, ebx
  0018e	2b c6		 sub	 eax, esi
  00190	89 45 10	 mov	 DWORD PTR tv483[ebp], eax
  00193	dd 5d d0	 fstp	 QWORD PTR tv489[ebp]
  00196	dc 4d d0	 fmul	 QWORD PTR tv489[ebp]
  00199	dd 5d d0	 fstp	 QWORD PTR tv680[ebp]
  0019c	db 45 10	 fild	 DWORD PTR tv483[ebp]
  0019f	dd 5d d8	 fstp	 QWORD PTR tv482[ebp]
  001a2	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001a8	dd 45 d8	 fld	 QWORD PTR tv482[ebp]
  001ab	e8 00 00 00 00	 call	 __CIpow
  001b0	dc 4d d0	 fmul	 QWORD PTR tv680[ebp]
  001b3	83 ec 08	 sub	 esp, 8
  001b6	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  001bc	dd 1c 24	 fstp	 QWORD PTR [esp]
  001bf	e8 00 00 00 00	 call	 _floor
  001c4	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]

; 269  : 
; 270  : 		/* Compensate for changed exponent through rounding */
; 271  : 		if (fpval2 >= (unsigned __int64)pow(10., precision + 1))

  001c7	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  001ca	83 c4 08	 add	 esp, 8
  001cd	89 45 10	 mov	 DWORD PTR tv468[ebp], eax
  001d0	db 45 10	 fild	 DWORD PTR tv468[ebp]
  001d3	dd 5d d8	 fstp	 QWORD PTR tv467[ebp]
  001d6	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001dc	dd 45 d8	 fld	 QWORD PTR tv467[ebp]
  001df	e8 00 00 00 00	 call	 __CIpow
  001e4	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  001ea	33 c9		 xor	 ecx, ecx
  001ec	33 d2		 xor	 edx, edx
  001ee	89 4d 10	 mov	 DWORD PTR tv685[ebp], ecx
  001f1	d9 c9		 fxch	 ST(1)
  001f3	89 55 08	 mov	 DWORD PTR tv681[ebp], edx
  001f6	db f1		 fcomi	 ST(1)
  001f8	72 18		 jb	 SHORT $LN116@format_flo
  001fa	d8 e1		 fsub	 ST(0), ST(1)
  001fc	d9 c9		 fxch	 ST(1)
  001fe	df f1		 fcomip	 ST(1)
  00200	76 12		 jbe	 SHORT $LN86@format_flo
  00202	03 c9		 add	 ecx, ecx
  00204	89 4d 10	 mov	 DWORD PTR tv685[ebp], ecx
  00207	81 d2 00 00 00
	80		 adc	 edx, -2147483648	; 80000000H
  0020d	89 55 08	 mov	 DWORD PTR tv681[ebp], edx
  00210	eb 02		 jmp	 SHORT $LN86@format_flo
$LN116@format_flo:
  00212	dd d9		 fstp	 ST(1)
$LN86@format_flo:
  00214	e8 00 00 00 00	 call	 __ftol2
  00219	03 45 10	 add	 eax, DWORD PTR tv685[ebp]
  0021c	89 45 d8	 mov	 DWORD PTR tv418[ebp], eax
  0021f	13 55 08	 adc	 edx, DWORD PTR tv681[ebp]
  00222	8b c2		 mov	 eax, edx
  00224	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0022a	89 55 dc	 mov	 DWORD PTR tv418[ebp+4], edx
  0022d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00232	df 6d d8	 fild	 QWORD PTR tv418[ebp]
  00235	89 45 dc	 mov	 DWORD PTR tv394[ebp+4], eax
  00238	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv394[ebp], 0
  0023f	df 6d d8	 fild	 QWORD PTR tv394[ebp]
  00242	d9 e0		 fchs
  00244	de c1		 faddp	 ST(1), ST(0)
  00246	dd 5d d8	 fstp	 QWORD PTR tv387[ebp]
  00249	dd 45 d8	 fld	 QWORD PTR tv387[ebp]
  0024c	dd 45 f0	 fld	 QWORD PTR _fpval2$1$[ebp]
  0024f	df f1		 fcomip	 ST(1)
  00251	dd d8		 fstp	 ST(0)
  00253	72 39		 jb	 SHORT $LN23@format_flo

; 272  : 		{
; 273  : 			exponent++;

  00255	46		 inc	 esi

; 274  : 			fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  00256	8b c3		 mov	 eax, ebx
  00258	2b c6		 sub	 eax, esi
  0025a	89 75 ec	 mov	 DWORD PTR _exponent$1$[ebp], esi
  0025d	89 45 10	 mov	 DWORD PTR tv379[ebp], eax
  00260	db 45 10	 fild	 DWORD PTR tv379[ebp]
  00263	dd 5d d8	 fstp	 QWORD PTR tv378[ebp]
  00266	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0026c	dd 45 d8	 fld	 QWORD PTR tv378[ebp]
  0026f	e8 00 00 00 00	 call	 __CIpow
  00274	dc 4d d0	 fmul	 QWORD PTR tv680[ebp]
  00277	83 ec 08	 sub	 esp, 8
  0027a	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00280	dd 1c 24	 fstp	 QWORD PTR [esp]
  00283	e8 00 00 00 00	 call	 _floor
  00288	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]
  0028b	83 c4 08	 add	 esp, 8
$LN23@format_flo:

; 275  : 		}
; 276  : 
; 277  : 		val32 = exponent >= 0 ? exponent : -exponent;

  0028e	8b c6		 mov	 eax, esi
  00290	99		 cdq
  00291	8b d8		 mov	 ebx, eax

; 278  : 
; 279  : 		// FIXME: handle length of exponent field:
; 280  : 		// http://msdn.microsoft.com/de-de/library/0fatw238%28VS.80%29.aspx
; 281  : 		num_digits = 3;
; 282  : 		while (num_digits--)

  00293	b8 03 00 00 00	 mov	 eax, 3
  00298	33 da		 xor	 ebx, edx
  0029a	2b da		 sub	 ebx, edx
  0029c	8d 64 24 00	 npad	 4
$LL22@format_flo:
  002a0	48		 dec	 eax

; 283  : 		{
; 284  : 			*--(*string) = digits[val32 % 10];

  002a1	ff 0f		 dec	 DWORD PTR [edi]
  002a3	89 45 10	 mov	 DWORD PTR _num_digits$1$[ebp], eax
  002a6	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  002ab	8b 37		 mov	 esi, DWORD PTR [edi]
  002ad	f7 eb		 imul	 ebx
  002af	c1 fa 02	 sar	 edx, 2
  002b2	8b ca		 mov	 ecx, edx
  002b4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002b7	03 ca		 add	 ecx, edx
  002b9	8b 55 f8	 mov	 edx, DWORD PTR _digits$1$[ebp]
  002bc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  002bf	03 c0		 add	 eax, eax
  002c1	2b d8		 sub	 ebx, eax
  002c3	8a 04 13	 mov	 al, BYTE PTR [ebx+edx]

; 285  : 			val32 /= 10;

  002c6	8b d9		 mov	 ebx, ecx
  002c8	88 06		 mov	 BYTE PTR [esi], al
  002ca	8b 45 10	 mov	 eax, DWORD PTR _num_digits$1$[ebp]
  002cd	85 c0		 test	 eax, eax
  002cf	75 cf		 jne	 SHORT $LL22@format_flo

; 286  : 		}
; 287  : 
; 288  : 		/* Sign for the exponent */
; 289  : 		*--(*string) = (exponent >= 0 ? ('+') : ('-'));

  002d1	ff 0f		 dec	 DWORD PTR [edi]
  002d3	39 45 ec	 cmp	 DWORD PTR _exponent$1$[ebp], eax
  002d6	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 290  : 
; 291  : 		/* Add 'e' or 'E' separator */
; 292  : 		*--(*string) = digits[0xe];
; 293  : 		break;

  002d8	8b 5d fc	 mov	 ebx, DWORD PTR _precision$1$[ebp]
  002db	0f 9c c0	 setl	 al
  002de	8d 04 45 2b 00
	00 00		 lea	 eax, DWORD PTR [eax*2+43]
  002e5	88 01		 mov	 BYTE PTR [ecx], al
  002e7	ff 0f		 dec	 DWORD PTR [edi]
  002e9	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002eb	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  002ee	88 01		 mov	 BYTE PTR [ecx], al
  002f0	eb 48		 jmp	 SHORT $LN33@format_flo
$LN103@format_flo:

; 294  : 
; 295  : 	case ('A'):
; 296  : 		digits = digits_u;

  002f2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN102@format_flo:
  002f9	dd d8		 fstp	 ST(0)

; 297  : 	case ('a'):
; 298  : 		//            base = 16;
; 299  : 		// FIXME: TODO
; 300  : 
; 301  : 	case ('f'):
; 302  : 	default:
; 303  : 		/* Shift the decimal point and round */
; 304  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  002fb	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  002fe	dd 5d d0	 fstp	 QWORD PTR tv351[ebp]
  00301	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00307	dd 45 d0	 fld	 QWORD PTR tv351[ebp]
  0030a	e8 00 00 00 00	 call	 __CIpow
  0030f	db 45 f4	 fild	 DWORD PTR _sign$[ebp]
  00312	83 ec 08	 sub	 esp, 8
  00315	dd 5d d0	 fstp	 QWORD PTR tv344[ebp]
  00318	dd 45 d0	 fld	 QWORD PTR tv344[ebp]
  0031b	dc 4d e0	 fmul	 QWORD PTR _fpval$1$[ebp]
  0031e	de c9		 fmulp	 ST(1), ST(0)
  00320	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00326	dd 1c 24	 fstp	 QWORD PTR [esp]
  00329	e8 00 00 00 00	 call	 _floor
  0032e	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]
  00331	83 c4 08	 add	 esp, 8
  00334	eb 04		 jmp	 SHORT $LN33@format_flo
$LN135@format_flo:
  00336	dd d9		 fstp	 ST(1)
$LN176@format_flo:
  00338	dd d8		 fstp	 ST(0)
$LN33@format_flo:

; 305  : 		break;
; 306  : 	}
; 307  : 
; 308  : 	/* Handle sign */
; 309  : 	if (fpval < 0)

  0033a	dd 45 e0	 fld	 QWORD PTR _fpval$1$[ebp]
  0033d	d9 ee		 fldz
  0033f	df f1		 fcomip	 ST(1)
  00341	76 0b		 jbe	 SHORT $LN18@format_flo

; 310  : 	{
; 311  : 		*prefix = ("-");

  00343	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00346	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  0034c	eb 1f		 jmp	 SHORT $LN14@format_flo
$LN18@format_flo:

; 312  : 	}
; 313  : 	else if (flags & FLAG_FORCE_SIGN)

  0034e	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00351	a8 02		 test	 al, 2
  00353	74 0b		 je	 SHORT $LN16@format_flo

; 314  : 		*prefix = ("+");

  00355	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00358	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_C@_01MIFGBAGJ@?$CL?$AA@
  0035e	eb 0d		 jmp	 SHORT $LN14@format_flo
$LN16@format_flo:

; 315  : 	else if (flags & FLAG_FORCE_SIGNSP)

  00360	a8 04		 test	 al, 4
  00362	74 09		 je	 SHORT $LN14@format_flo

; 316  : 		*prefix = (" ");

  00364	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00367	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_C@_01CLKCMJKC@?5?$AA@
$LN14@format_flo:

; 317  : 
; 318  : 	/* Handle special cases first */
; 319  : 	if (_isnan((double)fpval))

  0036d	83 ec 08	 sub	 esp, 8
  00370	dd 1c 24	 fstp	 QWORD PTR [esp]
  00373	e8 00 00 00 00	 call	 __isnan
  00378	83 c4 08	 add	 esp, 8
  0037b	85 c0		 test	 eax, eax
  0037d	74 26		 je	 SHORT $LN13@format_flo

; 320  : 	{
; 321  : 		(*string) -= sizeof(_nan) / sizeof(char) - 1;

  0037f	83 07 fb	 add	 DWORD PTR [edi], -5	; fffffffbH

; 322  : 		strcpy((*string), _nan);

  00382	b9 00 00 00 00	 mov	 ecx, OFFSET ?_nan@?1??format_float@@9@9
  00387	8b 17		 mov	 edx, DWORD PTR [edi]
  00389	8d a4 24 00 00
	00 00		 npad	 7
$LL48@format_flo:
  00390	8a 01		 mov	 al, BYTE PTR [ecx]
  00392	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00395	88 02		 mov	 BYTE PTR [edx], al
  00397	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0039a	84 c0		 test	 al, al
  0039c	75 f2		 jne	 SHORT $LL48@format_flo

; 323  : 		fpval2 = 1;

  0039e	d9 e8		 fld1
  003a0	e9 ac 00 00 00	 jmp	 $LN177@format_flo
$LN13@format_flo:

; 324  : 	}
; 325  : 	else if (!_finite((double)fpval))

  003a5	dd 45 e0	 fld	 QWORD PTR _fpval$1$[ebp]
  003a8	83 ec 08	 sub	 esp, 8
  003ab	dd 1c 24	 fstp	 QWORD PTR [esp]
  003ae	e8 00 00 00 00	 call	 __finite
  003b3	83 c4 08	 add	 esp, 8
  003b6	85 c0		 test	 eax, eax
  003b8	75 1c		 jne	 SHORT $LN54@format_flo

; 326  : 	{
; 327  : 		(*string) -= sizeof(_infinity) / sizeof(char) - 1;

  003ba	83 07 fc	 add	 DWORD PTR [edi], -4	; fffffffcH

; 328  : 		strcpy((*string), _infinity);

  003bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?_infinity@?1??format_float@@9@9
  003c2	8b 17		 mov	 edx, DWORD PTR [edi]
$LL49@format_flo:
  003c4	8a 01		 mov	 al, BYTE PTR [ecx]
  003c6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  003c9	88 02		 mov	 BYTE PTR [edx], al
  003cb	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003ce	84 c0		 test	 al, al
  003d0	75 f2		 jne	 SHORT $LL49@format_flo

; 329  : 		fpval2 = 1;

  003d2	d9 e8		 fld1

; 330  : 	}
; 331  : 	else

  003d4	eb 7b		 jmp	 SHORT $LN177@format_flo
$LN54@format_flo:

; 332  : 	{
; 333  : 		/* Zero padding */
; 334  : 		while (padding-- > 0) *--(*string) = ('0');

  003d6	8b 4d e8	 mov	 ecx, DWORD PTR _padding$1$[ebp]
  003d9	85 c9		 test	 ecx, ecx
  003db	7e 0f		 jle	 SHORT $LN60@format_flo
  003dd	8d 49 00	 npad	 3
$LL9@format_flo:
  003e0	ff 0f		 dec	 DWORD PTR [edi]
  003e2	49		 dec	 ecx
  003e3	8b 07		 mov	 eax, DWORD PTR [edi]
  003e5	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  003e8	85 c9		 test	 ecx, ecx
  003ea	7f f4		 jg	 SHORT $LL9@format_flo
$LN60@format_flo:

; 335  : 
; 336  : 		/* Digits after the decimal point */
; 337  : 		num_digits = precision;

  003ec	89 5d 10	 mov	 DWORD PTR _num_digits$2$[ebp], ebx

; 338  : 		while (num_digits-- > 0)

  003ef	85 db		 test	 ebx, ebx
  003f1	7e 65		 jle	 SHORT $LN82@format_flo
  003f3	dd 45 f0	 fld	 QWORD PTR _fpval2$1$[ebp]
$LN7@format_flo:

; 339  : 		{
; 340  : 			*--(*string) = digits[(unsigned __int64)fpval2 % 10];

  003f6	ff 0f		 dec	 DWORD PTR [edi]
  003f8	d9 c0		 fld	 ST(0)
  003fa	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  00400	33 c9		 xor	 ecx, ecx
  00402	d9 c9		 fxch	 ST(1)
  00404	89 4d 10	 mov	 DWORD PTR tv322[ebp], ecx
  00407	4b		 dec	 ebx
  00408	33 f6		 xor	 esi, esi
  0040a	db f1		 fcomi	 ST(1)
  0040c	72 15		 jb	 SHORT $LN151@format_flo
  0040e	d8 e1		 fsub	 ST(0), ST(1)
  00410	d9 c9		 fxch	 ST(1)
  00412	df f1		 fcomip	 ST(1)
  00414	76 0f		 jbe	 SHORT $LN87@format_flo
  00416	03 f1		 add	 esi, ecx
  00418	81 d1 00 00 00
	80		 adc	 ecx, -2147483648	; 80000000H
  0041e	89 4d 10	 mov	 DWORD PTR tv322[ebp], ecx
  00421	eb 02		 jmp	 SHORT $LN87@format_flo
$LN151@format_flo:
  00423	dd d9		 fstp	 ST(1)
$LN87@format_flo:
  00425	e8 00 00 00 00	 call	 __ftol2
  0042a	03 c6		 add	 eax, esi
  0042c	6a 00		 push	 0
  0042e	13 55 10	 adc	 edx, DWORD PTR tv322[ebp]
  00431	6a 0a		 push	 10			; 0000000aH
  00433	52		 push	 edx
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 __aullrem
  0043a	8b 4d f8	 mov	 ecx, DWORD PTR _digits$1$[ebp]

; 341  : 			fpval2 /= base;

  0043d	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4024000000000000
  00443	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00446	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00448	88 01		 mov	 BYTE PTR [ecx], al
  0044a	85 db		 test	 ebx, ebx
  0044c	7f a8		 jg	 SHORT $LN7@format_flo
  0044e	8b 5d fc	 mov	 ebx, DWORD PTR _precision$1$[ebp]
$LN177@format_flo:
  00451	dd 5d f0	 fstp	 QWORD PTR _fpval2$1$[ebp]

; 342  : 		}
; 343  : 	}
; 344  : 
; 345  : 	if (precision > 0 || flags & FLAG_SPECIAL)

  00454	85 db		 test	 ebx, ebx
  00456	7f 06		 jg	 SHORT $LN4@format_flo
$LN82@format_flo:
  00458	f6 45 0c 10	 test	 BYTE PTR _flags$[ebp], 16 ; 00000010H
  0045c	74 07		 je	 SHORT $LN83@format_flo
$LN4@format_flo:

; 346  : 		*--(*string) = ('.');

  0045e	ff 0f		 dec	 DWORD PTR [edi]
  00460	8b 07		 mov	 eax, DWORD PTR [edi]
  00462	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
$LN83@format_flo:
  00465	dd 45 f0	 fld	 QWORD PTR _fpval2$1$[ebp]
  00468	33 f6		 xor	 esi, esi
  0046a	d9 c0		 fld	 ST(0)
  0046c	33 db		 xor	 ebx, ebx
  0046e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  00474	d9 c9		 fxch	 ST(1)
  00476	db f1		 fcomi	 ST(1)
  00478	72 12		 jb	 SHORT $LN88@format_flo
  0047a	d8 e1		 fsub	 ST(0), ST(1)
  0047c	d9 c9		 fxch	 ST(1)
  0047e	db f1		 fcomi	 ST(1)
  00480	76 08		 jbe	 SHORT $LN163@format_flo
  00482	03 f3		 add	 esi, ebx
  00484	81 d3 00 00 00
	80		 adc	 ebx, -2147483648	; 80000000H
$LN163@format_flo:
  0048a	d9 c9		 fxch	 ST(1)
$LN88@format_flo:
  0048c	e8 00 00 00 00	 call	 __ftol2
  00491	8b c8		 mov	 ecx, eax
  00493	03 ce		 add	 ecx, esi
  00495	13 d3		 adc	 edx, ebx
$LN3@format_flo:

; 347  : 
; 348  : 	/* Digits before the decimal point */
; 349  : 	do
; 350  : 	{
; 351  : 		*--(*string) = digits[(unsigned __int64)fpval2 % base];

  00497	ff 0f		 dec	 DWORD PTR [edi]
  00499	8b 37		 mov	 esi, DWORD PTR [edi]
  0049b	6a 00		 push	 0
  0049d	6a 0a		 push	 10			; 0000000aH
  0049f	52		 push	 edx
  004a0	51		 push	 ecx
  004a1	e8 00 00 00 00	 call	 __aullrem

; 352  : 		fpval2 /= base;

  004a6	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000

; 353  : 	}
; 354  : 	while ((unsigned __int64)fpval2);

  004ac	33 db		 xor	 ebx, ebx
  004ae	de fa		 fdivp	 ST(2), ST(0)
  004b0	8b 4d f8	 mov	 ecx, DWORD PTR _digits$1$[ebp]
  004b3	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  004b6	88 06		 mov	 BYTE PTR [esi], al
  004b8	33 f6		 xor	 esi, esi
  004ba	d9 c1		 fld	 ST(1)
  004bc	db f1		 fcomi	 ST(1)
  004be	72 12		 jb	 SHORT $LN89@format_flo
  004c0	d8 e1		 fsub	 ST(0), ST(1)
  004c2	d9 c9		 fxch	 ST(1)
  004c4	db f1		 fcomi	 ST(1)
  004c6	76 08		 jbe	 SHORT $LN171@format_flo
  004c8	03 f3		 add	 esi, ebx
  004ca	81 d3 00 00 00
	80		 adc	 ebx, -2147483648	; 80000000H
$LN171@format_flo:
  004d0	d9 c9		 fxch	 ST(1)
$LN89@format_flo:
  004d2	e8 00 00 00 00	 call	 __ftol2
  004d7	8b c8		 mov	 ecx, eax
  004d9	03 ce		 add	 ecx, esi
  004db	8b c1		 mov	 eax, ecx
  004dd	13 d3		 adc	 edx, ebx
  004df	0b c2		 or	 eax, edx
  004e1	75 b4		 jne	 SHORT $LN3@format_flo
  004e3	5f		 pop	 edi
  004e4	dd d9		 fstp	 ST(1)
  004e6	5e		 pop	 esi
  004e7	dd d8		 fstp	 ST(0)
  004e9	5b		 pop	 ebx

; 355  : 
; 356  : }

  004ea	8b e5		 mov	 esp, ebp
  004ec	5d		 pop	 ebp
  004ed	c3		 ret	 0
  004ee	8b ff		 npad	 2
$LN179@format_flo:
  004f0	00 00 00 00	 DD	 $LN103@format_flo
  004f4	00 00 00 00	 DD	 $LN25@format_flo
  004f8	00 00 00 00	 DD	 $LN32@format_flo
  004fc	00 00 00 00	 DD	 $case_e$180
  00500	00 00 00 00	 DD	 $LN31@format_flo
  00504	00 00 00 00	 DD	 $LN102@format_flo
$LN84@format_flo:
  00508	00		 DB	 0
  00509	05		 DB	 5
  0050a	05		 DB	 5
  0050b	05		 DB	 5
  0050c	01		 DB	 1
  0050d	05		 DB	 5
  0050e	02		 DB	 2
  0050f	05		 DB	 5
  00510	05		 DB	 5
  00511	05		 DB	 5
  00512	05		 DB	 5
  00513	05		 DB	 5
  00514	05		 DB	 5
  00515	05		 DB	 5
  00516	05		 DB	 5
  00517	05		 DB	 5
  00518	05		 DB	 5
  00519	05		 DB	 5
  0051a	05		 DB	 5
  0051b	05		 DB	 5
  0051c	05		 DB	 5
  0051d	05		 DB	 5
  0051e	05		 DB	 5
  0051f	05		 DB	 5
  00520	05		 DB	 5
  00521	05		 DB	 5
  00522	05		 DB	 5
  00523	05		 DB	 5
  00524	05		 DB	 5
  00525	05		 DB	 5
  00526	05		 DB	 5
  00527	05		 DB	 5
  00528	05		 DB	 5
  00529	05		 DB	 5
  0052a	05		 DB	 5
  0052b	05		 DB	 5
  0052c	03		 DB	 3
  0052d	05		 DB	 5
  0052e	04		 DB	 4
_format_float ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_wstring
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_string$ = 16						; size = 4
_count$ = 20						; size = 4
_streamout_wstring PROC					; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 204  : 	wchar_t chr;
; 205  : 	int written = 0;
; 206  : 
; 207  : 	while (count--)

  00005	8b 75 14	 mov	 esi, DWORD PTR _count$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	85 f6		 test	 esi, esi
  0000d	74 22		 je	 SHORT $LN8@streamout_
  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _string$[ebp]
$LL3@streamout_:

; 208  : 	{
; 209  : 		chr = *string++;

  00012	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00015	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]

; 210  : 		{
; 211  : 			if (StreamOutCharacter(out, cnt, chr) == 0) return -1;

  00018	50		 push	 eax
  00019	ff 75 0c	 push	 DWORD PTR _cnt$[ebp]
  0001c	4e		 dec	 esi
  0001d	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00020	e8 00 00 00 00	 call	 _StreamOutCharacter
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	85 c0		 test	 eax, eax
  0002a	74 0c		 je	 SHORT $LN7@streamout_

; 212  : 			written++;

  0002c	47		 inc	 edi
  0002d	85 f6		 test	 esi, esi
  0002f	75 e1		 jne	 SHORT $LL3@streamout_
$LN8@streamout_:

; 213  : 		}
; 214  : 	}
; 215  : 
; 216  : 	return written;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 217  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN7@streamout_:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 210  : 		{
; 211  : 			if (StreamOutCharacter(out, cnt, chr) == 0) return -1;

  0003a	83 c8 ff	 or	 eax, -1
  0003d	5b		 pop	 ebx

; 217  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_streamout_wstring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_astring
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_string$ = 16						; size = 4
_count$ = 20						; size = 4
_streamout_astring PROC					; COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 189  : 	char chr;
; 190  : 	int written = 0;
; 191  : 
; 192  : 	while (count--)

  00005	8b 75 14	 mov	 esi, DWORD PTR _count$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	85 f6		 test	 esi, esi
  0000d	74 24		 je	 SHORT $LN8@streamout_
  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _string$[ebp]
$LL3@streamout_:

; 193  : 	{
; 194  : 		chr = *string++;

  00012	8a 03		 mov	 al, BYTE PTR [ebx]
  00014	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]

; 195  : 		if (StreamOutCharacter(out, cnt, chr) == 0) return -1;

  00017	0f be c0	 movsx	 eax, al
  0001a	4e		 dec	 esi
  0001b	50		 push	 eax
  0001c	ff 75 0c	 push	 DWORD PTR _cnt$[ebp]
  0001f	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00022	e8 00 00 00 00	 call	 _StreamOutCharacter
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	85 c0		 test	 eax, eax
  0002c	74 0c		 je	 SHORT $LN7@streamout_

; 196  : 		written++;

  0002e	47		 inc	 edi
  0002f	85 f6		 test	 esi, esi
  00031	75 df		 jne	 SHORT $LL3@streamout_
$LN8@streamout_:

; 197  : 	}
; 198  : 
; 199  : 	return written;

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 200  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN7@streamout_:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 195  : 		if (StreamOutCharacter(out, cnt, chr) == 0) return -1;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5b		 pop	 ebx

; 200  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_streamout_astring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamOutCharacter
_TEXT	SEGMENT
_oStream$ = 8						; size = 4
_uLen$1 = 12						; size = 4
_oLen$ = 12						; size = 4
_Character$ = 16					; size = 4
_StreamOutCharacter PROC				; COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 159  : 	/* Sanity */
; 160  : 	if (*oLen == 0)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _oLen$[ebp]
  00007	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0000a	75 05		 jne	 SHORT $LN3@StreamOutC

; 161  : 		return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	5b		 pop	 ebx

; 183  : #endif
; 184  : 	}
; 185  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN3@StreamOutC:
  00011	57		 push	 edi

; 162  : 
; 163  : 	/* Do we have a stream to write to? */
; 164  : 	if (oStream) {

  00012	8b 7d 08	 mov	 edi, DWORD PTR _oStream$[ebp]
  00015	85 ff		 test	 edi, edi
  00017	74 26		 je	 SHORT $LN2@StreamOutC

; 165  : 		/* We cannot just copy an U32 character 
; 166  : 		 * to stream like this, we must encode it back */
; 167  : 		uint32_t uLen = 0;
; 168  : 		StreamCharacterToUtf8(Character, *oStream, &uLen);

  00019	8d 45 0c	 lea	 eax, DWORD PTR _uLen$1[ebp]
  0001c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _uLen$1[ebp], 0
  00023	50		 push	 eax
  00024	ff 37		 push	 DWORD PTR [edi]
  00026	ff 75 10	 push	 DWORD PTR _Character$[ebp]
  00029	e8 00 00 00 00	 call	 _StreamCharacterToUtf8

; 169  : 		(*oStream) += uLen;

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _uLen$1[ebp]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	01 0f		 add	 DWORD PTR [edi], ecx

; 170  : 		*oLen -= uLen;

  00036	29 0b		 sub	 DWORD PTR [ebx], ecx

; 171  : 
; 172  : 		/* Done ! */
; 173  : 		return Character;

  00038	8b 45 10	 mov	 eax, DWORD PTR _Character$[ebp]
  0003b	5f		 pop	 edi
  0003c	5b		 pop	 ebx

; 183  : #endif
; 184  : 	}
; 185  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN2@StreamOutC:

; 174  : 	}
; 175  : 	else 
; 176  : 	{
; 177  : 		/* These routines need the 
; 178  : 		 * unicode-point */
; 179  : #ifndef LIBC_KERNEL
; 180  : 		return putchar(Character);
; 181  : #else
; 182  : 		return VideoPutChar(Character);

  0003f	ff 75 10	 push	 DWORD PTR _Character$[ebp]
  00042	e8 00 00 00 00	 call	 _VideoPutChar
  00047	83 c4 04	 add	 esp, 4
  0004a	5f		 pop	 edi
  0004b	5b		 pop	 ebx

; 183  : #endif
; 184  : 	}
; 185  : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_StreamOutCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _StreamCharacterToUtf8
_TEXT	SEGMENT
_TmpBuffer$ = -12					; size = 10
_Character$ = 8						; size = 4
_oBuffer$ = 12						; size = 4
_Length$ = 16						; size = 4
_StreamCharacterToUtf8 PROC				; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 77   : 	/* Encode Buffer */
; 78   : 	char TmpBuffer[10] = { 0 };
; 79   : 	char* BufPtr = &TmpBuffer[0];
; 80   : 
; 81   : 	uint32_t NumBytes = 0;
; 82   : 	uint32_t Error = 0;
; 83   : 
; 84   : 	if (Character <= 0x7F)  /* 0XXX XXXX one byte */

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _Character$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	c6 45 f4 00	 mov	 BYTE PTR _TmpBuffer$[ebp], 0
  00013	33 ff		 xor	 edi, edi
  00015	89 45 f5	 mov	 DWORD PTR _TmpBuffer$[ebp+1], eax
  00018	89 45 f9	 mov	 DWORD PTR _TmpBuffer$[ebp+5], eax
  0001b	88 45 fd	 mov	 BYTE PTR _TmpBuffer$[ebp+9], al
  0001e	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00021	77 0b		 ja	 SHORT $LN18@StreamChar

; 85   : 	{
; 86   : 		TmpBuffer[0] = (char)Character;

  00023	88 4d f4	 mov	 BYTE PTR _TmpBuffer$[ebp], cl

; 87   : 		NumBytes = 1;

  00026	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00029	e9 bc 00 00 00	 jmp	 $LN21@StreamChar
$LN18@StreamChar:

; 88   : 	}
; 89   : 	else if (Character <= 0x7FF)  /* 110X XXXX  two bytes */

  0002e	81 f9 ff 07 00
	00		 cmp	 ecx, 2047		; 000007ffH
  00034	77 1d		 ja	 SHORT $LN16@StreamChar

; 90   : 	{
; 91   : 		TmpBuffer[0] = (char)(0xC0 | (Character >> 6));

  00036	8b c1		 mov	 eax, ecx

; 92   : 		TmpBuffer[1] = (char)(0x80 | (Character & 0x3F));
; 93   : 		NumBytes = 2;

  00038	be 02 00 00 00	 mov	 esi, 2
  0003d	c1 e8 06	 shr	 eax, 6
  00040	80 e1 3f	 and	 cl, 63			; 0000003fH
  00043	0c c0		 or	 al, -64			; ffffffc0H
  00045	80 c9 80	 or	 cl, -128		; ffffff80H
  00048	88 45 f4	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  0004b	88 4d f5	 mov	 BYTE PTR _TmpBuffer$[ebp+1], cl
  0004e	e9 97 00 00 00	 jmp	 $LN21@StreamChar
$LN16@StreamChar:

; 94   : 	}
; 95   : 	else if (Character <= 0xFFFF)  /* 1110 XXXX  three bytes */

  00053	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00059	77 4f		 ja	 SHORT $LN14@StreamChar

; 96   : 	{
; 97   : 		TmpBuffer[0] = (char)(0xE0 | (Character >> 12));

  0005b	8b c1		 mov	 eax, ecx

; 98   : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 99   : 		TmpBuffer[2] = (char)(0x80 | (Character & 0x3F));
; 100  : 		NumBytes = 3;

  0005d	be 03 00 00 00	 mov	 esi, 3
  00062	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00065	0c e0		 or	 al, -32			; ffffffe0H
  00067	88 45 f4	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  0006a	8b c1		 mov	 eax, ecx
  0006c	c1 e8 06	 shr	 eax, 6
  0006f	24 3f		 and	 al, 63			; 0000003fH
  00071	0c 80		 or	 al, -128		; ffffff80H
  00073	88 45 f5	 mov	 BYTE PTR _TmpBuffer$[ebp+1], al
  00076	8a c1		 mov	 al, cl
  00078	24 3f		 and	 al, 63			; 0000003fH
  0007a	0c 80		 or	 al, -128		; ffffff80H
  0007c	88 45 f6	 mov	 BYTE PTR _TmpBuffer$[ebp+2], al

; 101  : 
; 102  : 		/* Sanity no special characters */
; 103  : 		if (Character == 0xFFFE || Character == 0xFFFF)

  0007f	81 f9 fe ff 00
	00		 cmp	 ecx, 65534		; 0000fffeH
  00085	74 08		 je	 SHORT $LN5@StreamChar
  00087	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0008d	75 5b		 jne	 SHORT $LN21@StreamChar
$LN5@StreamChar:

; 128  : 	{
; 129  : 		TmpBuffer[0] = (char)(0xFC | (Character >> 30));
; 130  : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 24) & 0x3F));
; 131  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 18) & 0x3F));
; 132  : 		TmpBuffer[3] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 133  : 		TmpBuffer[4] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 134  : 		TmpBuffer[5] = (char)(0x80 | (Character & 0x3F));
; 135  : 		NumBytes = 6;
; 136  : 		Error = 1;
; 137  : 	}
; 138  : 	else
; 139  : 		Error = 1;

  0008f	bf 01 00 00 00	 mov	 edi, 1
$LN3@StreamChar:

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00094	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  00097	89 30		 mov	 DWORD PTR [eax], esi

; 147  : 
; 148  : 	/* Sanity */
; 149  : 	if (Error)

  00099	85 ff		 test	 edi, edi
  0009b	0f 84 98 00 00
	00		 je	 $LN2@StreamChar

; 150  : 		return -1;

  000a1	5f		 pop	 edi
  000a2	83 c8 ff	 or	 eax, -1
  000a5	5e		 pop	 esi

; 153  : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN14@StreamChar:

; 104  : 			Error = 1;
; 105  : 	}
; 106  : 	else if (Character <= 0x1FFFFF)  /* 1111 0XXX  four bytes */

  000aa	81 f9 ff ff 1f
	00		 cmp	 ecx, 2097151		; 001fffffH
  000b0	77 4f		 ja	 SHORT $LN10@StreamChar

; 107  : 	{
; 108  : 		TmpBuffer[0] = (char)(0xF0 | (Character >> 18));

  000b2	8b c1		 mov	 eax, ecx

; 109  : 		TmpBuffer[1] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 110  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 111  : 		TmpBuffer[3] = (char)(0x80 | (Character & 0x3F));
; 112  : 		NumBytes = 4;

  000b4	be 04 00 00 00	 mov	 esi, 4
  000b9	c1 e8 12	 shr	 eax, 18			; 00000012H
  000bc	0c f0		 or	 al, -16			; fffffff0H
  000be	88 45 f4	 mov	 BYTE PTR _TmpBuffer$[ebp], al
  000c1	8b c1		 mov	 eax, ecx
  000c3	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000c6	24 3f		 and	 al, 63			; 0000003fH
  000c8	0c 80		 or	 al, -128		; ffffff80H
  000ca	88 45 f5	 mov	 BYTE PTR _TmpBuffer$[ebp+1], al
  000cd	8b c1		 mov	 eax, ecx
  000cf	c1 e8 06	 shr	 eax, 6
  000d2	24 3f		 and	 al, 63			; 0000003fH
  000d4	0c 80		 or	 al, -128		; ffffff80H
  000d6	88 45 f6	 mov	 BYTE PTR _TmpBuffer$[ebp+2], al
  000d9	8a c1		 mov	 al, cl
  000db	24 3f		 and	 al, 63			; 0000003fH
  000dd	0c 80		 or	 al, -128		; ffffff80H
  000df	88 45 f7	 mov	 BYTE PTR _TmpBuffer$[ebp+3], al

; 113  : 
; 114  : 		if (Character > 0x10FFFF)

  000e2	81 f9 ff ff 10
	00		 cmp	 ecx, 1114111		; 0010ffffH
  000e8	77 a5		 ja	 SHORT $LN5@StreamChar
$LN21@StreamChar:

; 140  : 
; 141  : 	/* Write buffer only if it's a valid byte sequence */
; 142  : 	if (!Error && oBuffer != NULL)

  000ea	8b 45 0c	 mov	 eax, DWORD PTR _oBuffer$[ebp]
  000ed	85 c0		 test	 eax, eax
  000ef	74 a3		 je	 SHORT $LN3@StreamChar

; 143  : 		memcpy(oBuffer, BufPtr, NumBytes);

  000f1	56		 push	 esi
  000f2	8d 4d f4	 lea	 ecx, DWORD PTR _TmpBuffer$[ebp]
  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _memcpy
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	eb 93		 jmp	 SHORT $LN3@StreamChar
$LN10@StreamChar:

; 115  : 			Error = 1;
; 116  : 	}
; 117  : 	else if (Character <= 0x3FFFFFF)  /* 1111 10XX  five bytes */

  00101	81 f9 ff ff ff
	03		 cmp	 ecx, 67108863		; 03ffffffH
  00107	77 12		 ja	 SHORT $LN7@StreamChar

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00109	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5

; 150  : 		return -1;

  00114	83 c8 ff	 or	 eax, -1

; 153  : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
$LN7@StreamChar:

; 118  : 	{
; 119  : 		TmpBuffer[0] = (char)(0xF8 | (Character >> 24));
; 120  : 		TmpBuffer[1] = (char)(0x80 | (Character >> 18));
; 121  : 		TmpBuffer[2] = (char)(0x80 | ((Character >> 12) & 0x3F));
; 122  : 		TmpBuffer[3] = (char)(0x80 | ((Character >> 6) & 0x3F));
; 123  : 		TmpBuffer[4] = (char)(0x80 | (Character & 0x3F));
; 124  : 		NumBytes = 5;
; 125  : 		Error = 1;
; 126  : 	}
; 127  : 	else if (Character <= 0x7FFFFFFF)  /* 1111 110X  six bytes */

  0011b	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00121	0f 87 68 ff ff
	ff		 ja	 $LN5@StreamChar

; 144  : 
; 145  : 	/* We want the length */
; 146  : 	*Length = NumBytes;

  00127	8b 45 10	 mov	 eax, DWORD PTR _Length$[ebp]
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6

; 150  : 		return -1;

  00132	83 c8 ff	 or	 eax, -1

; 153  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
$LN2@StreamChar:
  00139	5f		 pop	 edi

; 151  : 	else
; 152  : 		return 0;

  0013a	33 c0		 xor	 eax, eax
  0013c	5e		 pop	 esi

; 153  : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
_StreamCharacterToUtf8 ENDP
_TEXT	ENDS
END
