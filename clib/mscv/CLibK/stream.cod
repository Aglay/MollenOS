; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\stdio\stream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2354	DB	'-', 00H
	ORG $+2
$SG2357	DB	'+', 00H
	ORG $+2
$SG2360	DB	' ', 00H
	ORG $+2
$SG2399	DB	'(null)', 00H
	ORG $+1
?_nullstring@?1??streamout@@9@9 DD FLAT:$SG2399		; `streamout'::`2'::_nullstring
$SG2607	DB	'-', 00H
	ORG $+2
$SG2610	DB	'+', 00H
	ORG $+2
$SG2613	DB	' ', 00H
	ORG $+2
$SG2617	DB	'0', 00H
_DATA	ENDS
CONST	SEGMENT
?digits_l@?1??format_float@@9@9 DB '0123456789abcdef0x', 00H ; `format_float'::`2'::digits_l
	ORG $+1
?digits_u@?1??format_float@@9@9 DB '0123456789ABCDEF0X', 00H ; `format_float'::`2'::digits_u
	ORG $+1
?_nan@?1??format_float@@9@9 DB '#QNAN', 00H		; `format_float'::`2'::_nan
	ORG $+2
?_infinity@?1??format_float@@9@9 DB '#INF', 00H		; `format_float'::`2'::_infinity
	ORG $+3
?digits_l@?1??streamout@@9@9 DB '0123456789abcdef0x', 00H ; `streamout'::`2'::digits_l
	ORG $+1
?digits_u@?1??streamout@@9@9 DB '0123456789ABCDEF0X', 00H ; `streamout'::`2'::digits_u
CONST	ENDS
EXTRN	_video_putchar:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_char
_TEXT	SEGMENT
_streamout_char PROC					; COMDAT
; _out$ = ecx
; _cnt$ = edx
; _c$ = eax

; 73   : 	/* Sanity */
; 74   : 	if(*cnt == 0)

  00000	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00003	75 03		 jne	 SHORT $LN3@streamout_

; 75   : 		return 0;

  00005	33 c0		 xor	 eax, eax

; 89   : #endif
; 90   : 	}
; 91   : }

  00007	c3		 ret	 0
$LN3@streamout_:

; 76   : 
; 77   : 	if (out) {

  00008	85 c9		 test	 ecx, ecx
  0000a	74 0b		 je	 SHORT $LN2@streamout_

; 78   : 		**out = (char)c;

  0000c	56		 push	 esi
  0000d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000f	88 06		 mov	 BYTE PTR [esi], al

; 79   : 		++(*out);

  00011	ff 01		 inc	 DWORD PTR [ecx]

; 80   : 		*cnt -= 1;

  00013	ff 0a		 dec	 DWORD PTR [edx]
  00015	5e		 pop	 esi

; 89   : #endif
; 90   : 	}
; 91   : }

  00016	c3		 ret	 0
$LN2@streamout_:

; 81   : 		return c;
; 82   : 	}
; 83   : 	else 
; 84   : 	{
; 85   : #ifndef LIBC_KERNEL
; 86   : 		return putchar(c);
; 87   : #else
; 88   : 		return video_putchar(c);

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _video_putchar
  0001d	83 c4 04	 add	 esp, 4

; 89   : #endif
; 90   : 	}
; 91   : }

  00020	c3		 ret	 0
_streamout_char ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _streamout_astring
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_streamout_astring PROC					; COMDAT
; _string$ = ecx
; _count$ = eax

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax

; 95   : 	char chr;
; 96   : 	int written = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx

; 97   : 
; 98   : 	while (count--)

  0000c	85 f6		 test	 esi, esi
  0000e	74 1b		 je	 SHORT $LN8@streamout_@2
$LL3@streamout_@2:

; 99   : 	{
; 100  : 		chr = *string++;

  00010	8a 07		 mov	 al, BYTE PTR [edi]

; 101  : 		if (streamout_char(out, cnt, chr) == 0) return -1;

  00012	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  00018	0f be c0	 movsx	 eax, al
  0001b	4e		 dec	 esi
  0001c	47		 inc	 edi
  0001d	e8 00 00 00 00	 call	 _streamout_char
  00022	85 c0		 test	 eax, eax
  00024	74 0c		 je	 SHORT $LN7@streamout_@2

; 102  : 		written++;

  00026	43		 inc	 ebx
  00027	85 f6		 test	 esi, esi
  00029	75 e5		 jne	 SHORT $LL3@streamout_@2
$LN8@streamout_@2:
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 103  : 	}
; 104  : 
; 105  : 	return written;

  0002d	8b c3		 mov	 eax, ebx
  0002f	5b		 pop	 ebx

; 106  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN7@streamout_@2:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 101  : 		if (streamout_char(out, cnt, chr) == 0) return -1;

  00034	83 c8 ff	 or	 eax, -1
  00037	5b		 pop	 ebx

; 106  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_streamout_astring ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _streamout_wstring
_TEXT	SEGMENT
_written$ = -4						; size = 4
_out$ = 8						; size = 4
_streamout_wstring PROC					; COMDAT
; _cnt$ = ebx
; _string$ = ecx
; _count$ = eax

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 110  : 	wchar_t chr;
; 111  : 	int written = 0;

  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _written$[ebp], 0

; 112  : 
; 113  : 	while (count--)

  00011	85 f6		 test	 esi, esi
  00013	74 1c		 je	 SHORT $LN8@streamout_@3
$LL3@streamout_@3:

; 114  : 	{
; 115  : 		chr = *string++;

  00015	0f b7 07	 movzx	 eax, WORD PTR [edi]

; 116  : 		{
; 117  : 			if (streamout_char(out, cnt, chr) == 0) return -1;

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  0001b	8b d3		 mov	 edx, ebx
  0001d	4e		 dec	 esi
  0001e	83 c7 02	 add	 edi, 2
  00021	e8 00 00 00 00	 call	 _streamout_char
  00026	85 c0		 test	 eax, eax
  00028	74 10		 je	 SHORT $LN7@streamout_@3

; 118  : 			written++;

  0002a	ff 45 fc	 inc	 DWORD PTR _written$[ebp]
  0002d	85 f6		 test	 esi, esi
  0002f	75 e4		 jne	 SHORT $LL3@streamout_@3
$LN8@streamout_@3:

; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	return written;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _written$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 123  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN7@streamout_@3:
  0003a	5f		 pop	 edi

; 116  : 		{
; 117  : 			if (streamout_char(out, cnt, chr) == 0) return -1;

  0003b	83 c8 ff	 or	 eax, -1
  0003e	5e		 pop	 esi

; 123  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_streamout_wstring ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_format_float
EXTRN	__finite:PROC
EXTRN	__isnan:PROC
EXTRN	__fltused:DWORD
EXTRN	__aullrem:PROC
EXTRN	__ftol2:PROC
EXTRN	__CIpow:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	__CIlog10:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _format_float
_TEXT	SEGMENT
tv381 = -44						; size = 8
tv446 = -36						; size = 8
tv443 = -36						; size = 8
_fpval$ = -28						; size = 8
_padding$ = -20						; size = 4
_exponent$ = -16					; size = 4
_fpval2$ = -12						; size = 8
_sign$ = -8						; size = 4
_digits$ = -4						; size = 4
tv468 = 8						; size = 4
tv458 = 8						; size = 4
tv428 = 8						; size = 4
_chr$ = 8						; size = 1
_flags$ = 12						; size = 4
_precision$ = 16					; size = 4
_string$ = 20						; size = 4
_prefix$ = 24						; size = 4
_argptr$ = 28						; size = 4
_format_float PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx

; 128  : 	static const char digits_l[] = ("0123456789abcdef0x");
; 129  : 	static const char digits_u[] = ("0123456789ABCDEF0X");
; 130  : 	static const char _nan[] = ("#QNAN");
; 131  : 	static const char _infinity[] = ("#INF");
; 132  : 	const char *digits = digits_l;
; 133  : 	int exponent = 0, sign;
; 134  : 	long double fpval, fpval2;
; 135  : 	int padding = 0, num_digits, val32, base = 10;
; 136  : 
; 137  : 	/* Normalize the precision */
; 138  : 	if (precision < 0) precision = 6;

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_l@?1??format_float@@9@9
  00013	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _padding$[ebp], 0
  0001a	85 db		 test	 ebx, ebx
  0001c	79 09		 jns	 SHORT $LN37@format_flo
  0001e	c7 45 10 06 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 6
  00025	eb 12		 jmp	 SHORT $LN133@format_flo
$LN37@format_flo:

; 139  : 	else if (precision > 17)

  00027	83 fb 11	 cmp	 ebx, 17			; 00000011H
  0002a	7e 10		 jle	 SHORT $LN35@format_flo

; 140  : 	{
; 141  : 		padding = precision - 17;

  0002c	83 c3 ef	 add	 ebx, -17		; ffffffefH
  0002f	89 5d ec	 mov	 DWORD PTR _padding$[ebp], ebx

; 142  : 		precision = 17;

  00032	c7 45 10 11 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 17 ; 00000011H
$LN133@format_flo:
  00039	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
$LN35@format_flo:

; 143  : 	}
; 144  : 
; 145  : 	/* Get the float value and calculate the exponent */
; 146  : 	fpval = va_arg_ffp(*argptr, flags);

  0003c	8b 45 1c	 mov	 eax, DWORD PTR _argptr$[ebp]
  0003f	83 00 08	 add	 DWORD PTR [eax], 8
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	dd 40 f8	 fld	 QWORD PTR [eax-8]
  00047	dd 55 e4	 fst	 QWORD PTR _fpval$[ebp]

; 147  : 	exponent = get_exp((double)fpval);

  0004a	d9 c0		 fld	 ST(0)
  0004c	d9 ee		 fldz
  0004e	d9 c0		 fld	 ST(0)
  00050	dd ea		 fucomp	 ST(2)
  00052	df e0		 fnstsw	 ax
  00054	dd d9		 fstp	 ST(1)
  00056	f6 c4 44	 test	 ah, 68			; 00000044H
  00059	7a 04		 jp	 SHORT $LN44@format_flo
  0005b	dd d9		 fstp	 ST(1)
  0005d	eb 10		 jmp	 SHORT $LN43@format_flo
$LN44@format_flo:
  0005f	d8 d9		 fcomp	 ST(1)
  00061	df e0		 fnstsw	 ax
  00063	f6 c4 41	 test	 ah, 65			; 00000041H
  00066	7b 02		 jnp	 SHORT $LN134@format_flo
  00068	d9 e0		 fchs
$LN134@format_flo:
  0006a	e8 00 00 00 00	 call	 __CIlog10
$LN43@format_flo:
  0006f	83 ec 08	 sub	 esp, 8
  00072	dd 1c 24	 fstp	 QWORD PTR [esp]
  00075	e8 00 00 00 00	 call	 _floor
  0007a	83 c4 08	 add	 esp, 8
  0007d	e8 00 00 00 00	 call	 __ftol2_sse

; 148  : 	sign = fpval < 0 ? -1 : 1;

  00082	d9 ee		 fldz
  00084	dd 45 e4	 fld	 QWORD PTR _fpval$[ebp]
  00087	8b f8		 mov	 edi, eax
  00089	d8 d1		 fcom	 ST(1)
  0008b	89 7d f0	 mov	 DWORD PTR _exponent$[ebp], edi
  0008e	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _sign$[ebp], -1
  00095	df e0		 fnstsw	 ax
  00097	dd d9		 fstp	 ST(1)
  00099	f6 c4 05	 test	 ah, 5
  0009c	7b 07		 jnp	 SHORT $LN47@format_flo
  0009e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1
$LN47@format_flo:

; 149  : 
; 150  : 	switch (chr)

  000a5	0f be 45 08	 movsx	 eax, BYTE PTR _chr$[ebp]
  000a9	8b 75 14	 mov	 esi, DWORD PTR _string$[ebp]
  000ac	83 c0 bf	 add	 eax, -65		; ffffffbfH
  000af	83 f8 26	 cmp	 eax, 38			; 00000026H
  000b2	0f 87 cc 01 00
	00		 ja	 $LN87@format_flo
  000b8	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN68@format_flo[eax]
  000bf	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN136@format_flo[eax*4]
$LN32@format_flo:

; 151  : 	{
; 152  : 	case ('G'):
; 153  : 		digits = digits_u;

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN31@format_flo:

; 154  : 	case ('g'):
; 155  : 		if (precision > 0) precision--;

  000cd	85 db		 test	 ebx, ebx
  000cf	7e 04		 jle	 SHORT $LN30@format_flo
  000d1	4b		 dec	 ebx
  000d2	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
$LN30@format_flo:

; 156  : 		if (exponent < -4 || exponent >= precision) goto case_e;

  000d5	83 ff fc	 cmp	 edi, -4			; fffffffcH
  000d8	0f 8c 91 00 00
	00		 jl	 $case_e$2335
  000de	3b fb		 cmp	 edi, ebx
  000e0	0f 8d 89 00 00
	00		 jge	 $case_e$2335
  000e6	dd d8		 fstp	 ST(0)

; 157  : 
; 158  : 		/* Shift the decimal point and round */
; 159  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  000e8	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  000ee	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  000f1	e8 00 00 00 00	 call	 __CIpow
  000f6	db 45 f8	 fild	 DWORD PTR _sign$[ebp]
  000f9	83 ec 08	 sub	 esp, 8
  000fc	dc 4d e4	 fmul	 QWORD PTR _fpval$[ebp]
  000ff	de c9		 fmulp	 ST(1), ST(0)
  00101	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00107	dd 1c 24	 fstp	 QWORD PTR [esp]
  0010a	e8 00 00 00 00	 call	 _floor
  0010f	83 c4 08	 add	 esp, 8
  00112	dd 55 f4	 fst	 QWORD PTR _fpval2$[ebp]

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  00115	85 db		 test	 ebx, ebx
  00117	0f 84 98 01 00
	00		 je	 $LN104@format_flo
  0011d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
$LN27@format_flo:
  00123	d9 c1		 fld	 ST(1)
  00125	e8 00 00 00 00	 call	 __ftol2
  0012a	6a 00		 push	 0
  0012c	6a 0a		 push	 10			; 0000000aH
  0012e	52		 push	 edx
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 __aullrem
  00135	0b c2		 or	 eax, edx
  00137	75 05		 jne	 SHORT $LN108@format_flo

; 163  : 		{
; 164  : 			precision--;

  00139	4b		 dec	 ebx

; 165  : 			fpval2 /= 10;

  0013a	dc f9		 fdiv	 ST(1), ST(0)
  0013c	75 e5		 jne	 SHORT $LN27@format_flo
$LN108@format_flo:

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  0013e	dd d8		 fstp	 ST(0)

; 163  : 		{
; 164  : 			precision--;

  00140	89 5d 10	 mov	 DWORD PTR _precision$[ebp], ebx
$LN135@format_flo:

; 165  : 			fpval2 /= 10;

  00143	dd 5d f4	 fstp	 QWORD PTR _fpval2$[ebp]
$LN33@format_flo:

; 211  : 		break;
; 212  : 	}
; 213  : 
; 214  : 	/* Handle sign */
; 215  : 	if (fpval < 0)

  00146	d9 ee		 fldz
  00148	dd 45 e4	 fld	 QWORD PTR _fpval$[ebp]
  0014b	d8 d1		 fcom	 ST(1)
  0014d	df e0		 fnstsw	 ax
  0014f	dd d9		 fstp	 ST(1)
  00151	f6 c4 05	 test	 ah, 5
  00154	0f 8a 62 01 00
	00		 jp	 $LN18@format_flo

; 216  : 	{
; 217  : 		*prefix = ("-");

  0015a	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  0015d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2354
  00163	e9 73 01 00 00	 jmp	 $LN14@format_flo
$LN25@format_flo:

; 166  : 		}
; 167  : 		break;
; 168  : 
; 169  : 	case ('E'):
; 170  : 		digits = digits_u;

  00168	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$case_e$2335:

; 171  : 	case ('e'):
; 172  : case_e:
; 173  : 		/* Shift the decimal point and round */
; 174  : 		fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  0016f	da 4d f8	 fimul	 DWORD PTR _sign$[ebp]
  00172	8b cb		 mov	 ecx, ebx
  00174	2b cf		 sub	 ecx, edi
  00176	89 4d 08	 mov	 DWORD PTR tv468[ebp], ecx
  00179	dd 5d d4	 fstp	 QWORD PTR tv381[ebp]
  0017c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  00182	db 45 08	 fild	 DWORD PTR tv468[ebp]
  00185	e8 00 00 00 00	 call	 __CIpow
  0018a	dc 4d d4	 fmul	 QWORD PTR tv381[ebp]
  0018d	83 ec 08	 sub	 esp, 8
  00190	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00196	dd 1c 24	 fstp	 QWORD PTR [esp]
  00199	e8 00 00 00 00	 call	 _floor

; 175  : 
; 176  : 		/* Compensate for changed exponent through rounding */
; 177  : 		if (fpval2 >= (unsigned __int64)pow(10., precision + 1))

  0019e	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  001a1	dd 5d f4	 fstp	 QWORD PTR _fpval2$[ebp]
  001a4	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001aa	89 55 08	 mov	 DWORD PTR tv458[ebp], edx
  001ad	db 45 08	 fild	 DWORD PTR tv458[ebp]
  001b0	83 c4 08	 add	 esp, 8
  001b3	e8 00 00 00 00	 call	 __CIpow
  001b8	e8 00 00 00 00	 call	 __ftol2
  001bd	89 45 dc	 mov	 DWORD PTR tv446[ebp], eax
  001c0	8b c2		 mov	 eax, edx
  001c2	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  001c8	89 55 e0	 mov	 DWORD PTR tv446[ebp+4], edx
  001cb	df 6d dc	 fild	 QWORD PTR tv446[ebp]
  001ce	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001d3	89 45 e0	 mov	 DWORD PTR tv443[ebp+4], eax
  001d6	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv443[ebp], 0
  001dd	df 6d dc	 fild	 QWORD PTR tv443[ebp]
  001e0	d9 e0		 fchs
  001e2	de c1		 faddp	 ST(1), ST(0)
  001e4	dc 5d f4	 fcomp	 QWORD PTR _fpval2$[ebp]
  001e7	df e0		 fnstsw	 ax
  001e9	f6 c4 41	 test	 ah, 65			; 00000041H
  001ec	7a 31		 jp	 SHORT $LN23@format_flo

; 178  : 		{
; 179  : 			exponent++;
; 180  : 			fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  001ee	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001f4	47		 inc	 edi
  001f5	2b df		 sub	 ebx, edi
  001f7	89 5d 08	 mov	 DWORD PTR tv428[ebp], ebx
  001fa	db 45 08	 fild	 DWORD PTR tv428[ebp]
  001fd	89 7d f0	 mov	 DWORD PTR _exponent$[ebp], edi
  00200	e8 00 00 00 00	 call	 __CIpow
  00205	dc 4d d4	 fmul	 QWORD PTR tv381[ebp]
  00208	83 ec 08	 sub	 esp, 8
  0020b	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00211	dd 1c 24	 fstp	 QWORD PTR [esp]
  00214	e8 00 00 00 00	 call	 _floor
  00219	dd 5d f4	 fstp	 QWORD PTR _fpval2$[ebp]
  0021c	83 c4 08	 add	 esp, 8
$LN23@format_flo:

; 181  : 		}
; 182  : 
; 183  : 		val32 = exponent >= 0 ? exponent : -exponent;

  0021f	8b c7		 mov	 eax, edi
  00221	99		 cdq
  00222	8b c8		 mov	 ecx, eax
  00224	33 ca		 xor	 ecx, edx
  00226	2b ca		 sub	 ecx, edx

; 184  : 
; 185  : 		// FIXME: handle length of exponent field:
; 186  : 		// http://msdn.microsoft.com/de-de/library/0fatw238%28VS.80%29.aspx
; 187  : 		num_digits = 3;

  00228	bf 03 00 00 00	 mov	 edi, 3
  0022d	8d 49 00	 npad	 3
$LL22@format_flo:

; 188  : 		while (num_digits--)
; 189  : 		{
; 190  : 			*--(*string) = digits[val32 % 10];

  00230	ff 0e		 dec	 DWORD PTR [esi]
  00232	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00234	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00239	f7 e9		 imul	 ecx
  0023b	c1 fa 02	 sar	 edx, 2
  0023e	8b c2		 mov	 eax, edx
  00240	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00243	03 c2		 add	 eax, edx
  00245	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00248	03 d2		 add	 edx, edx
  0024a	2b ca		 sub	 ecx, edx
  0024c	4f		 dec	 edi
  0024d	8b 55 fc	 mov	 edx, DWORD PTR _digits$[ebp]
  00250	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00253	88 0b		 mov	 BYTE PTR [ebx], cl

; 191  : 			val32 /= 10;

  00255	8b c8		 mov	 ecx, eax
  00257	75 d7		 jne	 SHORT $LL22@format_flo

; 192  : 		}
; 193  : 
; 194  : 		/* Sign for the exponent */
; 195  : 		*--(*string) = (exponent >= 0 ? ('+') : ('-'));

  00259	ff 0e		 dec	 DWORD PTR [esi]
  0025b	39 7d f0	 cmp	 DWORD PTR _exponent$[ebp], edi
  0025e	8b 06		 mov	 eax, DWORD PTR [esi]

; 196  : 
; 197  : 		/* Add 'e' or 'E' separator */
; 198  : 		*--(*string) = digits[0xe];

  00260	8b 4d fc	 mov	 ecx, DWORD PTR _digits$[ebp]

; 199  : 		break;

  00263	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
  00266	0f 9c c2	 setl	 dl
  00269	8d 54 12 2b	 lea	 edx, DWORD PTR [edx+edx+43]
  0026d	88 10		 mov	 BYTE PTR [eax], dl
  0026f	ff 0e		 dec	 DWORD PTR [esi]
  00271	8b 06		 mov	 eax, DWORD PTR [esi]
  00273	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  00276	88 10		 mov	 BYTE PTR [eax], dl
  00278	e9 c9 fe ff ff	 jmp	 $LN33@format_flo
$LN88@format_flo:

; 200  : 
; 201  : 	case ('A'):
; 202  : 		digits = digits_u;

  0027d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN87@format_flo:
  00284	dd d8		 fstp	 ST(0)

; 203  : 	case ('a'):
; 204  : 		//            base = 16;
; 205  : 		// FIXME: TODO
; 206  : 
; 207  : 	case ('f'):
; 208  : 	default:
; 209  : 		/* Shift the decimal point and round */
; 210  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  00286	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  0028c	db 45 10	 fild	 DWORD PTR _precision$[ebp]
  0028f	e8 00 00 00 00	 call	 __CIpow
  00294	db 45 f8	 fild	 DWORD PTR _sign$[ebp]
  00297	83 ec 08	 sub	 esp, 8
  0029a	dc 4d e4	 fmul	 QWORD PTR _fpval$[ebp]
  0029d	de c9		 fmulp	 ST(1), ST(0)
  0029f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  002a5	dd 1c 24	 fstp	 QWORD PTR [esp]
  002a8	e8 00 00 00 00	 call	 _floor
  002ad	83 c4 08	 add	 esp, 8
  002b0	e9 8e fe ff ff	 jmp	 $LN135@format_flo
$LN104@format_flo:

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  002b5	dd d8		 fstp	 ST(0)

; 199  : 		break;

  002b7	e9 8a fe ff ff	 jmp	 $LN33@format_flo
$LN18@format_flo:

; 218  : 	}
; 219  : 	else if (flags & FLAG_FORCE_SIGN)

  002bc	8a 45 0c	 mov	 al, BYTE PTR _flags$[ebp]
  002bf	a8 02		 test	 al, 2
  002c1	74 0b		 je	 SHORT $LN16@format_flo

; 220  : 		*prefix = ("+");

  002c3	8b 4d 18	 mov	 ecx, DWORD PTR _prefix$[ebp]
  002c6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET $SG2357
  002cc	eb 0d		 jmp	 SHORT $LN14@format_flo
$LN16@format_flo:

; 221  : 	else if (flags & FLAG_FORCE_SIGNSP)

  002ce	a8 04		 test	 al, 4
  002d0	74 09		 je	 SHORT $LN14@format_flo

; 222  : 		*prefix = (" ");

  002d2	8b 55 18	 mov	 edx, DWORD PTR _prefix$[ebp]
  002d5	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET $SG2360
$LN14@format_flo:

; 223  : 
; 224  : 	/* Handle special cases first */
; 225  : 	if (_isnan((double)fpval))

  002db	83 ec 08	 sub	 esp, 8
  002de	dd 1c 24	 fstp	 QWORD PTR [esp]
  002e1	e8 00 00 00 00	 call	 __isnan
  002e6	83 c4 08	 add	 esp, 8
  002e9	85 c0		 test	 eax, eax
  002eb	74 1b		 je	 SHORT $LN13@format_flo

; 226  : 	{
; 227  : 		(*string) -= sizeof(_nan) / sizeof(char) - 1;

  002ed	83 06 fb	 add	 DWORD PTR [esi], -5	; fffffffbH
  002f0	8b 16		 mov	 edx, DWORD PTR [esi]

; 228  : 		strcpy((*string), _nan);

  002f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?_nan@?1??format_float@@9@9
$LL48@format_flo:
  002f7	8a 01		 mov	 al, BYTE PTR [ecx]
  002f9	88 02		 mov	 BYTE PTR [edx], al
  002fb	41		 inc	 ecx
  002fc	42		 inc	 edx
  002fd	84 c0		 test	 al, al
  002ff	75 f6		 jne	 SHORT $LL48@format_flo

; 229  : 		fpval2 = 1;

  00301	d9 e8		 fld1
  00303	e9 79 00 00 00	 jmp	 $LN62@format_flo
$LN13@format_flo:

; 230  : 	}
; 231  : 	else if (!_finite((double)fpval))

  00308	dd 45 e4	 fld	 QWORD PTR _fpval$[ebp]
  0030b	83 ec 08	 sub	 esp, 8
  0030e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00311	e8 00 00 00 00	 call	 __finite
  00316	83 c4 08	 add	 esp, 8
  00319	85 c0		 test	 eax, eax
  0031b	75 18		 jne	 SHORT $LN54@format_flo

; 232  : 	{
; 233  : 		(*string) -= sizeof(_infinity) / sizeof(char) - 1;

  0031d	83 06 fc	 add	 DWORD PTR [esi], -4	; fffffffcH
  00320	8b 16		 mov	 edx, DWORD PTR [esi]

; 234  : 		strcpy((*string), _infinity);

  00322	b9 00 00 00 00	 mov	 ecx, OFFSET ?_infinity@?1??format_float@@9@9
$LL49@format_flo:
  00327	8a 01		 mov	 al, BYTE PTR [ecx]
  00329	88 02		 mov	 BYTE PTR [edx], al
  0032b	41		 inc	 ecx
  0032c	42		 inc	 edx
  0032d	84 c0		 test	 al, al
  0032f	75 f6		 jne	 SHORT $LL49@format_flo

; 235  : 		fpval2 = 1;

  00331	d9 e8		 fld1

; 236  : 	}
; 237  : 	else

  00333	eb 4c		 jmp	 SHORT $LN62@format_flo
$LN54@format_flo:

; 238  : 	{
; 239  : 		/* Zero padding */
; 240  : 		while (padding-- > 0) *--(*string) = ('0');

  00335	8b 4d ec	 mov	 ecx, DWORD PTR _padding$[ebp]
  00338	85 c9		 test	 ecx, ecx
  0033a	7e 10		 jle	 SHORT $LN60@format_flo
  0033c	8d 64 24 00	 npad	 4
$LL9@format_flo:
  00340	ff 0e		 dec	 DWORD PTR [esi]
  00342	8b 06		 mov	 eax, DWORD PTR [esi]
  00344	49		 dec	 ecx
  00345	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  00348	85 c9		 test	 ecx, ecx
  0034a	7f f4		 jg	 SHORT $LL9@format_flo
$LN60@format_flo:

; 241  : 
; 242  : 		/* Digits after the decimal point */
; 243  : 		num_digits = precision;
; 244  : 		while (num_digits-- > 0)

  0034c	dd 45 f4	 fld	 QWORD PTR _fpval2$[ebp]
  0034f	8b fb		 mov	 edi, ebx
  00351	85 db		 test	 ebx, ebx
  00353	7e 30		 jle	 SHORT $LN66@format_flo
$LN7@format_flo:

; 245  : 		{
; 246  : 			*--(*string) = digits[(unsigned __int64)fpval2 % 10];

  00355	ff 0e		 dec	 DWORD PTR [esi]
  00357	d9 c0		 fld	 ST(0)
  00359	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0035b	4f		 dec	 edi
  0035c	e8 00 00 00 00	 call	 __ftol2
  00361	6a 00		 push	 0
  00363	6a 0a		 push	 10			; 0000000aH
  00365	52		 push	 edx
  00366	50		 push	 eax
  00367	e8 00 00 00 00	 call	 __aullrem

; 247  : 			fpval2 /= base;

  0036c	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4024000000000000
  00372	8b 4d fc	 mov	 ecx, DWORD PTR _digits$[ebp]
  00375	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00378	88 13		 mov	 BYTE PTR [ebx], dl
  0037a	85 ff		 test	 edi, edi
  0037c	7f d7		 jg	 SHORT $LN7@format_flo

; 241  : 
; 242  : 		/* Digits after the decimal point */
; 243  : 		num_digits = precision;
; 244  : 		while (num_digits-- > 0)

  0037e	8b 5d 10	 mov	 ebx, DWORD PTR _precision$[ebp]
$LN62@format_flo:

; 248  : 		}
; 249  : 	}
; 250  : 
; 251  : 	if (precision > 0 || flags & FLAG_SPECIAL)

  00381	85 db		 test	 ebx, ebx
  00383	7f 06		 jg	 SHORT $LN4@format_flo
$LN66@format_flo:
  00385	f6 45 0c 10	 test	 BYTE PTR _flags$[ebp], 16 ; 00000010H
  00389	74 07		 je	 SHORT $LN73@format_flo
$LN4@format_flo:

; 252  : 		*--(*string) = ('.');

  0038b	ff 0e		 dec	 DWORD PTR [esi]
  0038d	8b 06		 mov	 eax, DWORD PTR [esi]
  0038f	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
$LN73@format_flo:

; 259  : 	}
; 260  : 	while ((unsigned __int64)fpval2);

  00392	d9 c0		 fld	 ST(0)
  00394	e8 00 00 00 00	 call	 __ftol2
  00399	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
$LN3@format_flo:

; 253  : 
; 254  : 	/* Digits before the decimal point */
; 255  : 	do
; 256  : 	{
; 257  : 		*--(*string) = digits[(unsigned __int64)fpval2 % base];

  0039f	ff 0e		 dec	 DWORD PTR [esi]
  003a1	8b 3e		 mov	 edi, DWORD PTR [esi]
  003a3	6a 00		 push	 0
  003a5	6a 0a		 push	 10			; 0000000aH
  003a7	52		 push	 edx
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 __aullrem

; 258  : 		fpval2 /= base;

  003ae	dc f9		 fdiv	 ST(1), ST(0)
  003b0	8b 4d fc	 mov	 ecx, DWORD PTR _digits$[ebp]
  003b3	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  003b6	88 17		 mov	 BYTE PTR [edi], dl

; 259  : 	}
; 260  : 	while ((unsigned __int64)fpval2);

  003b8	d9 c1		 fld	 ST(1)
  003ba	e8 00 00 00 00	 call	 __ftol2
  003bf	8b c8		 mov	 ecx, eax
  003c1	0b ca		 or	 ecx, edx
  003c3	75 da		 jne	 SHORT $LN3@format_flo
  003c5	5f		 pop	 edi
  003c6	dd d9		 fstp	 ST(1)
  003c8	5e		 pop	 esi
  003c9	dd d8		 fstp	 ST(0)
  003cb	5b		 pop	 ebx

; 261  : 
; 262  : }

  003cc	8b e5		 mov	 esp, ebp
  003ce	5d		 pop	 ebp
  003cf	c3		 ret	 0
$LN136@format_flo:
  003d0	00 00 00 00	 DD	 $LN88@format_flo
  003d4	00 00 00 00	 DD	 $LN25@format_flo
  003d8	00 00 00 00	 DD	 $LN32@format_flo
  003dc	00 00 00 00	 DD	 $case_e$2335
  003e0	00 00 00 00	 DD	 $LN31@format_flo
  003e4	00 00 00 00	 DD	 $LN87@format_flo
$LN68@format_flo:
  003e8	00		 DB	 0
  003e9	05		 DB	 5
  003ea	05		 DB	 5
  003eb	05		 DB	 5
  003ec	01		 DB	 1
  003ed	05		 DB	 5
  003ee	02		 DB	 2
  003ef	05		 DB	 5
  003f0	05		 DB	 5
  003f1	05		 DB	 5
  003f2	05		 DB	 5
  003f3	05		 DB	 5
  003f4	05		 DB	 5
  003f5	05		 DB	 5
  003f6	05		 DB	 5
  003f7	05		 DB	 5
  003f8	05		 DB	 5
  003f9	05		 DB	 5
  003fa	05		 DB	 5
  003fb	05		 DB	 5
  003fc	05		 DB	 5
  003fd	05		 DB	 5
  003fe	05		 DB	 5
  003ff	05		 DB	 5
  00400	05		 DB	 5
  00401	05		 DB	 5
  00402	05		 DB	 5
  00403	05		 DB	 5
  00404	05		 DB	 5
  00405	05		 DB	 5
  00406	05		 DB	 5
  00407	05		 DB	 5
  00408	05		 DB	 5
  00409	05		 DB	 5
  0040a	05		 DB	 5
  0040b	05		 DB	 5
  0040c	03		 DB	 3
  0040d	05		 DB	 5
  0040e	04		 DB	 4
_format_float ENDP
_TEXT	ENDS
PUBLIC	_streamout
EXTRN	__aulldvrm:PROC
; Function compile flags: /Ogtp
;	COMDAT _streamout
_TEXT	SEGMENT
_buffer$ = -100						; size = 50
tv600 = -48						; size = 8
tv621 = -40						; size = 4
_digits$ = -40						; size = 4
_fieldwidth$ = -36					; size = 4
_cnt$ = -32						; size = 4
tv87 = -28						; size = 8
_len$ = -24						; size = 4
_written$ = -24						; size = 4
_prefix$ = -20						; size = 4
_chr$ = -16						; size = 1
_flags$ = -12						; size = 4
_string$ = -8						; size = 4
_written_all$ = -4					; size = 4
_out$ = 8						; size = 4
_precision$ = 12					; size = 4
_size$ = 12						; size = 4
_format$ = 16						; size = 4
_argptr$ = 20						; size = 4
_streamout PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H

; 269  : 	static const char digits_l[] = "0123456789abcdef0x";
; 270  : 	static const char digits_u[] = "0123456789ABCDEF0X";
; 271  : 	static const char *_nullstring = "(null)";
; 272  : 	char buffer[BUFFER_SIZE + 1];
; 273  : 	uint32_t cnt = size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	89 45 e0	 mov	 DWORD PTR _cnt$[ebp], eax

; 274  : 	char chr, *string;
; 275  : 	STRING *nt_string;
; 276  : 	const char *digits, *prefix;
; 277  : 	int base, fieldwidth, precision, padding;
; 278  : 	size_t prefixlen, len;
; 279  : 	int written = 1, written_all = 0;

  0000e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _written$[ebp], 1
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _written_all$[ebp], 0

; 280  : 	unsigned int flags;
; 281  : 	unsigned __int64 val64;
; 282  : 
; 283  : 	buffer[BUFFER_SIZE] = '\0';

  0001c	c6 45 cd 00	 mov	 BYTE PTR _buffer$[ebp+49], 0
  00020	57		 push	 edi
$LL112@streamout:

; 286  : 	{
; 287  : 		chr = *format++;

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _format$[ebp]
  00024	8a 01		 mov	 al, BYTE PTR [ecx]
  00026	41		 inc	 ecx
  00027	89 4d 10	 mov	 DWORD PTR _format$[ebp], ecx

; 288  : 
; 289  : 		/* Check for end of format string */
; 290  : 		if (chr == '\0') break;

  0002a	84 c0		 test	 al, al
  0002c	0f 84 e6 05 00
	00		 je	 $LN111@streamout

; 291  : 
; 292  : 		/* Check for 'normal' character or double % */
; 293  : 		if ((chr != ('%')) ||
; 294  : 			(chr = *format++) == ('%'))

  00032	3c 25		 cmp	 al, 37			; 00000025H
  00034	0f 85 bc 05 00
	00		 jne	 $LN108@streamout
  0003a	8b d1		 mov	 edx, ecx
  0003c	8a 02		 mov	 al, BYTE PTR [edx]
  0003e	42		 inc	 edx
  0003f	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00042	89 55 10	 mov	 DWORD PTR _format$[ebp], edx
  00045	3c 25		 cmp	 al, 37			; 00000025H
  00047	0f 84 a9 05 00
	00		 je	 $LN108@streamout

; 299  : 			continue;
; 300  : 		}
; 301  : 
; 302  : 		/* Handle flags */
; 303  : 		flags = 0;

  0004d	33 db		 xor	 ebx, ebx
  0004f	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
$LL106@streamout:

; 304  : 		while (1)
; 305  : 		{
; 306  : 			if (chr == ('-')) flags |= FLAG_ALIGN_LEFT;

  00052	3c 2d		 cmp	 al, 45			; 0000002dH
  00054	75 08		 jne	 SHORT $LN104@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00056	8a 02		 mov	 al, BYTE PTR [edx]
  00058	83 cb 01	 or	 ebx, 1
  0005b	42		 inc	 edx

; 313  : 		}

  0005c	eb f4		 jmp	 SHORT $LL106@streamout
$LN104@streamout:

; 307  : 			else if (chr == ('+')) flags |= FLAG_FORCE_SIGN;

  0005e	3c 2b		 cmp	 al, 43			; 0000002bH
  00060	75 08		 jne	 SHORT $LN102@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00062	8a 02		 mov	 al, BYTE PTR [edx]
  00064	83 cb 02	 or	 ebx, 2
  00067	42		 inc	 edx

; 313  : 		}

  00068	eb e8		 jmp	 SHORT $LL106@streamout
$LN102@streamout:

; 308  : 			else if (chr == (' ')) flags |= FLAG_FORCE_SIGNSP;

  0006a	3c 20		 cmp	 al, 32			; 00000020H
  0006c	75 08		 jne	 SHORT $LN100@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  0006e	8a 02		 mov	 al, BYTE PTR [edx]
  00070	83 cb 04	 or	 ebx, 4
  00073	42		 inc	 edx

; 313  : 		}

  00074	eb dc		 jmp	 SHORT $LL106@streamout
$LN100@streamout:

; 309  : 			else if (chr == ('0')) flags |= FLAG_PAD_ZERO;

  00076	3c 30		 cmp	 al, 48			; 00000030H
  00078	75 08		 jne	 SHORT $LN98@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  0007a	8a 02		 mov	 al, BYTE PTR [edx]
  0007c	83 cb 08	 or	 ebx, 8
  0007f	42		 inc	 edx

; 313  : 		}

  00080	eb d0		 jmp	 SHORT $LL106@streamout
$LN98@streamout:

; 310  : 			else if (chr == ('#')) flags |= FLAG_SPECIAL;

  00082	3c 23		 cmp	 al, 35			; 00000023H
  00084	75 08		 jne	 SHORT $LN96@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00086	8a 02		 mov	 al, BYTE PTR [edx]
  00088	83 cb 10	 or	 ebx, 16			; 00000010H
  0008b	42		 inc	 edx

; 313  : 		}

  0008c	eb c4		 jmp	 SHORT $LL106@streamout
$LN96@streamout:

; 311  : 			else break;
; 312  : 			chr = *format++;

  0008e	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00091	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx

; 314  : 
; 315  : 		/* Handle field width modifier */
; 316  : 		if (chr == ('*'))

  00094	3c 2a		 cmp	 al, 42			; 0000002aH
  00096	75 25		 jne	 SHORT $LN94@streamout

; 317  : 		{
; 318  : 			fieldwidth = va_arg(argptr, int);

  00098	8b 75 14	 mov	 esi, DWORD PTR _argptr$[ebp]
  0009b	8b 06		 mov	 eax, DWORD PTR [esi]
  0009d	83 c6 04	 add	 esi, 4
  000a0	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  000a3	89 45 dc	 mov	 DWORD PTR _fieldwidth$[ebp], eax

; 319  : 			if (fieldwidth < 0)

  000a6	85 c0		 test	 eax, eax
  000a8	79 0b		 jns	 SHORT $LN93@streamout

; 320  : 			{
; 321  : 				flags |= FLAG_ALIGN_LEFT;

  000aa	83 cb 01	 or	 ebx, 1

; 322  : 				fieldwidth = -fieldwidth;

  000ad	f7 d8		 neg	 eax
  000af	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
  000b2	89 45 dc	 mov	 DWORD PTR _fieldwidth$[ebp], eax
$LN93@streamout:

; 323  : 			}
; 324  : 			chr = *format++;

  000b5	8a 02		 mov	 al, BYTE PTR [edx]
  000b7	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  000ba	42		 inc	 edx

; 325  : 		}
; 326  : 		else

  000bb	eb 27		 jmp	 SHORT $LN90@streamout
$LN94@streamout:

; 327  : 		{
; 328  : 			fieldwidth = 0;

  000bd	33 c9		 xor	 ecx, ecx
  000bf	89 4d dc	 mov	 DWORD PTR _fieldwidth$[ebp], ecx

; 329  : 			while (chr >= ('0') && chr <= ('9'))

  000c2	3c 30		 cmp	 al, 48			; 00000030H
  000c4	7c 1b		 jl	 SHORT $LN185@streamout
$LL91@streamout:
  000c6	3c 39		 cmp	 al, 57			; 00000039H
  000c8	7f 11		 jg	 SHORT $LN203@streamout

; 330  : 			{
; 331  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000ca	0f be c0	 movsx	 eax, al
  000cd	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000d0	8d 4c 48 d0	 lea	 ecx, DWORD PTR [eax+ecx*2-48]

; 332  : 				chr = *format++;

  000d4	8a 02		 mov	 al, BYTE PTR [edx]
  000d6	42		 inc	 edx
  000d7	3c 30		 cmp	 al, 48			; 00000030H
  000d9	7d eb		 jge	 SHORT $LL91@streamout
$LN203@streamout:

; 330  : 			{
; 331  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000db	89 4d dc	 mov	 DWORD PTR _fieldwidth$[ebp], ecx

; 332  : 				chr = *format++;

  000de	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
$LN185@streamout:

; 329  : 			while (chr >= ('0') && chr <= ('9'))

  000e1	8b 75 14	 mov	 esi, DWORD PTR _argptr$[ebp]
$LN90@streamout:

; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 		/* Handle precision modifier */
; 337  : 		if (chr == '.')

  000e4	3c 2e		 cmp	 al, 46			; 0000002eH
  000e6	75 4f		 jne	 SHORT $LN89@streamout

; 338  : 		{
; 339  : 			chr = *format++;

  000e8	8a 02		 mov	 al, BYTE PTR [edx]
  000ea	42		 inc	 edx
  000eb	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 340  : 
; 341  : 			if (chr == ('*'))

  000ee	3c 2a		 cmp	 al, 42			; 0000002aH
  000f0	75 20		 jne	 SHORT $LN88@streamout

; 342  : 			{
; 343  : 				precision = va_arg(argptr, int);
; 344  : 				chr = *format++;

  000f2	8a 02		 mov	 al, BYTE PTR [edx]
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	83 c6 04	 add	 esi, 4
  000f9	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  000fc	42		 inc	 edx
$LN204@streamout:

; 352  : 					chr = *format++;

  000fd	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al
  00100	89 4d 0c	 mov	 DWORD PTR _precision$[ebp], ecx
$LL83@streamout:

; 357  : 
; 358  : 		/* Handle argument size prefix */
; 359  : 		do
; 360  : 		{
; 361  : 			if (chr == ('h')) flags |= FLAG_SHORT;

  00103	3c 68		 cmp	 al, 104			; 00000068H
  00105	75 39		 jne	 SHORT $LN80@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00107	8a 02		 mov	 al, BYTE PTR [edx]
  00109	81 cb 00 01 00
	00		 or	 ebx, 256		; 00000100H
  0010f	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00110	eb f1		 jmp	 SHORT $LL83@streamout
$LN88@streamout:

; 345  : 			}
; 346  : 			else
; 347  : 			{
; 348  : 				precision = 0;

  00112	33 c9		 xor	 ecx, ecx
  00114	89 4d 0c	 mov	 DWORD PTR _precision$[ebp], ecx

; 349  : 				while (chr >= ('0') && chr <= ('9'))

  00117	3c 30		 cmp	 al, 48			; 00000030H
  00119	7c e8		 jl	 SHORT $LL83@streamout
  0011b	eb 03 8d 49 00	 npad	 5
$LL86@streamout:
  00120	3c 39		 cmp	 al, 57			; 00000039H
  00122	7f d9		 jg	 SHORT $LN204@streamout

; 350  : 				{
; 351  : 					precision = precision * 10 + (chr - ('0'));

  00124	0f be c0	 movsx	 eax, al
  00127	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0012a	8d 4c 48 d0	 lea	 ecx, DWORD PTR [eax+ecx*2-48]

; 352  : 					chr = *format++;

  0012e	8a 02		 mov	 al, BYTE PTR [edx]
  00130	42		 inc	 edx
  00131	3c 30		 cmp	 al, 48			; 00000030H
  00133	7d eb		 jge	 SHORT $LL86@streamout

; 353  : 				}
; 354  : 			}

  00135	eb c6		 jmp	 SHORT $LN204@streamout
$LN89@streamout:

; 355  : 		}
; 356  : 		else precision = -1;

  00137	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR _precision$[ebp], -1
  0013e	eb c3		 jmp	 SHORT $LL83@streamout
$LN80@streamout:

; 362  : 			else if (chr == ('w')) flags |= FLAG_WIDECHAR;

  00140	3c 77		 cmp	 al, 119			; 00000077H
  00142	75 0b		 jne	 SHORT $LN78@streamout
$LN71@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00144	8a 02		 mov	 al, BYTE PTR [edx]
  00146	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  0014c	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  0014d	eb b4		 jmp	 SHORT $LL83@streamout
$LN78@streamout:

; 363  : 			else if (chr == ('L')) flags |= 0; // FIXME: long double

  0014f	3c 4c		 cmp	 al, 76			; 0000004cH
  00151	74 70		 je	 SHORT $LN62@streamout

; 364  : 			else if (chr == ('F')) flags |= 0; // FIXME: what is that?

  00153	3c 46		 cmp	 al, 70			; 00000046H
  00155	74 6c		 je	 SHORT $LN62@streamout

; 365  : 			else if (chr == ('l'))

  00157	3c 6c		 cmp	 al, 108			; 0000006cH
  00159	75 10		 jne	 SHORT $LN72@streamout

; 366  : 			{
; 367  : 				/* Check if this is the 2nd 'l' in a row */
; 368  : 				if (format[-2] == 'l') flags |= FLAG_INT64;

  0015b	38 42 fe	 cmp	 BYTE PTR [edx-2], al
  0015e	75 e4		 jne	 SHORT $LN71@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00160	8a 02		 mov	 al, BYTE PTR [edx]
  00162	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  00168	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00169	eb 98		 jmp	 SHORT $LL83@streamout
$LN72@streamout:

; 369  : 				else flags |= FLAG_LONG;
; 370  : 			}
; 371  : 			else if (chr == ('I'))

  0016b	3c 49		 cmp	 al, 73			; 00000049H
  0016d	75 5c		 jne	 SHORT $LN206@streamout

; 372  : 			{
; 373  : 				if (format[0] == ('3') && format[1] == ('2'))

  0016f	8a 0a		 mov	 cl, BYTE PTR [edx]
  00171	80 f9 33	 cmp	 cl, 51			; 00000033H
  00174	75 12		 jne	 SHORT $LN67@streamout
  00176	80 7a 01 32	 cmp	 BYTE PTR [edx+1], 50	; 00000032H
  0017a	75 0c		 jne	 SHORT $LN67@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  0017c	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  0017f	83 c2 02	 add	 edx, 2
  00182	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00183	e9 7b ff ff ff	 jmp	 $LL83@streamout
$LN67@streamout:

; 374  : 				{
; 375  : 					format += 2;
; 376  : 				}
; 377  : 				else if (format[0] == ('6') && format[1] == ('4'))

  00188	80 f9 36	 cmp	 cl, 54			; 00000036H
  0018b	75 18		 jne	 SHORT $LN65@streamout
  0018d	80 7a 01 34	 cmp	 BYTE PTR [edx+1], 52	; 00000034H
  00191	75 12		 jne	 SHORT $LN65@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00193	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00196	83 c2 02	 add	 edx, 2
  00199	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  0019f	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001a0	e9 5e ff ff ff	 jmp	 $LL83@streamout
$LN65@streamout:

; 378  : 				{
; 379  : 					format += 2;
; 380  : 					flags |= FLAG_INT64;
; 381  : 				}
; 382  : 				else if (format[0] == ('x') || format[0] == ('X') ||
; 383  : 					format[0] == ('d') || format[0] == ('i') ||
; 384  : 					format[0] == ('u') || format[0] == ('o'))

  001a5	80 f9 78	 cmp	 cl, 120			; 00000078H
  001a8	74 19		 je	 SHORT $LN62@streamout
  001aa	80 f9 58	 cmp	 cl, 88			; 00000058H
  001ad	74 14		 je	 SHORT $LN62@streamout
  001af	80 f9 64	 cmp	 cl, 100			; 00000064H
  001b2	74 0f		 je	 SHORT $LN62@streamout
  001b4	80 f9 69	 cmp	 cl, 105			; 00000069H
  001b7	74 0a		 je	 SHORT $LN62@streamout
  001b9	80 f9 75	 cmp	 cl, 117			; 00000075H
  001bc	74 05		 je	 SHORT $LN62@streamout
  001be	80 f9 6f	 cmp	 cl, 111			; 0000006fH
  001c1	75 08		 jne	 SHORT $LN206@streamout
$LN62@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001c3	8a 02		 mov	 al, BYTE PTR [edx]
  001c5	42		 inc	 edx

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001c6	e9 38 ff ff ff	 jmp	 $LL83@streamout
$LN206@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001cb	88 45 f0	 mov	 BYTE PTR _chr$[ebp], al

; 394  : 
; 395  : 		/* Handle the format specifier */
; 396  : 		digits = digits_l;
; 397  : 		string = &buffer[BUFFER_SIZE];
; 398  : 		base = 10;
; 399  : 		prefix = 0;
; 400  : 		switch (chr)

  001ce	0f be c0	 movsx	 eax, al
  001d1	8d 7d cd	 lea	 edi, DWORD PTR _buffer$[ebp+49]
  001d4	83 c0 bf	 add	 eax, -65		; ffffffbfH
  001d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?digits_l@?1??streamout@@9@9
  001dc	89 7d f8	 mov	 DWORD PTR _string$[ebp], edi
  001df	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
  001e2	89 55 10	 mov	 DWORD PTR _format$[ebp], edx
  001e5	89 4d d8	 mov	 DWORD PTR _digits$[ebp], ecx
  001e8	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  001ed	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], 0
  001f4	83 f8 37	 cmp	 eax, 55			; 00000037H
  001f7	0f 87 f3 03 00
	00		 ja	 $LN22@streamout
  001fd	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN169@streamout[eax]
  00204	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN218@streamout[eax*4]
$LN57@streamout:

; 401  : 		{
; 402  : 		case ('n'):
; 403  : 			if (flags & FLAG_INT64)
; 404  : 				*va_arg(argptr, __int64*) = written_all;

  0020b	83 c6 04	 add	 esi, 4
  0020e	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  00211	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00217	74 11		 je	 SHORT $LN56@streamout
  00219	8b 45 fc	 mov	 eax, DWORD PTR _written_all$[ebp]
  0021c	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  0021f	99		 cdq
  00220	89 06		 mov	 DWORD PTR [esi], eax
  00222	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00225	e9 e4 03 00 00	 jmp	 $LN152@streamout
$LN56@streamout:

; 405  : 			else if (flags & FLAG_SHORT)

  0022a	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00230	74 0f		 je	 SHORT $LN54@streamout

; 406  : 				*va_arg(argptr, short*) = (short)written_all;

  00232	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00235	66 8b 55 fc	 mov	 dx, WORD PTR _written_all$[ebp]
  00239	66 89 11	 mov	 WORD PTR [ecx], dx

; 407  : 			else

  0023c	e9 cd 03 00 00	 jmp	 $LN152@streamout
$LN54@streamout:

; 408  : 				*va_arg(argptr, int*) = written_all;

  00241	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00244	8b 4d fc	 mov	 ecx, DWORD PTR _written_all$[ebp]
  00247	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 			continue;

  00249	e9 c0 03 00 00	 jmp	 $LN152@streamout
$LN52@streamout:

; 410  : 
; 411  : 		case ('C'):
; 412  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  0024e	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00254	75 09		 jne	 SHORT $case_char$2521
  00256	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  0025c	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
$case_char$2521:

; 413  : 			goto case_char;
; 414  : 
; 415  : 		case ('c'):
; 416  : case_char:
; 417  : 			string = buffer;
; 418  : 			len = 1;
; 419  :  			if (flags & FLAG_WIDECHAR)
; 420  :  			{
; 421  :  				((wchar_t*)string)[0] = (wchar_t)va_arg(argptr, int);

  0025f	83 c6 04	 add	 esi, 4
  00262	8d 55 9c	 lea	 edx, DWORD PTR _buffer$[ebp]
  00265	89 55 f8	 mov	 DWORD PTR _string$[ebp], edx
  00268	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  0026f	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  00272	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00278	74 6a		 je	 SHORT $LN49@streamout
  0027a	66 8b 46 fc	 mov	 ax, WORD PTR [esi-4]

; 422  :  				((wchar_t*)string)[1] = (wchar_t)('\0');

  0027e	33 c9		 xor	 ecx, ecx
  00280	66 89 45 9c	 mov	 WORD PTR _buffer$[ebp], ax
  00284	66 89 4d 9e	 mov	 WORD PTR _buffer$[ebp+2], cx
$LN199@streamout:

; 547  : 		}
; 548  : 
; 549  : 		/* Calculate padding */
; 550  : 		prefixlen = prefix ? strlen(prefix) : 0;

  00288	33 db		 xor	 ebx, ebx
$LN124@streamout:

; 551  : 		if (precision < 0) precision = 0;

  0028a	8b 45 0c	 mov	 eax, DWORD PTR _precision$[ebp]
  0028d	85 c0		 test	 eax, eax
  0028f	79 05		 jns	 SHORT $LN21@streamout
  00291	33 c0		 xor	 eax, eax
  00293	89 45 0c	 mov	 DWORD PTR _precision$[ebp], eax
$LN21@streamout:

; 552  : 		padding = (int)(fieldwidth - len - prefixlen - precision);

  00296	8b 75 dc	 mov	 esi, DWORD PTR _fieldwidth$[ebp]
  00299	2b f3		 sub	 esi, ebx
  0029b	2b 75 e8	 sub	 esi, DWORD PTR _len$[ebp]
  0029e	2b f0		 sub	 esi, eax

; 553  : 		if (padding < 0) padding = 0;

  002a0	79 02		 jns	 SHORT $LN20@streamout
  002a2	33 f6		 xor	 esi, esi
$LN20@streamout:

; 554  : 
; 555  : 		/* Optional left space padding */
; 556  : 		if ((flags & (FLAG_ALIGN_LEFT | FLAG_PAD_ZERO)) == 0)

  002a4	f6 45 f4 09	 test	 BYTE PTR _flags$[ebp], 9
  002a8	0f 85 72 02 00
	00		 jne	 $LN187@streamout

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  002ae	85 f6		 test	 esi, esi
  002b0	0f 8e 6a 02 00
	00		 jle	 $LN187@streamout
  002b6	8b 7d 08	 mov	 edi, DWORD PTR _out$[ebp]
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL18@streamout:

; 559  : 			{
; 560  : 				if ((written = streamout_char(out, &cnt, (' '))) == 0) return -1;

  002c0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002c5	8d 55 e0	 lea	 edx, DWORD PTR _cnt$[ebp]
  002c8	8b cf		 mov	 ecx, edi
  002ca	e8 00 00 00 00	 call	 _streamout_char
  002cf	85 c0		 test	 eax, eax
  002d1	0f 84 53 03 00
	00		 je	 $LN143@streamout

; 561  : 				written_all += written;

  002d7	01 45 fc	 add	 DWORD PTR _written_all$[ebp], eax
  002da	4e		 dec	 esi
  002db	85 f6		 test	 esi, esi
  002dd	7f e1		 jg	 SHORT $LL18@streamout

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  002df	e9 3f 02 00 00	 jmp	 $LN189@streamout
$LN49@streamout:

; 423  :  			}
; 424  :  			else
; 425  :  			{
; 426  : 				((char*)string)[0] = (char)va_arg(argptr, int);

  002e4	8a 56 fc	 mov	 dl, BYTE PTR [esi-4]
  002e7	88 55 9c	 mov	 BYTE PTR _buffer$[ebp], dl

; 427  : 				((char*)string)[1] = (char)('\0');

  002ea	c6 45 9d 00	 mov	 BYTE PTR _buffer$[ebp+1], 0

; 428  : 			}
; 429  : 			break;

  002ee	eb 98		 jmp	 SHORT $LN199@streamout
$LN47@streamout:

; 430  : 
; 431  : 		case ('Z'):
; 432  : 			nt_string = va_arg(argptr, void*);

  002f0	83 c6 04	 add	 esi, 4
  002f3	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  002f6	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]

; 433  : 			if (nt_string && (string = nt_string->Buffer))

  002f9	85 f6		 test	 esi, esi
  002fb	74 53		 je	 SHORT $LN163@streamout
  002fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00300	89 45 f8	 mov	 DWORD PTR _string$[ebp], eax
  00303	85 c0		 test	 eax, eax
  00305	74 49		 je	 SHORT $LN163@streamout

; 434  : 			{
; 435  : 				len = nt_string->Length;

  00307	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0030a	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 436  : 				if (flags & FLAG_WIDECHAR) len /= sizeof(wchar_t);

  0030d	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00313	0f 84 6f ff ff
	ff		 je	 $LN199@streamout
  00319	d1 6d e8	 shr	 DWORD PTR _len$[ebp], 1

; 437  : 				break;

  0031c	e9 67 ff ff ff	 jmp	 $LN199@streamout
$LN44@streamout:

; 438  : 			}
; 439  : 			string = 0;
; 440  : 			goto case_string;
; 441  : 
; 442  : 		case ('S'):
; 443  : 			string = va_arg(argptr, void*);

  00321	83 c6 04	 add	 esi, 4
  00324	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  00327	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  0032a	89 75 f8	 mov	 DWORD PTR _string$[ebp], esi

; 444  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  0032d	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00333	75 17		 jne	 SHORT $case_string$2558
  00335	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  0033b	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx

; 445  : 			goto case_string;

  0033e	eb 0c		 jmp	 SHORT $case_string$2558
$LN42@streamout:

; 446  : 
; 447  : 		case ('s'):
; 448  : 			string = va_arg(argptr, void*);

  00340	83 c6 04	 add	 esi, 4
  00343	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  00346	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00349	89 75 f8	 mov	 DWORD PTR _string$[ebp], esi
$case_string$2558:

; 449  : 
; 450  : case_string:
; 451  : 			if (!string)

  0034c	85 f6		 test	 esi, esi
  0034e	75 12		 jne	 SHORT $LN200@streamout
$LN163@streamout:

; 452  : 			{
; 453  : 				string = (char*)_nullstring;

  00350	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_nullstring@?1??streamout@@9@9

; 454  : 				flags &= ~FLAG_WIDECHAR;

  00356	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  0035c	89 75 f8	 mov	 DWORD PTR _string$[ebp], esi
  0035f	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
$LN200@streamout:

; 455  : 			}
; 456  : 
; 457  : // 			if (flags & FLAG_WIDECHAR)
; 458  : // 				len = wcsnlen((wchar_t*)string, (unsigned)precision);
; 459  : // 			else
; 460  : 				len = strlen((char*)string);

  00362	8b c6		 mov	 eax, esi
  00364	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL170@streamout:
  00367	8a 08		 mov	 cl, BYTE PTR [eax]
  00369	40		 inc	 eax
  0036a	84 c9		 test	 cl, cl
  0036c	75 f9		 jne	 SHORT $LL170@streamout
  0036e	2b c2		 sub	 eax, edx
  00370	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 461  : 			precision = 0;

  00373	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 0

; 462  : 			break;

  0037a	e9 09 ff ff ff	 jmp	 $LN199@streamout
$LN40@streamout:

; 463  : 
; 464  : 		case ('G'):
; 465  : 		case ('E'):
; 466  : 		case ('A'):
; 467  : 		case ('g'):
; 468  : 		case ('e'):
; 469  : 		case ('a'):
; 470  : 		case ('f'):
; 471  : #ifdef _UNICODE
; 472  : 			flags |= FLAG_WIDECHAR;
; 473  : #else
; 474  : 			flags &= ~FLAG_WIDECHAR;
; 475  : #endif
; 476  : 			/* Use external function, one for kernel one for user mode */
; 477  : 			format_float(chr, flags, precision, &string, &prefix, &argptr);

  0037f	8d 4d 14	 lea	 ecx, DWORD PTR _argptr$[ebp]
  00382	51		 push	 ecx
  00383	8b 4d 0c	 mov	 ecx, DWORD PTR _precision$[ebp]
  00386	8d 55 ec	 lea	 edx, DWORD PTR _prefix$[ebp]
  00389	52		 push	 edx
  0038a	8b 55 f0	 mov	 edx, DWORD PTR _chr$[ebp]
  0038d	8d 45 f8	 lea	 eax, DWORD PTR _string$[ebp]
  00390	50		 push	 eax
  00391	51		 push	 ecx
  00392	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  00398	53		 push	 ebx
  00399	52		 push	 edx
  0039a	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
  0039d	e8 00 00 00 00	 call	 _format_float

; 478  : 			len = strlen(string);

  003a2	8b 45 f8	 mov	 eax, DWORD PTR _string$[ebp]
  003a5	83 c4 18	 add	 esp, 24			; 00000018H
  003a8	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  003ab	eb 03 8d 49 00	 npad	 5
$LL171@streamout:
  003b0	8a 08		 mov	 cl, BYTE PTR [eax]
  003b2	40		 inc	 eax
  003b3	84 c9		 test	 cl, cl
  003b5	75 f9		 jne	 SHORT $LL171@streamout

; 479  : 			precision = 0;

  003b7	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 0

; 480  : 			break;

  003be	e9 34 01 00 00	 jmp	 $LN216@streamout
$LN39@streamout:

; 481  : 
; 482  : 		case ('d'):
; 483  : 		case ('i'):
; 484  : 			val64 = (__int64)va_arg_f(argptr, flags);

  003c3	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  003c9	74 0d		 je	 SHORT $LN117@streamout
  003cb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003cd	83 c6 08	 add	 esi, 8
  003d0	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  003d3	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  003d6	eb 1c		 jmp	 SHORT $LN118@streamout
$LN117@streamout:
  003d8	83 c6 04	 add	 esi, 4
  003db	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  003de	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  003e4	74 06		 je	 SHORT $LN115@streamout
  003e6	0f bf 46 fc	 movsx	 eax, WORD PTR [esi-4]
  003ea	eb 03		 jmp	 SHORT $LN116@streamout
$LN115@streamout:
  003ec	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
$LN116@streamout:
  003ef	99		 cdq
  003f0	8b c8		 mov	 ecx, eax
  003f2	8b f2		 mov	 esi, edx
$LN118@streamout:

; 485  : 
; 486  : 			if ((__int64)val64 < 0)

  003f4	85 f6		 test	 esi, esi
  003f6	7f 19		 jg	 SHORT $LN38@streamout
  003f8	7c 04		 jl	 SHORT $LN172@streamout
  003fa	85 c9		 test	 ecx, ecx
  003fc	73 13		 jae	 SHORT $LN38@streamout
$LN172@streamout:

; 487  : 			{
; 488  : 				val64 = -(__int64)val64;

  003fe	f7 d9		 neg	 ecx
  00400	83 d6 00	 adc	 esi, 0
  00403	f7 de		 neg	 esi

; 489  : 				prefix = ("-");

  00405	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2607
  0040c	e9 87 00 00 00	 jmp	 $case_number$2614
$LN38@streamout:

; 490  : 			}
; 491  : 			else if (flags & FLAG_FORCE_SIGN)

  00411	f6 c3 02	 test	 bl, 2
  00414	74 09		 je	 SHORT $LN36@streamout

; 492  : 				prefix = ("+");

  00416	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2610
  0041d	eb 79		 jmp	 SHORT $case_number$2614
$LN36@streamout:

; 493  : 			else if (flags & FLAG_FORCE_SIGNSP)

  0041f	f6 c3 04	 test	 bl, 4
  00422	74 74		 je	 SHORT $case_number$2614

; 494  : 				prefix = (" ");

  00424	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2613

; 495  : 
; 496  : 			goto case_number;

  0042b	eb 6b		 jmp	 SHORT $case_number$2614
$LN33@streamout:

; 497  : 
; 498  : 		case ('o'):
; 499  : 			base = 8;

  0042d	bf 08 00 00 00	 mov	 edi, 8

; 500  : 			if (flags & FLAG_SPECIAL)

  00432	f6 c3 10	 test	 bl, 16			; 00000010H
  00435	74 33		 je	 SHORT $case_unsigned$2619

; 501  : 			{
; 502  : 				prefix = ("0");
; 503  : 				if (precision > 0) precision--;

  00437	83 7d 0c 00	 cmp	 DWORD PTR _precision$[ebp], 0
  0043b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], OFFSET $SG2617
  00442	7e 26		 jle	 SHORT $case_unsigned$2619
  00444	ff 4d 0c	 dec	 DWORD PTR _precision$[ebp]

; 504  : 			}
; 505  : 			goto case_unsigned;

  00447	eb 21		 jmp	 SHORT $case_unsigned$2619
$LN30@streamout:

; 506  : 
; 507  : 		case ('p'):
; 508  : 			precision = 2 * sizeof(void*);

  00449	c7 45 0c 08 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 8

; 509  : 			flags &= ~FLAG_PAD_ZERO;

  00450	83 e3 f7	 and	 ebx, -9			; fffffff7H
$LN192@streamout:

; 510  : 			flags |= FLAG_INTPTR;
; 511  : 			/* Fall through */
; 512  : 
; 513  : 		case ('X'):
; 514  : 			digits = digits_u;

  00453	b9 00 00 00 00	 mov	 ecx, OFFSET ?digits_u@?1??streamout@@9@9
  00458	89 4d d8	 mov	 DWORD PTR _digits$[ebp], ecx
$LN193@streamout:

; 515  : 			/* Fall through */
; 516  : 
; 517  : 		case ('x'):
; 518  : 			base = 16;

  0045b	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 519  : 			if (flags & FLAG_SPECIAL)

  00460	f6 c3 10	 test	 bl, 16			; 00000010H
  00463	74 05		 je	 SHORT $case_unsigned$2619

; 520  : 			{
; 521  : 				prefix = &digits[16];

  00465	03 cf		 add	 ecx, edi
  00467	89 4d ec	 mov	 DWORD PTR _prefix$[ebp], ecx
$case_unsigned$2619:

; 522  : 			}
; 523  : 
; 524  : 		case ('u'):
; 525  : case_unsigned:
; 526  : 			val64 = va_arg_fu(argptr, flags);

  0046a	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  00470	74 0d		 je	 SHORT $LN121@streamout
  00472	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00474	83 c6 08	 add	 esi, 8
  00477	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  0047a	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  0047d	eb 19		 jmp	 SHORT $case_number$2614
$LN121@streamout:
  0047f	83 c6 04	 add	 esi, 4
  00482	89 75 14	 mov	 DWORD PTR _argptr$[ebp], esi
  00485	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0048b	74 06		 je	 SHORT $LN119@streamout
  0048d	0f b7 4e fc	 movzx	 ecx, WORD PTR [esi-4]
  00491	eb 03		 jmp	 SHORT $LN120@streamout
$LN119@streamout:
  00493	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
$LN120@streamout:
  00496	33 f6		 xor	 esi, esi
$case_number$2614:

; 527  : 
; 528  : case_number:
; 529  : 			flags &= ~FLAG_WIDECHAR;

  00498	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH

; 530  : 			if (precision < 0) precision = 1;

  0049e	83 7d 0c 00	 cmp	 DWORD PTR _precision$[ebp], 0
  004a2	89 5d f4	 mov	 DWORD PTR _flags$[ebp], ebx
  004a5	7d 07		 jge	 SHORT $LN133@streamout
  004a7	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _precision$[ebp], 1
$LN133@streamout:

; 531  : 
; 532  : 			/* Gather digits in reverse order */
; 533  : 			while (val64)

  004ae	8b c1		 mov	 eax, ecx
  004b0	0b c6		 or	 eax, esi
  004b2	74 36		 je	 SHORT $LN23@streamout
  004b4	8b c7		 mov	 eax, edi
  004b6	99		 cdq
  004b7	8b f8		 mov	 edi, eax
  004b9	89 55 d4	 mov	 DWORD PTR tv600[ebp+4], edx
  004bc	8d 64 24 00	 npad	 4
$LL24@streamout:

; 534  : 			{
; 535  : 				*--string = digits[val64 % base];

  004c0	8b 55 d4	 mov	 edx, DWORD PTR tv600[ebp+4]
  004c3	ff 4d f8	 dec	 DWORD PTR _string$[ebp]
  004c6	52		 push	 edx
  004c7	57		 push	 edi
  004c8	56		 push	 esi
  004c9	51		 push	 ecx
  004ca	e8 00 00 00 00	 call	 __aulldvrm
  004cf	8b 75 d8	 mov	 esi, DWORD PTR _digits$[ebp]
  004d2	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  004d5	8b 75 f8	 mov	 esi, DWORD PTR _string$[ebp]

; 536  : 				val64 /= base;
; 537  : 				precision--;

  004d8	ff 4d 0c	 dec	 DWORD PTR _precision$[ebp]
  004db	88 0e		 mov	 BYTE PTR [esi], cl
  004dd	8b c8		 mov	 ecx, eax
  004df	8b f2		 mov	 esi, edx
  004e1	8b d1		 mov	 edx, ecx
  004e3	0b d6		 or	 edx, esi
  004e5	89 5d e8	 mov	 DWORD PTR tv87[ebp+4], ebx
  004e8	75 d6		 jne	 SHORT $LL24@streamout
$LN23@streamout:

; 538  : 			}
; 539  : 
; 540  : 			len = strlen(string);

  004ea	8b 45 f8	 mov	 eax, DWORD PTR _string$[ebp]
  004ed	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL173@streamout:
  004f0	8a 08		 mov	 cl, BYTE PTR [eax]
  004f2	40		 inc	 eax
  004f3	84 c9		 test	 cl, cl
  004f5	75 f9		 jne	 SHORT $LL173@streamout
$LN216@streamout:
  004f7	2b c2		 sub	 eax, edx
  004f9	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 547  : 		}
; 548  : 
; 549  : 		/* Calculate padding */
; 550  : 		prefixlen = prefix ? strlen(prefix) : 0;

  004fc	8b 45 ec	 mov	 eax, DWORD PTR _prefix$[ebp]
  004ff	85 c0		 test	 eax, eax
  00501	0f 84 81 fd ff
	ff		 je	 $LN199@streamout
  00507	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0050a	8d 9b 00 00 00
	00		 npad	 6
$LL174@streamout:
  00510	8a 08		 mov	 cl, BYTE PTR [eax]
  00512	40		 inc	 eax
  00513	84 c9		 test	 cl, cl
  00515	75 f9		 jne	 SHORT $LL174@streamout
  00517	2b c2		 sub	 eax, edx
  00519	8b d8		 mov	 ebx, eax
  0051b	e9 6a fd ff ff	 jmp	 $LN124@streamout
$LN187@streamout:

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  00520	8b 7d 08	 mov	 edi, DWORD PTR _out$[ebp]
$LN189@streamout:

; 562  : 			}
; 563  : 		}
; 564  : 
; 565  : 		/* Optional prefix */
; 566  : 		if (prefix)

  00523	83 7d ec 00	 cmp	 DWORD PTR _prefix$[ebp], 0
  00527	74 1e		 je	 SHORT $LN14@streamout

; 567  : 		{
; 568  : 			written = streamout_string(out, &cnt, prefix, prefixlen);

  00529	8b 4d ec	 mov	 ecx, DWORD PTR _prefix$[ebp]
  0052c	8d 45 e0	 lea	 eax, DWORD PTR _cnt$[ebp]
  0052f	50		 push	 eax
  00530	57		 push	 edi
  00531	8b c3		 mov	 eax, ebx
  00533	e8 00 00 00 00	 call	 _streamout_astring
  00538	83 c4 08	 add	 esp, 8

; 569  : 			if (written == -1) return -1;

  0053b	83 f8 ff	 cmp	 eax, -1
  0053e	0f 84 e6 00 00
	00		 je	 $LN143@streamout

; 570  : 			written_all += written;

  00544	01 45 fc	 add	 DWORD PTR _written_all$[ebp], eax
$LN14@streamout:

; 571  : 		}
; 572  : 
; 573  : 		/* Optional left '0' padding */
; 574  : 		if ((flags & FLAG_ALIGN_LEFT) == 0) precision += padding;

  00547	8b 5d f4	 mov	 ebx, DWORD PTR _flags$[ebp]
  0054a	83 e3 01	 and	 ebx, 1
  0054d	89 5d d8	 mov	 DWORD PTR tv621[ebp], ebx
  00550	75 03		 jne	 SHORT $LN190@streamout
  00552	01 75 0c	 add	 DWORD PTR _precision$[ebp], esi
$LN190@streamout:

; 575  : 		while (precision-- > 0)

  00555	83 7d 0c 00	 cmp	 DWORD PTR _precision$[ebp], 0
  00559	7e 28		 jle	 SHORT $LN148@streamout
  0055b	eb 03 8d 49 00	 npad	 5
$LL11@streamout:
  00560	ff 4d 0c	 dec	 DWORD PTR _precision$[ebp]

; 576  : 		{
; 577  : 			if ((written = streamout_char(out, &cnt, ('0'))) == 0) return -1;

  00563	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00568	8d 55 e0	 lea	 edx, DWORD PTR _cnt$[ebp]
  0056b	8b cf		 mov	 ecx, edi
  0056d	e8 00 00 00 00	 call	 _streamout_char
  00572	85 c0		 test	 eax, eax
  00574	0f 84 b0 00 00
	00		 je	 $LN143@streamout

; 578  : 			written_all += written;

  0057a	01 45 fc	 add	 DWORD PTR _written_all$[ebp], eax
  0057d	83 7d 0c 00	 cmp	 DWORD PTR _precision$[ebp], 0
  00581	7f dd		 jg	 SHORT $LL11@streamout
$LN148@streamout:

; 579  : 		}
; 580  : 
; 581  : 		/* Output the string */
; 582  : 		if (flags & FLAG_WIDECHAR)

  00583	f7 45 f4 00 02
	00 00		 test	 DWORD PTR _flags$[ebp], 512 ; 00000200H

; 583  : 			written = streamout_wstring(out, &cnt, (wchar_t*)string, len);

  0058a	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  0058d	74 17		 je	 SHORT $LN8@streamout
  0058f	8b 7d 08	 mov	 edi, DWORD PTR _out$[ebp]
  00592	8b 4d f8	 mov	 ecx, DWORD PTR _string$[ebp]
  00595	57		 push	 edi
  00596	8d 5d e0	 lea	 ebx, DWORD PTR _cnt$[ebp]
  00599	e8 00 00 00 00	 call	 _streamout_wstring

; 584  : 		else

  0059e	8b 5d d8	 mov	 ebx, DWORD PTR tv621[ebp]
  005a1	83 c4 04	 add	 esp, 4
  005a4	eb 13		 jmp	 SHORT $LN217@streamout
$LN8@streamout:

; 585  : 			written = streamout_astring(out, &cnt, (char*)string, len);

  005a6	8d 4d e0	 lea	 ecx, DWORD PTR _cnt$[ebp]
  005a9	51		 push	 ecx
  005aa	8b 4d f8	 mov	 ecx, DWORD PTR _string$[ebp]
  005ad	57		 push	 edi
  005ae	e8 00 00 00 00	 call	 _streamout_astring
  005b3	8b 7d 08	 mov	 edi, DWORD PTR _out$[ebp]
  005b6	83 c4 08	 add	 esp, 8
$LN217@streamout:
  005b9	89 45 e8	 mov	 DWORD PTR _written$[ebp], eax

; 586  : 		if (written == -1) return -1;

  005bc	83 f8 ff	 cmp	 eax, -1
  005bf	74 69		 je	 SHORT $LN143@streamout

; 587  : 		written_all += written;

  005c1	01 45 fc	 add	 DWORD PTR _written_all$[ebp], eax

; 588  : 
; 589  : #if 0 && SUPPORT_FLOAT
; 590  : 		/* Optional right '0' padding */
; 591  : 		while (precision-- > 0)
; 592  : 		{
; 593  : 			if ((written = streamout_char(out, &cnt, ('0'))) == 0) return -1;
; 594  : 			written_all += written;
; 595  : 			len++;
; 596  : 		}
; 597  : #endif
; 598  : 
; 599  : 		/* Optional right padding */
; 600  : 		if (flags & FLAG_ALIGN_LEFT)

  005c4	85 db		 test	 ebx, ebx
  005c6	74 46		 je	 SHORT $LN152@streamout

; 601  : 		{
; 602  : 			while (padding-- > 0)

  005c8	85 f6		 test	 esi, esi
  005ca	7e 42		 jle	 SHORT $LN152@streamout
  005cc	8d 64 24 00	 npad	 4
$LL4@streamout:

; 603  : 			{
; 604  : 				if ((written = streamout_char(out, &cnt, (' '))) == 0) return -1;

  005d0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  005d5	8d 55 e0	 lea	 edx, DWORD PTR _cnt$[ebp]
  005d8	8b cf		 mov	 ecx, edi
  005da	4e		 dec	 esi
  005db	e8 00 00 00 00	 call	 _streamout_char
  005e0	89 45 e8	 mov	 DWORD PTR _written$[ebp], eax
  005e3	85 c0		 test	 eax, eax
  005e5	74 43		 je	 SHORT $LN143@streamout

; 605  : 				written_all += written;

  005e7	01 45 fc	 add	 DWORD PTR _written_all$[ebp], eax
  005ea	85 f6		 test	 esi, esi
  005ec	7f e2		 jg	 SHORT $LL4@streamout

; 606  : 			}
; 607  : 		}
; 608  : 
; 609  : 	}

  005ee	eb 1e		 jmp	 SHORT $LN152@streamout
$LN22@streamout:

; 541  : 			break;
; 542  : 
; 543  : 		default:
; 544  : 			/* Treat anything else as a new character */
; 545  : 			format--;

  005f0	4a		 dec	 edx
  005f1	89 55 10	 mov	 DWORD PTR _format$[ebp], edx

; 546  : 			continue;

  005f4	eb 18		 jmp	 SHORT $LN152@streamout
$LN108@streamout:

; 295  : 		{
; 296  : 			/* Write the character to the stream */
; 297  : 			if ((written = streamout_char(out, &cnt, chr)) == 0) return -1;

  005f6	8b 4d 08	 mov	 ecx, DWORD PTR _out$[ebp]
  005f9	0f be c0	 movsx	 eax, al
  005fc	8d 55 e0	 lea	 edx, DWORD PTR _cnt$[ebp]
  005ff	e8 00 00 00 00	 call	 _streamout_char
  00604	89 45 e8	 mov	 DWORD PTR _written$[ebp], eax
  00607	85 c0		 test	 eax, eax
  00609	74 1f		 je	 SHORT $LN143@streamout

; 298  : 			written_all += written;

  0060b	01 45 fc	 add	 DWORD PTR _written_all$[ebp], eax
$LN152@streamout:

; 284  : 
; 285  : 	while (written >= 0)

  0060e	83 7d e8 00	 cmp	 DWORD PTR _written$[ebp], 0
  00612	0f 8d 09 fa ff
	ff		 jge	 $LL112@streamout
$LN111@streamout:

; 610  : 
; 611  : 	if (written == -1) return -1;

  00618	83 c8 ff	 or	 eax, -1
  0061b	39 45 e8	 cmp	 DWORD PTR _written$[ebp], eax
  0061e	74 03		 je	 SHORT $LN113@streamout

; 612  : 
; 613  : 	return written_all;

  00620	8b 45 fc	 mov	 eax, DWORD PTR _written_all$[ebp]
$LN113@streamout:
  00623	5f		 pop	 edi
  00624	5e		 pop	 esi
  00625	5b		 pop	 ebx

; 614  : }

  00626	8b e5		 mov	 esp, ebp
  00628	5d		 pop	 ebp
  00629	c3		 ret	 0
$LN143@streamout:
  0062a	5f		 pop	 edi
  0062b	5e		 pop	 esi

; 295  : 		{
; 296  : 			/* Write the character to the stream */
; 297  : 			if ((written = streamout_char(out, &cnt, chr)) == 0) return -1;

  0062c	83 c8 ff	 or	 eax, -1
  0062f	5b		 pop	 ebx

; 614  : }

  00630	8b e5		 mov	 esp, ebp
  00632	5d		 pop	 ebp
  00633	c3		 ret	 0
$LN218@streamout:
  00634	00 00 00 00	 DD	 $LN40@streamout
  00638	00 00 00 00	 DD	 $LN52@streamout
  0063c	00 00 00 00	 DD	 $LN44@streamout
  00640	00 00 00 00	 DD	 $LN192@streamout
  00644	00 00 00 00	 DD	 $LN47@streamout
  00648	00 00 00 00	 DD	 $case_char$2521
  0064c	00 00 00 00	 DD	 $LN39@streamout
  00650	00 00 00 00	 DD	 $LN57@streamout
  00654	00 00 00 00	 DD	 $LN33@streamout
  00658	00 00 00 00	 DD	 $LN30@streamout
  0065c	00 00 00 00	 DD	 $LN42@streamout
  00660	00 00 00 00	 DD	 $case_unsigned$2619
  00664	00 00 00 00	 DD	 $LN193@streamout
  00668	00 00 00 00	 DD	 $LN22@streamout
$LN169@streamout:
  0066c	00		 DB	 0
  0066d	0d		 DB	 13			; 0000000dH
  0066e	01		 DB	 1
  0066f	0d		 DB	 13			; 0000000dH
  00670	00		 DB	 0
  00671	0d		 DB	 13			; 0000000dH
  00672	00		 DB	 0
  00673	0d		 DB	 13			; 0000000dH
  00674	0d		 DB	 13			; 0000000dH
  00675	0d		 DB	 13			; 0000000dH
  00676	0d		 DB	 13			; 0000000dH
  00677	0d		 DB	 13			; 0000000dH
  00678	0d		 DB	 13			; 0000000dH
  00679	0d		 DB	 13			; 0000000dH
  0067a	0d		 DB	 13			; 0000000dH
  0067b	0d		 DB	 13			; 0000000dH
  0067c	0d		 DB	 13			; 0000000dH
  0067d	0d		 DB	 13			; 0000000dH
  0067e	02		 DB	 2
  0067f	0d		 DB	 13			; 0000000dH
  00680	0d		 DB	 13			; 0000000dH
  00681	0d		 DB	 13			; 0000000dH
  00682	0d		 DB	 13			; 0000000dH
  00683	03		 DB	 3
  00684	0d		 DB	 13			; 0000000dH
  00685	04		 DB	 4
  00686	0d		 DB	 13			; 0000000dH
  00687	0d		 DB	 13			; 0000000dH
  00688	0d		 DB	 13			; 0000000dH
  00689	0d		 DB	 13			; 0000000dH
  0068a	0d		 DB	 13			; 0000000dH
  0068b	0d		 DB	 13			; 0000000dH
  0068c	00		 DB	 0
  0068d	0d		 DB	 13			; 0000000dH
  0068e	05		 DB	 5
  0068f	06		 DB	 6
  00690	00		 DB	 0
  00691	00		 DB	 0
  00692	00		 DB	 0
  00693	0d		 DB	 13			; 0000000dH
  00694	06		 DB	 6
  00695	0d		 DB	 13			; 0000000dH
  00696	0d		 DB	 13			; 0000000dH
  00697	0d		 DB	 13			; 0000000dH
  00698	0d		 DB	 13			; 0000000dH
  00699	07		 DB	 7
  0069a	08		 DB	 8
  0069b	09		 DB	 9
  0069c	0d		 DB	 13			; 0000000dH
  0069d	0d		 DB	 13			; 0000000dH
  0069e	0a		 DB	 10			; 0000000aH
  0069f	0d		 DB	 13			; 0000000dH
  006a0	0b		 DB	 11			; 0000000bH
  006a1	0d		 DB	 13			; 0000000dH
  006a2	0d		 DB	 13			; 0000000dH
  006a3	0c		 DB	 12			; 0000000cH
_streamout ENDP
_TEXT	ENDS
END
