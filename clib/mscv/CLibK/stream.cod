; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\stdio\stream.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2670	DB	'-', 00H
	ORG $+2
$SG2673	DB	'+', 00H
	ORG $+2
$SG2676	DB	' ', 00H
	ORG $+2
?_nullstring@?1??streamout@@9@9 DD FLAT:$SG2715		; `streamout'::`2'::_nullstring
$SG2715	DB	'(null)', 00H
	ORG $+1
$SG2924	DB	'-', 00H
	ORG $+2
$SG2927	DB	'+', 00H
	ORG $+2
$SG2930	DB	' ', 00H
	ORG $+2
$SG2934	DB	'0', 00H
_DATA	ENDS
CONST	SEGMENT
?digits_l@?1??format_float@@9@9 DB '0123456789abcdef0x', 00H ; `format_float'::`2'::digits_l
	ORG $+1
?digits_u@?1??format_float@@9@9 DB '0123456789ABCDEF0X', 00H ; `format_float'::`2'::digits_u
	ORG $+1
?_nan@?1??format_float@@9@9 DB '#QNAN', 00H		; `format_float'::`2'::_nan
	ORG $+2
?_infinity@?1??format_float@@9@9 DB '#INF', 00H		; `format_float'::`2'::_infinity
	ORG $+3
?digits_l@?1??streamout@@9@9 DB '0123456789abcdef0x', 00H ; `streamout'::`2'::digits_l
	ORG $+1
?digits_u@?1??streamout@@9@9 DB '0123456789ABCDEF0X', 00H ; `streamout'::`2'::digits_u
CONST	ENDS
PUBLIC	_format_float
PUBLIC	_streamout
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__finite:PROC
EXTRN	__isnan:PROC
EXTRN	_PutChar:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__aullrem:PROC
EXTRN	__dtoul3:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__ultod3:PROC
EXTRN	_floor:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout
_TEXT	SEGMENT
tv607 = -128						; size = 4
_digits$1$ = -124					; size = 4
_flags$1$ = -120					; size = 4
tv671 = -120						; size = 4
tv669 = -120						; size = 4
_base$1$ = -116						; size = 4
tv614 = -116						; size = 4
tv528 = -112						; size = 8
_val64$2$ = -108					; size = 4
_written$4$ = -108					; size = 4
_cnt$ = -104						; size = 4
_prefixlen$1$ = -100					; size = 4
tv613 = -100						; size = 4
_prefix$ = -100						; size = 4
_chr$ = -96						; size = 1
_prefix$1$ = -92					; size = 4
_val64$1$ = -88						; size = 4
_string$ = -88						; size = 4
_padding$2$ = -84					; size = 4
_string$1$ = -80					; size = 4
_out$GSCopy$1$ = -76					; size = 4
_written_all$1$ = -72					; size = 4
_precision$2$ = -68					; size = 4
_argptr$GSCopy$1$ = -64					; size = 4
_argptr$GSCopy$ = -60					; size = 4
_buffer$ = -56						; size = 50
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_size$ = 12						; size = 4
_format$ = 16						; size = 4
_argptr$ = 20						; size = 4
_streamout PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 14	 mov	 edx, DWORD PTR _argptr$[ebp]

; 269  : 	static const char digits_l[] = "0123456789abcdef0x";
; 270  : 	static const char digits_u[] = "0123456789ABCDEF0X";
; 271  : 	static const char *_nullstring = "(null)";
; 272  : 	char buffer[BUFFER_SIZE + 1];
; 273  : 	uint32_t cnt = size;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 08	 mov	 ebx, DWORD PTR _out$[ebp]
  0001d	56		 push	 esi

; 274  : 	char chr, *string;
; 275  : 	STRING *nt_string;
; 276  : 	const char *digits, *prefix;
; 277  : 	int base, fieldwidth, precision, padding;
; 278  : 	size_t prefixlen, len;
; 279  : 	int written = 1, written_all = 0;
; 280  : 	unsigned int flags;
; 281  : 	unsigned __int64 val64;
; 282  : 
; 283  : 	buffer[BUFFER_SIZE] = '\0';

  0001e	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  00021	57		 push	 edi
  00022	33 ff		 xor	 edi, edi
  00024	89 5d b4	 mov	 DWORD PTR _out$GSCopy$1$[ebp], ebx
  00027	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  0002a	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  0002d	89 45 98	 mov	 DWORD PTR _cnt$[ebp], eax
  00030	c7 45 94 01 00
	00 00		 mov	 DWORD PTR _written$4$[ebp], 1
  00037	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0003a	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
  0003d	c6 45 f9 00	 mov	 BYTE PTR _buffer$[ebp+49], 0
  00041	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv607[ebp], 1
$LL112@streamout:

; 286  : 	{
; 287  : 		chr = *format++;

  00048	8a 06		 mov	 al, BYTE PTR [esi]
  0004a	46		 inc	 esi

; 288  : 
; 289  : 		/* Check for end of format string */
; 290  : 		if (chr == '\0') break;

  0004b	84 c0		 test	 al, al
  0004d	0f 84 2b 02 00
	00		 je	 $LN111@streamout

; 291  : 
; 292  : 		/* Check for 'normal' character or double % */
; 293  : 		if ((chr != ('%')) ||
; 294  : 			(chr = *format++) == ('%'))

  00053	3c 25		 cmp	 al, 37			; 00000025H
  00055	0f 85 37 06 00
	00		 jne	 $LN108@streamout
  0005b	8a 06		 mov	 al, BYTE PTR [esi]
  0005d	46		 inc	 esi
  0005e	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  00061	3c 25		 cmp	 al, 37			; 00000025H
  00063	0f 84 29 06 00
	00		 je	 $LN108@streamout

; 299  : 			continue;
; 300  : 		}
; 301  : 
; 302  : 		/* Handle flags */
; 303  : 		flags = 0;

  00069	33 db		 xor	 ebx, ebx
  0006b	eb 03 8d 49 00	 npad	 5
$LL106@streamout:

; 304  : 		while (1)
; 305  : 		{
; 306  : 			if (chr == ('-')) flags |= FLAG_ALIGN_LEFT;

  00070	3c 2d		 cmp	 al, 45			; 0000002dH
  00072	75 0b		 jne	 SHORT $LN104@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00074	8a 06		 mov	 al, BYTE PTR [esi]
  00076	83 cb 01	 or	 ebx, 1
  00079	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  0007c	46		 inc	 esi

; 313  : 		}

  0007d	eb f1		 jmp	 SHORT $LL106@streamout
$LN104@streamout:

; 307  : 			else if (chr == ('+')) flags |= FLAG_FORCE_SIGN;

  0007f	3c 2b		 cmp	 al, 43			; 0000002bH
  00081	75 0b		 jne	 SHORT $LN102@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00083	8a 06		 mov	 al, BYTE PTR [esi]
  00085	83 cb 02	 or	 ebx, 2
  00088	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  0008b	46		 inc	 esi

; 313  : 		}

  0008c	eb e2		 jmp	 SHORT $LL106@streamout
$LN102@streamout:

; 308  : 			else if (chr == (' ')) flags |= FLAG_FORCE_SIGNSP;

  0008e	3c 20		 cmp	 al, 32			; 00000020H
  00090	75 0b		 jne	 SHORT $LN100@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  00092	8a 06		 mov	 al, BYTE PTR [esi]
  00094	83 cb 04	 or	 ebx, 4
  00097	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  0009a	46		 inc	 esi

; 313  : 		}

  0009b	eb d3		 jmp	 SHORT $LL106@streamout
$LN100@streamout:

; 309  : 			else if (chr == ('0')) flags |= FLAG_PAD_ZERO;

  0009d	3c 30		 cmp	 al, 48			; 00000030H
  0009f	75 0b		 jne	 SHORT $LN98@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  000a1	8a 06		 mov	 al, BYTE PTR [esi]
  000a3	83 cb 08	 or	 ebx, 8
  000a6	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  000a9	46		 inc	 esi

; 313  : 		}

  000aa	eb c4		 jmp	 SHORT $LL106@streamout
$LN98@streamout:

; 310  : 			else if (chr == ('#')) flags |= FLAG_SPECIAL;

  000ac	3c 23		 cmp	 al, 35			; 00000023H
  000ae	75 0b		 jne	 SHORT $LN96@streamout

; 311  : 			else break;
; 312  : 			chr = *format++;

  000b0	8a 06		 mov	 al, BYTE PTR [esi]
  000b2	83 cb 10	 or	 ebx, 16			; 00000010H
  000b5	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  000b8	46		 inc	 esi

; 313  : 		}

  000b9	eb b5		 jmp	 SHORT $LL106@streamout
$LN96@streamout:

; 314  : 
; 315  : 		/* Handle field width modifier */
; 316  : 		if (chr == ('*'))

  000bb	3c 2a		 cmp	 al, 42			; 0000002aH
  000bd	75 22		 jne	 SHORT $LN94@streamout

; 317  : 		{
; 318  : 			fieldwidth = va_arg(argptr, int);

  000bf	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000c1	83 c2 04	 add	 edx, 4
  000c4	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  000c7	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  000ca	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx

; 319  : 			if (fieldwidth < 0)

  000cd	85 c9		 test	 ecx, ecx
  000cf	79 08		 jns	 SHORT $LN93@streamout

; 320  : 			{
; 321  : 				flags |= FLAG_ALIGN_LEFT;

  000d1	83 cb 01	 or	 ebx, 1

; 322  : 				fieldwidth = -fieldwidth;

  000d4	f7 d9		 neg	 ecx
  000d6	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx
$LN93@streamout:

; 323  : 			}
; 324  : 			chr = *format++;

  000d9	8a 06		 mov	 al, BYTE PTR [esi]
  000db	46		 inc	 esi
  000dc	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al

; 325  : 		}
; 326  : 		else

  000df	eb 2c		 jmp	 SHORT $LN90@streamout
$LN94@streamout:

; 327  : 		{
; 328  : 			fieldwidth = 0;

  000e1	33 c9		 xor	 ecx, ecx
  000e3	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx

; 329  : 			while (chr >= ('0') && chr <= ('9'))

  000e6	3c 30		 cmp	 al, 48			; 00000030H
  000e8	7c 23		 jl	 SHORT $LN90@streamout
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL91@streamout:
  000f0	3c 39		 cmp	 al, 57			; 00000039H
  000f2	7f 16		 jg	 SHORT $LN229@streamout

; 330  : 			{
; 331  : 				fieldwidth = fieldwidth * 10 + (chr - ('0'));

  000f4	0f be c0	 movsx	 eax, al
  000f7	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  000fa	8d 49 e8	 lea	 ecx, DWORD PTR [ecx-24]
  000fd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]

; 332  : 				chr = *format++;

  00100	8a 06		 mov	 al, BYTE PTR [esi]
  00102	46		 inc	 esi
  00103	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  00106	3c 30		 cmp	 al, 48			; 00000030H
  00108	7d e6		 jge	 SHORT $LL91@streamout
$LN229@streamout:
  0010a	89 4d ac	 mov	 DWORD PTR _padding$2$[ebp], ecx
$LN90@streamout:

; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 		/* Handle precision modifier */
; 337  : 		if (chr == '.')

  0010d	3c 2e		 cmp	 al, 46			; 0000002eH
  0010f	75 46		 jne	 SHORT $LN89@streamout

; 338  : 		{
; 339  : 			chr = *format++;

  00111	8a 06		 mov	 al, BYTE PTR [esi]
  00113	46		 inc	 esi
  00114	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al

; 340  : 
; 341  : 			if (chr == ('*'))

  00117	3c 2a		 cmp	 al, 42			; 0000002aH
  00119	75 14		 jne	 SHORT $LN88@streamout

; 342  : 			{
; 343  : 				precision = va_arg(argptr, int);
; 344  : 				chr = *format++;

  0011b	8a 06		 mov	 al, BYTE PTR [esi]
  0011d	83 c2 04	 add	 edx, 4
  00120	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  00123	46		 inc	 esi
  00124	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  00127	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  0012a	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]

; 345  : 			}
; 346  : 			else

  0012d	eb 2b		 jmp	 SHORT $LN244@streamout
$LN88@streamout:

; 347  : 			{
; 348  : 				precision = 0;

  0012f	33 ff		 xor	 edi, edi
  00131	89 7d bc	 mov	 DWORD PTR _precision$2$[ebp], edi

; 349  : 				while (chr >= ('0') && chr <= ('9'))

  00134	3c 30		 cmp	 al, 48			; 00000030H
  00136	7c 28		 jl	 SHORT $LL83@streamout
$LL86@streamout:
  00138	3c 39		 cmp	 al, 57			; 00000039H
  0013a	7f 24		 jg	 SHORT $LL83@streamout

; 350  : 				{
; 351  : 					precision = precision * 10 + (chr - ('0'));

  0013c	0f be c0	 movsx	 eax, al
  0013f	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00142	8d 79 e8	 lea	 edi, DWORD PTR [ecx-24]
  00145	8d 3c 78	 lea	 edi, DWORD PTR [eax+edi*2]

; 352  : 					chr = *format++;

  00148	8a 06		 mov	 al, BYTE PTR [esi]
  0014a	46		 inc	 esi
  0014b	89 7d bc	 mov	 DWORD PTR _precision$2$[ebp], edi
  0014e	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  00151	3c 30		 cmp	 al, 48			; 00000030H
  00153	7d e3		 jge	 SHORT $LL86@streamout

; 353  : 				}
; 354  : 			}

  00155	eb 09		 jmp	 SHORT $LL83@streamout
$LN89@streamout:

; 355  : 		}
; 356  : 		else precision = -1;

  00157	83 cf ff	 or	 edi, -1
$LN244@streamout:
  0015a	89 7d bc	 mov	 DWORD PTR _precision$2$[ebp], edi
  0015d	8d 49 00	 npad	 3
$LL83@streamout:

; 357  : 
; 358  : 		/* Handle argument size prefix */
; 359  : 		do
; 360  : 		{
; 361  : 			if (chr == ('h')) flags |= FLAG_SHORT;

  00160	3c 68		 cmp	 al, 104			; 00000068H
  00162	75 0e		 jne	 SHORT $LN80@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00164	8a 06		 mov	 al, BYTE PTR [esi]
  00166	81 cb 00 01 00
	00		 or	 ebx, 256		; 00000100H
  0016c	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  0016f	46		 inc	 esi

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00170	eb ee		 jmp	 SHORT $LL83@streamout
$LN80@streamout:

; 362  : 			else if (chr == ('w')) flags |= FLAG_WIDECHAR;

  00172	3c 77		 cmp	 al, 119			; 00000077H
  00174	75 0e		 jne	 SHORT $LN78@streamout
$LN71@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00176	8a 06		 mov	 al, BYTE PTR [esi]
  00178	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
  0017e	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  00181	46		 inc	 esi

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00182	eb dc		 jmp	 SHORT $LL83@streamout
$LN78@streamout:

; 363  : 			else if (chr == ('L')) flags |= 0; // FIXME: long double

  00184	3c 4c		 cmp	 al, 76			; 0000004cH
  00186	74 73		 je	 SHORT $LN62@streamout

; 364  : 			else if (chr == ('F')) flags |= 0; // FIXME: what is that?

  00188	3c 46		 cmp	 al, 70			; 00000046H
  0018a	74 6f		 je	 SHORT $LN62@streamout

; 365  : 			else if (chr == ('l'))

  0018c	3c 6c		 cmp	 al, 108			; 0000006cH
  0018e	75 13		 jne	 SHORT $LN72@streamout

; 366  : 			{
; 367  : 				/* Check if this is the 2nd 'l' in a row */
; 368  : 				if (format[-2] == 'l') flags |= FLAG_INT64;

  00190	38 46 fe	 cmp	 BYTE PTR [esi-2], al
  00193	75 e1		 jne	 SHORT $LN71@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  00195	8a 06		 mov	 al, BYTE PTR [esi]
  00197	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  0019d	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  001a0	46		 inc	 esi

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001a1	eb bd		 jmp	 SHORT $LL83@streamout
$LN72@streamout:

; 369  : 				else flags |= FLAG_LONG;
; 370  : 			}
; 371  : 			else if (chr == ('I'))

  001a3	3c 49		 cmp	 al, 73			; 00000049H
  001a5	75 5f		 jne	 SHORT $LN81@streamout

; 372  : 			{
; 373  : 				if (format[0] == ('3') && format[1] == ('2'))

  001a7	8a 0e		 mov	 cl, BYTE PTR [esi]
  001a9	80 f9 33	 cmp	 cl, 51			; 00000033H
  001ac	75 12		 jne	 SHORT $LN67@streamout
  001ae	80 7e 01 32	 cmp	 BYTE PTR [esi+1], 50	; 00000032H
  001b2	75 0c		 jne	 SHORT $LN67@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001b4	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001b7	83 c6 02	 add	 esi, 2
  001ba	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  001bd	46		 inc	 esi

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001be	eb a0		 jmp	 SHORT $LL83@streamout
$LN67@streamout:

; 374  : 				{
; 375  : 					format += 2;
; 376  : 				}
; 377  : 				else if (format[0] == ('6') && format[1] == ('4'))

  001c0	80 f9 36	 cmp	 cl, 54			; 00000036H
  001c3	75 18		 jne	 SHORT $LN65@streamout
  001c5	80 7e 01 34	 cmp	 BYTE PTR [esi+1], 52	; 00000034H
  001c9	75 12		 jne	 SHORT $LN65@streamout

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001cb	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  001ce	83 c6 02	 add	 esi, 2
  001d1	81 cb 00 04 00
	00		 or	 ebx, 1024		; 00000400H
  001d7	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al
  001da	46		 inc	 esi

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  001db	eb 83		 jmp	 SHORT $LL83@streamout
$LN65@streamout:

; 378  : 				{
; 379  : 					format += 2;
; 380  : 					flags |= FLAG_INT64;
; 381  : 				}
; 382  : 				else if (format[0] == ('x') || format[0] == ('X') ||
; 383  : 					format[0] == ('d') || format[0] == ('i') ||
; 384  : 					format[0] == ('u') || format[0] == ('o'))

  001dd	80 f9 78	 cmp	 cl, 120			; 00000078H
  001e0	74 19		 je	 SHORT $LN62@streamout
  001e2	80 f9 58	 cmp	 cl, 88			; 00000058H
  001e5	74 14		 je	 SHORT $LN62@streamout
  001e7	80 f9 64	 cmp	 cl, 100			; 00000064H
  001ea	74 0f		 je	 SHORT $LN62@streamout
  001ec	80 f9 69	 cmp	 cl, 105			; 00000069H
  001ef	74 0a		 je	 SHORT $LN62@streamout
  001f1	80 f9 75	 cmp	 cl, 117			; 00000075H
  001f4	74 05		 je	 SHORT $LN62@streamout
  001f6	80 f9 6f	 cmp	 cl, 111			; 0000006fH
  001f9	75 0b		 jne	 SHORT $LN81@streamout
$LN62@streamout:

; 385  : 				{
; 386  : 					flags |= FLAG_INTPTR;
; 387  : 				}
; 388  : 				else break;
; 389  : 			}
; 390  : 			else break;
; 391  : 			chr = *format++;

  001fb	8a 06		 mov	 al, BYTE PTR [esi]
  001fd	46		 inc	 esi
  001fe	88 45 a0	 mov	 BYTE PTR _chr$[ebp], al

; 392  : 		}
; 393  : 		while (USE_MULTISIZE);

  00201	e9 5a ff ff ff	 jmp	 $LL83@streamout
$LN81@streamout:

; 394  : 
; 395  : 		/* Handle the format specifier */
; 396  : 		digits = digits_l;
; 397  : 		string = &buffer[BUFFER_SIZE];
; 398  : 		base = 10;
; 399  : 		prefix = 0;
; 400  : 		switch (chr)

  00206	0f be c0	 movsx	 eax, al
  00209	8d 4d f9	 lea	 ecx, DWORD PTR _buffer$[ebp+49]
  0020c	83 c0 bf	 add	 eax, -65		; ffffffbfH
  0020f	89 75 10	 mov	 DWORD PTR _format$[ebp], esi
  00212	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??streamout@@9@9
  00219	89 4d b0	 mov	 DWORD PTR _string$1$[ebp], ecx
  0021c	89 4d a8	 mov	 DWORD PTR _string$[ebp], ecx
  0021f	c7 45 8c 0a 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 10 ; 0000000aH
  00226	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], 0
  0022d	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _prefix$[ebp], 0
  00234	83 f8 37	 cmp	 eax, 55			; 00000037H
  00237	0f 87 4c 04 00
	00		 ja	 $LN22@streamout
  0023d	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN205@streamout[eax]
  00244	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN253@streamout[eax*4]
$LN57@streamout:

; 401  : 		{
; 402  : 		case ('n'):
; 403  : 			if (flags & FLAG_INT64)
; 404  : 				*va_arg(argptr, __int64*) = written_all;

  0024b	8b 7d b8	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  0024e	83 c2 04	 add	 edx, 4
  00251	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  00254	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  00257	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  0025d	74 3a		 je	 SHORT $LN56@streamout
  0025f	8b 4d c0	 mov	 ecx, DWORD PTR _argptr$GSCopy$1$[ebp]
  00262	8b c7		 mov	 eax, edi
  00264	99		 cdq
  00265	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00268	89 01		 mov	 DWORD PTR [ecx], eax
  0026a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN233@streamout:
  0026d	8b 55 c0	 mov	 edx, DWORD PTR _argptr$GSCopy$1$[ebp]
$LN250@streamout:
  00270	8b 5d b4	 mov	 ebx, DWORD PTR _out$GSCopy$1$[ebp]
$LN154@streamout:

; 284  : 
; 285  : 	while (written >= 0)

  00273	8b 4d 94	 mov	 ecx, DWORD PTR _written$4$[ebp]
  00276	85 c9		 test	 ecx, ecx
  00278	0f 89 ca fd ff
	ff		 jns	 $LL112@streamout
$LN111@streamout:

; 610  : 
; 611  : 	if (written == -1) return -1;

  0027e	83 c8 ff	 or	 eax, -1
  00281	3b c8		 cmp	 ecx, eax
  00283	0f 44 f8	 cmove	 edi, eax
  00286	8b c7		 mov	 eax, edi
  00288	5f		 pop	 edi
  00289	5e		 pop	 esi
  0028a	5b		 pop	 ebx

; 612  : 
; 613  : 	return written_all;
; 614  : }

  0028b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028e	33 cd		 xor	 ecx, ebp
  00290	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00295	8b e5		 mov	 esp, ebp
  00297	5d		 pop	 ebp
  00298	c3		 ret	 0
$LN56@streamout:

; 405  : 			else if (flags & FLAG_SHORT)
; 406  : 				*va_arg(argptr, short*) = (short)written_all;

  00299	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0029c	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H

; 407  : 			else

  002a2	8b 5d b4	 mov	 ebx, DWORD PTR _out$GSCopy$1$[ebp]
  002a5	74 05		 je	 SHORT $LN54@streamout

; 405  : 			else if (flags & FLAG_SHORT)
; 406  : 				*va_arg(argptr, short*) = (short)written_all;

  002a7	66 89 38	 mov	 WORD PTR [eax], di

; 407  : 			else

  002aa	eb c7		 jmp	 SHORT $LN154@streamout
$LN54@streamout:

; 408  : 				*va_arg(argptr, int*) = written_all;

  002ac	89 38		 mov	 DWORD PTR [eax], edi

; 409  : 			continue;

  002ae	eb c3		 jmp	 SHORT $LN154@streamout
$LN52@streamout:

; 410  : 
; 411  : 		case ('C'):
; 412  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  002b0	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  002b6	75 06		 jne	 SHORT $case_char$254
  002b8	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H
$case_char$254:

; 423  :  			}
; 424  :  			else

  002be	8b 4d bc	 mov	 ecx, DWORD PTR _precision$2$[ebp]
  002c1	8d 45 c8	 lea	 eax, DWORD PTR _buffer$[ebp]
  002c4	83 c2 04	 add	 edx, 4
  002c7	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
  002ca	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  002cd	bf 01 00 00 00	 mov	 edi, 1
  002d2	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  002d5	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  002db	0f 84 ef 00 00
	00		 je	 $LN49@streamout

; 413  : 			goto case_char;
; 414  : 
; 415  : 		case ('c'):
; 416  : case_char:
; 417  : 			string = buffer;
; 418  : 			len = 1;
; 419  :  			if (flags & FLAG_WIDECHAR)
; 420  :  			{
; 421  :  				((wchar_t*)string)[0] = (wchar_t)va_arg(argptr, int);

  002e1	66 8b 42 fc	 mov	 ax, WORD PTR [edx-4]
  002e5	66 89 45 c8	 mov	 WORD PTR _buffer$[ebp], ax

; 422  :  				((wchar_t*)string)[1] = (wchar_t)('\0');

  002e9	33 c0		 xor	 eax, eax
  002eb	66 89 45 ca	 mov	 WORD PTR _buffer$[ebp+2], ax
$LN125@streamout:

; 547  : 		}
; 548  : 
; 549  : 		/* Calculate padding */
; 550  : 		prefixlen = prefix ? strlen(prefix) : 0;

  002ef	33 d2		 xor	 edx, edx
$LN248@streamout:

; 551  : 		if (precision < 0) precision = 0;

  002f1	33 c0		 xor	 eax, eax
  002f3	89 55 9c	 mov	 DWORD PTR _prefixlen$1$[ebp], edx
  002f6	85 c9		 test	 ecx, ecx
  002f8	0f 48 c8	 cmovs	 ecx, eax

; 552  : 		padding = (int)(fieldwidth - len - prefixlen - precision);

  002fb	8b 45 ac	 mov	 eax, DWORD PTR _padding$2$[ebp]
  002fe	2b c2		 sub	 eax, edx
  00300	89 4d bc	 mov	 DWORD PTR _precision$2$[ebp], ecx
  00303	2b c7		 sub	 eax, edi
  00305	2b c1		 sub	 eax, ecx

; 553  : 		if (padding < 0) padding = 0;

  00307	b9 00 00 00 00	 mov	 ecx, 0
  0030c	0f 48 c1	 cmovs	 eax, ecx
  0030f	89 45 ac	 mov	 DWORD PTR _padding$2$[ebp], eax

; 554  : 
; 555  : 		/* Optional left space padding */
; 556  : 		if ((flags & (FLAG_ALIGN_LEFT | FLAG_PAD_ZERO)) == 0)

  00312	f6 c3 09	 test	 bl, 9
  00315	75 33		 jne	 SHORT $LN16@streamout

; 557  : 		{
; 558  : 			for (; padding > 0; padding--)

  00317	85 c0		 test	 eax, eax
  00319	7e 2f		 jle	 SHORT $LN16@streamout
  0031b	eb 03 8d 49 00	 npad	 5
$LL18@streamout:

; 559  : 			{
; 560  : 				if ((written = streamout_char(out, &cnt, (' '))) == 0) return -1;

  00320	6a 20		 push	 32			; 00000020H
  00322	8d 45 98	 lea	 eax, DWORD PTR _cnt$[ebp]
  00325	50		 push	 eax
  00326	ff 75 b4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  00329	e8 00 00 00 00	 call	 _streamout_char
  0032e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00331	85 c0		 test	 eax, eax
  00333	0f 84 80 03 00
	00		 je	 $LN145@streamout

; 561  : 				written_all += written;

  00339	01 45 b8	 add	 DWORD PTR _written_all$1$[ebp], eax
  0033c	8b 45 ac	 mov	 eax, DWORD PTR _padding$2$[ebp]
  0033f	48		 dec	 eax
  00340	89 45 ac	 mov	 DWORD PTR _padding$2$[ebp], eax
  00343	85 c0		 test	 eax, eax
  00345	7f d9		 jg	 SHORT $LL18@streamout
  00347	8b 55 9c	 mov	 edx, DWORD PTR _prefixlen$1$[ebp]
$LN16@streamout:

; 562  : 			}
; 563  : 		}
; 564  : 
; 565  : 		/* Optional prefix */
; 566  : 		if (prefix)

  0034a	8b 45 a4	 mov	 eax, DWORD PTR _prefix$1$[ebp]
  0034d	85 c0		 test	 eax, eax
  0034f	74 1d		 je	 SHORT $LN14@streamout

; 567  : 		{
; 568  : 			written = streamout_string(out, &cnt, prefix, prefixlen);

  00351	52		 push	 edx
  00352	50		 push	 eax
  00353	8d 45 98	 lea	 eax, DWORD PTR _cnt$[ebp]
  00356	50		 push	 eax
  00357	ff 75 b4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  0035a	e8 00 00 00 00	 call	 _streamout_astring
  0035f	83 c4 10	 add	 esp, 16			; 00000010H

; 569  : 			if (written == -1) return -1;

  00362	83 f8 ff	 cmp	 eax, -1
  00365	0f 84 4e 03 00
	00		 je	 $LN145@streamout

; 570  : 			written_all += written;

  0036b	01 45 b8	 add	 DWORD PTR _written_all$1$[ebp], eax
$LN14@streamout:

; 571  : 		}
; 572  : 
; 573  : 		/* Optional left '0' padding */
; 574  : 		if ((flags & FLAG_ALIGN_LEFT) == 0) precision += padding;

  0036e	8b c3		 mov	 eax, ebx
  00370	83 e0 01	 and	 eax, 1
  00373	89 45 88	 mov	 DWORD PTR tv671[ebp], eax
  00376	8b 45 bc	 mov	 eax, DWORD PTR _precision$2$[ebp]
  00379	75 03		 jne	 SHORT $LN137@streamout
  0037b	03 45 ac	 add	 eax, DWORD PTR _padding$2$[ebp]
$LN137@streamout:

; 575  : 		while (precision-- > 0)

  0037e	85 c0		 test	 eax, eax
  00380	7e 27		 jle	 SHORT $LN150@streamout
$LL11@streamout:
  00382	48		 dec	 eax
  00383	89 45 bc	 mov	 DWORD PTR _precision$2$[ebp], eax

; 576  : 		{
; 577  : 			if ((written = streamout_char(out, &cnt, ('0'))) == 0) return -1;

  00386	8d 45 98	 lea	 eax, DWORD PTR _cnt$[ebp]
  00389	6a 30		 push	 48			; 00000030H
  0038b	50		 push	 eax
  0038c	ff 75 b4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  0038f	e8 00 00 00 00	 call	 _streamout_char
  00394	83 c4 0c	 add	 esp, 12			; 0000000cH
  00397	85 c0		 test	 eax, eax
  00399	0f 84 1a 03 00
	00		 je	 $LN145@streamout

; 578  : 			written_all += written;

  0039f	01 45 b8	 add	 DWORD PTR _written_all$1$[ebp], eax
  003a2	8b 45 bc	 mov	 eax, DWORD PTR _precision$2$[ebp]
  003a5	85 c0		 test	 eax, eax
  003a7	7f d9		 jg	 SHORT $LL11@streamout
$LN150@streamout:

; 579  : 		}
; 580  : 
; 581  : 		/* Output the string */
; 582  : 		if (flags & FLAG_WIDECHAR)
; 583  : 			written = streamout_wstring(out, &cnt, (wchar_t*)string, len);

  003a9	57		 push	 edi
  003aa	ff 75 b0	 push	 DWORD PTR _string$1$[ebp]
  003ad	8d 45 98	 lea	 eax, DWORD PTR _cnt$[ebp]
  003b0	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  003b6	8b 5d b4	 mov	 ebx, DWORD PTR _out$GSCopy$1$[ebp]
  003b9	50		 push	 eax
  003ba	53		 push	 ebx
  003bb	0f 84 73 02 00
	00		 je	 $LN8@streamout
  003c1	e8 00 00 00 00	 call	 _streamout_wstring
  003c6	8b d0		 mov	 edx, eax
  003c8	89 55 94	 mov	 DWORD PTR _written$4$[ebp], edx

; 584  : 		else

  003cb	e9 6e 02 00 00	 jmp	 $LN249@streamout
$LN49@streamout:

; 425  :  			{
; 426  : 				((char*)string)[0] = (char)va_arg(argptr, int);

  003d0	8a 42 fc	 mov	 al, BYTE PTR [edx-4]
  003d3	88 45 c8	 mov	 BYTE PTR _buffer$[ebp], al

; 427  : 				((char*)string)[1] = (char)('\0');

  003d6	c6 45 c9 00	 mov	 BYTE PTR _buffer$[ebp+1], 0

; 428  : 			}
; 429  : 			break;

  003da	e9 10 ff ff ff	 jmp	 $LN125@streamout
$LN47@streamout:

; 430  : 
; 431  : 		case ('Z'):
; 432  : 			nt_string = va_arg(argptr, void*);

  003df	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003e1	83 c2 04	 add	 edx, 4
  003e4	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  003e7	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx

; 433  : 			if (nt_string && (string = nt_string->Buffer))

  003ea	85 c9		 test	 ecx, ecx
  003ec	74 53		 je	 SHORT $LN193@streamout
  003ee	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  003f1	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
  003f4	85 c0		 test	 eax, eax
  003f6	74 49		 je	 SHORT $LN193@streamout

; 434  : 			{
; 435  : 				len = nt_string->Length;

  003f8	0f b7 39	 movzx	 edi, WORD PTR [ecx]

; 437  : 				break;

  003fb	8b 4d bc	 mov	 ecx, DWORD PTR _precision$2$[ebp]
  003fe	f7 c3 00 02 00
	00		 test	 ebx, 512		; 00000200H
  00404	0f 84 e5 fe ff
	ff		 je	 $LN125@streamout

; 436  : 				if (flags & FLAG_WIDECHAR) len /= sizeof(wchar_t);

  0040a	d1 ef		 shr	 edi, 1

; 437  : 				break;

  0040c	e9 de fe ff ff	 jmp	 $LN125@streamout
$LN44@streamout:

; 438  : 			}
; 439  : 			string = 0;
; 440  : 			goto case_string;
; 441  : 
; 442  : 		case ('S'):
; 443  : 			string = va_arg(argptr, void*);

  00411	8b 02		 mov	 eax, DWORD PTR [edx]
  00413	83 c2 04	 add	 edx, 4
  00416	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  00419	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  0041c	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax

; 444  : 			if (!(flags & FLAG_SHORT)) flags |= FLAG_WIDECHAR;

  0041f	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  00425	75 16		 jne	 SHORT $case_string$255
  00427	81 cb 00 02 00
	00		 or	 ebx, 512		; 00000200H

; 445  : 			goto case_string;

  0042d	eb 0e		 jmp	 SHORT $case_string$255
$LN42@streamout:

; 446  : 
; 447  : 		case ('s'):
; 448  : 			string = va_arg(argptr, void*);

  0042f	8b 02		 mov	 eax, DWORD PTR [edx]
  00431	83 c2 04	 add	 edx, 4
  00434	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  00437	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  0043a	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
$case_string$255:

; 449  : 
; 450  : case_string:
; 451  : 			if (!string)

  0043d	85 c0		 test	 eax, eax
  0043f	75 0e		 jne	 SHORT $LN41@streamout
$LN193@streamout:

; 452  : 			{
; 453  : 				string = (char*)_nullstring;

  00441	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_nullstring@?1??streamout@@9@9

; 454  : 				flags &= ~FLAG_WIDECHAR;

  00446	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  0044c	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
$LN41@streamout:

; 455  : 			}
; 456  : 
; 457  : // 			if (flags & FLAG_WIDECHAR)
; 458  : // 				len = wcsnlen((wchar_t*)string, (unsigned)precision);
; 459  : // 			else
; 460  : 				len = strlen((char*)string);

  0044f	8b f8		 mov	 edi, eax
  00451	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL206@streamout:
  00454	8a 07		 mov	 al, BYTE PTR [edi]
  00456	47		 inc	 edi
  00457	84 c0		 test	 al, al
  00459	75 f9		 jne	 SHORT $LL206@streamout
  0045b	2b f9		 sub	 edi, ecx

; 461  : 			precision = 0;

  0045d	33 c9		 xor	 ecx, ecx

; 462  : 			break;

  0045f	e9 8b fe ff ff	 jmp	 $LN125@streamout
$LN40@streamout:

; 463  : 
; 464  : 		case ('G'):
; 465  : 		case ('E'):
; 466  : 		case ('A'):
; 467  : 		case ('g'):
; 468  : 		case ('e'):
; 469  : 		case ('a'):
; 470  : 		case ('f'):
; 471  : #ifdef _UNICODE
; 472  : 			flags |= FLAG_WIDECHAR;
; 473  : #else
; 474  : 			flags &= ~FLAG_WIDECHAR;
; 475  : #endif
; 476  : 			/* Use external function, one for kernel one for user mode */
; 477  : 			format_float(chr, flags, precision, &string, &prefix, &argptr);

  00464	8d 45 c4	 lea	 eax, DWORD PTR _argptr$GSCopy$[ebp]
  00467	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH
  0046d	50		 push	 eax
  0046e	8d 45 9c	 lea	 eax, DWORD PTR _prefix$[ebp]
  00471	50		 push	 eax
  00472	8d 45 a8	 lea	 eax, DWORD PTR _string$[ebp]
  00475	50		 push	 eax
  00476	57		 push	 edi
  00477	53		 push	 ebx
  00478	ff 75 a0	 push	 DWORD PTR _chr$[ebp]
  0047b	e8 00 00 00 00	 call	 _format_float

; 478  : 			len = strlen(string);

  00480	8b 45 a8	 mov	 eax, DWORD PTR _string$[ebp]
  00483	83 c4 18	 add	 esp, 24			; 00000018H
  00486	8b f8		 mov	 edi, eax
  00488	89 45 b0	 mov	 DWORD PTR _string$1$[ebp], eax
  0048b	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0048e	8b ff		 npad	 2
$LL207@streamout:
  00490	8a 07		 mov	 al, BYTE PTR [edi]
  00492	47		 inc	 edi
  00493	84 c0		 test	 al, al
  00495	75 f9		 jne	 SHORT $LL207@streamout

; 479  : 			precision = 0;
; 480  : 			break;

  00497	8b 55 9c	 mov	 edx, DWORD PTR _prefix$[ebp]
  0049a	2b f9		 sub	 edi, ecx
  0049c	8b 45 c4	 mov	 eax, DWORD PTR _argptr$GSCopy$[ebp]
  0049f	33 c9		 xor	 ecx, ecx
  004a1	89 55 a4	 mov	 DWORD PTR _prefix$1$[ebp], edx
  004a4	89 45 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], eax
  004a7	e9 6b 01 00 00	 jmp	 $LN58@streamout
$LN39@streamout:

; 481  : 
; 482  : 		case ('d'):
; 483  : 		case ('i'):
; 484  : 			val64 = (__int64)va_arg_f(argptr, flags);

  004ac	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  004b2	74 10		 je	 SHORT $LN119@streamout
  004b4	8b 02		 mov	 eax, DWORD PTR [edx]
  004b6	83 c2 08	 add	 edx, 8
  004b9	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  004bc	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  004bf	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  004c2	eb 1b		 jmp	 SHORT $LN245@streamout
$LN119@streamout:
  004c4	83 c2 04	 add	 edx, 4
  004c7	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  004ca	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  004cd	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  004d3	74 06		 je	 SHORT $LN117@streamout
  004d5	0f bf 42 fc	 movsx	 eax, WORD PTR [edx-4]
  004d9	eb 03		 jmp	 SHORT $LN118@streamout
$LN117@streamout:
  004db	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
$LN118@streamout:
  004de	99		 cdq
$LN245@streamout:
  004df	89 55 94	 mov	 DWORD PTR _val64$2$[ebp], edx
  004e2	89 45 a8	 mov	 DWORD PTR _val64$1$[ebp], eax

; 485  : 
; 486  : 			if ((__int64)val64 < 0)

  004e5	85 d2		 test	 edx, edx
  004e7	7f 19		 jg	 SHORT $LN38@streamout
  004e9	7c 04		 jl	 SHORT $LN208@streamout
  004eb	85 c0		 test	 eax, eax
  004ed	73 13		 jae	 SHORT $LN38@streamout
$LN208@streamout:

; 487  : 			{
; 488  : 				val64 = -(__int64)val64;

  004ef	f7 d8		 neg	 eax

; 489  : 				prefix = ("-");

  004f1	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG2924
  004f8	83 d2 00	 adc	 edx, 0
  004fb	f7 da		 neg	 edx
  004fd	e9 98 00 00 00	 jmp	 $LN251@streamout
$LN38@streamout:

; 490  : 			}
; 491  : 			else if (flags & FLAG_FORCE_SIGN)

  00502	f6 c3 02	 test	 bl, 2
  00505	74 0c		 je	 SHORT $LN36@streamout

; 492  : 				prefix = ("+");

  00507	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG2927
  0050e	e9 8d 00 00 00	 jmp	 $case_number$256
$LN36@streamout:

; 493  : 			else if (flags & FLAG_FORCE_SIGNSP)

  00513	f6 c3 04	 test	 bl, 4
  00516	0f 84 84 00 00
	00		 je	 $case_number$256

; 494  : 				prefix = (" ");

  0051c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG2930

; 495  : 
; 496  : 			goto case_number;

  00523	eb 7b		 jmp	 SHORT $case_number$256
$LN33@streamout:

; 497  : 
; 498  : 		case ('o'):
; 499  : 			base = 8;

  00525	c7 45 8c 08 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 8

; 500  : 			if (flags & FLAG_SPECIAL)

  0052c	f6 c3 10	 test	 bl, 16			; 00000010H
  0052f	74 35		 je	 SHORT $case_unsigned$257

; 501  : 			{
; 502  : 				prefix = ("0");

  00531	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _prefix$1$[ebp], OFFSET $SG2934

; 503  : 				if (precision > 0) precision--;

  00538	85 ff		 test	 edi, edi
  0053a	7e 2a		 jle	 SHORT $case_unsigned$257
  0053c	4f		 dec	 edi

; 504  : 			}
; 505  : 			goto case_unsigned;

  0053d	eb 27		 jmp	 SHORT $case_unsigned$257
$LN30@streamout:

; 506  : 
; 507  : 		case ('p'):
; 508  : 			precision = 2 * sizeof(void*);

  0053f	bf 08 00 00 00	 mov	 edi, 8

; 509  : 			flags &= ~FLAG_PAD_ZERO;

  00544	83 e3 f7	 and	 ebx, -9			; fffffff7H
$LN29@streamout:

; 510  : 			flags |= FLAG_INTPTR;
; 511  : 			/* Fall through */
; 512  : 
; 513  : 		case ('X'):
; 514  : 			digits = digits_u;

  00547	b8 00 00 00 00	 mov	 eax, OFFSET ?digits_u@?1??streamout@@9@9
  0054c	89 45 84	 mov	 DWORD PTR _digits$1$[ebp], eax
  0054f	eb 03		 jmp	 SHORT $LN28@streamout
$LN234@streamout:
  00551	8b 45 84	 mov	 eax, DWORD PTR _digits$1$[ebp]
$LN28@streamout:

; 515  : 			/* Fall through */
; 516  : 
; 517  : 		case ('x'):
; 518  : 			base = 16;

  00554	c7 45 8c 10 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], 16 ; 00000010H

; 519  : 			if (flags & FLAG_SPECIAL)

  0055b	f6 c3 10	 test	 bl, 16			; 00000010H
  0055e	74 06		 je	 SHORT $case_unsigned$257

; 520  : 			{
; 521  : 				prefix = &digits[16];

  00560	83 c0 10	 add	 eax, 16			; 00000010H
  00563	89 45 a4	 mov	 DWORD PTR _prefix$1$[ebp], eax
$case_unsigned$257:

; 522  : 			}
; 523  : 
; 524  : 		case ('u'):
; 525  : case_unsigned:
; 526  : 			val64 = va_arg_fu(argptr, flags);

  00566	f7 c3 00 04 00
	00		 test	 ebx, 1024		; 00000400H
  0056c	74 10		 je	 SHORT $LN123@streamout
  0056e	8b 02		 mov	 eax, DWORD PTR [edx]
  00570	83 c2 08	 add	 edx, 8
  00573	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  00576	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  00579	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  0057c	eb 1c		 jmp	 SHORT $LN251@streamout
$LN123@streamout:
  0057e	83 c2 04	 add	 edx, 4
  00581	89 55 c0	 mov	 DWORD PTR _argptr$GSCopy$1$[ebp], edx
  00584	89 55 c4	 mov	 DWORD PTR _argptr$GSCopy$[ebp], edx
  00587	f7 c3 00 01 00
	00		 test	 ebx, 256		; 00000100H
  0058d	74 06		 je	 SHORT $LN121@streamout
  0058f	0f b7 42 fc	 movzx	 eax, WORD PTR [edx-4]
  00593	eb 03		 jmp	 SHORT $LN247@streamout
$LN121@streamout:
  00595	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
$LN247@streamout:
  00598	33 d2		 xor	 edx, edx
$LN251@streamout:
  0059a	89 45 a8	 mov	 DWORD PTR _val64$1$[ebp], eax
  0059d	89 55 94	 mov	 DWORD PTR _val64$2$[ebp], edx
$case_number$256:

; 527  : 
; 528  : case_number:
; 529  : 			flags &= ~FLAG_WIDECHAR;

  005a0	81 e3 ff fd ff
	ff		 and	 ebx, -513		; fffffdffH

; 530  : 			if (precision < 0) precision = 1;

  005a6	85 ff		 test	 edi, edi
  005a8	89 5d 88	 mov	 DWORD PTR _flags$1$[ebp], ebx
  005ab	0f 48 7d 80	 cmovs	 edi, DWORD PTR tv607[ebp]

; 531  : 
; 532  : 			/* Gather digits in reverse order */
; 533  : 			while (val64)

  005af	0b c2		 or	 eax, edx
  005b1	89 7d bc	 mov	 DWORD PTR _precision$2$[ebp], edi
  005b4	74 4d		 je	 SHORT $LN23@streamout
  005b6	8b 45 8c	 mov	 eax, DWORD PTR _base$1$[ebp]
  005b9	8b 75 b0	 mov	 esi, DWORD PTR _string$1$[ebp]
  005bc	8b 5d a8	 mov	 ebx, DWORD PTR _val64$1$[ebp]
  005bf	99		 cdq
  005c0	8b c8		 mov	 ecx, eax
  005c2	8b c2		 mov	 eax, edx
  005c4	8b 55 94	 mov	 edx, DWORD PTR _val64$2$[ebp]
  005c7	89 4d 8c	 mov	 DWORD PTR tv614[ebp], ecx
  005ca	89 45 9c	 mov	 DWORD PTR tv613[ebp], eax
  005cd	8d 49 00	 npad	 3
$LL24@streamout:

; 534  : 			{
; 535  : 				*--string = digits[val64 % base];

  005d0	50		 push	 eax
  005d1	51		 push	 ecx
  005d2	52		 push	 edx
  005d3	53		 push	 ebx
  005d4	4e		 dec	 esi
  005d5	e8 00 00 00 00	 call	 __aulldvrm
  005da	89 5d 94	 mov	 DWORD PTR tv528[ebp+4], ebx

; 536  : 				val64 /= base;
; 537  : 				precision--;

  005dd	4f		 dec	 edi
  005de	8b d8		 mov	 ebx, eax
  005e0	8b 45 84	 mov	 eax, DWORD PTR _digits$1$[ebp]
  005e3	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  005e6	8b 4d 8c	 mov	 ecx, DWORD PTR tv614[ebp]
  005e9	88 06		 mov	 BYTE PTR [esi], al
  005eb	8b c3		 mov	 eax, ebx
  005ed	0b c2		 or	 eax, edx
  005ef	8b 45 9c	 mov	 eax, DWORD PTR tv613[ebp]
  005f2	75 dc		 jne	 SHORT $LL24@streamout
  005f4	8b 5d 88	 mov	 ebx, DWORD PTR _flags$1$[ebp]
  005f7	89 75 b0	 mov	 DWORD PTR _string$1$[ebp], esi
  005fa	8b 75 10	 mov	 esi, DWORD PTR _format$[ebp]
  005fd	8b 4d b0	 mov	 ecx, DWORD PTR _string$1$[ebp]
  00600	89 7d bc	 mov	 DWORD PTR _precision$2$[ebp], edi
$LN23@streamout:

; 538  : 			}
; 539  : 
; 540  : 			len = strlen(string);

  00603	8b f9		 mov	 edi, ecx
  00605	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL209@streamout:
  00608	8a 07		 mov	 al, BYTE PTR [edi]
  0060a	47		 inc	 edi
  0060b	84 c0		 test	 al, al
  0060d	75 f9		 jne	 SHORT $LL209@streamout
  0060f	8b 55 a4	 mov	 edx, DWORD PTR _prefix$1$[ebp]
  00612	2b f9		 sub	 edi, ecx
  00614	8b 4d bc	 mov	 ecx, DWORD PTR _precision$2$[ebp]
$LN58@streamout:

; 547  : 		}
; 548  : 
; 549  : 		/* Calculate padding */
; 550  : 		prefixlen = prefix ? strlen(prefix) : 0;

  00617	85 d2		 test	 edx, edx
  00619	0f 84 d0 fc ff
	ff		 je	 $LN125@streamout
  0061f	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00622	89 45 88	 mov	 DWORD PTR tv669[ebp], eax
$LL210@streamout:
  00625	8a 02		 mov	 al, BYTE PTR [edx]
  00627	42		 inc	 edx
  00628	84 c0		 test	 al, al
  0062a	75 f9		 jne	 SHORT $LL210@streamout
  0062c	2b 55 88	 sub	 edx, DWORD PTR tv669[ebp]
  0062f	e9 bd fc ff ff	 jmp	 $LN248@streamout
$LN8@streamout:

; 585  : 			written = streamout_astring(out, &cnt, (char*)string, len);

  00634	e8 00 00 00 00	 call	 _streamout_astring
  00639	8b d0		 mov	 edx, eax
  0063b	89 45 94	 mov	 DWORD PTR _written$4$[ebp], eax
$LN249@streamout:
  0063e	83 c4 10	 add	 esp, 16			; 00000010H

; 586  : 		if (written == -1) return -1;

  00641	83 fa ff	 cmp	 edx, -1
  00644	74 73		 je	 SHORT $LN145@streamout

; 587  : 		written_all += written;

  00646	8b 7d b8	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  00649	03 fa		 add	 edi, edx

; 588  : 
; 589  : #if 0 && SUPPORT_FLOAT
; 590  : 		/* Optional right '0' padding */
; 591  : 		while (precision-- > 0)
; 592  : 		{
; 593  : 			if ((written = streamout_char(out, &cnt, ('0'))) == 0) return -1;
; 594  : 			written_all += written;
; 595  : 			len++;
; 596  : 		}
; 597  : #endif
; 598  : 
; 599  : 		/* Optional right padding */
; 600  : 		if (flags & FLAG_ALIGN_LEFT)

  0064b	83 7d 88 00	 cmp	 DWORD PTR tv671[ebp], 0
  0064f	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00652	74 5d		 je	 SHORT $LN232@streamout

; 601  : 		{
; 602  : 			while (padding-- > 0)

  00654	8b 5d ac	 mov	 ebx, DWORD PTR _padding$2$[ebp]
  00657	85 db		 test	 ebx, ebx
  00659	0f 8e 0e fc ff
	ff		 jle	 $LN233@streamout
  0065f	90		 npad	 1
$LL4@streamout:

; 603  : 			{
; 604  : 				if ((written = streamout_char(out, &cnt, (' '))) == 0) return -1;

  00660	6a 20		 push	 32			; 00000020H
  00662	8d 45 98	 lea	 eax, DWORD PTR _cnt$[ebp]
  00665	4b		 dec	 ebx
  00666	50		 push	 eax
  00667	ff 75 b4	 push	 DWORD PTR _out$GSCopy$1$[ebp]
  0066a	e8 00 00 00 00	 call	 _streamout_char
  0066f	8b d0		 mov	 edx, eax
  00671	83 c4 0c	 add	 esp, 12			; 0000000cH
  00674	89 55 94	 mov	 DWORD PTR _written$4$[ebp], edx
  00677	85 d2		 test	 edx, edx
  00679	74 3e		 je	 SHORT $LN145@streamout

; 605  : 				written_all += written;

  0067b	03 fa		 add	 edi, edx
  0067d	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
  00680	85 db		 test	 ebx, ebx
  00682	7f dc		 jg	 SHORT $LL4@streamout

; 606  : 			}
; 607  : 		}
; 608  : 
; 609  : 	}

  00684	e9 e4 fb ff ff	 jmp	 $LN233@streamout
$LN22@streamout:

; 541  : 			break;
; 542  : 
; 543  : 		default:
; 544  : 			/* Treat anything else as a new character */
; 545  : 			format--;
; 546  : 			continue;

  00689	8b 7d b8	 mov	 edi, DWORD PTR _written_all$1$[ebp]
  0068c	4e		 dec	 esi
  0068d	e9 de fb ff ff	 jmp	 $LN250@streamout
$LN108@streamout:

; 295  : 		{
; 296  : 			/* Write the character to the stream */
; 297  : 			if ((written = streamout_char(out, &cnt, chr)) == 0) return -1;

  00692	0f be c0	 movsx	 eax, al
  00695	50		 push	 eax
  00696	8d 45 98	 lea	 eax, DWORD PTR _cnt$[ebp]
  00699	50		 push	 eax
  0069a	53		 push	 ebx
  0069b	e8 00 00 00 00	 call	 _streamout_char
  006a0	8b d0		 mov	 edx, eax
  006a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a5	89 55 94	 mov	 DWORD PTR _written$4$[ebp], edx
  006a8	85 d2		 test	 edx, edx
  006aa	74 0d		 je	 SHORT $LN145@streamout

; 298  : 			written_all += written;

  006ac	03 fa		 add	 edi, edx
  006ae	89 7d b8	 mov	 DWORD PTR _written_all$1$[ebp], edi
$LN232@streamout:
  006b1	8b 55 c0	 mov	 edx, DWORD PTR _argptr$GSCopy$1$[ebp]
  006b4	e9 ba fb ff ff	 jmp	 $LN154@streamout
$LN145@streamout:

; 612  : 
; 613  : 	return written_all;
; 614  : }

  006b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006bc	83 c8 ff	 or	 eax, -1
  006bf	5f		 pop	 edi
  006c0	5e		 pop	 esi
  006c1	33 cd		 xor	 ecx, ebp
  006c3	5b		 pop	 ebx
  006c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006c9	8b e5		 mov	 esp, ebp
  006cb	5d		 pop	 ebp
  006cc	c3		 ret	 0
  006cd	8d 49 00	 npad	 3
$LN253@streamout:
  006d0	00 00 00 00	 DD	 $LN40@streamout
  006d4	00 00 00 00	 DD	 $LN52@streamout
  006d8	00 00 00 00	 DD	 $LN44@streamout
  006dc	00 00 00 00	 DD	 $LN29@streamout
  006e0	00 00 00 00	 DD	 $LN47@streamout
  006e4	00 00 00 00	 DD	 $case_char$254
  006e8	00 00 00 00	 DD	 $LN39@streamout
  006ec	00 00 00 00	 DD	 $LN57@streamout
  006f0	00 00 00 00	 DD	 $LN33@streamout
  006f4	00 00 00 00	 DD	 $LN30@streamout
  006f8	00 00 00 00	 DD	 $LN42@streamout
  006fc	00 00 00 00	 DD	 $case_unsigned$257
  00700	00 00 00 00	 DD	 $LN234@streamout
  00704	00 00 00 00	 DD	 $LN22@streamout
$LN205@streamout:
  00708	00		 DB	 0
  00709	0d		 DB	 13			; 0000000dH
  0070a	01		 DB	 1
  0070b	0d		 DB	 13			; 0000000dH
  0070c	00		 DB	 0
  0070d	0d		 DB	 13			; 0000000dH
  0070e	00		 DB	 0
  0070f	0d		 DB	 13			; 0000000dH
  00710	0d		 DB	 13			; 0000000dH
  00711	0d		 DB	 13			; 0000000dH
  00712	0d		 DB	 13			; 0000000dH
  00713	0d		 DB	 13			; 0000000dH
  00714	0d		 DB	 13			; 0000000dH
  00715	0d		 DB	 13			; 0000000dH
  00716	0d		 DB	 13			; 0000000dH
  00717	0d		 DB	 13			; 0000000dH
  00718	0d		 DB	 13			; 0000000dH
  00719	0d		 DB	 13			; 0000000dH
  0071a	02		 DB	 2
  0071b	0d		 DB	 13			; 0000000dH
  0071c	0d		 DB	 13			; 0000000dH
  0071d	0d		 DB	 13			; 0000000dH
  0071e	0d		 DB	 13			; 0000000dH
  0071f	03		 DB	 3
  00720	0d		 DB	 13			; 0000000dH
  00721	04		 DB	 4
  00722	0d		 DB	 13			; 0000000dH
  00723	0d		 DB	 13			; 0000000dH
  00724	0d		 DB	 13			; 0000000dH
  00725	0d		 DB	 13			; 0000000dH
  00726	0d		 DB	 13			; 0000000dH
  00727	0d		 DB	 13			; 0000000dH
  00728	00		 DB	 0
  00729	0d		 DB	 13			; 0000000dH
  0072a	05		 DB	 5
  0072b	06		 DB	 6
  0072c	00		 DB	 0
  0072d	00		 DB	 0
  0072e	00		 DB	 0
  0072f	0d		 DB	 13			; 0000000dH
  00730	06		 DB	 6
  00731	0d		 DB	 13			; 0000000dH
  00732	0d		 DB	 13			; 0000000dH
  00733	0d		 DB	 13			; 0000000dH
  00734	0d		 DB	 13			; 0000000dH
  00735	07		 DB	 7
  00736	08		 DB	 8
  00737	09		 DB	 9
  00738	0d		 DB	 13			; 0000000dH
  00739	0d		 DB	 13			; 0000000dH
  0073a	0a		 DB	 10			; 0000000aH
  0073b	0d		 DB	 13			; 0000000dH
  0073c	0b		 DB	 11			; 0000000bH
  0073d	0d		 DB	 13			; 0000000dH
  0073e	0d		 DB	 13			; 0000000dH
  0073f	0c		 DB	 12			; 0000000cH
_streamout ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _format_float
_TEXT	SEGMENT
tv570 = -44						; size = 8
tv516 = -44						; size = 8
tv490 = -44						; size = 8
tv366 = -44						; size = 8
tv578 = -36						; size = 8
_fpval$1$ = -28						; size = 8
_padding$1$ = -20					; size = 4
_fpval2$1$ = -16					; size = 8
tv535 = -16						; size = 8
tv85 = -16						; size = 8
_fpval2$ = -16						; size = 8
_sign$1$ = -12						; size = 4
_exponent$1$ = -8					; size = 4
_digits$1$ = -4						; size = 4
_num_digits$2$ = 8					; size = 4
_val32$1$ = 8						; size = 4
_chr$ = 8						; size = 1
_flags$ = 12						; size = 4
_precision$ = 16					; size = 4
_num_digits$1$ = 20					; size = 4
_string$ = 20						; size = 4
_prefix$ = 24						; size = 4
_argptr$ = 28						; size = 4
_format_float PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 128  : 	static const char digits_l[] = ("0123456789abcdef0x");
; 129  : 	static const char digits_u[] = ("0123456789ABCDEF0X");
; 130  : 	static const char _nan[] = ("#QNAN");
; 131  : 	static const char _infinity[] = ("#INF");
; 132  : 	const char *digits = digits_l;
; 133  : 	int exponent = 0, sign;
; 134  : 	long double fpval, fpval2;
; 135  : 	int padding = 0, num_digits, val32, base = 10;

  00007	33 f6		 xor	 esi, esi
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_l@?1??format_float@@9@9
  00010	89 75 ec	 mov	 DWORD PTR _padding$1$[ebp], esi

; 136  : 
; 137  : 	/* Normalize the precision */
; 138  : 	if (precision < 0) precision = 6;

  00013	8b 75 10	 mov	 esi, DWORD PTR _precision$[ebp]
  00016	57		 push	 edi
  00017	85 f6		 test	 esi, esi
  00019	79 07		 jns	 SHORT $LN37@format_flo
  0001b	be 06 00 00 00	 mov	 esi, 6
  00020	eb 10		 jmp	 SHORT $LN84@format_flo
$LN37@format_flo:

; 139  : 	else if (precision > 17)

  00022	83 fe 11	 cmp	 esi, 17			; 00000011H
  00025	7e 0e		 jle	 SHORT $LN35@format_flo

; 140  : 	{
; 141  : 		padding = precision - 17;

  00027	83 c6 ef	 add	 esi, -17		; ffffffefH
  0002a	89 75 ec	 mov	 DWORD PTR _padding$1$[ebp], esi

; 142  : 		precision = 17;

  0002d	be 11 00 00 00	 mov	 esi, 17			; 00000011H
$LN84@format_flo:
  00032	89 75 10	 mov	 DWORD PTR _precision$[ebp], esi
$LN35@format_flo:

; 143  : 	}
; 144  : 
; 145  : 	/* Get the float value and calculate the exponent */
; 146  : 	fpval = va_arg_ffp(*argptr, flags);

  00035	8b 45 1c	 mov	 eax, DWORD PTR _argptr$[ebp]
  00038	0f 57 c9	 xorps	 xmm1, xmm1
  0003b	83 00 08	 add	 DWORD PTR [eax], 8
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	f2 0f 10 40 f8	 movsd	 xmm0, QWORD PTR [eax-8]

; 147  : 	exponent = get_exp((double)fpval);

  00045	66 0f 2e c1	 ucomisd xmm0, xmm1
  00049	f2 0f 11 45 e4	 movsd	 QWORD PTR _fpval$1$[ebp], xmm0
  0004e	9f		 lahf
  0004f	f6 c4 44	 test	 ah, 68			; 00000044H
  00052	7a 07		 jp	 SHORT $LN44@format_flo
  00054	f2 0f 11 4d f0	 movsd	 QWORD PTR tv85[ebp], xmm1
  00059	eb 18		 jmp	 SHORT $LN43@format_flo
$LN44@format_flo:
  0005b	66 0f 2f c1	 comisd	 xmm0, xmm1
  0005f	73 08		 jae	 SHORT $LN85@format_flo
  00061	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
$LN85@format_flo:
  00069	e8 00 00 00 00	 call	 __libm_sse2_log10_precise
  0006e	f2 0f 11 45 f0	 movsd	 QWORD PTR tv85[ebp], xmm0
$LN43@format_flo:
  00073	dd 45 f0	 fld	 QWORD PTR tv85[ebp]
  00076	83 ec 08	 sub	 esp, 8
  00079	dd 1c 24	 fstp	 QWORD PTR [esp]
  0007c	e8 00 00 00 00	 call	 _floor

; 148  : 	sign = fpval < 0 ? -1 : 1;

  00081	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _fpval$1$[ebp]
  00086	33 d2		 xor	 edx, edx

; 149  : 
; 150  : 	switch (chr)

  00088	8b 45 08	 mov	 eax, DWORD PTR _chr$[ebp]
  0008b	83 c4 08	 add	 esp, 8
  0008e	8b 7d 14	 mov	 edi, DWORD PTR _string$[ebp]
  00091	0f 57 c9	 xorps	 xmm1, xmm1
  00094	66 0f 2f c8	 comisd	 xmm1, xmm0
  00098	0f be c0	 movsx	 eax, al
  0009b	dd 5d dc	 fstp	 QWORD PTR tv578[ebp]
  0009e	f2 0f 2c 4d dc	 cvttsd2si ecx, QWORD PTR tv578[ebp]
  000a3	0f 96 c2	 setbe	 dl
  000a6	83 c0 bf	 add	 eax, -65		; ffffffbfH
  000a9	8d 14 55 ff ff
	ff ff		 lea	 edx, DWORD PTR [edx*2-1]
  000b0	89 55 f4	 mov	 DWORD PTR _sign$1$[ebp], edx
  000b3	89 4d f8	 mov	 DWORD PTR _exponent$1$[ebp], ecx
  000b6	83 f8 26	 cmp	 eax, 38			; 00000026H
  000b9	0f 87 11 02 00
	00		 ja	 $LN19@format_flo
  000bf	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN82@format_flo[eax]
  000c6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN87@format_flo[eax*4]
$LN32@format_flo:

; 151  : 	{
; 152  : 	case ('G'):
; 153  : 		digits = digits_u;

  000cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN31@format_flo:

; 154  : 	case ('g'):
; 155  : 		if (precision > 0) precision--;

  000d4	85 f6		 test	 esi, esi
  000d6	7e 04		 jle	 SHORT $LN30@format_flo
  000d8	4e		 dec	 esi
  000d9	89 75 10	 mov	 DWORD PTR _precision$[ebp], esi
$LN30@format_flo:

; 156  : 		if (exponent < -4 || exponent >= precision) goto case_e;

  000dc	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  000df	0f 8c a2 00 00
	00		 jl	 $case_e$88
  000e5	3b ce		 cmp	 ecx, esi
  000e7	0f 8d 9a 00 00
	00		 jge	 $case_e$88

; 157  : 
; 158  : 		/* Shift the decimal point and round */
; 159  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  000ed	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  000f5	66 0f 6e ce	 movd	 xmm1, esi
  000f9	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000fd	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  00102	66 0f 6e 4d f4	 movd	 xmm1, DWORD PTR _sign$1$[ebp]
  00107	83 ec 08	 sub	 esp, 8
  0010a	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0010e	f2 0f 59 4d e4	 mulsd	 xmm1, QWORD PTR _fpval$1$[ebp]
  00113	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00117	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0011f	f2 0f 11 45 d4	 movsd	 QWORD PTR tv570[ebp], xmm0
  00124	dd 45 d4	 fld	 QWORD PTR tv570[ebp]
  00127	dd 1c 24	 fstp	 QWORD PTR [esp]
  0012a	e8 00 00 00 00	 call	 _floor
  0012f	83 c4 08	 add	 esp, 8
  00132	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]

; 160  : 
; 161  : 		/* Skip trailing zeroes */
; 162  : 		while (precision && (unsigned __int64)fpval2 % 10 == 0)

  00135	85 f6		 test	 esi, esi
  00137	0f 84 db 01 00
	00		 je	 $LN83@format_flo
  0013d	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR _fpval2$[ebp]
  00142	f2 0f 11 4d f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm1
$LL27@format_flo:
  00147	66 0f 28 c1	 movapd	 xmm0, xmm1
  0014b	e8 00 00 00 00	 call	 __dtoul3
  00150	6a 00		 push	 0
  00152	6a 0a		 push	 10			; 0000000aH
  00154	52		 push	 edx
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 __aullrem
  0015b	0b c2		 or	 eax, edx
  0015d	0f 85 bf 01 00
	00		 jne	 $LN33@format_flo

; 163  : 		{
; 164  : 			precision--;
; 165  : 			fpval2 /= 10;

  00163	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR _fpval2$1$[ebp]
  00168	4e		 dec	 esi
  00169	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@4024000000000000
  00171	89 75 10	 mov	 DWORD PTR _precision$[ebp], esi
  00174	f2 0f 11 4d f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm1
  00179	75 cc		 jne	 SHORT $LL27@format_flo

; 166  : 		}
; 167  : 		break;

  0017b	e9 a2 01 00 00	 jmp	 $LN33@format_flo
$LN25@format_flo:

; 168  : 
; 169  : 	case ('E'):
; 170  : 		digits = digits_u;

  00180	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$case_e$88:
  00187	66 0f 6e ca	 movd	 xmm1, edx

; 171  : 	case ('e'):
; 172  : case_e:
; 173  : 		/* Shift the decimal point and round */
; 174  : 		fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  0018b	8b c6		 mov	 eax, esi
  0018d	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00191	2b c1		 sub	 eax, ecx
  00193	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00197	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  0019f	f2 0f 11 4d d4	 movsd	 QWORD PTR tv366[ebp], xmm1
  001a4	66 0f 6e c8	 movd	 xmm1, eax
  001a8	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001ac	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  001b1	f2 0f 59 45 d4	 mulsd	 xmm0, QWORD PTR tv366[ebp]
  001b6	83 ec 08	 sub	 esp, 8
  001b9	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001c1	f2 0f 11 45 f0	 movsd	 QWORD PTR tv535[ebp], xmm0
  001c6	dd 45 f0	 fld	 QWORD PTR tv535[ebp]
  001c9	dd 1c 24	 fstp	 QWORD PTR [esp]
  001cc	e8 00 00 00 00	 call	 _floor

; 175  : 
; 176  : 		/* Compensate for changed exponent through rounding */
; 177  : 		if (fpval2 >= (unsigned __int64)pow(10., precision + 1))

  001d1	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  001d9	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001dc	66 0f 6e c8	 movd	 xmm1, eax
  001e0	83 c4 08	 add	 esp, 8
  001e3	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001e7	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]
  001ea	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  001ef	e8 00 00 00 00	 call	 __dtoul3
  001f4	8b c8		 mov	 ecx, eax
  001f6	e8 00 00 00 00	 call	 __ultod3
  001fb	f2 0f 10 4d f0	 movsd	 xmm1, QWORD PTR _fpval2$[ebp]
  00200	66 0f 2f c8	 comisd	 xmm1, xmm0
  00204	f2 0f 11 4d f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm1
  00209	72 52		 jb	 SHORT $LN23@format_flo

; 178  : 		{
; 179  : 			exponent++;

  0020b	f2 0f 2c 4d dc	 cvttsd2si ecx, QWORD PTR tv578[ebp]

; 180  : 			fpval2 = round(sign * (double)fpval * pow(10., precision - exponent));

  00210	8b c6		 mov	 eax, esi
  00212	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  0021a	41		 inc	 ecx
  0021b	2b c1		 sub	 eax, ecx
  0021d	89 4d f8	 mov	 DWORD PTR _exponent$1$[ebp], ecx
  00220	66 0f 6e c8	 movd	 xmm1, eax
  00224	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00228	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  0022d	f2 0f 59 45 d4	 mulsd	 xmm0, QWORD PTR tv366[ebp]
  00232	83 ec 08	 sub	 esp, 8
  00235	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0023d	f2 0f 11 45 d4	 movsd	 QWORD PTR tv516[ebp], xmm0
  00242	dd 45 d4	 fld	 QWORD PTR tv516[ebp]
  00245	dd 1c 24	 fstp	 QWORD PTR [esp]
  00248	e8 00 00 00 00	 call	 _floor
  0024d	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]
  00250	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$[ebp]
  00255	83 c4 08	 add	 esp, 8
  00258	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
$LN23@format_flo:

; 181  : 		}
; 182  : 
; 183  : 		val32 = exponent >= 0 ? exponent : -exponent;

  0025d	8b 45 f8	 mov	 eax, DWORD PTR _exponent$1$[ebp]
  00260	99		 cdq
  00261	8b c8		 mov	 ecx, eax

; 184  : 
; 185  : 		// FIXME: handle length of exponent field:
; 186  : 		// http://msdn.microsoft.com/de-de/library/0fatw238%28VS.80%29.aspx
; 187  : 		num_digits = 3;
; 188  : 		while (num_digits--)

  00263	b8 03 00 00 00	 mov	 eax, 3
  00268	33 ca		 xor	 ecx, edx
  0026a	2b ca		 sub	 ecx, edx
  0026c	89 4d 08	 mov	 DWORD PTR _val32$1$[ebp], ecx
  0026f	90		 npad	 1
$LL22@format_flo:
  00270	48		 dec	 eax

; 189  : 		{
; 190  : 			*--(*string) = digits[val32 % 10];

  00271	ff 0f		 dec	 DWORD PTR [edi]
  00273	89 45 14	 mov	 DWORD PTR _num_digits$1$[ebp], eax
  00276	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0027b	f7 e9		 imul	 ecx
  0027d	8b 37		 mov	 esi, DWORD PTR [edi]
  0027f	c1 fa 02	 sar	 edx, 2
  00282	8b ca		 mov	 ecx, edx
  00284	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00287	03 ca		 add	 ecx, edx
  00289	8b 55 08	 mov	 edx, DWORD PTR _val32$1$[ebp]

; 191  : 			val32 /= 10;

  0028c	89 4d 08	 mov	 DWORD PTR _val32$1$[ebp], ecx
  0028f	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00292	03 c0		 add	 eax, eax
  00294	2b d0		 sub	 edx, eax
  00296	8b 45 fc	 mov	 eax, DWORD PTR _digits$1$[ebp]
  00299	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0029c	88 06		 mov	 BYTE PTR [esi], al
  0029e	8b 45 14	 mov	 eax, DWORD PTR _num_digits$1$[ebp]
  002a1	85 c0		 test	 eax, eax
  002a3	75 cb		 jne	 SHORT $LL22@format_flo

; 192  : 		}
; 193  : 
; 194  : 		/* Sign for the exponent */
; 195  : 		*--(*string) = (exponent >= 0 ? ('+') : ('-'));

  002a5	ff 0f		 dec	 DWORD PTR [edi]
  002a7	39 45 f8	 cmp	 DWORD PTR _exponent$1$[ebp], eax
  002aa	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 196  : 
; 197  : 		/* Add 'e' or 'E' separator */
; 198  : 		*--(*string) = digits[0xe];
; 199  : 		break;

  002ac	8b 75 10	 mov	 esi, DWORD PTR _precision$[ebp]
  002af	0f 9c c0	 setl	 al
  002b2	8d 04 45 2b 00
	00 00		 lea	 eax, DWORD PTR [eax*2+43]
  002b9	88 01		 mov	 BYTE PTR [ecx], al
  002bb	ff 0f		 dec	 DWORD PTR [edi]
  002bd	8b 45 fc	 mov	 eax, DWORD PTR _digits$1$[ebp]
  002c0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002c2	8a 40 0e	 mov	 al, BYTE PTR [eax+14]
  002c5	88 01		 mov	 BYTE PTR [ecx], al
  002c7	eb 59		 jmp	 SHORT $LN33@format_flo
$LN20@format_flo:

; 200  : 
; 201  : 	case ('A'):
; 202  : 		digits = digits_u;

  002c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _digits$1$[ebp], OFFSET ?digits_u@?1??format_float@@9@9
$LN19@format_flo:

; 203  : 	case ('a'):
; 204  : 		//            base = 16;
; 205  : 		// FIXME: TODO
; 206  : 
; 207  : 	case ('f'):
; 208  : 	default:
; 209  : 		/* Shift the decimal point and round */
; 210  : 		fpval2 = round(sign * (double)fpval * pow(10., precision));

  002d0	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  002d8	66 0f 6e ce	 movd	 xmm1, esi
  002dc	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002e0	e8 00 00 00 00	 call	 __libm_sse2_pow_precise
  002e5	66 0f 6e 4d f4	 movd	 xmm1, DWORD PTR _sign$1$[ebp]
  002ea	83 ec 08	 sub	 esp, 8
  002ed	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002f1	f2 0f 59 4d e4	 mulsd	 xmm1, QWORD PTR _fpval$1$[ebp]
  002f6	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  002fa	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00302	f2 0f 11 45 d4	 movsd	 QWORD PTR tv490[ebp], xmm0
  00307	dd 45 d4	 fld	 QWORD PTR tv490[ebp]
  0030a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0030d	e8 00 00 00 00	 call	 _floor
  00312	dd 5d f0	 fstp	 QWORD PTR _fpval2$[ebp]
  00315	83 c4 08	 add	 esp, 8
$LN83@format_flo:
  00318	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$[ebp]
  0031d	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
$LN33@format_flo:

; 211  : 		break;
; 212  : 	}
; 213  : 
; 214  : 	/* Handle sign */
; 215  : 	if (fpval < 0)

  00322	f2 0f 10 45 e4	 movsd	 xmm0, QWORD PTR _fpval$1$[ebp]
  00327	0f 57 c9	 xorps	 xmm1, xmm1
  0032a	66 0f 2f c8	 comisd	 xmm1, xmm0
  0032e	76 0b		 jbe	 SHORT $LN18@format_flo

; 216  : 	{
; 217  : 		*prefix = ("-");

  00330	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00333	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2670
  00339	eb 1f		 jmp	 SHORT $LN14@format_flo
$LN18@format_flo:

; 218  : 	}
; 219  : 	else if (flags & FLAG_FORCE_SIGN)

  0033b	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0033e	a8 02		 test	 al, 2
  00340	74 0b		 je	 SHORT $LN16@format_flo

; 220  : 		*prefix = ("+");

  00342	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00345	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2673
  0034b	eb 0d		 jmp	 SHORT $LN14@format_flo
$LN16@format_flo:

; 221  : 	else if (flags & FLAG_FORCE_SIGNSP)

  0034d	a8 04		 test	 al, 4
  0034f	74 09		 je	 SHORT $LN14@format_flo

; 222  : 		*prefix = (" ");

  00351	8b 45 18	 mov	 eax, DWORD PTR _prefix$[ebp]
  00354	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET $SG2676
$LN14@format_flo:

; 223  : 
; 224  : 	/* Handle special cases first */
; 225  : 	if (_isnan((double)fpval))

  0035a	83 ec 08	 sub	 esp, 8
  0035d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00362	e8 00 00 00 00	 call	 __isnan
  00367	83 c4 08	 add	 esp, 8
  0036a	85 c0		 test	 eax, eax
  0036c	74 2a		 je	 SHORT $LN13@format_flo

; 226  : 	{
; 227  : 		(*string) -= sizeof(_nan) / sizeof(char) - 1;

  0036e	83 07 fb	 add	 DWORD PTR [edi], -5	; fffffffbH

; 228  : 		strcpy((*string), _nan);

  00371	b9 00 00 00 00	 mov	 ecx, OFFSET ?_nan@?1??format_float@@9@9
  00376	8b 17		 mov	 edx, DWORD PTR [edi]
$LL46@format_flo:
  00378	8a 01		 mov	 al, BYTE PTR [ecx]
  0037a	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  0037d	88 02		 mov	 BYTE PTR [edx], al
  0037f	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00382	84 c0		 test	 al, al
  00384	75 f2		 jne	 SHORT $LL46@format_flo

; 229  : 		fpval2 = 1;

  00386	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0038e	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
  00393	e9 a1 00 00 00	 jmp	 $LN60@format_flo
$LN13@format_flo:

; 230  : 	}
; 231  : 	else if (!_finite((double)fpval))

  00398	f2 0f 10 55 e4	 movsd	 xmm2, QWORD PTR _fpval$1$[ebp]
  0039d	83 ec 08	 sub	 esp, 8
  003a0	f2 0f 11 14 24	 movsd	 QWORD PTR [esp], xmm2
  003a5	e8 00 00 00 00	 call	 __finite
  003aa	83 c4 08	 add	 esp, 8
  003ad	85 c0		 test	 eax, eax
  003af	75 2c		 jne	 SHORT $LN52@format_flo

; 232  : 	{
; 233  : 		(*string) -= sizeof(_infinity) / sizeof(char) - 1;

  003b1	83 07 fc	 add	 DWORD PTR [edi], -4	; fffffffcH

; 234  : 		strcpy((*string), _infinity);

  003b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?_infinity@?1??format_float@@9@9
  003b9	8b 17		 mov	 edx, DWORD PTR [edi]
  003bb	eb 03 8d 49 00	 npad	 5
$LL47@format_flo:
  003c0	8a 01		 mov	 al, BYTE PTR [ecx]
  003c2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  003c5	88 02		 mov	 BYTE PTR [edx], al
  003c7	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  003ca	84 c0		 test	 al, al
  003cc	75 f2		 jne	 SHORT $LL47@format_flo

; 235  : 		fpval2 = 1;

  003ce	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  003d6	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0

; 236  : 	}
; 237  : 	else

  003db	eb 5c		 jmp	 SHORT $LN60@format_flo
$LN52@format_flo:

; 238  : 	{
; 239  : 		/* Zero padding */
; 240  : 		while (padding-- > 0) *--(*string) = ('0');

  003dd	8b 4d ec	 mov	 ecx, DWORD PTR _padding$1$[ebp]
  003e0	85 c9		 test	 ecx, ecx
  003e2	7e 0c		 jle	 SHORT $LN58@format_flo
$LL9@format_flo:
  003e4	ff 0f		 dec	 DWORD PTR [edi]
  003e6	49		 dec	 ecx
  003e7	8b 07		 mov	 eax, DWORD PTR [edi]
  003e9	c6 00 30	 mov	 BYTE PTR [eax], 48	; 00000030H
  003ec	85 c9		 test	 ecx, ecx
  003ee	7f f4		 jg	 SHORT $LL9@format_flo
$LN58@format_flo:

; 241  : 
; 242  : 		/* Digits after the decimal point */
; 243  : 		num_digits = precision;

  003f0	8b c6		 mov	 eax, esi

; 244  : 		while (num_digits-- > 0)

  003f2	85 f6		 test	 esi, esi
  003f4	7e 49		 jle	 SHORT $LN80@format_flo
  003f6	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  003fb	eb 03 8d 49 00	 npad	 5
$LL7@format_flo:

; 245  : 		{
; 246  : 			*--(*string) = digits[(unsigned __int64)fpval2 % 10];

  00400	ff 0f		 dec	 DWORD PTR [edi]
  00402	48		 dec	 eax
  00403	8b 37		 mov	 esi, DWORD PTR [edi]
  00405	89 45 08	 mov	 DWORD PTR _num_digits$2$[ebp], eax
  00408	e8 00 00 00 00	 call	 __dtoul3
  0040d	6a 00		 push	 0
  0040f	6a 0a		 push	 10			; 0000000aH
  00411	52		 push	 edx
  00412	50		 push	 eax
  00413	e8 00 00 00 00	 call	 __aullrem

; 247  : 			fpval2 /= base;

  00418	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  0041d	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00425	8b 4d fc	 mov	 ecx, DWORD PTR _digits$1$[ebp]
  00428	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0042b	88 06		 mov	 BYTE PTR [esi], al
  0042d	8b 45 08	 mov	 eax, DWORD PTR _num_digits$2$[ebp]
  00430	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0
  00435	85 c0		 test	 eax, eax
  00437	7f c7		 jg	 SHORT $LL7@format_flo
$LN60@format_flo:

; 248  : 		}
; 249  : 	}
; 250  : 
; 251  : 	if (precision > 0 || flags & FLAG_SPECIAL)

  00439	83 7d 10 00	 cmp	 DWORD PTR _precision$[ebp], 0
  0043d	7f 06		 jg	 SHORT $LN4@format_flo
$LN80@format_flo:
  0043f	f6 45 0c 10	 test	 BYTE PTR _flags$[ebp], 16 ; 00000010H
  00443	74 07		 je	 SHORT $LN81@format_flo
$LN4@format_flo:

; 252  : 		*--(*string) = ('.');

  00445	ff 0f		 dec	 DWORD PTR [edi]
  00447	8b 07		 mov	 eax, DWORD PTR [edi]
  00449	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
$LN81@format_flo:
  0044c	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  00451	e8 00 00 00 00	 call	 __dtoul3
  00456	8b c8		 mov	 ecx, eax
$LL3@format_flo:

; 253  : 
; 254  : 	/* Digits before the decimal point */
; 255  : 	do
; 256  : 	{
; 257  : 		*--(*string) = digits[(unsigned __int64)fpval2 % base];

  00458	ff 0f		 dec	 DWORD PTR [edi]
  0045a	8b 37		 mov	 esi, DWORD PTR [edi]
  0045c	6a 00		 push	 0
  0045e	6a 0a		 push	 10			; 0000000aH
  00460	52		 push	 edx
  00461	51		 push	 ecx
  00462	e8 00 00 00 00	 call	 __aullrem

; 258  : 		fpval2 /= base;

  00467	f2 0f 10 45 f0	 movsd	 xmm0, QWORD PTR _fpval2$1$[ebp]
  0046c	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00474	8b 4d fc	 mov	 ecx, DWORD PTR _digits$1$[ebp]
  00477	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  0047a	88 06		 mov	 BYTE PTR [esi], al
  0047c	f2 0f 11 45 f0	 movsd	 QWORD PTR _fpval2$1$[ebp], xmm0

; 259  : 	}
; 260  : 	while ((unsigned __int64)fpval2);

  00481	e8 00 00 00 00	 call	 __dtoul3
  00486	8b c8		 mov	 ecx, eax
  00488	0b c2		 or	 eax, edx
  0048a	75 cc		 jne	 SHORT $LL3@format_flo
  0048c	5f		 pop	 edi
  0048d	5e		 pop	 esi

; 261  : 
; 262  : }

  0048e	8b e5		 mov	 esp, ebp
  00490	5d		 pop	 ebp
  00491	c3		 ret	 0
  00492	8b ff		 npad	 2
$LN87@format_flo:
  00494	00 00 00 00	 DD	 $LN20@format_flo
  00498	00 00 00 00	 DD	 $LN25@format_flo
  0049c	00 00 00 00	 DD	 $LN32@format_flo
  004a0	00 00 00 00	 DD	 $case_e$88
  004a4	00 00 00 00	 DD	 $LN31@format_flo
  004a8	00 00 00 00	 DD	 $LN19@format_flo
$LN82@format_flo:
  004ac	00		 DB	 0
  004ad	05		 DB	 5
  004ae	05		 DB	 5
  004af	05		 DB	 5
  004b0	01		 DB	 1
  004b1	05		 DB	 5
  004b2	02		 DB	 2
  004b3	05		 DB	 5
  004b4	05		 DB	 5
  004b5	05		 DB	 5
  004b6	05		 DB	 5
  004b7	05		 DB	 5
  004b8	05		 DB	 5
  004b9	05		 DB	 5
  004ba	05		 DB	 5
  004bb	05		 DB	 5
  004bc	05		 DB	 5
  004bd	05		 DB	 5
  004be	05		 DB	 5
  004bf	05		 DB	 5
  004c0	05		 DB	 5
  004c1	05		 DB	 5
  004c2	05		 DB	 5
  004c3	05		 DB	 5
  004c4	05		 DB	 5
  004c5	05		 DB	 5
  004c6	05		 DB	 5
  004c7	05		 DB	 5
  004c8	05		 DB	 5
  004c9	05		 DB	 5
  004ca	05		 DB	 5
  004cb	05		 DB	 5
  004cc	05		 DB	 5
  004cd	05		 DB	 5
  004ce	05		 DB	 5
  004cf	05		 DB	 5
  004d0	03		 DB	 3
  004d1	05		 DB	 5
  004d2	04		 DB	 4
_format_float ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_wstring
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_string$ = 16						; size = 4
_count$ = 20						; size = 4
_streamout_wstring PROC					; COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 110  : 	wchar_t chr;
; 111  : 	int written = 0;
; 112  : 
; 113  : 	while (count--)

  00005	8b 75 14	 mov	 esi, DWORD PTR _count$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	85 f6		 test	 esi, esi
  0000d	74 22		 je	 SHORT $LN8@streamout_
  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _string$[ebp]
$LL3@streamout_:

; 114  : 	{
; 115  : 		chr = *string++;

  00012	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00015	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]

; 116  : 		{
; 117  : 			if (streamout_char(out, cnt, chr) == 0) return -1;

  00018	50		 push	 eax
  00019	ff 75 0c	 push	 DWORD PTR _cnt$[ebp]
  0001c	4e		 dec	 esi
  0001d	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00020	e8 00 00 00 00	 call	 _streamout_char
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	85 c0		 test	 eax, eax
  0002a	74 0c		 je	 SHORT $LN7@streamout_

; 118  : 			written++;

  0002c	47		 inc	 edi
  0002d	85 f6		 test	 esi, esi
  0002f	75 e1		 jne	 SHORT $LL3@streamout_
$LN8@streamout_:

; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	return written;

  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 123  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN7@streamout_:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 116  : 		{
; 117  : 			if (streamout_char(out, cnt, chr) == 0) return -1;

  0003a	83 c8 ff	 or	 eax, -1
  0003d	5b		 pop	 ebx

; 123  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_streamout_wstring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_astring
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_string$ = 16						; size = 4
_count$ = 20						; size = 4
_streamout_astring PROC					; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 95   : 	char chr;
; 96   : 	int written = 0;
; 97   : 
; 98   : 	while (count--)

  00005	8b 75 14	 mov	 esi, DWORD PTR _count$[ebp]
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	85 f6		 test	 esi, esi
  0000d	74 24		 je	 SHORT $LN8@streamout_
  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _string$[ebp]
$LL3@streamout_:

; 99   : 	{
; 100  : 		chr = *string++;

  00012	8a 03		 mov	 al, BYTE PTR [ebx]
  00014	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]

; 101  : 		if (streamout_char(out, cnt, chr) == 0) return -1;

  00017	0f be c0	 movsx	 eax, al
  0001a	4e		 dec	 esi
  0001b	50		 push	 eax
  0001c	ff 75 0c	 push	 DWORD PTR _cnt$[ebp]
  0001f	ff 75 08	 push	 DWORD PTR _out$[ebp]
  00022	e8 00 00 00 00	 call	 _streamout_char
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	85 c0		 test	 eax, eax
  0002c	74 0c		 je	 SHORT $LN7@streamout_

; 102  : 		written++;

  0002e	47		 inc	 edi
  0002f	85 f6		 test	 esi, esi
  00031	75 df		 jne	 SHORT $LL3@streamout_
$LN8@streamout_:

; 103  : 	}
; 104  : 
; 105  : 	return written;

  00033	8b c7		 mov	 eax, edi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 106  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN7@streamout_:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 101  : 		if (streamout_char(out, cnt, chr) == 0) return -1;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5b		 pop	 ebx

; 106  : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_streamout_astring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\stdio\stream.c
;	COMDAT _streamout_char
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cnt$ = 12						; size = 4
_c$ = 16						; size = 4
_streamout_char PROC					; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 73   : 	/* Sanity */
; 74   : 	if(*cnt == 0 && out != NULL)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _cnt$[ebp]
  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 0b		 jne	 SHORT $LN3@streamout_
  0000c	83 7d 08 00	 cmp	 DWORD PTR _out$[ebp], 0
  00010	74 1a		 je	 SHORT $LN2@streamout_

; 75   : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 89   : #endif
; 90   : 	}
; 91   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN3@streamout_:

; 76   : 
; 77   : 	if (out) {

  00017	8b 55 08	 mov	 edx, DWORD PTR _out$[ebp]
  0001a	85 d2		 test	 edx, edx
  0001c	74 0e		 je	 SHORT $LN2@streamout_

; 78   : 		**out = (char)c;

  0001e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00020	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00023	88 01		 mov	 BYTE PTR [ecx], al

; 79   : 		++(*out);

  00025	ff 02		 inc	 DWORD PTR [edx]

; 80   : 		*cnt -= 1;

  00027	ff 0e		 dec	 DWORD PTR [esi]
  00029	5e		 pop	 esi

; 89   : #endif
; 90   : 	}
; 91   : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@streamout_:

; 81   : 		return c;
; 82   : 	}
; 83   : 	else 
; 84   : 	{
; 85   : #ifndef LIBC_KERNEL
; 86   : 		return putchar(c);
; 87   : #else
; 88   : 		return PutChar(c);

  0002c	ff 75 10	 push	 DWORD PTR _c$[ebp]
  0002f	e8 00 00 00 00	 call	 _PutChar
  00034	83 c4 04	 add	 esp, 4
  00037	5e		 pop	 esi

; 89   : #endif
; 90   : 	}
; 91   : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_streamout_char ENDP
_TEXT	ENDS
END
