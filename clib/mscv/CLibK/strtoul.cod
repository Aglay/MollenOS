; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdlib\strtoul.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoul
EXTRN	___locale_ctype_ptr:PROC
EXTRN	___errno:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtoul.c
;	COMDAT _strtoul
_TEXT	SEGMENT
_cutlim$1$ = -12					; size = 4
_cutoff$1$ = -8						; size = 4
_neg$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_any$1$ = 16						; size = 4
_base$ = 16						; size = 4
_strtoul PROC						; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 49   : 	register const unsigned char *s = (const unsigned char *)nptr;

  00009	8b 7d 08	 mov	 edi, DWORD PTR _nptr$[ebp]

; 50   : 	register unsigned long acc;
; 51   : 	register int c;
; 52   : 	register unsigned long cutoff;
; 53   : 	register int neg = 0, any, cutlim;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 0
$LL27@strtoul:

; 54   : 
; 55   : 	/*
; 56   : 	* See strtol for comments as to the logic used.
; 57   : 	*/
; 58   : 	do {
; 59   : 		c = *s++;

  00013	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00016	47		 inc	 edi

; 60   : 	} while (isspace(c));

  00017	e8 00 00 00 00	 call	 ___locale_ctype_ptr
  0001c	f6 44 30 01 08	 test	 BYTE PTR [eax+esi+1], 8
  00021	75 f0		 jne	 SHORT $LL27@strtoul

; 61   : 	if (c == '-') {

  00023	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  00026	75 09		 jne	 SHORT $LN24@strtoul

; 62   : 		neg = 1;

  00028	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 1

; 63   : 		c = *s++;

  0002f	eb 05		 jmp	 SHORT $LN40@strtoul
$LN24@strtoul:

; 64   : 	}
; 65   : 	else if (c == '+')

  00031	83 fe 2b	 cmp	 esi, 43			; 0000002bH
  00034	75 04		 jne	 SHORT $LN22@strtoul
$LN40@strtoul:

; 66   : 		c = *s++;

  00036	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00039	47		 inc	 edi
$LN22@strtoul:

; 67   : 	if ((base == 0 || base == 16) &&
; 68   : 		c == '0' && (*s == 'x' || *s == 'X')) {

  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _base$[ebp]
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 05		 je	 SHORT $LN20@strtoul
  00041	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00044	75 1d		 jne	 SHORT $LN21@strtoul
$LN20@strtoul:
  00046	83 fe 30	 cmp	 esi, 48			; 00000030H
  00049	75 18		 jne	 SHORT $LN21@strtoul
  0004b	8a 07		 mov	 al, BYTE PTR [edi]
  0004d	3c 78		 cmp	 al, 120			; 00000078H
  0004f	74 04		 je	 SHORT $LN19@strtoul
  00051	3c 58		 cmp	 al, 88			; 00000058H
  00053	75 0e		 jne	 SHORT $LN21@strtoul
$LN19@strtoul:

; 69   : 		c = s[1];

  00055	0f b6 77 01	 movzx	 esi, BYTE PTR [edi+1]

; 70   : 		s += 2;
; 71   : 		base = 16;

  00059	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0005e	83 c7 02	 add	 edi, 2

; 72   : 	}
; 73   : 	if (base == 0)

  00061	eb 11		 jmp	 SHORT $LN18@strtoul
$LN21@strtoul:
  00063	85 c9		 test	 ecx, ecx
  00065	75 0d		 jne	 SHORT $LN18@strtoul

; 74   : 		base = c == '0' ? 8 : 10;

  00067	83 fe 30	 cmp	 esi, 48			; 00000030H
  0006a	0f 95 c1	 setne	 cl
  0006d	8d 0c 4d 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+8]
$LN18@strtoul:

; 75   : 	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;

  00074	83 c8 ff	 or	 eax, -1
  00077	33 d2		 xor	 edx, edx
  00079	f7 f1		 div	 ecx

; 76   : 	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
; 77   : 	for (acc = 0, any = 0;; c = *s++) {

  0007b	33 db		 xor	 ebx, ebx
  0007d	89 55 f4	 mov	 DWORD PTR _cutlim$1$[ebp], edx
  00080	33 d2		 xor	 edx, edx
  00082	89 45 f8	 mov	 DWORD PTR _cutoff$1$[ebp], eax
$LL17@strtoul:

; 78   : 		if (c >= '0' && c <= '9')

  00085	8d 46 d0	 lea	 eax, DWORD PTR [esi-48]
  00088	83 f8 09	 cmp	 eax, 9
  0008b	77 04		 ja	 SHORT $LN14@strtoul

; 79   : 			c -= '0';

  0008d	8b f0		 mov	 esi, eax
  0008f	eb 18		 jmp	 SHORT $LN9@strtoul
$LN14@strtoul:

; 80   : 		else if (c >= 'A' && c <= 'Z')

  00091	8d 46 bf	 lea	 eax, DWORD PTR [esi-65]
  00094	83 f8 19	 cmp	 eax, 25			; 00000019H
  00097	77 05		 ja	 SHORT $LN12@strtoul

; 81   : 			c -= 'A' - 10;

  00099	83 ee 37	 sub	 esi, 55			; 00000037H
  0009c	eb 0b		 jmp	 SHORT $LN9@strtoul
$LN12@strtoul:

; 82   : 		else if (c >= 'a' && c <= 'z')

  0009e	8d 46 9f	 lea	 eax, DWORD PTR [esi-97]
  000a1	83 f8 19	 cmp	 eax, 25			; 00000019H
  000a4	77 32		 ja	 SHORT $LN34@strtoul

; 83   : 			c -= 'a' - 10;

  000a6	83 ee 57	 sub	 esi, 87			; 00000057H
$LN9@strtoul:

; 84   : 		else
; 85   : 			break;
; 86   : 		if (c >= base)

  000a9	3b f1		 cmp	 esi, ecx
  000ab	7d 2b		 jge	 SHORT $LN34@strtoul

; 87   : 			break;
; 88   : 		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000ad	85 d2		 test	 edx, edx
  000af	78 1e		 js	 SHORT $LN6@strtoul
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _cutoff$1$[ebp]
  000b4	3b d8		 cmp	 ebx, eax
  000b6	77 17		 ja	 SHORT $LN6@strtoul
  000b8	75 05		 jne	 SHORT $LN7@strtoul
  000ba	3b 75 f4	 cmp	 esi, DWORD PTR _cutlim$1$[ebp]
  000bd	7f 10		 jg	 SHORT $LN6@strtoul
$LN7@strtoul:

; 90   : 		else {
; 91   : 			any = 1;
; 92   : 			acc *= base;

  000bf	0f af d9	 imul	 ebx, ecx
  000c2	ba 01 00 00 00	 mov	 edx, 1

; 93   : 			acc += c;

  000c7	03 de		 add	 ebx, esi
  000c9	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  000cc	47		 inc	 edi
  000cd	eb b6		 jmp	 SHORT $LL17@strtoul
$LN6@strtoul:

; 76   : 	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
; 77   : 	for (acc = 0, any = 0;; c = *s++) {

  000cf	0f b6 37	 movzx	 esi, BYTE PTR [edi]

; 89   : 			any = -1;

  000d2	83 ca ff	 or	 edx, -1
  000d5	47		 inc	 edi
  000d6	eb ad		 jmp	 SHORT $LL17@strtoul
$LN34@strtoul:
  000d8	89 55 10	 mov	 DWORD PTR _any$1$[ebp], edx

; 94   : 		}
; 95   : 	}
; 96   : 	if (any < 0) {

  000db	85 d2		 test	 edx, edx
  000dd	79 13		 jns	 SHORT $LN4@strtoul

; 97   : 		acc = ULONG_MAX;

  000df	83 cb ff	 or	 ebx, -1

; 98   : 		_set_errno(ERANGE);

  000e2	e8 00 00 00 00	 call	 ___errno
  000e7	8b 55 10	 mov	 edx, DWORD PTR _any$1$[ebp]
  000ea	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  000f0	eb 08		 jmp	 SHORT $LN2@strtoul
$LN4@strtoul:

; 99   : 	}
; 100  : 	else if (neg)

  000f2	83 7d fc 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  000f6	74 02		 je	 SHORT $LN2@strtoul

; 101  : 		acc = -acc;

  000f8	f7 db		 neg	 ebx
$LN2@strtoul:

; 102  : 	if (endptr != 0)

  000fa	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  000fd	85 c0		 test	 eax, eax
  000ff	74 0c		 je	 SHORT $LN39@strtoul

; 103  : 		*endptr = (char *)(any ? (char *)s - 1 : nptr);

  00101	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  00104	85 d2		 test	 edx, edx
  00106	75 03		 jne	 SHORT $LN31@strtoul
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
$LN31@strtoul:
  0010b	89 08		 mov	 DWORD PTR [eax], ecx
$LN39@strtoul:
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi

; 104  : 	return (acc);

  0010f	8b c3		 mov	 eax, ebx
  00111	5b		 pop	 ebx

; 105  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_strtoul ENDP
_TEXT	ENDS
END
