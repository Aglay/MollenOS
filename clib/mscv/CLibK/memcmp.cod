; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\memcmp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_memcmp
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\memcmp.c
;	COMDAT _memcmp
_TEXT	SEGMENT
_ptr1$ = 8						; size = 4
_ptr2$ = 12						; size = 4
_num$ = 16						; size = 4
_memcmp	PROC						; COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21   : 	unsigned char *s1 = (unsigned char *) ptr1;
; 22   : 	unsigned char *s2 = (unsigned char *) ptr2;
; 23   : 	unsigned long *a1;
; 24   : 	unsigned long *a2;
; 25   : 
; 26   : 	/* If the size is too small, or either pointer is unaligned,
; 27   : 		then we punt to the byte compare loop.  Hopefully this will
; 28   : 		not turn up in inner loops.  */
; 29   : 	if (!TOO_SMALL(num) && !MEMCMP_UNALIGNED(s1, s2))

  00003	8b 45 10	 mov	 eax, DWORD PTR _num$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR _ptr2$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _ptr1$[ebp]
  0000e	8b cf		 mov	 ecx, edi
  00010	83 f8 04	 cmp	 eax, 4
  00013	72 1f		 jb	 SHORT $LN12@memcmp
  00015	8b d7		 mov	 edx, edi
  00017	0b d6		 or	 edx, esi
  00019	f6 c2 03	 test	 dl, 3
  0001c	75 16		 jne	 SHORT $LN12@memcmp
  0001e	8b ff		 npad	 2
$LL6@memcmp:

; 30   : 	{
; 31   : 		/* Otherwise, load and compare the blocks of memory one 
; 32   : 			word at a time.  */
; 33   : 		a1 = (unsigned long*) s1;
; 34   : 		a2 = (unsigned long*) s2;
; 35   : 		while (num >= LBLOCKSIZE)
; 36   : 		{
; 37   : 			if (*a1 != *a2) 

  00020	8b 11		 mov	 edx, DWORD PTR [ecx]
  00022	3b 16		 cmp	 edx, DWORD PTR [esi]
  00024	75 0e		 jne	 SHORT $LN12@memcmp

; 38   :    				break;
; 39   : 
; 40   : 			a1++;
; 41   : 			a2++;
; 42   : 			num -= LBLOCKSIZE;

  00026	83 e8 04	 sub	 eax, 4
  00029	83 c1 04	 add	 ecx, 4
  0002c	83 c6 04	 add	 esi, 4
  0002f	83 f8 04	 cmp	 eax, 4
  00032	73 ec		 jae	 SHORT $LL6@memcmp
$LN12@memcmp:

; 43   : 		}
; 44   : 
; 45   : 		/* check m mod LBLOCKSIZE remaining characters */
; 46   : 
; 47   : 		s1 = (unsigned char*)a1;
; 48   : 		s2 = (unsigned char*)a2;
; 49   : 	}
; 50   : 
; 51   : 	while (num--)

  00034	85 c0		 test	 eax, eax
  00036	74 0d		 je	 SHORT $LN15@memcmp
$LL3@memcmp:

; 52   : 	{
; 53   : 		if (*s1 != *s2)

  00038	8a 11		 mov	 dl, BYTE PTR [ecx]
  0003a	48		 dec	 eax
  0003b	3a 16		 cmp	 dl, BYTE PTR [esi]
  0003d	75 0c		 jne	 SHORT $LN13@memcmp

; 55   : 
; 56   : 		s1++;

  0003f	41		 inc	 ecx

; 57   : 		s2++;

  00040	46		 inc	 esi
  00041	85 c0		 test	 eax, eax
  00043	75 f3		 jne	 SHORT $LL3@memcmp
$LN15@memcmp:
  00045	5f		 pop	 edi

; 58   : 	}
; 59   : 
; 60   : 	return 0;

  00046	33 c0		 xor	 eax, eax
  00048	5e		 pop	 esi

; 61   : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN13@memcmp:

; 54   : 			return *s1 - *s2;

  0004b	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  0004e	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00051	5f		 pop	 edi
  00052	2b c2		 sub	 eax, edx
  00054	5e		 pop	 esi

; 61   : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_memcmp	ENDP
_TEXT	ENDS
END
