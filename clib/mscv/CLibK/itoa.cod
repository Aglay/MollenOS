; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\itoa.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_i64toa
EXTRN	_memcpy:PROC
EXTRN	__aulldvrm:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\itoa.c
;	COMDAT _i64toa
_TEXT	SEGMENT
_buffer$ = -76						; size = 65
tv131 = -8						; size = 8
tv164 = 8						; size = 8
_value$ = 8						; size = 8
_string$ = 16						; size = 4
_negative$ = 20						; size = 4
_radix$ = 20						; size = 4
_i64toa	PROC						; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11   :     unsigned long long val;
; 12   :     int negative;
; 13   :     char buffer[65];
; 14   :     char *pos;
; 15   :     int digit;
; 16   : 
; 17   :     if (value < 0 && radix == 10) {

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp+4]
  00006	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00009	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _value$[ebp]
  00011	33 d2		 xor	 edx, edx
  00013	57		 push	 edi
  00014	3b ca		 cmp	 ecx, edx
  00016	7f 1a		 jg	 SHORT $LN8@i64toa
  00018	7c 04		 jl	 SHORT $LN12@i64toa
  0001a	3b f2		 cmp	 esi, edx
  0001c	73 14		 jae	 SHORT $LN8@i64toa
$LN12@i64toa:
  0001e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00021	75 0f		 jne	 SHORT $LN8@i64toa

; 18   : 	negative = 1;
; 19   :         val = -value;

  00023	f7 de		 neg	 esi
  00025	13 ca		 adc	 ecx, edx
  00027	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1
  0002e	f7 d9		 neg	 ecx

; 20   :     } else {

  00030	eb 03		 jmp	 SHORT $LN14@i64toa
$LN8@i64toa:

; 21   : 	negative = 0;

  00032	89 55 14	 mov	 DWORD PTR _negative$[ebp], edx
$LN14@i64toa:

; 22   :         val = value;
; 23   :     } /* if */
; 24   : 
; 25   :     pos = &buffer[64];
; 26   :     *pos = '\0';

  00035	88 55 f4	 mov	 BYTE PTR _buffer$[ebp+64], dl

; 35   : 	} /* if */
; 36   :     } while (val != 0L);

  00038	99		 cdq
  00039	8b d9		 mov	 ebx, ecx
  0003b	8d 7d f4	 lea	 edi, DWORD PTR _buffer$[ebp+64]
  0003e	89 45 08	 mov	 DWORD PTR tv164[ebp], eax
  00041	89 55 0c	 mov	 DWORD PTR tv164[ebp+4], edx
$LL6@i64toa:

; 27   : 
; 28   :     do {
; 29   : 	digit = val % radix;

  00044	8b 45 0c	 mov	 eax, DWORD PTR tv164[ebp+4]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR tv164[ebp]
  0004a	50		 push	 eax
  0004b	51		 push	 ecx
  0004c	53		 push	 ebx
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 __aulldvrm

; 30   : 	val = val / radix;
; 31   : 	if (digit < 10) {
; 32   : 	    *--pos = (char)('0' + digit);

  00053	4f		 dec	 edi
  00054	89 5d fc	 mov	 DWORD PTR tv131[ebp+4], ebx
  00057	8b f0		 mov	 esi, eax
  00059	8b da		 mov	 ebx, edx
  0005b	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0005e	7d 05		 jge	 SHORT $LN3@i64toa
  00060	80 c1 30	 add	 cl, 48			; 00000030H

; 33   : 	} else {

  00063	eb 03		 jmp	 SHORT $LN15@i64toa
$LN3@i64toa:

; 34   : 	    *--pos = (char)('a' + digit - 10);

  00065	80 c1 57	 add	 cl, 87			; 00000057H
$LN15@i64toa:

; 35   : 	} /* if */
; 36   :     } while (val != 0L);

  00068	8b d6		 mov	 edx, esi
  0006a	0b d3		 or	 edx, ebx
  0006c	88 0f		 mov	 BYTE PTR [edi], cl
  0006e	75 d4		 jne	 SHORT $LL6@i64toa

; 37   : 
; 38   :     if (negative) {

  00070	39 55 14	 cmp	 DWORD PTR _negative$[ebp], edx
  00073	74 04		 je	 SHORT $LN1@i64toa

; 39   : 	*--pos = '-';

  00075	4f		 dec	 edi
  00076	c6 07 2d	 mov	 BYTE PTR [edi], 45	; 0000002dH
$LN1@i64toa:

; 40   :     } /* if */
; 41   : 
; 42   :     memcpy(string, pos, &buffer[64] - pos + 1);

  00079	8b 75 10	 mov	 esi, DWORD PTR _string$[ebp]
  0007c	8d 45 f5	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  0007f	2b c7		 sub	 eax, edi
  00081	50		 push	 eax
  00082	57		 push	 edi
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 _memcpy
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	5f		 pop	 edi

; 43   :     return string;

  0008d	8b c6		 mov	 eax, esi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 44   : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_i64toa	ENDP
_TEXT	ENDS
PUBLIC	_i64toa_s
EXTRN	___errno:PROC
; Function compile flags: /Ogtp
;	COMDAT _i64toa_s
_TEXT	SEGMENT
_buffer$ = -88						; size = 65
tv289 = -20						; size = 8
tv200 = -12						; size = 8
_is_negative$ = -4					; size = 4
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_i64toa_s PROC						; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   :     unsigned __int64 val;
; 52   :     unsigned int digit;
; 53   :     int is_negative;
; 54   :     char buffer[65], *pos;
; 55   :     size_t len;
; 56   : 
; 57   :     if (!(str != NULL) || !(size > 0) ||
; 58   :         !(radix >= 2) || !(radix <= 36))

  00003	8b 55 10	 mov	 edx, DWORD PTR _str$[ebp]
  00006	83 ec 58	 sub	 esp, 88			; 00000058H
  00009	33 c0		 xor	 eax, eax
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	3b d0		 cmp	 edx, eax
  0000f	0f 84 e9 00 00
	00		 je	 $LN14@i64toa_s
  00015	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00018	3b c8		 cmp	 ecx, eax
  0001a	0f 86 da 00 00
	00		 jbe	 $LN26@i64toa_s
  00020	8b 7d 18	 mov	 edi, DWORD PTR _radix$[ebp]
  00023	8d 77 fe	 lea	 esi, DWORD PTR [edi-2]
  00026	83 fe 22	 cmp	 esi, 34			; 00000022H
  00029	0f 87 c9 00 00
	00		 ja	 $LN15@i64toa_s

; 64   :     }
; 65   : 
; 66   :     if (value < 0 && radix == 10)

  0002f	8b 75 08	 mov	 esi, DWORD PTR _value$[ebp]
  00032	53		 push	 ebx
  00033	8b 5d 0c	 mov	 ebx, DWORD PTR _value$[ebp+4]
  00036	3b d8		 cmp	 ebx, eax
  00038	7f 1a		 jg	 SHORT $LN13@i64toa_s
  0003a	7c 04		 jl	 SHORT $LN22@i64toa_s
  0003c	3b f0		 cmp	 esi, eax
  0003e	73 14		 jae	 SHORT $LN13@i64toa_s
$LN22@i64toa_s:
  00040	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00043	75 0f		 jne	 SHORT $LN13@i64toa_s

; 67   :     {
; 68   :         is_negative = 1;
; 69   :         val = -value;

  00045	f7 de		 neg	 esi
  00047	13 d8		 adc	 ebx, eax
  00049	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _is_negative$[ebp], 1
  00050	f7 db		 neg	 ebx

; 70   :     }
; 71   :     else

  00052	eb 03		 jmp	 SHORT $LN12@i64toa_s
$LN13@i64toa_s:

; 72   :     {
; 73   :         is_negative = 0;

  00054	89 45 fc	 mov	 DWORD PTR _is_negative$[ebp], eax
$LN12@i64toa_s:

; 74   :         val = value;
; 75   :     }
; 76   : 
; 77   :     pos = buffer + 64;
; 78   :     *pos = '\0';

  00057	88 45 e8	 mov	 BYTE PTR _buffer$[ebp+64], al

; 89   :     }
; 90   :     while (val != 0);

  0005a	8b 45 18	 mov	 eax, DWORD PTR _radix$[ebp]
  0005d	99		 cdq
  0005e	8d 7d e8	 lea	 edi, DWORD PTR _buffer$[ebp+64]
  00061	89 45 f4	 mov	 DWORD PTR tv200[ebp], eax
  00064	89 55 f8	 mov	 DWORD PTR tv200[ebp+4], edx
$LL11@i64toa_s:

; 79   : 
; 80   :     do
; 81   :     {
; 82   :         digit = val % radix;

  00067	8b 45 f8	 mov	 eax, DWORD PTR tv200[ebp+4]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR tv200[ebp]
  0006d	50		 push	 eax
  0006e	51		 push	 ecx
  0006f	53		 push	 ebx
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 __aulldvrm

; 83   :         val /= radix;
; 84   : 
; 85   :         if (digit < 10)
; 86   :             *--pos = (char)('0' + digit);

  00076	4f		 dec	 edi
  00077	89 5d f0	 mov	 DWORD PTR tv289[ebp+4], ebx
  0007a	8b f0		 mov	 esi, eax
  0007c	8b da		 mov	 ebx, edx
  0007e	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00081	73 05		 jae	 SHORT $LN8@i64toa_s
  00083	80 c1 30	 add	 cl, 48			; 00000030H

; 87   :         else

  00086	eb 03		 jmp	 SHORT $LN27@i64toa_s
$LN8@i64toa_s:

; 88   :             *--pos = (char)('a' + digit - 10);

  00088	80 c1 57	 add	 cl, 87			; 00000057H
$LN27@i64toa_s:

; 89   :     }
; 90   :     while (val != 0);

  0008b	8b d6		 mov	 edx, esi
  0008d	0b d3		 or	 edx, ebx
  0008f	88 0f		 mov	 BYTE PTR [edi], cl
  00091	75 d4		 jne	 SHORT $LL11@i64toa_s

; 91   : 
; 92   :     if (is_negative)

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _is_negative$[ebp]
  00096	5b		 pop	 ebx
  00097	85 c9		 test	 ecx, ecx
  00099	74 04		 je	 SHORT $LN24@i64toa_s

; 93   :         *--pos = '-';

  0009b	4f		 dec	 edi
  0009c	c6 07 2d	 mov	 BYTE PTR [edi], 45	; 0000002dH
$LN24@i64toa_s:

; 94   : 
; 95   :     len = buffer + 65 - pos;
; 96   :     if (len > size)

  0009f	8b 75 14	 mov	 esi, DWORD PTR _size$[ebp]
  000a2	8d 45 e9	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  000a5	2b c7		 sub	 eax, edi
  000a7	3b c6		 cmp	 eax, esi
  000a9	76 37		 jbe	 SHORT $LN5@i64toa_s

; 97   :     {
; 98   :         size_t i;
; 99   :         char *p = str;

  000ab	8b 7d 10	 mov	 edi, DWORD PTR _str$[ebp]
  000ae	8b c7		 mov	 eax, edi

; 100  : 
; 101  :         /* Copy the temporary buffer backwards up to the available number of
; 102  :          * characters. Don't copy the negative sign if present. */
; 103  : 
; 104  :         if (is_negative)

  000b0	85 c9		 test	 ecx, ecx
  000b2	74 04		 je	 SHORT $LN25@i64toa_s

; 105  :         {
; 106  :             p++;

  000b4	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 107  :             size--;

  000b7	4e		 dec	 esi
$LN25@i64toa_s:

; 108  :         }
; 109  : 
; 110  :         for (pos = buffer + 63, i = 0; i < size; i++)

  000b8	8d 4d e7	 lea	 ecx, DWORD PTR _buffer$[ebp+63]
  000bb	85 f6		 test	 esi, esi
  000bd	74 0a		 je	 SHORT $LN1@i64toa_s
  000bf	90		 npad	 1
$LL3@i64toa_s:

; 111  :             *p++ = *pos--;

  000c0	8a 11		 mov	 dl, BYTE PTR [ecx]
  000c2	88 10		 mov	 BYTE PTR [eax], dl
  000c4	40		 inc	 eax
  000c5	49		 dec	 ecx
  000c6	4e		 dec	 esi
  000c7	75 f7		 jne	 SHORT $LL3@i64toa_s
$LN1@i64toa_s:

; 112  : 
; 113  :         str[0] = '\0';

  000c9	c6 07 00	 mov	 BYTE PTR [edi], 0

; 114  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 115  : 
; 116  :         *__errno() = ERANGE;

  000cc	e8 00 00 00 00	 call	 ___errno
  000d1	5f		 pop	 edi
  000d2	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H

; 117  :         return ERANGE;

  000d8	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000dd	5e		 pop	 esi

; 122  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
$LN5@i64toa_s:

; 118  :     }
; 119  : 
; 120  :     memcpy(str, pos, len);

  000e2	50		 push	 eax
  000e3	8b 45 10	 mov	 eax, DWORD PTR _str$[ebp]
  000e6	57		 push	 edi
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _memcpy
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	5f		 pop	 edi

; 121  :     return 0;

  000f1	33 c0		 xor	 eax, eax
  000f3	5e		 pop	 esi

; 122  : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN15@i64toa_s:

; 59   :     {
; 60   :         if (str && size)

  000f8	3b c8		 cmp	 ecx, eax
$LN26@i64toa_s:
  000fa	74 02		 je	 SHORT $LN14@i64toa_s

; 61   :             str[0] = '\0';

  000fc	88 02		 mov	 BYTE PTR [edx], al
$LN14@i64toa_s:

; 62   :         *__errno() = EINVAL;

  000fe	e8 00 00 00 00	 call	 ___errno
  00103	5f		 pop	 edi
  00104	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 63   :         return EINVAL;

  0010a	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0010f	5e		 pop	 esi

; 122  : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
_i64toa_s ENDP
_TEXT	ENDS
PUBLIC	_ui64toa
; Function compile flags: /Ogtp
;	COMDAT _ui64toa
_TEXT	SEGMENT
_buffer$ = -76						; size = 65
tv161 = -8						; size = 8
tv133 = 8						; size = 8
_value$ = 8						; size = 8
_string$ = 16						; size = 4
_radix$ = 20						; size = 4
_ui64toa PROC						; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 143  : 	} /* if */
; 144  :     } while (value != 0L);

  00006	8b 45 14	 mov	 eax, DWORD PTR _radix$[ebp]
  00009	53		 push	 ebx
  0000a	99		 cdq
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00012	89 55 fc	 mov	 DWORD PTR tv161[ebp+4], edx
  00015	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00018	8d 75 f4	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  0001b	c6 45 f4 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  0001f	90		 npad	 1
$LL5@ui64toa:

; 129  :     char buffer[65];
; 130  :     char *pos;
; 131  :     int digit;
; 132  : 
; 133  :     pos = &buffer[64];
; 134  :     *pos = '\0';
; 135  : 
; 136  :     do {
; 137  : 	digit = value % radix;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR tv161[ebp+4]
  00023	51		 push	 ecx
  00024	57		 push	 edi
  00025	52		 push	 edx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __aulldvrm

; 138  : 	value = value / radix;
; 139  : 	if (digit < 10) {
; 140  : 	    *--pos = (char)('0' + digit);

  0002c	4e		 dec	 esi
  0002d	89 5d 0c	 mov	 DWORD PTR tv133[ebp+4], ebx
  00030	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00033	7d 05		 jge	 SHORT $LN2@ui64toa
  00035	80 c1 30	 add	 cl, 48			; 00000030H

; 141  : 	} else {

  00038	eb 03		 jmp	 SHORT $LN10@ui64toa
$LN2@ui64toa:

; 142  : 	    *--pos = (char)('a' + digit - 10);

  0003a	80 c1 57	 add	 cl, 87			; 00000057H
$LN10@ui64toa:
  0003d	88 0e		 mov	 BYTE PTR [esi], cl

; 143  : 	} /* if */
; 144  :     } while (value != 0L);

  0003f	8b c8		 mov	 ecx, eax
  00041	0b ca		 or	 ecx, edx
  00043	75 db		 jne	 SHORT $LL5@ui64toa

; 145  : 
; 146  :     memcpy(string, pos, &buffer[64] - pos + 1);

  00045	8d 55 f5	 lea	 edx, DWORD PTR _buffer$[ebp+65]
  00048	2b d6		 sub	 edx, esi
  0004a	52		 push	 edx
  0004b	56		 push	 esi
  0004c	8b 75 10	 mov	 esi, DWORD PTR _string$[ebp]
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 _memcpy
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	5f		 pop	 edi

; 147  :     return string;

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx

; 148  : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_ui64toa ENDP
_TEXT	ENDS
PUBLIC	_ui64toa_s
; Function compile flags: /Ogtp
;	COMDAT _ui64toa_s
_TEXT	SEGMENT
_buffer$ = -84						; size = 65
tv138 = -16						; size = 8
tv165 = -8						; size = 8
_value$ = 8						; size = 8
_str$ = 16						; size = 4
_size$ = 20						; size = 4
_radix$ = 24						; size = 4
_ui64toa_s PROC						; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H

; 155  :     char buffer[65], *pos;
; 156  :     int digit;
; 157  : 
; 158  :     if (!(str != NULL) || !(size > 0) ||
; 159  :         !(radix>=2) || !(radix<=36)) {

  00006	83 7d 10 00	 cmp	 DWORD PTR _str$[ebp], 0
  0000a	0f 84 83 00 00
	00		 je	 $LN7@ui64toa_s
  00010	83 7d 14 00	 cmp	 DWORD PTR _size$[ebp], 0
  00014	76 7d		 jbe	 SHORT $LN7@ui64toa_s
  00016	8b 45 18	 mov	 eax, DWORD PTR _radix$[ebp]
  00019	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  0001c	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0001f	77 72		 ja	 SHORT $LN7@ui64toa_s

; 175  :     }while(value != 0);

  00021	99		 cdq
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	8b f8		 mov	 edi, eax
  00026	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00029	89 55 fc	 mov	 DWORD PTR tv165[ebp+4], edx
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  0002f	8d 75 ec	 lea	 esi, DWORD PTR _buffer$[ebp+64]
  00032	c6 45 ec 00	 mov	 BYTE PTR _buffer$[ebp+64], 0
  00036	53		 push	 ebx
$LL6@ui64toa_s:

; 162  :     }
; 163  : 
; 164  :     pos = buffer+64;
; 165  :     *pos = '\0';
; 166  : 
; 167  :     do {
; 168  :         digit = value%radix;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR tv165[ebp+4]
  0003a	51		 push	 ecx
  0003b	57		 push	 edi
  0003c	52		 push	 edx
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 __aulldvrm

; 169  :         value /= radix;
; 170  : 
; 171  :         if(digit < 10)
; 172  :             *--pos = (char)('0' + digit);

  00043	4e		 dec	 esi
  00044	89 5d f4	 mov	 DWORD PTR tv138[ebp+4], ebx
  00047	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0004a	7d 05		 jge	 SHORT $LN3@ui64toa_s
  0004c	80 c1 30	 add	 cl, 48			; 00000030H

; 173  :         else

  0004f	eb 03		 jmp	 SHORT $LN14@ui64toa_s
$LN3@ui64toa_s:

; 174  :             *--pos = (char)('a' + digit - 10);

  00051	80 c1 57	 add	 cl, 87			; 00000057H
$LN14@ui64toa_s:
  00054	88 0e		 mov	 BYTE PTR [esi], cl

; 175  :     }while(value != 0);

  00056	8b c8		 mov	 ecx, eax
  00058	0b ca		 or	 ecx, edx
  0005a	75 db		 jne	 SHORT $LL6@ui64toa_s

; 176  : 
; 177  :     if((unsigned)(buffer-pos+65) > size) {

  0005c	8d 45 ed	 lea	 eax, DWORD PTR _buffer$[ebp+65]
  0005f	2b c6		 sub	 eax, esi
  00061	5b		 pop	 ebx
  00062	3b 45 14	 cmp	 eax, DWORD PTR _size$[ebp]
  00065	76 16		 jbe	 SHORT $LN1@ui64toa_s

; 178  :         //MSVCRT_INVALID_PMT("str[size] is too small");
; 179  : 
; 180  :         *__errno() = EINVAL;

  00067	e8 00 00 00 00	 call	 ___errno
  0006c	5f		 pop	 edi
  0006d	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 181  :         return EINVAL;

  00073	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00078	5e		 pop	 esi

; 186  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN1@ui64toa_s:

; 182  :     }
; 183  : 
; 184  :     memcpy(str, pos, buffer-pos+65);

  0007d	8b 55 10	 mov	 edx, DWORD PTR _str$[ebp]
  00080	50		 push	 eax
  00081	56		 push	 esi
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 _memcpy
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	5f		 pop	 edi

; 185  :     return 0;

  0008c	33 c0		 xor	 eax, eax
  0008e	5e		 pop	 esi

; 186  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN7@ui64toa_s:

; 160  :         *__errno() = EINVAL;

  00093	e8 00 00 00 00	 call	 ___errno
  00098	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 161  :         return EINVAL;

  0009e	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 186  : }

  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_ui64toa_s ENDP
_TEXT	ENDS
PUBLIC	_ltoa
; Function compile flags: /Ogtp
;	COMDAT _ltoa
_TEXT	SEGMENT
_buffer$ = -36						; size = 33
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ltoa	PROC						; COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 209  :     unsigned long val;
; 210  :     int negative;
; 211  :     char buffer[33];
; 212  :     char *pos;
; 213  :     int digit;
; 214  : 
; 215  :     if (value < 0 && radix == 10) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  0000d	57		 push	 edi
  0000e	85 c0		 test	 eax, eax
  00010	79 0c		 jns	 SHORT $LN8@ltoa
  00012	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00015	75 07		 jne	 SHORT $LN8@ltoa

; 216  : 	negative = 1;

  00017	8d 7e f7	 lea	 edi, DWORD PTR [esi-9]

; 217  :         val = -value;

  0001a	f7 d8		 neg	 eax

; 218  :     } else {

  0001c	eb 02		 jmp	 SHORT $LN7@ltoa
$LN8@ltoa:

; 219  : 	negative = 0;

  0001e	33 ff		 xor	 edi, edi
$LN7@ltoa:

; 220  :         val = value;
; 221  :     } /* if */
; 222  : 
; 223  :     pos = &buffer[32];

  00020	8d 4d fc	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 224  :     *pos = '\0';

  00023	c6 45 fc 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL6@ltoa:

; 225  : 
; 226  :     do {
; 227  : 	digit = val % radix;

  00027	33 d2		 xor	 edx, edx
  00029	f7 f6		 div	 esi

; 228  : 	val = val / radix;
; 229  : 	if (digit < 10) {
; 230  : 	    *--pos = (char)('0' + digit);

  0002b	49		 dec	 ecx
  0002c	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0002f	7d 05		 jge	 SHORT $LN3@ltoa
  00031	80 c2 30	 add	 dl, 48			; 00000030H

; 231  : 	} else {

  00034	eb 03		 jmp	 SHORT $LN12@ltoa
$LN3@ltoa:

; 232  : 	    *--pos = (char)('a' + digit - 10);

  00036	80 c2 57	 add	 dl, 87			; 00000057H
$LN12@ltoa:
  00039	88 11		 mov	 BYTE PTR [ecx], dl

; 233  : 	} /* if */
; 234  :     } while (val != 0L);

  0003b	85 c0		 test	 eax, eax
  0003d	75 e8		 jne	 SHORT $LL6@ltoa

; 235  : 
; 236  :     if (negative) {

  0003f	85 ff		 test	 edi, edi
  00041	74 04		 je	 SHORT $LN1@ltoa

; 237  : 	*--pos = '-';

  00043	49		 dec	 ecx
  00044	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN1@ltoa:

; 238  :     } /* if */
; 239  : 
; 240  :     memcpy(string, pos, &buffer[32] - pos + 1);

  00047	8b 75 0c	 mov	 esi, DWORD PTR _string$[ebp]
  0004a	8d 45 fd	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  0004d	2b c1		 sub	 eax, ecx
  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 _memcpy
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	5f		 pop	 edi

; 241  :     return string;

  0005b	8b c6		 mov	 eax, esi
  0005d	5e		 pop	 esi

; 242  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_ltoa	ENDP
_TEXT	ENDS
PUBLIC	_ltoa_s
; Function compile flags: /Ogtp
;	COMDAT _ltoa_s
_TEXT	SEGMENT
_buffer$ = -36						; size = 33
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_ltoa_s	PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  :     unsigned long val;
; 250  :     unsigned int digit;
; 251  :     int is_negative;
; 252  :     char buffer[33], *pos;
; 253  :     size_t len;
; 254  : 
; 255  :     if (!(str != NULL) || !(size > 0) ||
; 256  :         (radix >= 2) || !(radix <= 36))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00006	83 ec 24	 sub	 esp, 36			; 00000024H
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	85 c0		 test	 eax, eax
  0000d	0f 84 be 00 00
	00		 je	 $LN14@ltoa_s
  00013	8b 5d 10	 mov	 ebx, DWORD PTR _size$[ebp]
  00016	85 db		 test	 ebx, ebx
  00018	0f 84 b3 00 00
	00		 je	 $LN14@ltoa_s
  0001e	8b 7d 14	 mov	 edi, DWORD PTR _radix$[ebp]
  00021	83 ff 02	 cmp	 edi, 2
  00024	0f 8d a0 00 00
	00		 jge	 $LN15@ltoa_s
  0002a	83 ff 24	 cmp	 edi, 36			; 00000024H
  0002d	0f 8f 97 00 00
	00		 jg	 $LN15@ltoa_s

; 263  :     }
; 264  : 
; 265  :     if (value < 0 && radix == 10)

  00033	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00036	56		 push	 esi
  00037	85 c0		 test	 eax, eax
  00039	79 0c		 jns	 SHORT $LN13@ltoa_s
  0003b	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  0003e	75 07		 jne	 SHORT $LN13@ltoa_s

; 266  :     {
; 267  :         is_negative = 1;

  00040	8d 77 f7	 lea	 esi, DWORD PTR [edi-9]

; 268  :         val = -value;

  00043	f7 d8		 neg	 eax

; 269  :     }
; 270  :     else

  00045	eb 02		 jmp	 SHORT $LN12@ltoa_s
$LN13@ltoa_s:

; 271  :     {
; 272  :         is_negative = 0;

  00047	33 f6		 xor	 esi, esi
$LN12@ltoa_s:

; 273  :         val = value;
; 274  :     }
; 275  : 
; 276  :     pos = buffer + 32;

  00049	8d 4d fc	 lea	 ecx, DWORD PTR _buffer$[ebp+32]

; 277  :     *pos = '\0';

  0004c	c6 45 fc 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL11@ltoa_s:

; 278  : 
; 279  :     do
; 280  :     {
; 281  :         digit = val % radix;

  00050	33 d2		 xor	 edx, edx
  00052	f7 f7		 div	 edi

; 282  :         val /= radix;
; 283  : 
; 284  :         if (digit < 10)
; 285  :             *--pos = (char)('0' + digit);

  00054	49		 dec	 ecx
  00055	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00058	73 05		 jae	 SHORT $LN8@ltoa_s
  0005a	80 c2 30	 add	 dl, 48			; 00000030H

; 286  :         else

  0005d	eb 03		 jmp	 SHORT $LN26@ltoa_s
$LN8@ltoa_s:

; 287  :             *--pos = (char)('a' + digit - 10);

  0005f	80 c2 57	 add	 dl, 87			; 00000057H
$LN26@ltoa_s:
  00062	88 11		 mov	 BYTE PTR [ecx], dl

; 288  :     }
; 289  :     while (val != 0);

  00064	85 c0		 test	 eax, eax
  00066	75 e8		 jne	 SHORT $LL11@ltoa_s

; 290  : 
; 291  :     if (is_negative)

  00068	85 f6		 test	 esi, esi
  0006a	74 04		 je	 SHORT $LN22@ltoa_s

; 292  :         *--pos = '-';

  0006c	49		 dec	 ecx
  0006d	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN22@ltoa_s:

; 293  : 
; 294  :     len = buffer + 33 - pos;

  00070	8d 45 fd	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  00073	2b c1		 sub	 eax, ecx

; 295  :     if (len > size)

  00075	3b c3		 cmp	 eax, ebx
  00077	76 3a		 jbe	 SHORT $LN5@ltoa_s

; 296  :     {
; 297  :         size_t i;
; 298  :         char *p = str;

  00079	8b 7d 0c	 mov	 edi, DWORD PTR _str$[ebp]
  0007c	8b c7		 mov	 eax, edi

; 299  : 
; 300  :         /* Copy the temporary buffer backwards up to the available number of
; 301  :          * characters. Don't copy the negative sign if present. */
; 302  : 
; 303  :         if (is_negative)

  0007e	85 f6		 test	 esi, esi
  00080	74 04		 je	 SHORT $LN23@ltoa_s

; 304  :         {
; 305  :             p++;

  00082	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 306  :             size--;

  00085	4b		 dec	 ebx
$LN23@ltoa_s:

; 307  :         }
; 308  : 
; 309  :         for (pos = buffer + 31, i = 0; i < size; i++)

  00086	8d 4d fb	 lea	 ecx, DWORD PTR _buffer$[ebp+31]
  00089	85 db		 test	 ebx, ebx
  0008b	74 0c		 je	 SHORT $LN1@ltoa_s
  0008d	8b f3		 mov	 esi, ebx
  0008f	90		 npad	 1
$LL3@ltoa_s:

; 310  :             *p++ = *pos--;

  00090	8a 11		 mov	 dl, BYTE PTR [ecx]
  00092	88 10		 mov	 BYTE PTR [eax], dl
  00094	40		 inc	 eax
  00095	49		 dec	 ecx
  00096	4e		 dec	 esi
  00097	75 f7		 jne	 SHORT $LL3@ltoa_s
$LN1@ltoa_s:

; 311  : 
; 312  :         str[0] = '\0';

  00099	c6 07 00	 mov	 BYTE PTR [edi], 0

; 313  :         //("str[size] is too small");
; 314  :         *__errno() = EINVAL;

  0009c	e8 00 00 00 00	 call	 ___errno
  000a1	5e		 pop	 esi
  000a2	5f		 pop	 edi
  000a3	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 315  :         return ERANGE;

  000a9	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000ae	5b		 pop	 ebx

; 320  : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
$LN5@ltoa_s:

; 316  :     }
; 317  : 
; 318  :     memcpy(str, pos, len);

  000b3	50		 push	 eax
  000b4	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  000b7	51		 push	 ecx
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _memcpy
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	5e		 pop	 esi
  000c2	5f		 pop	 edi

; 319  :     return 0;

  000c3	33 c0		 xor	 eax, eax
  000c5	5b		 pop	 ebx

; 320  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN15@ltoa_s:

; 257  :     {
; 258  :         if (str && size)

  000ca	85 db		 test	 ebx, ebx
  000cc	74 03		 je	 SHORT $LN14@ltoa_s

; 259  :             str[0] = '\0';

  000ce	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN14@ltoa_s:

; 260  : 
; 261  :         *__errno() = EINVAL;

  000d1	e8 00 00 00 00	 call	 ___errno
  000d6	5f		 pop	 edi
  000d7	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H

; 262  :         return EINVAL;

  000dd	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000e2	5b		 pop	 ebx

; 320  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_ltoa_s	ENDP
_TEXT	ENDS
PUBLIC	_ultoa
; Function compile flags: /Ogtp
;	COMDAT _ultoa
_TEXT	SEGMENT
_buffer$ = -36						; size = 33
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_ultoa	PROC						; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 327  :     char buffer[33];
; 328  :     char *pos;
; 329  :     int digit;
; 330  : 
; 331  :     pos = &buffer[32];
; 332  :     *pos = '\0';

  00006	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 10	 mov	 esi, DWORD PTR _radix$[ebp]
  0000d	8d 4d fc	 lea	 ecx, DWORD PTR _buffer$[ebp+32]
  00010	c6 45 fc 00	 mov	 BYTE PTR _buffer$[ebp+32], 0
$LL5@ultoa:

; 333  : 
; 334  :     do {
; 335  : 	digit = value % radix;

  00014	33 d2		 xor	 edx, edx
  00016	f7 f6		 div	 esi

; 336  : 	value = value / radix;
; 337  : 	if (digit < 10) {
; 338  : 	    *--pos = (char)('0' + digit);

  00018	49		 dec	 ecx
  00019	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0001c	7d 05		 jge	 SHORT $LN2@ultoa
  0001e	80 c2 30	 add	 dl, 48			; 00000030H

; 339  : 	} else {

  00021	eb 03		 jmp	 SHORT $LN9@ultoa
$LN2@ultoa:

; 340  : 	    *--pos = (char)('a' + digit - 10);

  00023	80 c2 57	 add	 dl, 87			; 00000057H
$LN9@ultoa:
  00026	88 11		 mov	 BYTE PTR [ecx], dl

; 341  : 	} /* if */
; 342  :     } while (value != 0L);

  00028	85 c0		 test	 eax, eax
  0002a	75 e8		 jne	 SHORT $LL5@ultoa

; 343  : 
; 344  :     memcpy(string, pos, &buffer[32] - pos + 1);

  0002c	8b 75 0c	 mov	 esi, DWORD PTR _string$[ebp]
  0002f	8d 45 fd	 lea	 eax, DWORD PTR _buffer$[ebp+33]
  00032	2b c1		 sub	 eax, ecx
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 345  : 
; 346  :     return string;

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 347  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_ultoa	ENDP
_TEXT	ENDS
PUBLIC	_itoa_s
; Function compile flags: /Ogtp
;	COMDAT _itoa_s
_TEXT	SEGMENT
_value$ = 8						; size = 4
_str$ = 12						; size = 4
_size$ = 16						; size = 4
_radix$ = 20						; size = 4
_itoa_s	PROC						; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : }

  00003	5d		 pop	 ebp

; 193  :     return ltoa_s(value, str, size, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa_s
_itoa_s	ENDP
_TEXT	ENDS
PUBLIC	_itoa
; Function compile flags: /Ogtp
;	COMDAT _itoa
_TEXT	SEGMENT
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_itoa	PROC						; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : }

  00003	5d		 pop	 ebp

; 201  :   return ltoa(value, string, radix);

  00004	e9 00 00 00 00	 jmp	 _ltoa
_itoa	ENDP
_TEXT	ENDS
END
