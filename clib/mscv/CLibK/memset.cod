; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\memset.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_memset
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\memset.c
;	COMDAT _memset
_TEXT	SEGMENT
_d$1$ = -4						; size = 4
_dest$ = 8						; size = 4
_c$ = 12						; size = 4
_count$ = 16						; size = 4
_memset	PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 18   : 	char *s = (char *)dest;

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00007	8b d1		 mov	 edx, ecx
  00009	53		 push	 ebx

; 19   : 	int i;
; 20   : 	unsigned long buffer;
; 21   : 	unsigned long *aligned_addr;
; 22   : 	unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an

  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]
  0000d	0f b6 c3	 movzx	 eax, bl
  00010	89 45 fc	 mov	 DWORD PTR _d$1$[ebp], eax
  00013	56		 push	 esi

; 23   : 					unsigned variable.  */
; 24   : 
; 25   : 	while (UNALIGNED (s))

  00014	8b 75 10	 mov	 esi, DWORD PTR _count$[ebp]
  00017	f6 c1 03	 test	 cl, 3
  0001a	74 1a		 je	 SHORT $LN13@memset
  0001c	8d 64 24 00	 npad	 4
$LL14@memset:

; 26   : 	{
; 27   : 		if (count--)

  00020	8b c6		 mov	 eax, esi
  00022	4e		 dec	 esi
  00023	85 c0		 test	 eax, eax
  00025	0f 84 87 00 00
	00		 je	 $LN12@memset

; 28   : 			*s++ = (char) c;

  0002b	88 1a		 mov	 BYTE PTR [edx], bl
  0002d	42		 inc	 edx
  0002e	f6 c2 03	 test	 dl, 3
  00031	75 ed		 jne	 SHORT $LL14@memset

; 42   : 		for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)

  00033	8b 45 fc	 mov	 eax, DWORD PTR _d$1$[ebp]
$LN13@memset:
  00036	57		 push	 edi

; 31   : 	}
; 32   : 
; 33   : 	if (!TOO_SMALL (count))

  00037	83 fe 04	 cmp	 esi, 4
  0003a	72 4d		 jb	 SHORT $LN3@memset

; 37   : 
; 38   : 		/* Store D into each char sized location in BUFFER so that
; 39   : 			we can set large blocks quickly.  */
; 40   : 		buffer = (d << 8) | d;

  0003c	8b f8		 mov	 edi, eax
  0003e	c1 e7 08	 shl	 edi, 8
  00041	0b f8		 or	 edi, eax

; 41   : 		buffer |= (buffer << 16);

  00043	8b c7		 mov	 eax, edi
  00045	c1 e0 10	 shl	 eax, 16			; 00000010H
  00048	0b f8		 or	 edi, eax

; 43   : 			buffer = (buffer << i) | buffer;
; 44   : 
; 45   : 		/* Unroll the loop.  */
; 46   : 		while (count >= LBLOCKSIZE*4)

  0004a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0004d	72 19		 jb	 SHORT $LN20@memset

; 34   : 	{
; 35   : 		/* If we get this far, we know that n is large and s is word-aligned. */
; 36   : 		aligned_addr = (unsigned long *) s;

  0004f	8b c6		 mov	 eax, esi
  00051	c1 e8 04	 shr	 eax, 4
$LL6@memset:

; 47   : 		{
; 48   : 			*aligned_addr++ = buffer;

  00054	89 3a		 mov	 DWORD PTR [edx], edi

; 49   : 			*aligned_addr++ = buffer;
; 50   : 			*aligned_addr++ = buffer;
; 51   : 			*aligned_addr++ = buffer;
; 52   : 			count -= 4*LBLOCKSIZE;

  00056	83 ee 10	 sub	 esi, 16			; 00000010H
  00059	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  0005c	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  0005f	89 7a 0c	 mov	 DWORD PTR [edx+12], edi
  00062	83 c2 10	 add	 edx, 16			; 00000010H
  00065	48		 dec	 eax
  00066	75 ec		 jne	 SHORT $LL6@memset
$LN20@memset:

; 53   : 		}
; 54   : 
; 55   : 		while (count >= LBLOCKSIZE)

  00068	83 fe 04	 cmp	 esi, 4
  0006b	72 1c		 jb	 SHORT $LN3@memset
  0006d	8b de		 mov	 ebx, esi
  0006f	8b c7		 mov	 eax, edi
  00071	c1 eb 02	 shr	 ebx, 2
  00074	8b fa		 mov	 edi, edx
  00076	8b cb		 mov	 ecx, ebx
  00078	f3 ab		 rep stosd
  0007a	8d 14 9a	 lea	 edx, DWORD PTR [edx+ebx*4]
  0007d	8d 49 00	 npad	 3
$LL4@memset:

; 56   : 		{
; 57   : 			*aligned_addr++ = buffer;
; 58   : 			count -= LBLOCKSIZE;

  00080	83 ee 04	 sub	 esi, 4
  00083	4b		 dec	 ebx
  00084	75 fa		 jne	 SHORT $LL4@memset
  00086	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]
$LN3@memset:

; 59   : 		}
; 60   : 		/* Pick up the remainder with a bytewise loop.  */
; 61   : 		s = (char*)aligned_addr;
; 62   : 	}
; 63   : 
; 64   : 	while (count--)

  00089	85 f6		 test	 esi, esi
  0008b	74 1b		 je	 SHORT $LN2@memset
  0008d	8a c3		 mov	 al, bl
  0008f	8b ce		 mov	 ecx, esi
  00091	0f b6 c0	 movzx	 eax, al
  00094	8b fa		 mov	 edi, edx
  00096	69 c0 01 01 01
	01		 imul	 eax, 16843009		; 01010101H
  0009c	c1 e9 02	 shr	 ecx, 2
  0009f	f3 ab		 rep stosd
  000a1	8b ce		 mov	 ecx, esi
  000a3	83 e1 03	 and	 ecx, 3
  000a6	f3 aa		 rep stosb
$LN2@memset:

; 65   : 		*s++ = (char) c;
; 66   : 
; 67   : 	return dest;

  000a8	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 68   : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
$LN12@memset:
  000b2	5e		 pop	 esi

; 29   : 		else
; 30   : 			return dest;

  000b3	8b c1		 mov	 eax, ecx
  000b5	5b		 pop	 ebx

; 68   : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_memset	ENDP
_TEXT	ENDS
END
