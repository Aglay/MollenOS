; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strtoull.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoull
EXTRN	___errno:PROC
EXTRN	__ctype:BYTE
EXTRN	__allmul:PROC
EXTRN	__aulldvrm:PROC
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strtoull.c
;	COMDAT _strtoull
_TEXT	SEGMENT
tv213 = -36						; size = 8
_cutoff$ = -28						; size = 8
tv247 = -20						; size = 8
_neg$ = -12						; size = 4
_s$ = -8						; size = 4
_c$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoull PROC						; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 17   :   const char *s = nptr;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 18   :   unsigned long long acc;
; 19   :   int c;
; 20   :   unsigned long long cutoff;
; 21   :   int neg = 0, any, cutlim;

  0000c	33 ff		 xor	 edi, edi
  0000e	89 7d f4	 mov	 DWORD PTR _neg$[ebp], edi
  00011	b2 20		 mov	 dl, 32			; 00000020H
$LL25@strtoull:

; 22   : 
; 23   :   /*
; 24   :    * See strtol for comments as to the logic used.
; 25   :    */
; 26   :   do {
; 27   :     c = *s++;

  00013	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  00016	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 28   :   } while (isspace(c));

  00019	0f b6 c0	 movzx	 eax, al
  0001c	41		 inc	 ecx
  0001d	84 90 00 00 00
	00		 test	 BYTE PTR __ctype[eax], dl
  00023	75 ee		 jne	 SHORT $LL25@strtoull

; 29   :   if (c == '-')

  00025	8b 75 fc	 mov	 esi, DWORD PTR _c$[ebp]
  00028	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx
  0002b	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  0002e	75 0f		 jne	 SHORT $LN22@strtoull

; 30   :   {
; 31   :     neg = 1;
; 32   :     c = *s++;

  00030	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00033	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _neg$[ebp], 1
  0003a	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
  0003d	eb 0b		 jmp	 SHORT $LN36@strtoull
$LN22@strtoull:

; 33   :   }
; 34   :   else if (c == '+')

  0003f	83 fe 2b	 cmp	 esi, 43			; 0000002bH
  00042	75 0d		 jne	 SHORT $LN20@strtoull

; 35   :     c = *s++;

  00044	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  00047	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
$LN36@strtoull:
  0004a	8b 75 fc	 mov	 esi, DWORD PTR _c$[ebp]
  0004d	41		 inc	 ecx
  0004e	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx
$LN20@strtoull:

; 36   :   if ((base == 0 || base == 16) &&
; 37   :       c == '0' && (*s == 'x' || *s == 'X'))

  00051	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
  00054	3b c7		 cmp	 eax, edi
  00056	74 05		 je	 SHORT $LN18@strtoull
  00058	83 f8 10	 cmp	 eax, 16			; 00000010H
  0005b	75 27		 jne	 SHORT $LN35@strtoull
$LN18@strtoull:
  0005d	83 fe 30	 cmp	 esi, 48			; 00000030H
  00060	75 22		 jne	 SHORT $LN35@strtoull
  00062	8a 11		 mov	 dl, BYTE PTR [ecx]
  00064	80 fa 78	 cmp	 dl, 120			; 00000078H
  00067	74 05		 je	 SHORT $LN17@strtoull
  00069	80 fa 58	 cmp	 dl, 88			; 00000058H
  0006c	75 16		 jne	 SHORT $LN35@strtoull
$LN17@strtoull:

; 38   :   {
; 39   :     c = s[1];

  0006e	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]

; 40   :     s += 2;

  00072	83 c1 02	 add	 ecx, 2
  00075	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
  00078	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx

; 41   :     base = 16;

  0007b	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H

; 42   :   }
; 43   :   if (base == 0)

  00082	eb 13		 jmp	 SHORT $LN37@strtoull
$LN35@strtoull:
  00084	3b c7		 cmp	 eax, edi
  00086	75 12		 jne	 SHORT $LN16@strtoull

; 44   :     base = c == '0' ? 8 : 10;

  00088	33 c0		 xor	 eax, eax
  0008a	83 fe 30	 cmp	 esi, 48			; 00000030H
  0008d	0f 95 c0	 setne	 al
  00090	8d 44 00 08	 lea	 eax, DWORD PTR [eax+eax+8]
  00094	89 45 10	 mov	 DWORD PTR _base$[ebp], eax
$LN37@strtoull:
  00097	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
$LN16@strtoull:

; 45   :   cutoff = (unsigned long long)ULLONG_MAX / (unsigned long long)base;

  0009a	99		 cdq
  0009b	52		 push	 edx
  0009c	50		 push	 eax
  0009d	6a ff		 push	 -1
  0009f	6a ff		 push	 -1
  000a1	89 45 ec	 mov	 DWORD PTR tv247[ebp], eax
  000a4	89 55 f0	 mov	 DWORD PTR tv247[ebp+4], edx
  000a7	e8 00 00 00 00	 call	 __aulldvrm
  000ac	89 4d dc	 mov	 DWORD PTR tv213[ebp], ecx
  000af	8b c8		 mov	 ecx, eax
  000b1	89 5d e0	 mov	 DWORD PTR tv213[ebp+4], ebx

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  000b4	33 f6		 xor	 esi, esi
  000b6	89 4d e4	 mov	 DWORD PTR _cutoff$[ebp], ecx
  000b9	89 55 e8	 mov	 DWORD PTR _cutoff$[ebp+4], edx
  000bc	33 db		 xor	 ebx, ebx
  000be	8b ff		 npad	 2
$LL15@strtoull:

; 48   :   {
; 49   :     if (isdigit(c))

  000c0	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  000c3	0f b6 c2	 movzx	 eax, dl
  000c6	8a 80 00 00 00
	00		 mov	 al, BYTE PTR __ctype[eax]
  000cc	a8 04		 test	 al, 4
  000ce	74 05		 je	 SHORT $LN12@strtoull

; 50   :       c -= '0';

  000d0	83 ea 30	 sub	 edx, 48			; 00000030H
  000d3	eb 19		 jmp	 SHORT $LN38@strtoull
$LN12@strtoull:

; 51   :     else if (isalpha(c))

  000d5	a8 03		 test	 al, 3
  000d7	0f 84 81 00 00
	00		 je	 $LN32@strtoull

; 52   :       c -= isupper(c) ? 'A' - 10 : 'a' - 10;

  000dd	24 01		 and	 al, 1
  000df	0f b6 c0	 movzx	 eax, al
  000e2	f7 d8		 neg	 eax
  000e4	1b c0		 sbb	 eax, eax
  000e6	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000e9	83 c0 57	 add	 eax, 87			; 00000057H
  000ec	2b d0		 sub	 edx, eax
$LN38@strtoull:
  000ee	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx

; 53   :     else
; 54   :       break;
; 55   :     if (c >= base)

  000f1	3b 55 10	 cmp	 edx, DWORD PTR _base$[ebp]
  000f4	7d 68		 jge	 SHORT $LN32@strtoull

; 56   :       break;
; 57   :     if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000f6	85 ff		 test	 edi, edi
  000f8	78 4f		 js	 SHORT $LN6@strtoull
  000fa	8b 45 e8	 mov	 eax, DWORD PTR _cutoff$[ebp+4]
  000fd	3b d8		 cmp	 ebx, eax
  000ff	77 48		 ja	 SHORT $LN6@strtoull
  00101	72 04		 jb	 SHORT $LN33@strtoull
  00103	3b f1		 cmp	 esi, ecx
  00105	77 42		 ja	 SHORT $LN6@strtoull
$LN33@strtoull:
  00107	3b f1		 cmp	 esi, ecx
  00109	75 09		 jne	 SHORT $LN7@strtoull
  0010b	3b d8		 cmp	 ebx, eax
  0010d	75 05		 jne	 SHORT $LN7@strtoull
  0010f	3b 55 dc	 cmp	 edx, DWORD PTR tv213[ebp]
  00112	7f 35		 jg	 SHORT $LN6@strtoull
$LN7@strtoull:

; 59   :     else {
; 60   :       any = 1;
; 61   :       acc *= base;

  00114	8b 4d f0	 mov	 ecx, DWORD PTR tv247[ebp+4]
  00117	8b 55 ec	 mov	 edx, DWORD PTR tv247[ebp]
  0011a	53		 push	 ebx
  0011b	56		 push	 esi
  0011c	51		 push	 ecx
  0011d	52		 push	 edx
  0011e	bf 01 00 00 00	 mov	 edi, 1
  00123	e8 00 00 00 00	 call	 __allmul

; 62   :       acc += c;

  00128	8b 4d e4	 mov	 ecx, DWORD PTR _cutoff$[ebp]
  0012b	8b f0		 mov	 esi, eax
  0012d	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00130	8b da		 mov	 ebx, edx
  00132	99		 cdq
  00133	03 f0		 add	 esi, eax
  00135	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00138	13 da		 adc	 ebx, edx
  0013a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0013d	40		 inc	 eax
  0013e	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
  00141	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00144	e9 77 ff ff ff	 jmp	 $LL15@strtoull
$LN6@strtoull:

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  00149	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0014c	0f be 10	 movsx	 edx, BYTE PTR [eax]

; 58   :       any = -1;

  0014f	83 cf ff	 or	 edi, -1
  00152	40		 inc	 eax
  00153	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
  00156	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00159	e9 62 ff ff ff	 jmp	 $LL15@strtoull
$LN32@strtoull:

; 63   :     }
; 64   :   }
; 65   :   if (any < 0)

  0015e	85 ff		 test	 edi, edi
  00160	79 13		 jns	 SHORT $LN4@strtoull

; 66   :   {
; 67   :     acc = ULLONG_MAX;

  00162	83 ce ff	 or	 esi, -1
  00165	83 cb ff	 or	 ebx, -1

; 68   :     errno = ERANGE;

  00168	e8 00 00 00 00	 call	 ___errno
  0016d	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00173	eb 0d		 jmp	 SHORT $LN2@strtoull
$LN4@strtoull:

; 69   :   }
; 70   :   else if (neg)

  00175	83 7d f4 00	 cmp	 DWORD PTR _neg$[ebp], 0
  00179	74 07		 je	 SHORT $LN2@strtoull

; 71   :     acc = 0-acc;

  0017b	f7 de		 neg	 esi
  0017d	83 d3 00	 adc	 ebx, 0
  00180	f7 db		 neg	 ebx
$LN2@strtoull:

; 72   :   if (endptr != 0)

  00182	8b 4d 0c	 mov	 ecx, DWORD PTR _endptr$[ebp]
  00185	85 c9		 test	 ecx, ecx
  00187	74 1a		 je	 SHORT $LN34@strtoull

; 73   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  00189	85 ff		 test	 edi, edi
  0018b	74 11		 je	 SHORT $LN28@strtoull
  0018d	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00190	48		 dec	 eax
  00191	5f		 pop	 edi
  00192	89 01		 mov	 DWORD PTR [ecx], eax

; 74   :   return acc;

  00194	8b c6		 mov	 eax, esi
  00196	5e		 pop	 esi
  00197	8b d3		 mov	 edx, ebx
  00199	5b		 pop	 ebx

; 75   : }

  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
$LN28@strtoull:

; 73   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  0019e	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
  001a1	89 01		 mov	 DWORD PTR [ecx], eax
$LN34@strtoull:

; 74   :   return acc;

  001a3	5f		 pop	 edi
  001a4	8b c6		 mov	 eax, esi
  001a6	5e		 pop	 esi
  001a7	8b d3		 mov	 edx, ebx
  001a9	5b		 pop	 ebx

; 75   : }

  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
_strtoull ENDP
_TEXT	ENDS
END
