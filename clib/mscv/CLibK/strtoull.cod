; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\string\strtoull.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoull
EXTRN	___errno:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\string\strtoull.c
;	COMDAT _strtoull
_TEXT	SEGMENT
tv183 = -40						; size = 4
tv182 = -36						; size = 4
_cutlim$1$ = -32					; size = 4
tv326 = -28						; size = 8
_cutoff$2$ = -24					; size = 4
tv174 = -20						; size = 4
_neg$1$ = -16						; size = 4
_cutoff$1$ = -12					; size = 4
_any$1$ = -8						; size = 4
_c$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoull PROC						; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 17   :   const char *s = nptr;

  00007	8b 75 08	 mov	 esi, DWORD PTR _nptr$[ebp]
  0000a	57		 push	 edi

; 18   :   unsigned long long acc;
; 19   :   int c;
; 20   :   unsigned long long cutoff;
; 21   :   int neg = 0, any, cutlim;

  0000b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 0
$LL25@strtoull:

; 22   : 
; 23   :   /*
; 24   :    * See strtol for comments as to the logic used.
; 25   :    */
; 26   :   do {
; 27   :     c = *s++;

  00012	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00015	46		 inc	 esi

; 28   :   } while (isspace(c));

  00016	0f b6 c8	 movzx	 ecx, al
  00019	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
  0001c	f6 81 00 00 00
	00 20		 test	 BYTE PTR __ctype[ecx], 32 ; 00000020H
  00023	75 ed		 jne	 SHORT $LL25@strtoull

; 29   :   if (c == '-')

  00025	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00028	75 09		 jne	 SHORT $LN22@strtoull

; 30   :   {
; 31   :     neg = 1;

  0002a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 1

; 32   :     c = *s++;

  00031	eb 05		 jmp	 SHORT $LN40@strtoull
$LN22@strtoull:

; 33   :   }
; 34   :   else if (c == '+')

  00033	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00036	75 07		 jne	 SHORT $LN20@strtoull
$LN40@strtoull:

; 35   :     c = *s++;

  00038	0f be 06	 movsx	 eax, BYTE PTR [esi]
  0003b	46		 inc	 esi
  0003c	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
$LN20@strtoull:

; 36   :   if ((base == 0 || base == 16) &&
; 37   :       c == '0' && (*s == 'x' || *s == 'X'))

  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _base$[ebp]
  00042	85 c9		 test	 ecx, ecx
  00044	74 05		 je	 SHORT $LN18@strtoull
  00046	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00049	75 22		 jne	 SHORT $LN19@strtoull
$LN18@strtoull:
  0004b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0004e	75 1d		 jne	 SHORT $LN19@strtoull
  00050	8a 16		 mov	 dl, BYTE PTR [esi]
  00052	80 fa 78	 cmp	 dl, 120			; 00000078H
  00055	74 05		 je	 SHORT $LN17@strtoull
  00057	80 fa 58	 cmp	 dl, 88			; 00000058H
  0005a	75 11		 jne	 SHORT $LN19@strtoull
$LN17@strtoull:

; 38   :   {
; 39   :     c = s[1];

  0005c	0f be 46 01	 movsx	 eax, BYTE PTR [esi+1]

; 40   :     s += 2;
; 41   :     base = 16;

  00060	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00065	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
  00068	83 c6 02	 add	 esi, 2

; 42   :   }
; 43   :   if (base == 0)

  0006b	eb 11		 jmp	 SHORT $LN41@strtoull
$LN19@strtoull:
  0006d	85 c9		 test	 ecx, ecx
  0006f	75 10		 jne	 SHORT $LN16@strtoull

; 44   :     base = c == '0' ? 8 : 10;

  00071	83 f8 30	 cmp	 eax, 48			; 00000030H
  00074	0f 95 c1	 setne	 cl
  00077	8d 0c 4d 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+8]
$LN41@strtoull:
  0007e	89 4d 10	 mov	 DWORD PTR _base$[ebp], ecx
$LN16@strtoull:

; 45   :   cutoff = (unsigned long long)ULLONG_MAX / (unsigned long long)base;

  00081	8b c1		 mov	 eax, ecx
  00083	99		 cdq
  00084	53		 push	 ebx
  00085	8b c8		 mov	 ecx, eax
  00087	8b c2		 mov	 eax, edx
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	6a ff		 push	 -1
  0008d	6a ff		 push	 -1
  0008f	89 4d d8	 mov	 DWORD PTR tv183[ebp], ecx
  00092	89 45 dc	 mov	 DWORD PTR tv182[ebp], eax
  00095	e8 00 00 00 00	 call	 __aulldvrm
  0009a	89 5d e8	 mov	 DWORD PTR tv326[ebp+4], ebx

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  0009d	33 ff		 xor	 edi, edi
  0009f	8b 5d fc	 mov	 ebx, DWORD PTR _c$1$[ebp]
  000a2	89 4d e0	 mov	 DWORD PTR _cutlim$1$[ebp], ecx
  000a5	33 c9		 xor	 ecx, ecx
  000a7	89 55 e8	 mov	 DWORD PTR _cutoff$2$[ebp], edx
  000aa	33 d2		 xor	 edx, edx
  000ac	89 45 f4	 mov	 DWORD PTR _cutoff$1$[ebp], eax
  000af	89 55 f8	 mov	 DWORD PTR _any$1$[ebp], edx
  000b2	c7 45 ec 37 00
	00 00		 mov	 DWORD PTR tv174[ebp], 55 ; 00000037H
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL15@strtoull:

; 48   :   {
; 49   :     if (isdigit(c))

  000c0	0f b6 c3	 movzx	 eax, bl
  000c3	8a 80 00 00 00
	00		 mov	 al, BYTE PTR __ctype[eax]
  000c9	a8 04		 test	 al, 4
  000cb	74 05		 je	 SHORT $LN12@strtoull

; 50   :       c -= '0';

  000cd	83 eb 30	 sub	 ebx, 48			; 00000030H
  000d0	eb 11		 jmp	 SHORT $LN9@strtoull
$LN12@strtoull:

; 51   :     else if (isalpha(c))

  000d2	a8 03		 test	 al, 3
  000d4	74 69		 je	 SHORT $LN32@strtoull

; 52   :       c -= isupper(c) ? 'A' - 10 : 'a' - 10;

  000d6	a8 01		 test	 al, 1
  000d8	b8 57 00 00 00	 mov	 eax, 87			; 00000057H
  000dd	0f 45 45 ec	 cmovne	 eax, DWORD PTR tv174[ebp]
  000e1	2b d8		 sub	 ebx, eax
$LN9@strtoull:

; 53   :     else
; 54   :       break;
; 55   :     if (c >= base)

  000e3	3b 5d 10	 cmp	 ebx, DWORD PTR _base$[ebp]
  000e6	7d 57		 jge	 SHORT $LN32@strtoull

; 56   :       break;
; 57   :     if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000e8	85 d2		 test	 edx, edx
  000ea	78 47		 js	 SHORT $LN6@strtoull
  000ec	8b 55 e8	 mov	 edx, DWORD PTR _cutoff$2$[ebp]
  000ef	3b fa		 cmp	 edi, edx
  000f1	77 40		 ja	 SHORT $LN6@strtoull
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _cutoff$1$[ebp]
  000f6	72 04		 jb	 SHORT $LN37@strtoull
  000f8	3b c8		 cmp	 ecx, eax
  000fa	77 37		 ja	 SHORT $LN6@strtoull
$LN37@strtoull:
  000fc	3b c8		 cmp	 ecx, eax
  000fe	75 09		 jne	 SHORT $LN7@strtoull
  00100	3b fa		 cmp	 edi, edx
  00102	75 05		 jne	 SHORT $LN7@strtoull
  00104	3b 5d e0	 cmp	 ebx, DWORD PTR _cutlim$1$[ebp]
  00107	7f 2a		 jg	 SHORT $LN6@strtoull
$LN7@strtoull:

; 59   :     else {
; 60   :       any = 1;
; 61   :       acc *= base;

  00109	57		 push	 edi
  0010a	51		 push	 ecx
  0010b	ff 75 dc	 push	 DWORD PTR tv182[ebp]
  0010e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _any$1$[ebp], 1
  00115	ff 75 d8	 push	 DWORD PTR tv183[ebp]
  00118	e8 00 00 00 00	 call	 __allmul
  0011d	8b c8		 mov	 ecx, eax
  0011f	8b fa		 mov	 edi, edx

; 62   :       acc += c;

  00121	8b c3		 mov	 eax, ebx
  00123	0f be 1e	 movsx	 ebx, BYTE PTR [esi]
  00126	99		 cdq
  00127	03 c8		 add	 ecx, eax
  00129	13 fa		 adc	 edi, edx
  0012b	ba 01 00 00 00	 mov	 edx, 1
  00130	46		 inc	 esi
  00131	eb 8d		 jmp	 SHORT $LL15@strtoull
$LN6@strtoull:

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  00133	0f be 1e	 movsx	 ebx, BYTE PTR [esi]

; 58   :       any = -1;

  00136	83 ca ff	 or	 edx, -1
  00139	89 55 f8	 mov	 DWORD PTR _any$1$[ebp], edx
  0013c	46		 inc	 esi
  0013d	eb 81		 jmp	 SHORT $LL15@strtoull
$LN32@strtoull:
  0013f	5b		 pop	 ebx

; 63   :     }
; 64   :   }
; 65   :   if (any < 0)

  00140	85 d2		 test	 edx, edx
  00142	79 16		 jns	 SHORT $LN4@strtoull

; 66   :   {
; 67   :     acc = ULLONG_MAX;

  00144	83 cf ff	 or	 edi, -1

; 68   :     errno = ERANGE;

  00147	e8 00 00 00 00	 call	 ___errno
  0014c	8b 55 f8	 mov	 edx, DWORD PTR _any$1$[ebp]
  0014f	83 c9 ff	 or	 ecx, -1
  00152	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  00158	eb 0d		 jmp	 SHORT $LN2@strtoull
$LN4@strtoull:

; 69   :   }
; 70   :   else if (neg)

  0015a	83 7d f0 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  0015e	74 07		 je	 SHORT $LN2@strtoull

; 71   :     acc = 0-acc;

  00160	f7 d9		 neg	 ecx
  00162	83 d7 00	 adc	 edi, 0
  00165	f7 df		 neg	 edi
$LN2@strtoull:

; 72   :   if (endptr != 0)

  00167	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  0016a	85 c0		 test	 eax, eax
  0016c	74 0c		 je	 SHORT $LN38@strtoull

; 73   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  0016e	85 d2		 test	 edx, edx
  00170	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00173	75 03		 jne	 SHORT $LN29@strtoull
  00175	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
$LN29@strtoull:
  00178	89 10		 mov	 DWORD PTR [eax], edx
$LN38@strtoull:

; 74   :   return acc;

  0017a	8b d7		 mov	 edx, edi
  0017c	8b c1		 mov	 eax, ecx
  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi

; 75   : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_strtoull ENDP
_TEXT	ENDS
END
