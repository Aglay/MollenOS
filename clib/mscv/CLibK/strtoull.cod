; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Phail\Documents\GitHub\MollenOS\clib\src\string\strtoull.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoull
EXTRN	___errno:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldvrm:PROC
EXTRN	__ctype:BYTE
; Function compile flags: /Ogtp
; File c:\users\phail\documents\github\mollenos\clib\src\string\strtoull.c
;	COMDAT _strtoull
_TEXT	SEGMENT
tv326 = -44						; size = 8
_acc$ = -44						; size = 8
tv182 = -36						; size = 4
tv181 = -32						; size = 4
_cutlim$1$ = -28					; size = 4
_cutoff$2$ = -24					; size = 4
tv173 = -20						; size = 4
_neg$1$ = -16						; size = 4
_cutoff$1$ = -12					; size = 4
_any$1$ = -8						; size = 4
_c$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoull PROC						; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi

; 17   :   const char *s = nptr;

  00007	8b 75 08	 mov	 esi, DWORD PTR _nptr$[ebp]
  0000a	57		 push	 edi

; 18   :   unsigned long long acc;
; 19   :   int c;
; 20   :   unsigned long long cutoff;
; 21   :   int neg = 0, any, cutlim;

  0000b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 0
$LL25@strtoull:

; 22   : 
; 23   :   /*
; 24   :    * See strtol for comments as to the logic used.
; 25   :    */
; 26   :   do {
; 27   :     c = *s++;

  00012	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00015	46		 inc	 esi

; 28   :   } while (isspace(c));

  00016	0f b6 c8	 movzx	 ecx, al
  00019	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
  0001c	f6 81 00 00 00
	00 20		 test	 BYTE PTR __ctype[ecx], 32 ; 00000020H
  00023	75 ed		 jne	 SHORT $LL25@strtoull

; 29   :   if (c == '-')

  00025	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00028	75 09		 jne	 SHORT $LN22@strtoull

; 30   :   {
; 31   :     neg = 1;

  0002a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 1

; 32   :     c = *s++;

  00031	eb 05		 jmp	 SHORT $LN40@strtoull
$LN22@strtoull:

; 33   :   }
; 34   :   else if (c == '+')

  00033	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00036	75 07		 jne	 SHORT $LN20@strtoull
$LN40@strtoull:

; 35   :     c = *s++;

  00038	0f be 06	 movsx	 eax, BYTE PTR [esi]
  0003b	46		 inc	 esi
  0003c	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
$LN20@strtoull:

; 36   :   if ((base == 0 || base == 16) &&
; 37   :       c == '0' && (*s == 'x' || *s == 'X'))

  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _base$[ebp]
  00042	85 c9		 test	 ecx, ecx
  00044	74 05		 je	 SHORT $LN18@strtoull
  00046	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00049	75 22		 jne	 SHORT $LN19@strtoull
$LN18@strtoull:
  0004b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0004e	75 1d		 jne	 SHORT $LN19@strtoull
  00050	8a 16		 mov	 dl, BYTE PTR [esi]
  00052	80 fa 78	 cmp	 dl, 120			; 00000078H
  00055	74 05		 je	 SHORT $LN17@strtoull
  00057	80 fa 58	 cmp	 dl, 88			; 00000058H
  0005a	75 11		 jne	 SHORT $LN19@strtoull
$LN17@strtoull:

; 38   :   {
; 39   :     c = s[1];

  0005c	0f be 46 01	 movsx	 eax, BYTE PTR [esi+1]

; 40   :     s += 2;
; 41   :     base = 16;

  00060	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00065	89 45 fc	 mov	 DWORD PTR _c$1$[ebp], eax
  00068	83 c6 02	 add	 esi, 2

; 42   :   }
; 43   :   if (base == 0)

  0006b	eb 11		 jmp	 SHORT $LN41@strtoull
$LN19@strtoull:
  0006d	85 c9		 test	 ecx, ecx
  0006f	75 10		 jne	 SHORT $LN16@strtoull

; 44   :     base = c == '0' ? 8 : 10;

  00071	83 f8 30	 cmp	 eax, 48			; 00000030H
  00074	0f 95 c1	 setne	 cl
  00077	8d 0c 4d 08 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+8]
$LN41@strtoull:
  0007e	89 4d 10	 mov	 DWORD PTR _base$[ebp], ecx
$LN16@strtoull:

; 45   :   cutoff = (unsigned long long)ULLONG_MAX / (unsigned long long)base;

  00081	8b c1		 mov	 eax, ecx
  00083	99		 cdq
  00084	53		 push	 ebx
  00085	8b c8		 mov	 ecx, eax
  00087	8b c2		 mov	 eax, edx
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	6a ff		 push	 -1
  0008d	6a ff		 push	 -1
  0008f	89 4d dc	 mov	 DWORD PTR tv182[ebp], ecx
  00092	89 45 e0	 mov	 DWORD PTR tv181[ebp], eax
  00095	e8 00 00 00 00	 call	 __aulldvrm
  0009a	89 5d d8	 mov	 DWORD PTR tv326[ebp+4], ebx
  0009d	0f 57 c0	 xorps	 xmm0, xmm0
  000a0	8b 5d fc	 mov	 ebx, DWORD PTR _c$1$[ebp]
  000a3	89 55 e8	 mov	 DWORD PTR _cutoff$2$[ebp], edx

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  000a6	33 d2		 xor	 edx, edx
  000a8	66 0f 13 45 d4	 movlpd	 QWORD PTR _acc$[ebp], xmm0
  000ad	8b 7d d8	 mov	 edi, DWORD PTR _acc$[ebp+4]
  000b0	89 4d e4	 mov	 DWORD PTR _cutlim$1$[ebp], ecx
  000b3	8b 4d d4	 mov	 ecx, DWORD PTR _acc$[ebp]
  000b6	89 45 f4	 mov	 DWORD PTR _cutoff$1$[ebp], eax
  000b9	89 55 f8	 mov	 DWORD PTR _any$1$[ebp], edx
  000bc	c7 45 ec 37 00
	00 00		 mov	 DWORD PTR tv173[ebp], 55 ; 00000037H
$LL15@strtoull:

; 48   :   {
; 49   :     if (isdigit(c))

  000c3	0f b6 c3	 movzx	 eax, bl
  000c6	8a 80 00 00 00
	00		 mov	 al, BYTE PTR __ctype[eax]
  000cc	a8 04		 test	 al, 4
  000ce	74 05		 je	 SHORT $LN12@strtoull

; 50   :       c -= '0';

  000d0	83 eb 30	 sub	 ebx, 48			; 00000030H
  000d3	eb 11		 jmp	 SHORT $LN9@strtoull
$LN12@strtoull:

; 51   :     else if (isalpha(c))

  000d5	a8 03		 test	 al, 3
  000d7	74 69		 je	 SHORT $LN32@strtoull

; 52   :       c -= isupper(c) ? 'A' - 10 : 'a' - 10;

  000d9	a8 01		 test	 al, 1
  000db	b8 57 00 00 00	 mov	 eax, 87			; 00000057H
  000e0	0f 45 45 ec	 cmovne	 eax, DWORD PTR tv173[ebp]
  000e4	2b d8		 sub	 ebx, eax
$LN9@strtoull:

; 53   :     else
; 54   :       break;
; 55   :     if (c >= base)

  000e6	3b 5d 10	 cmp	 ebx, DWORD PTR _base$[ebp]
  000e9	7d 57		 jge	 SHORT $LN32@strtoull

; 56   :       break;
; 57   :     if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000eb	85 d2		 test	 edx, edx
  000ed	78 47		 js	 SHORT $LN6@strtoull
  000ef	8b 55 e8	 mov	 edx, DWORD PTR _cutoff$2$[ebp]
  000f2	3b fa		 cmp	 edi, edx
  000f4	77 40		 ja	 SHORT $LN6@strtoull
  000f6	8b 45 f4	 mov	 eax, DWORD PTR _cutoff$1$[ebp]
  000f9	72 04		 jb	 SHORT $LN37@strtoull
  000fb	3b c8		 cmp	 ecx, eax
  000fd	77 37		 ja	 SHORT $LN6@strtoull
$LN37@strtoull:
  000ff	3b c8		 cmp	 ecx, eax
  00101	75 09		 jne	 SHORT $LN7@strtoull
  00103	3b fa		 cmp	 edi, edx
  00105	75 05		 jne	 SHORT $LN7@strtoull
  00107	3b 5d e4	 cmp	 ebx, DWORD PTR _cutlim$1$[ebp]
  0010a	7f 2a		 jg	 SHORT $LN6@strtoull
$LN7@strtoull:

; 59   :     else {
; 60   :       any = 1;
; 61   :       acc *= base;

  0010c	57		 push	 edi
  0010d	51		 push	 ecx
  0010e	ff 75 e0	 push	 DWORD PTR tv181[ebp]
  00111	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _any$1$[ebp], 1
  00118	ff 75 dc	 push	 DWORD PTR tv182[ebp]
  0011b	e8 00 00 00 00	 call	 __allmul
  00120	8b c8		 mov	 ecx, eax
  00122	8b fa		 mov	 edi, edx

; 62   :       acc += c;

  00124	8b c3		 mov	 eax, ebx
  00126	0f be 1e	 movsx	 ebx, BYTE PTR [esi]
  00129	99		 cdq
  0012a	03 c8		 add	 ecx, eax
  0012c	13 fa		 adc	 edi, edx
  0012e	ba 01 00 00 00	 mov	 edx, 1
  00133	46		 inc	 esi
  00134	eb 8d		 jmp	 SHORT $LL15@strtoull
$LN6@strtoull:

; 46   :   cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 47   :   for (acc = 0, any = 0;; c = *s++)

  00136	0f be 1e	 movsx	 ebx, BYTE PTR [esi]

; 58   :       any = -1;

  00139	83 ca ff	 or	 edx, -1
  0013c	89 55 f8	 mov	 DWORD PTR _any$1$[ebp], edx
  0013f	46		 inc	 esi
  00140	eb 81		 jmp	 SHORT $LL15@strtoull
$LN32@strtoull:
  00142	5b		 pop	 ebx

; 63   :     }
; 64   :   }
; 65   :   if (any < 0)

  00143	85 d2		 test	 edx, edx
  00145	79 16		 jns	 SHORT $LN4@strtoull

; 66   :   {
; 67   :     acc = ULLONG_MAX;

  00147	83 cf ff	 or	 edi, -1

; 68   :     errno = ERANGE;

  0014a	e8 00 00 00 00	 call	 ___errno
  0014f	8b 55 f8	 mov	 edx, DWORD PTR _any$1$[ebp]
  00152	83 c9 ff	 or	 ecx, -1
  00155	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  0015b	eb 0d		 jmp	 SHORT $LN2@strtoull
$LN4@strtoull:

; 69   :   }
; 70   :   else if (neg)

  0015d	83 7d f0 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  00161	74 07		 je	 SHORT $LN2@strtoull

; 71   :     acc = 0-acc;

  00163	f7 d9		 neg	 ecx
  00165	83 d7 00	 adc	 edi, 0
  00168	f7 df		 neg	 edi
$LN2@strtoull:

; 72   :   if (endptr != 0)

  0016a	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  0016d	85 c0		 test	 eax, eax
  0016f	74 0c		 je	 SHORT $LN38@strtoull

; 73   :     *endptr = any ? (char *)((size_t)(s - 1)) : (char *)((size_t)nptr);

  00171	85 d2		 test	 edx, edx
  00173	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00176	75 03		 jne	 SHORT $LN29@strtoull
  00178	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
$LN29@strtoull:
  0017b	89 10		 mov	 DWORD PTR [eax], edx
$LN38@strtoull:

; 74   :   return acc;

  0017d	8b d7		 mov	 edx, edi
  0017f	8b c1		 mov	 eax, ecx
  00181	5f		 pop	 edi
  00182	5e		 pop	 esi

; 75   : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
_strtoull ENDP
_TEXT	ENDS
END
