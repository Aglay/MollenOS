; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Philip\Documents\GitHub\MollenOS\clib\src\stdlib\strtoull.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strtoull
EXTRN	___locale_ctype_ptr:PROC
EXTRN	___errno:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldvrm:PROC
; Function compile flags: /Ogtp
; File c:\users\philip\documents\github\mollenos\clib\src\stdlib\strtoull.c
;	COMDAT _strtoull
_TEXT	SEGMENT
tv221 = -32						; size = 4
tv220 = -28						; size = 4
_cutlim$1$ = -24					; size = 4
tv371 = -20						; size = 8
_cutoff$2$ = -16					; size = 4
_neg$1$ = -12						; size = 4
_cutoff$1$ = -8						; size = 4
_any$1$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtoull PROC						; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 49   : 	register const unsigned char *s = (const unsigned char *)nptr;

  00009	8b 7d 08	 mov	 edi, DWORD PTR _nptr$[ebp]

; 50   : 	register unsigned long long acc;
; 51   : 	register int c;
; 52   : 	register unsigned long long cutoff;
; 53   : 	register int neg = 0, any, cutlim;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 0
$LL27@strtoull:

; 54   : 
; 55   : 	/*
; 56   : 	* See strtol for comments as to the logic used.
; 57   : 	*/
; 58   : 	do {
; 59   : 		c = *s++;

  00013	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00016	47		 inc	 edi

; 60   : 	} while (isspace(c));

  00017	e8 00 00 00 00	 call	 ___locale_ctype_ptr
  0001c	f6 44 30 01 08	 test	 BYTE PTR [eax+esi+1], 8
  00021	75 f0		 jne	 SHORT $LL27@strtoull

; 61   : 	if (c == '-') {

  00023	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  00026	75 09		 jne	 SHORT $LN24@strtoull

; 62   : 		neg = 1;

  00028	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _neg$1$[ebp], 1

; 63   : 		c = *s++;

  0002f	eb 05		 jmp	 SHORT $LN42@strtoull
$LN24@strtoull:

; 64   : 	}
; 65   : 	else if (c == '+')

  00031	83 fe 2b	 cmp	 esi, 43			; 0000002bH
  00034	75 04		 jne	 SHORT $LN22@strtoull
$LN42@strtoull:

; 66   : 		c = *s++;

  00036	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00039	47		 inc	 edi
$LN22@strtoull:

; 67   : 	if ((base == 0 || base == 16) &&
; 68   : 		c == '0' && (*s == 'x' || *s == 'X')) {

  0003a	8b 45 10	 mov	 eax, DWORD PTR _base$[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 05		 je	 SHORT $LN20@strtoull
  00041	83 f8 10	 cmp	 eax, 16			; 00000010H
  00044	75 1f		 jne	 SHORT $LN21@strtoull
$LN20@strtoull:
  00046	83 fe 30	 cmp	 esi, 48			; 00000030H
  00049	75 1a		 jne	 SHORT $LN21@strtoull
  0004b	8a 0f		 mov	 cl, BYTE PTR [edi]
  0004d	80 f9 78	 cmp	 cl, 120			; 00000078H
  00050	74 05		 je	 SHORT $LN19@strtoull
  00052	80 f9 58	 cmp	 cl, 88			; 00000058H
  00055	75 0e		 jne	 SHORT $LN21@strtoull
$LN19@strtoull:

; 69   : 		c = s[1];

  00057	0f b6 77 01	 movzx	 esi, BYTE PTR [edi+1]

; 70   : 		s += 2;
; 71   : 		base = 16;

  0005b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00060	83 c7 02	 add	 edi, 2

; 72   : 	}
; 73   : 	if (base == 0)

  00063	eb 11		 jmp	 SHORT $LN43@strtoull
$LN21@strtoull:
  00065	85 c0		 test	 eax, eax
  00067	75 10		 jne	 SHORT $LN18@strtoull

; 74   : 		base = c == '0' ? 8 : 10;

  00069	83 fe 30	 cmp	 esi, 48			; 00000030H
  0006c	0f 95 c0	 setne	 al
  0006f	8d 04 45 08 00
	00 00		 lea	 eax, DWORD PTR [eax*2+8]
$LN43@strtoull:
  00076	89 45 10	 mov	 DWORD PTR _base$[ebp], eax
$LN18@strtoull:

; 75   : 	cutoff = (unsigned long long)ULLONG_MAX / (unsigned long long)base;

  00079	99		 cdq
  0007a	8b c8		 mov	 ecx, eax
  0007c	8b c2		 mov	 eax, edx
  0007e	50		 push	 eax
  0007f	51		 push	 ecx
  00080	6a ff		 push	 -1
  00082	6a ff		 push	 -1
  00084	89 4d e0	 mov	 DWORD PTR tv221[ebp], ecx
  00087	89 45 e4	 mov	 DWORD PTR tv220[ebp], eax
  0008a	e8 00 00 00 00	 call	 __aulldvrm
  0008f	89 5d f0	 mov	 DWORD PTR tv371[ebp+4], ebx

; 76   : 	cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 77   : 	for (acc = 0, any = 0;; c = *s++) {

  00092	33 db		 xor	 ebx, ebx
  00094	89 4d e8	 mov	 DWORD PTR _cutlim$1$[ebp], ecx
  00097	33 c9		 xor	 ecx, ecx
  00099	89 55 f0	 mov	 DWORD PTR _cutoff$2$[ebp], edx
  0009c	33 d2		 xor	 edx, edx
  0009e	89 45 f8	 mov	 DWORD PTR _cutoff$1$[ebp], eax
  000a1	89 55 fc	 mov	 DWORD PTR _any$1$[ebp], edx
$LL17@strtoull:

; 78   : 		if (c >= '0' && c <= '9')

  000a4	8d 46 d0	 lea	 eax, DWORD PTR [esi-48]
  000a7	83 f8 09	 cmp	 eax, 9
  000aa	77 04		 ja	 SHORT $LN14@strtoull

; 79   : 			c -= '0';

  000ac	8b f0		 mov	 esi, eax
  000ae	eb 18		 jmp	 SHORT $LN9@strtoull
$LN14@strtoull:

; 80   : 		else if (c >= 'A' && c <= 'Z')

  000b0	8d 46 bf	 lea	 eax, DWORD PTR [esi-65]
  000b3	83 f8 19	 cmp	 eax, 25			; 00000019H
  000b6	77 05		 ja	 SHORT $LN12@strtoull

; 81   : 			c -= 'A' - 10;

  000b8	83 ee 37	 sub	 esi, 55			; 00000037H
  000bb	eb 0b		 jmp	 SHORT $LN9@strtoull
$LN12@strtoull:

; 82   : 		else if (c >= 'a' && c <= 'z')

  000bd	8d 46 9f	 lea	 eax, DWORD PTR [esi-97]
  000c0	83 f8 19	 cmp	 eax, 25			; 00000019H
  000c3	77 5f		 ja	 SHORT $LN34@strtoull

; 83   : 			c -= 'a' - 10;

  000c5	83 ee 57	 sub	 esi, 87			; 00000057H
$LN9@strtoull:

; 84   : 		else
; 85   : 			break;
; 86   : 		if (c >= base)

  000c8	3b 75 10	 cmp	 esi, DWORD PTR _base$[ebp]
  000cb	7d 57		 jge	 SHORT $LN34@strtoull

; 87   : 			break;
; 88   : 		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))

  000cd	85 d2		 test	 edx, edx
  000cf	78 47		 js	 SHORT $LN6@strtoull
  000d1	8b 55 f0	 mov	 edx, DWORD PTR _cutoff$2$[ebp]
  000d4	3b da		 cmp	 ebx, edx
  000d6	77 40		 ja	 SHORT $LN6@strtoull
  000d8	8b 45 f8	 mov	 eax, DWORD PTR _cutoff$1$[ebp]
  000db	72 04		 jb	 SHORT $LN39@strtoull
  000dd	3b c8		 cmp	 ecx, eax
  000df	77 37		 ja	 SHORT $LN6@strtoull
$LN39@strtoull:
  000e1	3b c8		 cmp	 ecx, eax
  000e3	75 09		 jne	 SHORT $LN7@strtoull
  000e5	3b da		 cmp	 ebx, edx
  000e7	75 05		 jne	 SHORT $LN7@strtoull
  000e9	3b 75 e8	 cmp	 esi, DWORD PTR _cutlim$1$[ebp]
  000ec	7f 2a		 jg	 SHORT $LN6@strtoull
$LN7@strtoull:

; 90   : 		else {
; 91   : 			any = 1;
; 92   : 			acc *= base;

  000ee	53		 push	 ebx
  000ef	51		 push	 ecx
  000f0	ff 75 e4	 push	 DWORD PTR tv220[ebp]
  000f3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _any$1$[ebp], 1
  000fa	ff 75 e0	 push	 DWORD PTR tv221[ebp]
  000fd	e8 00 00 00 00	 call	 __allmul
  00102	8b c8		 mov	 ecx, eax
  00104	8b da		 mov	 ebx, edx

; 93   : 			acc += c;

  00106	8b c6		 mov	 eax, esi
  00108	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  0010b	99		 cdq
  0010c	03 c8		 add	 ecx, eax
  0010e	13 da		 adc	 ebx, edx
  00110	ba 01 00 00 00	 mov	 edx, 1
  00115	47		 inc	 edi
  00116	eb 8c		 jmp	 SHORT $LL17@strtoull
$LN6@strtoull:

; 76   : 	cutlim = (unsigned long long)ULLONG_MAX % (unsigned long long)base;
; 77   : 	for (acc = 0, any = 0;; c = *s++) {

  00118	0f b6 37	 movzx	 esi, BYTE PTR [edi]

; 89   : 			any = -1;

  0011b	83 ca ff	 or	 edx, -1
  0011e	89 55 fc	 mov	 DWORD PTR _any$1$[ebp], edx
  00121	47		 inc	 edi
  00122	eb 80		 jmp	 SHORT $LL17@strtoull
$LN34@strtoull:

; 94   : 		}
; 95   : 	}
; 96   : 	if (any < 0) {

  00124	85 d2		 test	 edx, edx
  00126	79 16		 jns	 SHORT $LN4@strtoull

; 97   : 		acc = ULLONG_MAX;

  00128	83 cb ff	 or	 ebx, -1

; 98   : 		_set_errno(ERANGE);

  0012b	e8 00 00 00 00	 call	 ___errno
  00130	8b 55 fc	 mov	 edx, DWORD PTR _any$1$[ebp]
  00133	83 c9 ff	 or	 ecx, -1
  00136	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  0013c	eb 0d		 jmp	 SHORT $LN2@strtoull
$LN4@strtoull:

; 99   : 	}
; 100  : 	else if (neg)

  0013e	83 7d f4 00	 cmp	 DWORD PTR _neg$1$[ebp], 0
  00142	74 07		 je	 SHORT $LN2@strtoull

; 101  : 		acc = -acc;

  00144	f7 d9		 neg	 ecx
  00146	83 d3 00	 adc	 ebx, 0
  00149	f7 db		 neg	 ebx
$LN2@strtoull:

; 102  : 	if (endptr != 0)

  0014b	8b 45 0c	 mov	 eax, DWORD PTR _endptr$[ebp]
  0014e	85 c0		 test	 eax, eax
  00150	74 0c		 je	 SHORT $LN40@strtoull

; 103  : 		*endptr = (char *)(any ? (char *)s - 1 : nptr);

  00152	85 d2		 test	 edx, edx
  00154	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  00157	75 03		 jne	 SHORT $LN31@strtoull
  00159	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
$LN31@strtoull:
  0015c	89 10		 mov	 DWORD PTR [eax], edx
$LN40@strtoull:
  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi

; 104  : 	return (acc);

  00160	8b d3		 mov	 edx, ebx
  00162	8b c1		 mov	 eax, ecx
  00164	5b		 pop	 ebx

; 105  : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
_strtoull ENDP
_TEXT	ENDS
END
