Index: include/llvm/ADT/Triple.h
===================================================================
--- include/llvm/ADT/Triple.h	(revision 319878)
+++ include/llvm/ADT/Triple.h	(working copy)
@@ -144,7 +144,8 @@
     AMD,
     Mesa,
     SUSE,
-    LastVendorType = SUSE
+    Nordic,
+    LastVendorType = Nordic
   };
   enum OSType {
     UnknownOS,
@@ -180,7 +181,8 @@
     Mesa3D,
     Contiki,
     AMDPAL,     // AMD PAL Runtime
-    LastOSType = AMDPAL
+    ValiOS,     // ValiOS
+    LastOSType = ValiOS
   };
   enum EnvironmentType {
     UnknownEnvironment,
@@ -563,6 +565,11 @@
     return getOS() == Triple::Win32;
   }
 
+  /// Tests whether the OS is Windows.
+  bool isOSVali() const {
+    return getOS() == Triple::ValiOS;
+  }
+
   /// Tests whether the OS is NaCl (Native Client)
   bool isOSNaCl() const {
     return getOS() == Triple::NaCl;
Index: include/llvm/IR/DataLayout.h
===================================================================
--- include/llvm/IR/DataLayout.h	(revision 319878)
+++ include/llvm/IR/DataLayout.h	(working copy)
@@ -118,8 +118,8 @@
     MM_None,
     MM_ELF,
     MM_MachO,
-    MM_WinCOFF,
-    MM_WinCOFFX86,
+    MM_COFF,
+    MM_COFFX86,
     MM_Mips
   };
   ManglingModeT ManglingMode;
@@ -252,8 +252,8 @@
   unsigned getStackAlignment() const { return StackNaturalAlign; }
   unsigned getAllocaAddrSpace() const { return AllocaAddrSpace; }
 
-  bool hasMicrosoftFastStdCallMangling() const {
-    return ManglingMode == MM_WinCOFFX86;
+  bool hasFastStdCallMangling() const {
+    return (ManglingMode == MM_COFFX86);
   }
 
   bool hasLinkerPrivateGlobalPrefix() const { return ManglingMode == MM_MachO; }
@@ -269,10 +269,10 @@
     case MM_None:
     case MM_ELF:
     case MM_Mips:
-    case MM_WinCOFF:
+    case MM_COFF:
       return '\0';
     case MM_MachO:
-    case MM_WinCOFFX86:
+    case MM_COFFX86:
       return '_';
     }
     llvm_unreachable("invalid mangling mode");
@@ -283,12 +283,12 @@
     case MM_None:
       return "";
     case MM_ELF:
-    case MM_WinCOFF:
+    case MM_COFF:
       return ".L";
     case MM_Mips:
       return "$";
     case MM_MachO:
-    case MM_WinCOFFX86:
+    case MM_COFFX86:
       return "L";
     }
     llvm_unreachable("invalid mangling mode");
Index: include/llvm/MC/MCObjectFileInfo.h
===================================================================
--- include/llvm/MC/MCObjectFileInfo.h	(revision 319878)
+++ include/llvm/MC/MCObjectFileInfo.h	(working copy)
@@ -362,6 +362,8 @@
   MCContext *Ctx;
   Triple TT;
 
+  void selectMCDwarfEncodings(const Triple &T, bool Large);
+
   void initMachOMCObjectFileInfo(const Triple &T);
   void initELFMCObjectFileInfo(const Triple &T, bool Large);
   void initCOFFMCObjectFileInfo(const Triple &T);
Index: include/llvm/Support/TargetRegistry.h
===================================================================
--- include/llvm/Support/TargetRegistry.h	(revision 319878)
+++ include/llvm/Support/TargetRegistry.h	(working copy)
@@ -459,9 +459,8 @@
     default:
       llvm_unreachable("Unknown object format");
     case Triple::COFF:
-      assert(T.isOSWindows() && "only Windows COFF is supported");
       S = COFFStreamerCtorFn(Ctx, std::move(TAB), OS, std::move(Emitter),
-                             RelaxAll, IncrementalLinkerCompatible);
+                        RelaxAll, IncrementalLinkerCompatible);
       break;
     case Triple::MachO:
       if (MachOStreamerCtorFn)
Index: lib/Analysis/TargetLibraryInfo.cpp
===================================================================
--- lib/Analysis/TargetLibraryInfo.cpp	(revision 319878)
+++ lib/Analysis/TargetLibraryInfo.cpp	(working copy)
@@ -143,6 +143,107 @@
     TLI.setUnavailable(LibFunc_fiprintf);
   }
 
+  if (T.isOSVali()) {
+    // These definitions are due to math-finite.h header on Linux
+    TLI.setUnavailable(LibFunc_acos_finite);
+    TLI.setUnavailable(LibFunc_acosf_finite);
+    TLI.setUnavailable(LibFunc_acosl_finite);
+    TLI.setUnavailable(LibFunc_acosh_finite);
+    TLI.setUnavailable(LibFunc_acoshf_finite);
+    TLI.setUnavailable(LibFunc_acoshl_finite);
+    TLI.setUnavailable(LibFunc_asin_finite);
+    TLI.setUnavailable(LibFunc_asinf_finite);
+    TLI.setUnavailable(LibFunc_asinl_finite);
+    TLI.setUnavailable(LibFunc_atan2_finite);
+    TLI.setUnavailable(LibFunc_atan2f_finite);
+    TLI.setUnavailable(LibFunc_atan2l_finite);
+    TLI.setUnavailable(LibFunc_atanh_finite);
+    TLI.setUnavailable(LibFunc_atanhf_finite);
+    TLI.setUnavailable(LibFunc_atanhl_finite);
+    TLI.setUnavailable(LibFunc_cosh_finite);
+    TLI.setUnavailable(LibFunc_coshf_finite);
+    TLI.setUnavailable(LibFunc_coshl_finite);
+    TLI.setUnavailable(LibFunc_exp10_finite);
+    TLI.setUnavailable(LibFunc_exp10f_finite);
+    TLI.setUnavailable(LibFunc_exp10l_finite);
+    TLI.setUnavailable(LibFunc_exp2_finite);
+    TLI.setUnavailable(LibFunc_exp2f_finite);
+    TLI.setUnavailable(LibFunc_exp2l_finite);
+    TLI.setUnavailable(LibFunc_exp_finite);
+    TLI.setUnavailable(LibFunc_expf_finite);
+    TLI.setUnavailable(LibFunc_expl_finite);
+    TLI.setUnavailable(LibFunc_log10_finite);
+    TLI.setUnavailable(LibFunc_log10f_finite);
+    TLI.setUnavailable(LibFunc_log10l_finite);
+    TLI.setUnavailable(LibFunc_log2_finite);
+    TLI.setUnavailable(LibFunc_log2f_finite);
+    TLI.setUnavailable(LibFunc_log2l_finite);
+    TLI.setUnavailable(LibFunc_log_finite);
+    TLI.setUnavailable(LibFunc_logf_finite);
+    TLI.setUnavailable(LibFunc_logl_finite);
+    TLI.setUnavailable(LibFunc_pow_finite);
+    TLI.setUnavailable(LibFunc_powf_finite);
+    TLI.setUnavailable(LibFunc_powl_finite);
+    TLI.setUnavailable(LibFunc_sinh_finite);
+    TLI.setUnavailable(LibFunc_sinhf_finite);
+    TLI.setUnavailable(LibFunc_sinhl_finite);
+    TLI.setUnavailable(LibFunc_access);
+    TLI.setUnavailable(LibFunc_bcmp);
+    TLI.setUnavailable(LibFunc_bcopy);
+    TLI.setUnavailable(LibFunc_bzero);
+    TLI.setUnavailable(LibFunc_chmod);
+    TLI.setUnavailable(LibFunc_chown);
+    TLI.setUnavailable(LibFunc_closedir);
+    TLI.setUnavailable(LibFunc_ctermid);
+    TLI.setUnavailable(LibFunc_fdopen);
+    TLI.setUnavailable(LibFunc_ffs);
+    TLI.setUnavailable(LibFunc_fileno);
+    TLI.setUnavailable(LibFunc_flockfile);
+    TLI.setUnavailable(LibFunc_fseeko);
+    TLI.setUnavailable(LibFunc_fstat);
+    TLI.setUnavailable(LibFunc_fstatvfs);
+    TLI.setUnavailable(LibFunc_ftello);
+    TLI.setUnavailable(LibFunc_ftrylockfile);
+    TLI.setUnavailable(LibFunc_funlockfile);
+    TLI.setUnavailable(LibFunc_getc_unlocked);
+    TLI.setUnavailable(LibFunc_getitimer);
+    TLI.setUnavailable(LibFunc_getlogin_r);
+    TLI.setUnavailable(LibFunc_getpwnam);
+    TLI.setUnavailable(LibFunc_gettimeofday);
+    TLI.setUnavailable(LibFunc_htonl);
+    TLI.setUnavailable(LibFunc_htons);
+    TLI.setUnavailable(LibFunc_lchown);
+    TLI.setUnavailable(LibFunc_lstat);
+    TLI.setUnavailable(LibFunc_memccpy);
+    TLI.setUnavailable(LibFunc_mkdir);
+    TLI.setUnavailable(LibFunc_ntohl);
+    TLI.setUnavailable(LibFunc_ntohs);
+    TLI.setUnavailable(LibFunc_open);
+    TLI.setUnavailable(LibFunc_opendir);
+    TLI.setUnavailable(LibFunc_pclose);
+    TLI.setUnavailable(LibFunc_popen);
+    TLI.setUnavailable(LibFunc_pread);
+    TLI.setUnavailable(LibFunc_pwrite);
+    TLI.setUnavailable(LibFunc_read);
+    TLI.setUnavailable(LibFunc_readlink);
+    TLI.setUnavailable(LibFunc_realpath);
+    TLI.setUnavailable(LibFunc_rmdir);
+    TLI.setUnavailable(LibFunc_setitimer);
+    TLI.setUnavailable(LibFunc_stat);
+    TLI.setUnavailable(LibFunc_statvfs);
+    TLI.setUnavailable(LibFunc_stpcpy);
+    TLI.setUnavailable(LibFunc_stpncpy);
+    TLI.setUnavailable(LibFunc_strcasecmp);
+    TLI.setUnavailable(LibFunc_strncasecmp);
+    TLI.setUnavailable(LibFunc_times);
+    TLI.setUnavailable(LibFunc_uname);
+    TLI.setUnavailable(LibFunc_unlink);
+    TLI.setUnavailable(LibFunc_unsetenv);
+    TLI.setUnavailable(LibFunc_utime);
+    TLI.setUnavailable(LibFunc_utimes);
+    TLI.setUnavailable(LibFunc_write);
+  }
+
   if (T.isOSWindows() && !T.isOSCygMing()) {
     // Win32 does not support long double
     TLI.setUnavailable(LibFunc_acosl);
Index: lib/CodeGen/AsmPrinter/AsmPrinter.cpp
===================================================================
--- lib/CodeGen/AsmPrinter/AsmPrinter.cpp	(revision 319878)
+++ lib/CodeGen/AsmPrinter/AsmPrinter.cpp	(working copy)
@@ -1100,7 +1100,7 @@
   // FIXME: Hide this behind some API in e.g. MCAsmInfo or MCTargetStreamer.
   const Triple &TT = TM.getTargetTriple();
   if (!HasAnyRealCode && (MAI->hasSubsectionsViaSymbols() ||
-                          (TT.isOSWindows() && TT.isOSBinFormatCOFF()))) {
+                          ((TT.isOSWindows() || TT.isOSVali()) && TT.isOSBinFormatCOFF()))) {
     MCInst Noop;
     MF->getSubtarget().getInstrInfo()->getNoop(Noop);
 
Index: lib/IR/DataLayout.cpp
===================================================================
--- lib/IR/DataLayout.cpp	(revision 319878)
+++ lib/IR/DataLayout.cpp	(working copy)
@@ -154,7 +154,7 @@
 const char *DataLayout::getManglingComponent(const Triple &T) {
   if (T.isOSBinFormatMachO())
     return "-m:o";
-  if (T.isOSWindows() && T.isOSBinFormatCOFF())
+  if (T.isOSBinFormatCOFF())
     return T.getArch() == Triple::x86 ? "-m:x" : "-m:w";
   return "-m:e";
 }
@@ -384,10 +384,10 @@
         ManglingMode = MM_Mips;
         break;
       case 'w':
-        ManglingMode = MM_WinCOFF;
+        ManglingMode = MM_COFF;
         break;
       case 'x':
-        ManglingMode = MM_WinCOFFX86;
+        ManglingMode = MM_COFFX86;
         break;
       }
       break;
Index: lib/IR/Mangler.cpp
===================================================================
--- lib/IR/Mangler.cpp	(revision 319878)
+++ lib/IR/Mangler.cpp	(working copy)
@@ -139,7 +139,7 @@
     MSFunc = nullptr; // Don't mangle when \01 is present.
   CallingConv::ID CC =
       MSFunc ? MSFunc->getCallingConv() : (unsigned)CallingConv::C;
-  if (!DL.hasMicrosoftFastStdCallMangling() &&
+  if (!DL.hasFastStdCallMangling() &&
       CC != CallingConv::X86_VectorCall)
     MSFunc = nullptr;
   if (MSFunc) {
Index: lib/MC/CMakeLists.txt
===================================================================
--- lib/MC/CMakeLists.txt	(revision 319878)
+++ lib/MC/CMakeLists.txt	(working copy)
@@ -52,7 +52,7 @@
   StringTableBuilder.cpp
   SubtargetFeature.cpp
   WasmObjectWriter.cpp
-  WinCOFFObjectWriter.cpp
+  COFFObjectWriter.cpp
 
   ADDITIONAL_HEADER_DIRS
   ${LLVM_MAIN_INCLUDE_DIR}/llvm/MC
Index: lib/MC/MCObjectFileInfo.cpp
===================================================================
--- lib/MC/MCObjectFileInfo.cpp	(revision 319878)
+++ lib/MC/MCObjectFileInfo.cpp	(working copy)
@@ -278,7 +278,7 @@
   TLSExtraDataSection = TLSTLVSection;
 }
 
-void MCObjectFileInfo::initELFMCObjectFileInfo(const Triple &T, bool Large) {
+void MCObjectFileInfo::selectMCDwarfEncodings(const Triple &T, bool Large) {
   switch (T.getArch()) {
   case Triple::mips:
   case Triple::mipsel:
@@ -450,7 +450,11 @@
   default:
     break;
   }
+}
 
+void MCObjectFileInfo::initELFMCObjectFileInfo(const Triple &T, bool Large) {
+  selectMCDwarfEncodings(T, Large);
+
   unsigned EHSectionType = T.getArch() == Triple::x86_64
                                ? ELF::SHT_X86_64_UNWIND
                                : ELF::SHT_PROGBITS;
@@ -599,6 +603,10 @@
 }
 
 void MCObjectFileInfo::initCOFFMCObjectFileInfo(const Triple &T) {
+  if (T.isOSVali()) {
+    selectMCDwarfEncodings(T, T.getArch() == Triple::x86_64);
+  }
+
   EHFrameSection = Ctx->getCOFFSection(
       ".eh_frame", COFF::IMAGE_SCN_CNT_INITIALIZED_DATA |
                        COFF::IMAGE_SCN_MEM_READ | COFF::IMAGE_SCN_MEM_WRITE,
@@ -634,7 +642,7 @@
   // though it contains relocatable pointers.  In PIC mode, this is probably a
   // big runtime hit for C++ apps.  Either the contents of the LSDA need to be
   // adjusted or this should be a data section.
-  if (T.getArch() == Triple::x86_64) {
+  if (T.getArch() == Triple::x86_64 && !T.isOSVali()) {
     // On Windows 64 with SEH, the LSDA is emitted into the .xdata section
     LSDASection = nullptr;
   } else {
@@ -880,10 +888,6 @@
     initMachOMCObjectFileInfo(TT);
     break;
   case Triple::COFF:
-    if (!TT.isOSWindows())
-      report_fatal_error(
-          "Cannot initialize MC for non-Windows COFF object files.");
-
     Env = IsCOFF;
     initCOFFMCObjectFileInfo(TT);
     break;
Index: lib/Support/Triple.cpp
===================================================================
--- lib/Support/Triple.cpp	(revision 319878)
+++ lib/Support/Triple.cpp	(working copy)
@@ -168,6 +168,7 @@
   case AMD: return "amd";
   case Mesa: return "mesa";
   case SUSE: return "suse";
+  case Nordic: return "nordic";
   }
 
   llvm_unreachable("Invalid VendorType!");
@@ -208,6 +209,7 @@
   case Mesa3D: return "mesa3d";
   case Contiki: return "contiki";
   case AMDPAL: return "amdpal";
+  case ValiOS: return "vali";
   }
 
   llvm_unreachable("Invalid OSType");
@@ -465,6 +467,7 @@
     .Case("amd", Triple::AMD)
     .Case("mesa", Triple::Mesa)
     .Case("suse", Triple::SUSE)
+    .Case("nordic", Triple::Nordic)
     .Default(Triple::UnknownVendor);
 }
 
@@ -502,6 +505,7 @@
     .StartsWith("mesa3d", Triple::Mesa3D)
     .StartsWith("contiki", Triple::Contiki)
     .StartsWith("amdpal", Triple::AMDPAL)
+    .StartsWith("vali", Triple::ValiOS)
     .Default(Triple::UnknownOS);
 }
 
@@ -628,6 +632,8 @@
       return Triple::MachO;
     else if (T.isOSWindows())
       return Triple::COFF;
+    else if (T.isOSVali())
+      return Triple::COFF;
     return Triple::ELF;
 
   case Triple::aarch64_be:
Index: lib/Target/AArch64/AArch64MCInstLower.cpp
===================================================================
--- lib/Target/AArch64/AArch64MCInstLower.cpp	(revision 319878)
+++ lib/Target/AArch64/AArch64MCInstLower.cpp	(working copy)
@@ -41,9 +41,6 @@
   if (!TheTriple.isOSBinFormatCOFF())
     return Printer.getSymbol(GV);
 
-  assert(TheTriple.isOSWindows() &&
-         "Windows is the only supported COFF target");
-
   bool IsIndirect = (TargetFlags & AArch64II::MO_DLLIMPORT);
   if (!IsIndirect)
     return Printer.getSymbol(GV);
Index: lib/Target/AArch64/AArch64Subtarget.cpp
===================================================================
--- lib/Target/AArch64/AArch64Subtarget.cpp	(revision 319878)
+++ lib/Target/AArch64/AArch64Subtarget.cpp	(working copy)
@@ -149,7 +149,7 @@
                                    const std::string &FS,
                                    const TargetMachine &TM, bool LittleEndian)
     : AArch64GenSubtargetInfo(TT, CPU, FS),
-      ReserveX18(TT.isOSDarwin() || TT.isOSWindows()), IsLittle(LittleEndian),
+      ReserveX18(TT.isOSDarwin() || TT.isOSWindows() || TT.isOSVali()), IsLittle(LittleEndian),
       TargetTriple(TT), FrameLowering(),
       InstrInfo(initializeSubtargetDependencies(FS, CPU)), TSInfo(),
       TLInfo(TM, *this) {
Index: lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp
===================================================================
--- lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp	(revision 319878)
+++ lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp	(working copy)
@@ -599,7 +599,7 @@
 
   std::unique_ptr<MCObjectWriter>
   createObjectWriter(raw_pwrite_stream &OS) const override {
-    return createAArch64WinCOFFObjectWriter(OS);
+    return createAArch64COFFObjectWriter(OS);
   }
 };
 }
Index: lib/Target/AArch64/MCTargetDesc/AArch64MCTargetDesc.h
===================================================================
--- lib/Target/AArch64/MCTargetDesc/AArch64MCTargetDesc.h	(revision 319878)
+++ lib/Target/AArch64/MCTargetDesc/AArch64MCTargetDesc.h	(working copy)
@@ -62,7 +62,7 @@
                               uint32_t CPUSubtype);
 
 std::unique_ptr<MCObjectWriter>
-createAArch64WinCOFFObjectWriter(raw_pwrite_stream &OS);
+createAArch64COFFObjectWriter(raw_pwrite_stream &OS);
 
 MCTargetStreamer *createAArch64AsmTargetStreamer(MCStreamer &S,
                                                  formatted_raw_ostream &OS,
Index: lib/Target/AArch64/MCTargetDesc/CMakeLists.txt
===================================================================
--- lib/Target/AArch64/MCTargetDesc/CMakeLists.txt	(revision 319878)
+++ lib/Target/AArch64/MCTargetDesc/CMakeLists.txt	(working copy)
@@ -8,7 +8,7 @@
   AArch64MCTargetDesc.cpp
   AArch64MachObjectWriter.cpp
   AArch64TargetStreamer.cpp
-  AArch64WinCOFFObjectWriter.cpp
+  AArch64COFFObjectWriter.cpp
   AArch64WinCOFFStreamer.cpp
 )
 add_dependencies(LLVMAArch64Desc AArch64CommonTableGen)
Index: lib/Target/ARM/ARMTargetMachine.cpp
===================================================================
--- lib/Target/ARM/ARMTargetMachine.cpp	(revision 319878)
+++ lib/Target/ARM/ARMTargetMachine.cpp	(working copy)
@@ -97,7 +97,7 @@
 static std::unique_ptr<TargetLoweringObjectFile> createTLOF(const Triple &TT) {
   if (TT.isOSBinFormatMachO())
     return llvm::make_unique<TargetLoweringObjectFileMachO>();
-  if (TT.isOSWindows())
+  if (TT.isOSBinFormatCOFF())
     return llvm::make_unique<TargetLoweringObjectFileCOFF>();
   return llvm::make_unique<ARMElfTargetObjectFile>();
 }
Index: lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
===================================================================
--- lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp	(revision 319878)
+++ lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp	(working copy)
@@ -11,7 +11,7 @@
 #include "MCTargetDesc/ARMAddressingModes.h"
 #include "MCTargetDesc/ARMAsmBackendDarwin.h"
 #include "MCTargetDesc/ARMAsmBackendELF.h"
-#include "MCTargetDesc/ARMAsmBackendWinCOFF.h"
+#include "MCTargetDesc/ARMAsmBackendCOFF.h"
 #include "MCTargetDesc/ARMBaseInfo.h"
 #include "MCTargetDesc/ARMFixupKinds.h"
 #include "MCTargetDesc/ARMMCTargetDesc.h"
@@ -1168,8 +1168,8 @@
     return new ARMAsmBackendDarwin(T, TheTriple, MRI, CS);
   }
   case Triple::COFF:
-    assert(TheTriple.isOSWindows() && "non-Windows ARM COFF is not supported");
-    return new ARMAsmBackendWinCOFF(T, TheTriple);
+    assert(TheTriple.isOSBinFormatCOFF() && "using COFF for non-COFF target");
+    return new ARMAsmBackendCOFF(T, TheTriple);
   case Triple::ELF:
     assert(TheTriple.isOSBinFormatELF() && "using ELF for non-ELF target");
     uint8_t OSABI = MCELFObjectTargetWriter::getOSABI(TheTriple.getOS());
Index: lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h
===================================================================
--- lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h	(revision 319878)
+++ lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h	(working copy)
@@ -113,7 +113,7 @@
 
 /// Construct an ARM PE/COFF object writer.
 std::unique_ptr<MCObjectWriter>
-createARMWinCOFFObjectWriter(raw_pwrite_stream &OS, bool Is64Bit);
+createARMCOFFObjectWriter(raw_pwrite_stream &OS, bool Is64Bit);
 
 /// Construct ARM Mach-O relocation info.
 MCRelocationInfo *createARMMachORelocationInfo(MCContext &Ctx);
Index: lib/Target/ARM/MCTargetDesc/CMakeLists.txt
===================================================================
--- lib/Target/ARM/MCTargetDesc/CMakeLists.txt	(revision 319878)
+++ lib/Target/ARM/MCTargetDesc/CMakeLists.txt	(working copy)
@@ -11,6 +11,6 @@
   ARMMCTargetDesc.cpp
   ARMTargetStreamer.cpp
   ARMUnwindOpAsm.cpp
-  ARMWinCOFFObjectWriter.cpp
+  ARMCOFFObjectWriter.cpp
   ARMWinCOFFStreamer.cpp
   )
Index: lib/Target/X86/MCTargetDesc/CMakeLists.txt
===================================================================
--- lib/Target/X86/MCTargetDesc/CMakeLists.txt	(revision 319878)
+++ lib/Target/X86/MCTargetDesc/CMakeLists.txt	(working copy)
@@ -5,7 +5,7 @@
   X86MCCodeEmitter.cpp
   X86MachObjectWriter.cpp
   X86ELFObjectWriter.cpp
-  X86WinCOFFObjectWriter.cpp
+  X86COFFObjectWriter.cpp
   X86WinCOFFStreamer.cpp
   X86WinCOFFTargetStreamer.cpp
   )
Index: lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp
===================================================================
--- lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp	(revision 319878)
+++ lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp	(working copy)
@@ -449,7 +449,7 @@
 
   std::unique_ptr<MCObjectWriter>
   createObjectWriter(raw_pwrite_stream &OS) const override {
-    return createX86WinCOFFObjectWriter(OS, Is64Bit);
+    return createX86COFFObjectWriter(OS, Is64Bit);
   }
 };
 
@@ -853,7 +853,7 @@
   if (TheTriple.isOSBinFormatMachO())
     return new DarwinX86_32AsmBackend(T, MRI, CPU);
 
-  if (TheTriple.isOSWindows() && TheTriple.isOSBinFormatCOFF())
+  if ((TheTriple.isOSWindows() || TheTriple.isOSVali()) && TheTriple.isOSBinFormatCOFF())
     return new WindowsX86AsmBackend(T, false, CPU);
 
   uint8_t OSABI = MCELFObjectTargetWriter::getOSABI(TheTriple.getOS());
@@ -877,7 +877,7 @@
     return new DarwinX86_64AsmBackend(T, MRI, CPU, CS);
   }
 
-  if (TheTriple.isOSWindows() && TheTriple.isOSBinFormatCOFF())
+  if ((TheTriple.isOSWindows() || TheTriple.isOSVali()) && TheTriple.isOSBinFormatCOFF())
     return new WindowsX86AsmBackend(T, true, CPU);
 
   uint8_t OSABI = MCELFObjectTargetWriter::getOSABI(TheTriple.getOS());
Index: lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
===================================================================
--- lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp	(revision 319878)
+++ lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp	(working copy)
@@ -152,16 +152,23 @@
 void X86MCAsmInfoGNUCOFF::anchor() { }
 
 X86MCAsmInfoGNUCOFF::X86MCAsmInfoGNUCOFF(const Triple &Triple) {
-  assert(Triple.isOSWindows() && "Windows is the only supported COFF target");
   if (Triple.getArch() == Triple::x86_64) {
     PrivateGlobalPrefix = ".L";
     PrivateLabelPrefix = ".L";
     CodePointerSize = 8;
-    WinEHEncodingType = WinEH::EncodingType::Itanium;
-    ExceptionsType = ExceptionHandling::WinEH;
+    if (Triple.isOSWindows()) {
+      WinEHEncodingType = WinEH::EncodingType::Itanium;
+      ExceptionsType = ExceptionHandling::WinEH;
+    }
+    else {
+      ExceptionsType = ExceptionHandling::DwarfCFI;
+    }
   } else {
     ExceptionsType = ExceptionHandling::DwarfCFI;
   }
+  if (Triple.isOSVali()) {
+      SupportsDebugInformation = true;
+  }
 
   AssemblerDialect = AsmWriterFlavor;
 
Index: lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp
===================================================================
--- lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp	(revision 319878)
+++ lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp	(working copy)
@@ -251,7 +251,9 @@
   } else if (TheTriple.isOSCygMing() ||
              TheTriple.isWindowsItaniumEnvironment()) {
     MAI = new X86MCAsmInfoGNUCOFF(TheTriple);
-  } else {
+  } else if (TheTriple.isOSVali()) {
+    MAI = new X86MCAsmInfoGNUCOFF(TheTriple);
+  }else {
     // The default is ELF.
     MAI = new X86ELFMCAsmInfo(TheTriple);
   }
@@ -325,7 +327,6 @@
 
     // Register the asm target streamer.
     TargetRegistry::RegisterAsmTargetStreamer(*T, createX86AsmTargetStreamer);
-
     TargetRegistry::RegisterCOFFStreamer(*T, createX86WinCOFFStreamer);
 
     // Register the MCInstPrinter.
Index: lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h
===================================================================
--- lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h	(revision 319878)
+++ lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h	(working copy)
@@ -111,7 +111,7 @@
                                                          uint16_t EMachine);
 /// Construct an X86 Win COFF object writer.
 std::unique_ptr<MCObjectWriter>
-createX86WinCOFFObjectWriter(raw_pwrite_stream &OS, bool Is64Bit);
+createX86COFFObjectWriter(raw_pwrite_stream &OS, bool Is64Bit);
 
 /// Returns the sub or super register of a specific X86 register.
 /// e.g. getX86SubSuperRegister(X86::EAX, 16) returns X86::AX.
Index: lib/Target/X86/MCTargetDesc/X86WinCOFFStreamer.cpp
===================================================================
--- lib/Target/X86/MCTargetDesc/X86WinCOFFStreamer.cpp	(revision 319878)
+++ lib/Target/X86/MCTargetDesc/X86WinCOFFStreamer.cpp	(working copy)
@@ -1,4 +1,4 @@
-//===-- X86WinCOFFStreamer.cpp - X86 Target WinCOFF Streamer ----*- C++ -*-===//
+//===-- X86WinCOFFStreamer.cpp - X86 Target COFF Streamer ----*- C++ -*-===//
 //
 //                     The LLVM Compiler Infrastructure
 //
Index: lib/Target/X86/X86Subtarget.cpp
===================================================================
--- lib/Target/X86/X86Subtarget.cpp	(revision 319878)
+++ lib/Target/X86/X86Subtarget.cpp	(working copy)
@@ -203,7 +203,7 @@
 /// Return true if the subtarget allows calls to immediate address.
 bool X86Subtarget::isLegalToCallImmediateAddr() const {
   // FIXME: I386 PE/COFF supports PC relative calls using IMAGE_REL_I386_REL32
-  // but WinCOFFObjectWriter::RecordRelocation cannot emit them.  Once it does,
+  // but COFFObjectWriter::RecordRelocation cannot emit them.  Once it does,
   // the following check for Win32 should be removed.
   if (In64BitMode || isTargetWin32())
     return false;
